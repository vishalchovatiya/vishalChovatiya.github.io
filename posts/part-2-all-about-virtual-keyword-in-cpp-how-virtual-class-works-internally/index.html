<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? | Vishal Chovatiya</title>
<meta name=keywords content="all-about-virtual-keyword-in-c,class-virtual-method-c,complications-of-virtual-base-class,define-virtual-base-class-in-c,define-virtual-classes-in-c-plus-plus,definition-of-virtual-base-class-in-c,definition-of-virtual-classes-in-c-plus-plus,example-of-virtual-base-class-in-c,explain-virtual-base-class,explain-virtual-base-class-in-c,explain-virtual-base-class-with-example,explain-virtual-base-class-with-example-in-c,handling-of-virtual-function-in-the-virtual-base-class,handling-of-virtual-functions-in-the-virtual-base-class,how-does-virtual-base-class-addressing-works-internally,how-virtual-class-addressing-works-internally,how-virtual-class-works-internally,invariant-region-and-shared-region-in-virtual-base-class,need-of-virtual-base-class-in-c,virtual-base-class,virtual-base-class-example,virtual-base-class-example-in-c,virtual-base-class-in-c,virtual-base-class-in-c-plus-plus,virtual-base-class-in-c-2,virtual-base-class-in-c-definition,virtual-base-class-in-c-example,virtual-base-class-in-c-program,virtual-base-class-in-c-with-example,virtual-base-class-in-c-with-example-program,virtual-base-class-in-cpp,virtual-base-class-program-in-c,virtual-class,virtual-class-c,virtual-class-in-c-plus-plus,virtual-class-in-c-sharp,virtual-class-in-c,virtual-classes-in-c-plus-plus,virtual-inheritance-in-c,what-is-virtual-base-class-in-c-plus-plus,what-is-virtual-class,why-do-we-need-a-virtual-class,why-do-we-need-virtual-inheritance-in-c,why-we-need-a-virtual-class"><meta name=description content="In PART 1 of &ldquo;All About Virtual Keyword in C++&rdquo; series, we have discussed &ldquo;How Does Virtual Function Works Internally?&rdquo;. So, in this article, I will discuss &ldquo;How Does Virtual Base Class Works Internally?&rdquo;. I am iterating the same thing which I have mentioned in the earlier article as well that implementation of a virtual mechanism is purely compiler dependent. So, there is no C++ standard is defined for such dynamic dispatch."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally?"><meta property="og:description" content="In PART 1 of &ldquo;All About Virtual Keyword in C++&rdquo; series, we have discussed &ldquo;How Does Virtual Function Works Internally?&rdquo;. So, in this article, I will discuss &ldquo;How Does Virtual Base Class Works Internally?&rdquo;. I am iterating the same thing which I have mentioned in the earlier article as well that implementation of a virtual mechanism is purely compiler dependent. So, there is no C++ standard is defined for such dynamic dispatch."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/"><meta property="og:image" content="https://vishalchovatiya.github.io/images/memory-layout-of-C-objects.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-11T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-11T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/images/memory-layout-of-C-objects.png"><meta name=twitter:title content="Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally?"><meta name=twitter:description content="In PART 1 of &ldquo;All About Virtual Keyword in C++&rdquo; series, we have discussed &ldquo;How Does Virtual Function Works Internally?&rdquo;. So, in this article, I will discuss &ldquo;How Does Virtual Base Class Works Internally?&rdquo;. I am iterating the same thing which I have mentioned in the earlier article as well that implementation of a virtual mechanism is purely compiler dependent. So, there is no C++ standard is defined for such dynamic dispatch."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally?","item":"https://vishalchovatiya.github.io/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally?","name":"Part 2: All About Virtual Keyword in C\u002b\u002b: How Does Virtual Base Class Works Internally?","description":"In PART 1 of \u0026ldquo;All About Virtual Keyword in C++\u0026rdquo; series, we have discussed \u0026ldquo;How Does Virtual Function Works Internally?\u0026rdquo;. So, in this article, I will discuss \u0026ldquo;How Does Virtual Base Class Works Internally?\u0026rdquo;. I am iterating the same thing which I have mentioned in the earlier article as well that implementation of a virtual mechanism is purely compiler dependent. So, there is no C++ standard is defined for such dynamic dispatch.","keywords":["all-about-virtual-keyword-in-c","class-virtual-method-c","complications-of-virtual-base-class","define-virtual-base-class-in-c","define-virtual-classes-in-c-plus-plus","definition-of-virtual-base-class-in-c","definition-of-virtual-classes-in-c-plus-plus","example-of-virtual-base-class-in-c","explain-virtual-base-class","explain-virtual-base-class-in-c","explain-virtual-base-class-with-example","explain-virtual-base-class-with-example-in-c","handling-of-virtual-function-in-the-virtual-base-class","handling-of-virtual-functions-in-the-virtual-base-class","how-does-virtual-base-class-addressing-works-internally","how-virtual-class-addressing-works-internally","how-virtual-class-works-internally","invariant-region-and-shared-region-in-virtual-base-class","need-of-virtual-base-class-in-c","virtual-base-class","virtual-base-class-example","virtual-base-class-example-in-c","virtual-base-class-in-c","virtual-base-class-in-c-plus-plus","virtual-base-class-in-c-2","virtual-base-class-in-c-definition","virtual-base-class-in-c-example","virtual-base-class-in-c-program","virtual-base-class-in-c-with-example","virtual-base-class-in-c-with-example-program","virtual-base-class-in-cpp","virtual-base-class-program-in-c","virtual-class","virtual-class-c","virtual-class-in-c-plus-plus","virtual-class-in-c-sharp","virtual-class-in-c","virtual-classes-in-c-plus-plus","virtual-inheritance-in-c","what-is-virtual-base-class-in-c-plus-plus","what-is-virtual-class","why-do-we-need-a-virtual-class","why-do-we-need-virtual-inheritance-in-c","why-we-need-a-virtual-class"],"articleBody":"In PART 1 of “All About Virtual Keyword in C++” series, we have discussed “How Does Virtual Function Works Internally?”. So, in this article, I will discuss “How Does Virtual Base Class Works Internally?”. I am iterating the same thing which I have mentioned in the earlier article as well that implementation of a virtual mechanism is purely compiler dependent. So, there is no C++ standard is defined for such dynamic dispatch. Hence, here I am discussing the general approach.\nAs usual, before learning anything new I usually start with “Why do we need it in the first place?”\nWhy Do We Need a Virtual Class/Inheritance? When we use inheritance, we basically extending a derived class with base class functionality. In other words, the base class object would be treated as sub-object in the derived class. As a result, this would create a problem in multiple inheritances if base class sharing the same mutual class as sub-object in the top-level hierarchy and you want to access its property. Problem I know above statement is a bit complex. So, let see an example. class Top { public: int t; }; class Left : public Top { public: int l; }; class Right : public Top { public: int r; }; class Bottom : public Left, public Right { public: int b; }; The above class hierarchy/inheritance results in the “diamond” which looks like below: Top / \\ Left Right \\ / Bottom An instance of Bottom will be made up of Left, which includes Top, and Right which also includes Top. So, we have two sub-object of Top. This will create ambiguity as follows: Bottom *bot = new Bottom; bot-\u003et = 5; // is this Left's `t` or Right's `t` data member ?? This was by far the simplest reason for the need of the virtual base class. And consider the following scenarios as an example: Top *t_ptr1 = new Left; Top *t_ptr2 = new Right; These both will work fine as Left or Right object memory layout has Top subobject. You can see the memory layout of the Bottom object below for clear understanding. | | |----------------------| \u003c------ Bottom bot; // Bottom object | Left::Top::t | |----------------------| | Left::l | |----------------------| | Right::Top::t | |----------------------| | Right::r | |----------------------| | Bottom::b | |----------------------| | | Now, what happens when we upcast a Bottom pointer? Left *left = new Bottom; This will work fine as Bottom object memory layout starts with Left subobject. However, what happens when we upcast to Right? Right *right = new Bottom; For this to work, we have to adjust the right pointer value to make it point to the corresponding section of the Bottom layout: | | |----------------------| | Left::Top::t | |----------------------| | Left::l | |----------------------| \u003c------ right; | Right::Top::t | |----------------------| | Right::r | |----------------------| | Bottom::b | |----------------------| | | | | After this adjustment, we can access the Bottom through the right pointer as a normal Right object. But, what would happen if we do Top* Top = new Bottom; This statement is ambiguous: the compiler will complain error: `Top' is an ambiguous base of `Bottom' Although you can use force typecasting/C-style-cast as follows: Top* topL = (Left*) Bottom; Top* topR = (Right*) Bottom; Solution Virtual inheritance uses to solve such kind of diamond problems. When you specify virtual while inheriting your classes, you’re telling the compiler that you only want a single instance. class Top { public: int t; }; class Left : virtual public Top { public: int l; }; class Right : virtual public Top { public: int r; }; class Bottom : public Left, public Right { public: int b; }; This means that there is only one “instance” of Top included in the hierarchy. Hence Bottom *bot = new Bottom; bot-\u003et = 5; // no longer ambiguous So, this may seem more obvious and simpler from a programmer’s point of view. But from the compiler’s point of view, this is vastly more complicated. But an interesting question is how this bot-\u003et will be addressed \u0026 handle by the compiler? Ok, this is the time to move on to next point. How Does Virtual Base Class Addressing Works Internally? A class containing one or more virtual base class as a subobject, such as Bottom, is divided into two regions: Invariant region Shared region Data within the invariant region remains at a fixed offset(which decided in compilation step) from the start of the object regardless of subsequent derivations. So members within the invariant region can access directly. In our case, its Left \u0026 Right \u0026 Bottom. Additionally, the shared region represents the virtual base class subobjects whose location within the shared region fluctuates with an order of derivation \u0026 subsequent derivation. So members within the shared region need to accessed indirectly. As the name suggests, an invariant region placed at the start of objects memory layout and the shared region placed at the end. The offset of the shared region updated in the virtual table. The code necessary for this augmented by the compiler at the time of object construction. See below image for reference. | | |------------------------| \u003c------ Bottom bot; // Bottom object | Left::l | |------------------------| |------------------| | Left::_vptr_Left |-------| | offset of Top | // offset starts |------------------------| |-------|------------------| // from left subobject = 20 | Right::r | | ... | |------------------------| |------------------| | Right::_vptr_Right |-------| |------------------------| | |------------------| | Bottom::b | | | offset of Top | // offset starts |------------------------| |-------|------------------| // from right subobject = 12 | Top::t | | ... | |------------------------| |------------------| | | Now coming back to our interesting question i.e. “How this bot-\u003et will be addressed?” Bottom *bot = new Bottom; bot-\u003et = 5; Above code will probably be transformed into Bottom *bot = new Bottom; (bot + _vptr_Left[-1])-\u003et = 5; // If you haven't got this, then consider the above memory map So, as you can see addressing of virtual base class is done through the offset(of the base class) stored in the virtual table. Handling of Virtual Functions in the Virtual Base Class Handling of the virtual functions in the virtual base class is the same as we have discussed in our previous article with multiple inheritances. There is nothing special about it. Summary As I mentioned earlier this seems straight forward from the programmer’s point of view. But from the compiler’s point of view, it is complicated. And, there are many other Complications of Using the Virtual Base Class which I have discussed in a separate article. Let’s summaries few take away points:\nThere is no C++ standard on dynamic dispatch implementation \u0026 it only states behaviour The virtual class needed to avoid the diamond problem The object having virtual base class as subobject has memory layout divided in two regions: Invariant region: non-virtual classes Shared region: virtual classes Shared region i.e. virtual base class subobject placed at the end of memory layout. The addresses of the data members in the virtual base class resolved using offset(of virtual base class) store in the virtual table. ","wordCount":"1178","inLanguage":"en","image":"https://vishalchovatiya.github.io/images/memory-layout-of-C-objects.png","datePublished":"2019-09-11T00:00:00Z","dateModified":"2019-09-11T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally?</h1><div class=post-meta><span title='2019-09-11 00:00:00 +0000 UTC'>September 11, 2019</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1178 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://vishalchovatiya.github.io/images/memory-layout-of-C-objects.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#why-do-we-need-a-virtual-classinheritance>Why Do We Need a Virtual Class/Inheritance?</a><ul><li><a href=#problem>Problem</a></li><li><a href=#solution>Solution</a></li></ul></li><li><a href=#how-does-virtual-base-class-addressing-works-internally>How Does Virtual Base Class Addressing Works Internally?</a></li><li><a href=#handling-of-virtual-functions-in-the-virtual-base-class>Handling of Virtual Functions in the Virtual Base Class</a></li><li><a href=#summary>Summary</a></li></ul></nav></div></details></div><div class=post-content><p>In <a href=/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/>PART 1</a> of &ldquo;All About Virtual Keyword in C++&rdquo; series, we have discussed &ldquo;How Does Virtual Function Works Internally?&rdquo;. So, in this article, I will discuss &ldquo;How Does Virtual Base Class Works Internally?&rdquo;. I am iterating the same thing which I have mentioned in the earlier article as well that implementation of a virtual mechanism is purely compiler dependent. So, there is no C++ standard is defined for such dynamic dispatch. Hence, here I am discussing the general approach.</p><p>As usual, before learning anything new I usually start with “Why do we need it in the first place?”</p><h2 id=why-do-we-need-a-virtual-classinheritance>Why Do We Need a Virtual Class/Inheritance?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-a-virtual-classinheritance>#</a></h2><ul><li>When we use inheritance, we basically extending a derived class with base class functionality. In other words, the base class object would be treated as <a href=/posts/memory-layout-of-cpp-object/>sub-object</a> in the derived class.</li><li>As a result, this would create a problem in multiple inheritances if base class sharing the same mutual class as <a href=/posts/memory-layout-of-cpp-object/>sub-object</a> in the top-level hierarchy and you want to access its property.</li></ul><h3 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h3><ul><li>I know above statement is a bit complex. So, let see an example.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Top</span> <span class=p>{</span> <span class=k>public</span><span class=o>:</span> <span class=kt>int</span> <span class=n>t</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Left</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Top</span> <span class=p>{</span> <span class=k>public</span><span class=o>:</span> <span class=kt>int</span> <span class=n>l</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Right</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Top</span> <span class=p>{</span> <span class=k>public</span><span class=o>:</span> <span class=kt>int</span> <span class=n>r</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Bottom</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Left</span><span class=p>,</span> <span class=k>public</span> <span class=n>Right</span> <span class=p>{</span> <span class=k>public</span><span class=o>:</span> <span class=kt>int</span> <span class=n>b</span><span class=p>;</span> <span class=p>};</span>
</span></span></code></pre></div><ul><li>The above class hierarchy/inheritance results in the &ldquo;diamond&rdquo; which looks like below:</li></ul><pre tabindex=0><code>    Top
   /   \
Left   Right
   \   /
   Bottom
</code></pre><ul><li>An instance of <code>Bottom</code> will be made up of <code>Left</code>, which includes <code>Top</code>, and <code>Right</code> which also includes <code>Top</code>. So, we have two sub-object of <code>Top</code>. This will create ambiguity as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Bottom</span> <span class=o>*</span><span class=n>bot</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>bot</span><span class=o>-&gt;</span><span class=n>t</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>// is this Left&#39;s `t` or Right&#39;s `t` data member ??
</span></span></span></code></pre></div><ul><li>This was by far the simplest reason for the need of the virtual base class. And consider the following scenarios as an example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Top</span>   <span class=o>*</span><span class=n>t_ptr1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Left</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Top</span>   <span class=o>*</span><span class=n>t_ptr2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Right</span><span class=p>;</span> 
</span></span></code></pre></div><ul><li>These both will work fine as <code>Left</code> or <code>Right</code> object memory layout has <code>Top</code> subobject. You can see the memory layout of the <code>Bottom</code> object below for clear understanding.</li></ul><pre tabindex=0><code>|                      |
|----------------------|  &lt;------ Bottom bot;   // Bottom object 
|    Left::Top::t      |
|----------------------|
|    Left::l           |
|----------------------|
|    Right::Top::t     |
|----------------------|
|    Right::r          |
|----------------------|
|    Bottom::b         |
|----------------------|
|                      |
</code></pre><ul><li>Now, what happens when we upcast a <code>Bottom</code> pointer?</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Left</span>  <span class=o>*</span><span class=n>left</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>This will work fine as <code>Bottom</code> object memory layout starts with <code>Left</code> subobject.</li><li>However, what happens when we upcast to <code>Right</code>?</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Right</span>  <span class=o>*</span><span class=n>right</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>For this to work, we have to adjust the <code>right</code> pointer value to make it point to the corresponding section of the <code>Bottom</code> layout:</li></ul><pre tabindex=0><code>|                      |
|----------------------|
|    Left::Top::t      |
|----------------------|
|    Left::l           |
|----------------------|  &lt;------ right;
|    Right::Top::t     |
|----------------------|
|    Right::r          |
|----------------------|
|    Bottom::b         |
|----------------------|
|                      |
|                      |
</code></pre><ul><li>After this adjustment, we can access the <code>Bottom</code> through the <code>right</code> pointer as a normal <code>Right</code> object.</li><li>But, what would happen if we do</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Top</span><span class=o>*</span> <span class=n>Top</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>This statement is ambiguous: the compiler will complain</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=err>`</span><span class=n>Top</span><span class=err>&#39;</span> <span class=n>is</span> <span class=n>an</span> <span class=n>ambiguous</span> <span class=n>base</span> <span class=n>of</span> <span class=err>`</span><span class=n>Bottom</span><span class=err>&#39;</span>
</span></span></code></pre></div><ul><li>Although you can use force <a href=/posts/cpp-type-casting-with-example-for-c-developers/>typecasting/C-style-cast</a> as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Top</span><span class=o>*</span> <span class=n>topL</span> <span class=o>=</span> <span class=p>(</span><span class=n>Left</span><span class=o>*</span><span class=p>)</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Top</span><span class=o>*</span> <span class=n>topR</span> <span class=o>=</span> <span class=p>(</span><span class=n>Right</span><span class=o>*</span><span class=p>)</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h3><ul><li><strong><em>Virtual inheritance uses to solve such kind of diamond problems</em></strong>. When you specify virtual while inheriting your classes, you&rsquo;re telling the compiler that you only want a single instance.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Top</span> <span class=p>{</span> <span class=k>public</span><span class=o>:</span> <span class=kt>int</span> <span class=n>t</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Left</span> <span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>Top</span> <span class=p>{</span> <span class=k>public</span><span class=o>:</span> <span class=kt>int</span> <span class=n>l</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Right</span> <span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>Top</span> <span class=p>{</span> <span class=k>public</span><span class=o>:</span> <span class=kt>int</span> <span class=n>r</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Bottom</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Left</span><span class=p>,</span> <span class=k>public</span> <span class=n>Right</span> <span class=p>{</span> <span class=k>public</span><span class=o>:</span> <span class=kt>int</span> <span class=n>b</span><span class=p>;</span> <span class=p>};</span>
</span></span></code></pre></div><ul><li>This means that there is only one &ldquo;instance&rdquo; of <code>Top</code> included in the hierarchy. Hence</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Bottom</span> <span class=o>*</span><span class=n>bot</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>bot</span><span class=o>-&gt;</span><span class=n>t</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>// no longer ambiguous
</span></span></span></code></pre></div><ul><li>So, this may seem more obvious and simpler from a programmer&rsquo;s point of view. But from the compiler&rsquo;s point of view, this is vastly more complicated.</li><li>But an interesting question is how this <code>bot->t</code> will be addressed & handle by the compiler? Ok, this is the time to move on to next point.</li></ul><h2 id=how-does-virtual-base-class-addressing-works-internally>How Does Virtual Base Class Addressing Works Internally?<a hidden class=anchor aria-hidden=true href=#how-does-virtual-base-class-addressing-works-internally>#</a></h2><ul><li>A class containing one or more virtual base class as a subobject, such as <code>Bottom</code>, is divided into two regions:<ol><li><strong><em>Invariant region</em></strong></li><li><strong><em>Shared region</em></strong></li></ol></li><li>Data within the invariant region remains at a fixed offset(which decided in compilation step) from the start of the object regardless of subsequent derivations. So members within the invariant region can access directly. In our case, its <code>Left</code> & <code>Right</code> & <code>Bottom</code>.</li><li>Additionally, the shared region represents the virtual base class subobjects whose location within the shared region fluctuates with an order of derivation & subsequent derivation. So members within the shared region need to accessed indirectly.</li><li>As the name suggests, an <strong><em>invariant region placed at the start</em></strong> of objects memory layout and the <strong><em>shared region placed at the end</em></strong>.</li><li>The <strong><em>offset of the shared region updated in the virtual table</em></strong>. The code necessary for this augmented by the compiler at the time of object construction. See below image for reference.</li></ul><pre tabindex=0><code>|                        |          
|------------------------| &lt;------ Bottom bot;   // Bottom object           
|    Left::l             |          
|------------------------|               |------------------| 
|    Left::_vptr_Left    |-------|       |  offset of Top   | // offset starts 
|------------------------|       |-------|------------------|       // from left subobject = 20
|    Right::r            |               |    ...           |
|------------------------|               |------------------|  
|    Right::_vptr_Right  |-------|       
|------------------------|       |       |------------------| 
|    Bottom::b           |       |       |  offset of Top   | // offset starts 
|------------------------|       |-------|------------------|       // from right subobject = 12                       
|    Top::t              |               |    ...           |                                    
|------------------------|               |------------------|                                            
|                        |       
</code></pre><ul><li>Now coming back to our interesting question i.e. &ldquo;How this <code>bot->t</code> will be addressed?&rdquo;</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Bottom</span> <span class=o>*</span><span class=n>bot</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>bot</span><span class=o>-&gt;</span><span class=n>t</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Above code will probably be transformed into</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Bottom</span> <span class=o>*</span><span class=n>bot</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bottom</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>bot</span> <span class=o>+</span> <span class=n>_vptr_Left</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span><span class=o>-&gt;</span><span class=n>t</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>// If you haven&#39;t got this, then consider the above memory map
</span></span></span></code></pre></div><ul><li>So, as you can see addressing of <a href=http://www.avabodh.com/cxxin/virtualbase.html>virtual base class</a> is done through the offset(of the base class) stored in the virtual table.</li></ul><h2 id=handling-of-virtual-functions-in-the-virtual-base-class>Handling of Virtual Functions in the Virtual Base Class<a hidden class=anchor aria-hidden=true href=#handling-of-virtual-functions-in-the-virtual-base-class>#</a></h2><ul><li>Handling of the virtual functions in the virtual base class is the same as we have discussed in our previous <a href=/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/>article</a> with multiple inheritances. There is nothing special about it.</li></ul><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>As I mentioned earlier this seems straight forward from the programmer&rsquo;s point of view. But from the compiler’s point of view, it is complicated. And, there are many other <a href=/posts/complications-of-using-the-virtual-base-class/>Complications of Using the Virtual Base Class</a> which I have discussed in a separate article. Let&rsquo;s summaries few take away points:</p><ul><li>There is no C++ standard on dynamic dispatch implementation & it only states behaviour</li><li>The virtual class needed to avoid the diamond problem</li><li>The object having virtual base class as subobject has memory layout divided in two regions:<ol><li>Invariant region: non-virtual classes</li><li>Shared region: virtual classes</li></ol></li><li>Shared region i.e. virtual base class subobject placed at the end of memory layout.</li><li>The addresses of the data members in the virtual base class resolved using offset(of virtual base class) store in the virtual table.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/all-about-virtual-keyword-in-c/>All-About-Virtual-Keyword-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/class-virtual-method-c/>Class-Virtual-Method-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/complications-of-virtual-base-class/>Complications-of-Virtual-Base-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/define-virtual-base-class-in-c/>Define-Virtual-Base-Class-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/define-virtual-classes-in-c-plus-plus/>Define-Virtual-Classes-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/definition-of-virtual-base-class-in-c/>Definition-of-Virtual-Base-Class-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/definition-of-virtual-classes-in-c-plus-plus/>Definition-of-Virtual-Classes-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/example-of-virtual-base-class-in-c/>Example-of-Virtual-Base-Class-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/explain-virtual-base-class/>Explain-Virtual-Base-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/explain-virtual-base-class-in-c/>Explain-Virtual-Base-Class-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/explain-virtual-base-class-with-example/>Explain-Virtual-Base-Class-With-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/explain-virtual-base-class-with-example-in-c/>Explain-Virtual-Base-Class-With-Example-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/handling-of-virtual-function-in-the-virtual-base-class/>Handling-of-Virtual-Function-in-the-Virtual-Base-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/handling-of-virtual-functions-in-the-virtual-base-class/>Handling-of-Virtual-Functions-in-the-Virtual-Base-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-does-virtual-base-class-addressing-works-internally/>How-Does-Virtual-Base-Class-Addressing-Works-Internally</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-virtual-class-addressing-works-internally/>How-Virtual-Class-Addressing-Works-Internally</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-virtual-class-works-internally/>How-Virtual-Class-Works-Internally</a></li><li><a href=https://vishalchovatiya.github.io/tags/invariant-region-and-shared-region-in-virtual-base-class/>Invariant-Region-and-Shared-Region-in-Virtual-Base-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/need-of-virtual-base-class-in-c/>Need-of-Virtual-Base-Class-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class/>Virtual-Base-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-example/>Virtual-Base-Class-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-example-in-c/>Virtual-Base-Class-Example-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-in-c/>Virtual-Base-Class-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-in-c-plus-plus/>Virtual-Base-Class-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-in-c-2/>Virtual-Base-Class-in-C-2</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-in-c-definition/>Virtual-Base-Class-in-C-Definition</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-in-c-example/>Virtual-Base-Class-in-C-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-in-c-program/>Virtual-Base-Class-in-C-Program</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-in-c-with-example/>Virtual-Base-Class-in-C-With-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-in-c-with-example-program/>Virtual-Base-Class-in-C-With-Example-Program</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-in-cpp/>Virtual-Base-Class-in-Cpp</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-base-class-program-in-c/>Virtual-Base-Class-Program-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-class/>Virtual-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-class-c/>Virtual-Class-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-class-in-c-plus-plus/>Virtual-Class-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-class-in-c-sharp/>Virtual-Class-in-C-Sharp</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-class-in-c/>Virtual-Class-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-classes-in-c-plus-plus/>Virtual-Classes-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-inheritance-in-c/>Virtual-Inheritance-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/what-is-virtual-base-class-in-c-plus-plus/>What-Is-Virtual-Base-Class-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/what-is-virtual-class/>What-Is-Virtual-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/why-do-we-need-a-virtual-class/>Why-Do-We-Need-a-Virtual-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/why-do-we-need-virtual-inheritance-in-c/>Why-Do-We-Need-Virtual-Inheritance-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/why-we-need-a-virtual-class/>Why-We-Need-a-Virtual-Class</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/><span class=title>« Prev</span><br><span>Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally?</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/how-does-virtual-memory-work/><span class=title>Next »</span><br><span>How Does Virtual Memory Work?</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? on x" href="https://x.com/intent/tweet/?text=Part%202%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Base%20Class%20Works%20Internally%3f&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally%2f&amp;hashtags=all-about-virtual-keyword-in-c%2cclass-virtual-method-c%2ccomplications-of-virtual-base-class%2cdefine-virtual-base-class-in-c%2cdefine-virtual-classes-in-c-plus-plus%2cdefinition-of-virtual-base-class-in-c%2cdefinition-of-virtual-classes-in-c-plus-plus%2cexample-of-virtual-base-class-in-c%2cexplain-virtual-base-class%2cexplain-virtual-base-class-in-c%2cexplain-virtual-base-class-with-example%2cexplain-virtual-base-class-with-example-in-c%2chandling-of-virtual-function-in-the-virtual-base-class%2chandling-of-virtual-functions-in-the-virtual-base-class%2chow-does-virtual-base-class-addressing-works-internally%2chow-virtual-class-addressing-works-internally%2chow-virtual-class-works-internally%2cinvariant-region-and-shared-region-in-virtual-base-class%2cneed-of-virtual-base-class-in-c%2cvirtual-base-class%2cvirtual-base-class-example%2cvirtual-base-class-example-in-c%2cvirtual-base-class-in-c%2cvirtual-base-class-in-c-plus-plus%2cvirtual-base-class-in-c-2%2cvirtual-base-class-in-c-definition%2cvirtual-base-class-in-c-example%2cvirtual-base-class-in-c-program%2cvirtual-base-class-in-c-with-example%2cvirtual-base-class-in-c-with-example-program%2cvirtual-base-class-in-cpp%2cvirtual-base-class-program-in-c%2cvirtual-class%2cvirtual-class-c%2cvirtual-class-in-c-plus-plus%2cvirtual-class-in-c-sharp%2cvirtual-class-in-c%2cvirtual-classes-in-c-plus-plus%2cvirtual-inheritance-in-c%2cwhat-is-virtual-base-class-in-c-plus-plus%2cwhat-is-virtual-class%2cwhy-do-we-need-a-virtual-class%2cwhy-do-we-need-virtual-inheritance-in-c%2cwhy-we-need-a-virtual-class"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally%2f&amp;title=Part%202%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Base%20Class%20Works%20Internally%3f&amp;summary=Part%202%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Base%20Class%20Works%20Internally%3f&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally%2f&title=Part%202%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Base%20Class%20Works%20Internally%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? on whatsapp" href="https://api.whatsapp.com/send?text=Part%202%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Base%20Class%20Works%20Internally%3f%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? on telegram" href="https://telegram.me/share/url?text=Part%202%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Base%20Class%20Works%20Internally%3f&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? on ycombinator" href="https://news.ycombinator.com/submitlink?t=Part%202%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Base%20Class%20Works%20Internally%3f&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>