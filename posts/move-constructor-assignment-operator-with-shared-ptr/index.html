<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Move Constructor & Assignment Operator With std::shared_ptr | Vishal Chovatiya</title>
<meta name=keywords content="c-how-to-move-constructor,c-move-constructor-explained,c-move-constructor-tutorial,c-why-use-move-constructor,how-move-constructor-works,how-move-constructor-works-c,how-to-call-move-constructor,how-to-invoke-move-constructor,how-to-use-move-constructor-c,implementing-our-shared_ptr-with-move-constructor-and-assignment-operator,lvalue-reference-and-rvalue-reference,move-assignment,move-constructor,move-constructor-and-assignment-operator-with-shared_ptr,move-constructor-and-move-assignment-operator,move-constructor-c-example,move-constructor-c-header,move-constructor-how-to-use,move-constructor-in-c-example,move-constructor-in-c-geeksforgeeks,move-constructor-lvalue-rvalue,move-constructor-rvalue,move-constructor-stack-overflow,move-constructor-unique_ptr,move-constructor-with-swap,move-constructor-with-unique_ptr,move-copy-constructor-example,shared_ptr,syntax-for-move-constructor,unique_ptr,use-case-or-benefit-of-stdmove-move-constructor-c11,what-is-move-constructor-in-cpp,when-does-the-move-constructor-and-move-assignment-operator-get-called,when-is-move-constructor-called-c,why-do-we-need-move-constructor"><meta name=description content="In an earlier article, we have seen how move constructor & move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor & assignment operator to implement unsophisticated shared_ptr.
Implementing Our shared_ptr with Move Constructor & Assignment Operator In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=http://localhost:1313/posts/move-constructor-assignment-operator-with-shared-ptr/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/move-constructor-assignment-operator-with-shared-ptr/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Move Constructor & Assignment Operator With std::shared_ptr"><meta property="og:description" content="In an earlier article, we have seen how move constructor & move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor & assignment operator to implement unsophisticated shared_ptr.
Implementing Our shared_ptr with Move Constructor & Assignment Operator In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/move-constructor-assignment-operator-with-shared-ptr/"><meta property="og:image" content="http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-15T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-15T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png"><meta name=twitter:title content="Move Constructor & Assignment Operator With std::shared_ptr"><meta name=twitter:description content="In an earlier article, we have seen how move constructor & move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor & assignment operator to implement unsophisticated shared_ptr.
Implementing Our shared_ptr with Move Constructor & Assignment Operator In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Move Constructor \u0026 Assignment Operator With std::shared_ptr","item":"http://localhost:1313/posts/move-constructor-assignment-operator-with-shared-ptr/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Move Constructor \u0026 Assignment Operator With std::shared_ptr","name":"Move Constructor \u0026 Assignment Operator With std::shared_ptr","description":"In an earlier article, we have seen how move constructor \u0026amp; move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor \u0026amp; assignment operator to implement unsophisticated shared_ptr.\nImplementing Our shared_ptr with Move Constructor \u0026amp; Assignment Operator In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time.","keywords":["c-how-to-move-constructor","c-move-constructor-explained","c-move-constructor-tutorial","c-why-use-move-constructor","how-move-constructor-works","how-move-constructor-works-c","how-to-call-move-constructor","how-to-invoke-move-constructor","how-to-use-move-constructor-c","implementing-our-shared_ptr-with-move-constructor-and-assignment-operator","lvalue-reference-and-rvalue-reference","move-assignment","move-constructor","move-constructor-and-assignment-operator-with-shared_ptr","move-constructor-and-move-assignment-operator","move-constructor-c-example","move-constructor-c-header","move-constructor-how-to-use","move-constructor-in-c-example","move-constructor-in-c-geeksforgeeks","move-constructor-lvalue-rvalue","move-constructor-rvalue","move-constructor-stack-overflow","move-constructor-unique_ptr","move-constructor-with-swap","move-constructor-with-unique_ptr","move-copy-constructor-example","shared_ptr","syntax-for-move-constructor","unique_ptr","use-case-or-benefit-of-stdmove-move-constructor-c11","what-is-move-constructor-in-cpp","when-does-the-move-constructor-and-move-assignment-operator-get-called","when-is-move-constructor-called-c","why-do-we-need-move-constructor"],"articleBody":"In an earlier article, we have seen how move constructor \u0026 move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor \u0026 assignment operator to implement unsophisticated shared_ptr.\nImplementing Our shared_ptr with Move Constructor \u0026 Assignment Operator In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time. And when the reference count goes to zero which means nobody is using that resource, we will deallocate that resource. Unlike std::unique_ptr, which is designed to singly own and manage a resource, std::shared_ptr is meant to solve the case where you need multiple smart pointers co-owning a resource. template\u003cclass T\u003e class smart_ptr { T* m_ptr; uint32_t *m_refCount; public: smart_ptr(T* ptr = nullptr):m_ptr(ptr) { if(m_ptr) m_refCount = new uint32_t(1); else m_refCount = nullptr; } ~smart_ptr() { if(m_refCount != nullptr){ (*m_refCount)--; if((*m_refCount) == 0){ delete m_ptr; delete m_refCount; } } } // Copy constructor smart_ptr(const smart_ptr\u0026 a) { m_ptr = a.m_ptr; m_refCount = a.m_refCount; (*m_refCount)++; } // Move constructor smart_ptr(smart_ptr\u0026\u0026 a): m_ptr(a.m_ptr), m_refCount(a.m_refCount) { a.m_ptr = nullptr; a.m_refCount = nullptr; } // Copy assignment smart_ptr\u0026 operator=(const smart_ptr\u0026 a) { m_ptr = a.m_ptr; m_refCount = a.m_refCount; (*m_refCount)++; return *this; } // Move assignment smart_ptr\u0026 operator=(smart_ptr\u0026\u0026 a) { if (\u0026a == this) return *this; delete m_ptr; delete m_refCount; m_ptr = a.m_ptr; a.m_ptr = nullptr; m_refCount = a.m_refCount; a.m_refCount = nullptr; return *this; } T\u0026 operator*() const { return *m_ptr; } T* operator-\u003e() const { return m_ptr; } }; class Resource { public: Resource() { std::cout \u003c\u003c \"Resource acquired\\n\"; } ~Resource() { std::cout \u003c\u003c \"Resource destroyed\\n\"; } }; smart_ptr\u003cResource\u003e func(smart_ptr\u003cResource\u003e temp) { // Do something return temp; } int main() { Resource *res = new Resource; smart_ptr\u003cResource\u003e ptr1(res); { smart_ptr\u003cResource\u003e ptr2(ptr1); auto ptr3 = func(ptr1); std::cout \u003c\u003c \"Killing one shared pointer\\n\"; } std::cout \u003c\u003c \"Killing another shared pointer\\n\"; return 0; } Unlike std::unique_ptr, which uses a single pointer internally, std::shared_ptr uses two pointers internally. One pointer points at the managed resource. The other points at a “control block”, which is a dynamically allocated object that tracks of a bunch of stuff, including how many std::shared_ptr are pointing at the resource. Here I have only used a single variable to keep track of references pointing to resource for simplicity. The actual implementation is a bit bulky for more feature \u0026 security purpose. A bit about move constructor \u0026 move assignment operator When does the move constructor \u0026 move assignment operator get called?\nThe move constructor and move assignment are called when those functions have been defined, and the argument for construction or assignment is an r-value. Most typically, this r-value will be a literal or temporary value.\nIn most cases, a move constructor and move assignment operator will not be provided by default, unless the class does not have any defined copy constructors, copy assignment, move assignment, or destructors. However, the default move constructor and move assignment do the same thing as the default copy constructor and copy assignment (make copies, not do moves). l-value reference \u0026 r-value reference I have already written a separate article for that. std::move In C++11, std::move is a standard library function that serves a single purpose – to convert its argument into an r-value. Once you start using move semantics more regularly, you’ll start to find cases where you want to invoke move semantics, but the objects you have to work with are l-values, not r-values. Use case or benefit of std::move Consider the following swap()function as an example: template\u003cclass T\u003e void swap(T\u0026 a, T\u0026 b) { T tmp { a }; // invokes copy constructor a = b; // invokes copy assignment b = tmp; // invokes copy assignment } int main() { std::string x{ \"abc\" }; std::string y{ \"de\" }; swap(x, y); return 0; } Above swap()function makes 3 copies. That leads to a lot of excessive string creation and destruction, which is slow. However, doing copies isn’t necessary here. All we’re really trying to do is swap the values of a and b, which can be accomplished just as well using 3 moves instead! So if we switch from copy semantics to move semantics, we can make our code more performant. template\u003cclass T\u003e void swap(T\u0026 a, T\u0026 b) { T tmp { std::move(a) }; // invokes move constructor a = std::move(b); // invokes move assignment b = std::move(tmp); // invokes move assignment } std::move can also be useful when sorting an array of elements. Many sorting algorithms (such as selection sort and bubble sort) work by swapping pairs of elements. Here we can use move semantics, which is more efficient. ","wordCount":"792","inLanguage":"en","image":"http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png","datePublished":"2019-09-15T00:00:00Z","dateModified":"2019-09-15T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/move-constructor-assignment-operator-with-shared-ptr/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=http://localhost:1313/posts/ title=Latest><span>Latest</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Move Constructor & Assignment Operator With std::shared_ptr</h1><div class=post-meta><span title='2019-09-15 00:00:00 +0000 UTC'>September 15, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;792 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/move-constructor-assignment-operator-with-shared-ptr.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#implementing-our-shared_ptr-with-move-constructor--assignment-operator>Implementing Our shared_ptr with Move Constructor & Assignment Operator</a></li><li><a href=#a-bit-about-move-constructor--move-assignment-operator>A bit about move constructor & move assignment operator</a><ul><li><a href=#l-value-reference--r-value-reference><code>l-value</code> reference & <code>r-value</code> reference</a></li></ul></li><li><a href=#stdmove>std::move</a><ul><li><a href=#use-case-or-benefit-of-stdmove>Use case or benefit of std::move</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>In an earlier <a href=/posts/understanding-unique-ptr-with-example-in-cpp11/>article</a>, we have seen how move constructor & move assignment operators helped us in creating our own <code>unique_ptr</code>. Here we will use move constructor & assignment operator to implement unsophisticated shared_ptr.</p><h2 id=implementing-our-shared_ptr-with-move-constructor--assignment-operator>Implementing Our shared_ptr with Move Constructor & Assignment Operator<a hidden class=anchor aria-hidden=true href=#implementing-our-shared_ptr-with-move-constructor--assignment-operator>#</a></h2><ul><li>In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by <code>std::unique_ptr</code>. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time. And when the reference count goes to zero which means nobody is using that resource, we will deallocate that resource.</li><li>Unlike <code>std::unique_ptr</code>, which is designed to singly own and manage a resource, <code>std::shared_ptr</code> is meant to solve the case where you need multiple smart pointers co-owning a resource.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>smart_ptr</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>m_refCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>)</span><span class=o>:</span><span class=n>m_ptr</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>m_ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>m_refCount</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>uint32_t</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>m_refCount</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>smart_ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>m_refCount</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>*</span><span class=n>m_refCount</span><span class=p>)</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>((</span><span class=o>*</span><span class=n>m_refCount</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>delete</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>delete</span> <span class=n>m_refCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Copy constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=p>(</span><span class=k>const</span> <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>m_ptr</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>m_refCount</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>m_refCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=o>*</span><span class=n>m_refCount</span><span class=p>)</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Move constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&amp;&amp;</span> <span class=n>a</span><span class=p>)</span><span class=o>:</span> <span class=n>m_ptr</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>),</span> <span class=n>m_refCount</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>m_refCount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>m_refCount</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Copy assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>m_ptr</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>m_refCount</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>m_refCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=o>*</span><span class=n>m_refCount</span><span class=p>)</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Move assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&amp;&amp;</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>a</span> <span class=o>==</span> <span class=k>this</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>m_refCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>m_ptr</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>m_refCount</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>m_refCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>m_refCount</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>*</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=k>operator</span><span class=o>-&gt;</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Resource</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Resource</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Resource acquired</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Resource</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Resource destroyed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>func</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>temp</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Resource</span> <span class=o>*</span><span class=n>res</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Resource</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>ptr1</span><span class=p>(</span><span class=n>res</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>ptr2</span><span class=p>(</span><span class=n>ptr1</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=n>ptr3</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=n>ptr1</span><span class=p>);</span>     
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Killing one shared pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Killing another shared pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Unlike <code>std::unique_ptr</code>, which uses a single pointer internally, <code>std::shared_ptr</code> uses two pointers internally. One pointer points at the managed resource. The other points at a &ldquo;control block&rdquo;, which is a dynamically allocated object that tracks of a bunch of stuff, including how many <code>std::shared_ptr</code> are pointing at the resource.</li><li>Here I have only used a single variable to keep track of references pointing to resource for simplicity. The actual implementation is a bit bulky for more feature & security purpose.</li></ul><h2 id=a-bit-about-move-constructor--move-assignment-operator>A bit about move constructor & move assignment operator<a hidden class=anchor aria-hidden=true href=#a-bit-about-move-constructor--move-assignment-operator>#</a></h2><p><strong>When does the move constructor & move assignment operator get called?</strong></p><p>The move constructor and move assignment are called when those functions have been defined, and the argument for construction or assignment is an <code>r-value</code>. Most typically, this <code>r-value</code> will be a literal or temporary value.</p><ul><li>In most cases, a move constructor and move assignment operator will not be provided by default, unless the class does not have any defined copy constructors, copy assignment, move assignment, or destructors. However, the default move constructor and move assignment do the same thing as the default copy constructor and copy assignment (<strong>make copies, not do moves</strong>).</li></ul><h3 id=l-value-reference--r-value-reference><code>l-value</code> reference & <code>r-value</code> reference<a hidden class=anchor aria-hidden=true href=#l-value-reference--r-value-reference>#</a></h3><ul><li>I have already written a separate <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>article</a> for that.</li></ul><h2 id=stdmove>std::move<a hidden class=anchor aria-hidden=true href=#stdmove>#</a></h2><ul><li>In C++11, <code>std::move</code> is a standard library function that serves a single purpose &ndash; <strong>to convert its argument into an <code>r-value</code></strong>.</li><li>Once you start using <a href=https://stackoverflow.com/questions/3106110/what-is-move-semantics>move semantics</a> more regularly, you&rsquo;ll start to find cases where you want to invoke move semantics, but the objects you have to work with are <code>l-values</code>, not <code>r-values</code>.</li></ul><h3 id=use-case-or-benefit-of-stdmove>Use case or benefit of std::move<a hidden class=anchor aria-hidden=true href=#use-case-or-benefit-of-stdmove>#</a></h3><ul><li>Consider the following <code>swap()</code>function as an example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>swap</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=n>tmp</span> <span class=p>{</span> <span class=n>a</span> <span class=p>};</span> <span class=c1>// invokes copy constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span> <span class=c1>// invokes copy assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>b</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span> <span class=c1>// invokes copy assignment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>x</span><span class=p>{</span> <span class=s>&#34;abc&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>y</span><span class=p>{</span> <span class=s>&#34;de&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>swap</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Above <code>swap()</code>function makes 3 copies. That leads to a lot of excessive string creation and destruction, which is slow.</li><li>However, doing copies isn&rsquo;t necessary here. All we&rsquo;re really trying to do is swap the values of <code>a</code> and <code>b</code>, which can be accomplished just as well using 3 moves instead! So if we switch from copy semantics to move semantics, we can make our code more performant.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>swap</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=n>tmp</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=p>};</span> <span class=c1>// invokes move constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>a</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>b</span><span class=p>);</span> <span class=c1>// invokes move assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>b</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span> <span class=c1>// invokes move assignment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li><code>std::move</code> can also be useful when sorting an array of elements. Many sorting algorithms (such as selection sort and bubble sort) work by swapping pairs of elements. Here we can use move semantics, which is more efficient.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/c-how-to-move-constructor/>C-How-to-Move-Constructor</a></li><li><a href=http://localhost:1313/tags/c-move-constructor-explained/>C-Move-Constructor-Explained</a></li><li><a href=http://localhost:1313/tags/c-move-constructor-tutorial/>C-Move-Constructor-Tutorial</a></li><li><a href=http://localhost:1313/tags/c-why-use-move-constructor/>C-Why-Use-Move-Constructor</a></li><li><a href=http://localhost:1313/tags/how-move-constructor-works/>How-Move-Constructor-Works</a></li><li><a href=http://localhost:1313/tags/how-move-constructor-works-c/>How-Move-Constructor-Works-C</a></li><li><a href=http://localhost:1313/tags/how-to-call-move-constructor/>How-to-Call-Move-Constructor</a></li><li><a href=http://localhost:1313/tags/how-to-invoke-move-constructor/>How-to-Invoke-Move-Constructor</a></li><li><a href=http://localhost:1313/tags/how-to-use-move-constructor-c/>How-to-Use-Move-Constructor-C</a></li><li><a href=http://localhost:1313/tags/implementing-our-shared_ptr-with-move-constructor-and-assignment-operator/>Implementing-Our-Shared_ptr-With-Move-Constructor-and-Assignment-Operator</a></li><li><a href=http://localhost:1313/tags/lvalue-reference-and-rvalue-reference/>Lvalue-Reference-and-Rvalue-Reference</a></li><li><a href=http://localhost:1313/tags/move-assignment/>Move-Assignment</a></li><li><a href=http://localhost:1313/tags/move-constructor/>Move-Constructor</a></li><li><a href=http://localhost:1313/tags/move-constructor-and-assignment-operator-with-shared_ptr/>Move-Constructor-and-Assignment-Operator-With-Shared_ptr</a></li><li><a href=http://localhost:1313/tags/move-constructor-and-move-assignment-operator/>Move-Constructor-and-Move-Assignment-Operator</a></li><li><a href=http://localhost:1313/tags/move-constructor-c-example/>Move-Constructor-C-Example</a></li><li><a href=http://localhost:1313/tags/move-constructor-c-header/>Move-Constructor-C-Header</a></li><li><a href=http://localhost:1313/tags/move-constructor-how-to-use/>Move-Constructor-How-to-Use</a></li><li><a href=http://localhost:1313/tags/move-constructor-in-c-example/>Move-Constructor-in-C-Example</a></li><li><a href=http://localhost:1313/tags/move-constructor-in-c-geeksforgeeks/>Move-Constructor-in-C-Geeksforgeeks</a></li><li><a href=http://localhost:1313/tags/move-constructor-lvalue-rvalue/>Move-Constructor-Lvalue-Rvalue</a></li><li><a href=http://localhost:1313/tags/move-constructor-rvalue/>Move-Constructor-Rvalue</a></li><li><a href=http://localhost:1313/tags/move-constructor-stack-overflow/>Move-Constructor-Stack-Overflow</a></li><li><a href=http://localhost:1313/tags/move-constructor-unique_ptr/>Move-Constructor-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/move-constructor-with-swap/>Move-Constructor-With-Swap</a></li><li><a href=http://localhost:1313/tags/move-constructor-with-unique_ptr/>Move-Constructor-With-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/move-copy-constructor-example/>Move-Copy-Constructor-Example</a></li><li><a href=http://localhost:1313/tags/shared_ptr/>Shared_ptr</a></li><li><a href=http://localhost:1313/tags/syntax-for-move-constructor/>Syntax-for-Move-Constructor</a></li><li><a href=http://localhost:1313/tags/unique_ptr/>Unique_ptr</a></li><li><a href=http://localhost:1313/tags/use-case-or-benefit-of-stdmove-move-constructor-c11/>Use-Case-or-Benefit-of-Stdmove-Move-Constructor-C11</a></li><li><a href=http://localhost:1313/tags/what-is-move-constructor-in-cpp/>What-Is-Move-Constructor-in-Cpp</a></li><li><a href=http://localhost:1313/tags/when-does-the-move-constructor-and-move-assignment-operator-get-called/>When-Does-the-Move-Constructor-and-Move-Assignment-Operator-Get-Called</a></li><li><a href=http://localhost:1313/tags/when-is-move-constructor-called-c/>When-Is-Move-Constructor-Called-C</a></li><li><a href=http://localhost:1313/tags/why-do-we-need-move-constructor/>Why-Do-We-Need-Move-Constructor</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/><span class=title>« Prev</span><br><span>Lvalue Rvalue and Their References With Example in C++</span>
</a><a class=next href=http://localhost:1313/posts/unique_ptr-with-example-in-c/><span class=title>Next »</span><br><span>Understanding unique_ptr with Example in C++11</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Move Constructor & Assignment Operator With std::shared_ptr on x" href="https://x.com/intent/tweet/?text=Move%20Constructor%20%26%20Assignment%20Operator%20With%20std%3a%3ashared_ptr&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fmove-constructor-assignment-operator-with-shared-ptr%2f&amp;hashtags=c-how-to-move-constructor%2cc-move-constructor-explained%2cc-move-constructor-tutorial%2cc-why-use-move-constructor%2chow-move-constructor-works%2chow-move-constructor-works-c%2chow-to-call-move-constructor%2chow-to-invoke-move-constructor%2chow-to-use-move-constructor-c%2cimplementing-our-shared_ptr-with-move-constructor-and-assignment-operator%2clvalue-reference-and-rvalue-reference%2cmove-assignment%2cmove-constructor%2cmove-constructor-and-assignment-operator-with-shared_ptr%2cmove-constructor-and-move-assignment-operator%2cmove-constructor-c-example%2cmove-constructor-c-header%2cmove-constructor-how-to-use%2cmove-constructor-in-c-example%2cmove-constructor-in-c-geeksforgeeks%2cmove-constructor-lvalue-rvalue%2cmove-constructor-rvalue%2cmove-constructor-stack-overflow%2cmove-constructor-unique_ptr%2cmove-constructor-with-swap%2cmove-constructor-with-unique_ptr%2cmove-copy-constructor-example%2cshared_ptr%2csyntax-for-move-constructor%2cunique_ptr%2cuse-case-or-benefit-of-stdmove-move-constructor-c11%2cwhat-is-move-constructor-in-cpp%2cwhen-does-the-move-constructor-and-move-assignment-operator-get-called%2cwhen-is-move-constructor-called-c%2cwhy-do-we-need-move-constructor"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Move Constructor & Assignment Operator With std::shared_ptr on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fmove-constructor-assignment-operator-with-shared-ptr%2f&amp;title=Move%20Constructor%20%26%20Assignment%20Operator%20With%20std%3a%3ashared_ptr&amp;summary=Move%20Constructor%20%26%20Assignment%20Operator%20With%20std%3a%3ashared_ptr&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fmove-constructor-assignment-operator-with-shared-ptr%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Move Constructor & Assignment Operator With std::shared_ptr on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fmove-constructor-assignment-operator-with-shared-ptr%2f&title=Move%20Constructor%20%26%20Assignment%20Operator%20With%20std%3a%3ashared_ptr"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Move Constructor & Assignment Operator With std::shared_ptr on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fmove-constructor-assignment-operator-with-shared-ptr%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Move Constructor & Assignment Operator With std::shared_ptr on whatsapp" href="https://api.whatsapp.com/send?text=Move%20Constructor%20%26%20Assignment%20Operator%20With%20std%3a%3ashared_ptr%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fmove-constructor-assignment-operator-with-shared-ptr%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Move Constructor & Assignment Operator With std::shared_ptr on telegram" href="https://telegram.me/share/url?text=Move%20Constructor%20%26%20Assignment%20Operator%20With%20std%3a%3ashared_ptr&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fmove-constructor-assignment-operator-with-shared-ptr%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Move Constructor & Assignment Operator With std::shared_ptr on ycombinator" href="https://news.ycombinator.com/submitlink?t=Move%20Constructor%20%26%20Assignment%20Operator%20With%20std%3a%3ashared_ptr&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fmove-constructor-assignment-operator-with-shared-ptr%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>