<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Move Constructor &amp; Assignment Operator With std::shared_ptr · Vishal Chovatiya
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Vishal Chovatiya">
<meta name="description" content="In an earlier article, we have seen how move constructor &amp; move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor &amp; assignment operator to implement unsophisticated shared_ptr.
Implementing Our shared_ptr with Move Constructor &amp; Assignment Operator Link to heading In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time.">
<meta name="keywords" content="blog,developer,personal">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Move Constructor &amp; Assignment Operator With std::shared_ptr">
  <meta name="twitter:description" content="In an earlier article, we have seen how move constructor &amp; move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor &amp; assignment operator to implement unsophisticated shared_ptr.
Implementing Our shared_ptr with Move Constructor &amp; Assignment Operator Link to heading In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time.">

<meta property="og:url" content="http://localhost:1313/posts/move-constructor-assignment-operator-with-shared-ptr/">
  <meta property="og:site_name" content="Vishal Chovatiya">
  <meta property="og:title" content="Move Constructor &amp; Assignment Operator With std::shared_ptr">
  <meta property="og:description" content="In an earlier article, we have seen how move constructor &amp; move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor &amp; assignment operator to implement unsophisticated shared_ptr.
Implementing Our shared_ptr with Move Constructor &amp; Assignment Operator Link to heading In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-09-15T00:00:00+00:00">
    <meta property="article:modified_time" content="2019-09-15T00:00:00+00:00">




<link rel="canonical" href="http://localhost:1313/posts/move-constructor-assignment-operator-with-shared-ptr/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>




<body class="preload-transitions colorscheme-light">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      Vishal Chovatiya
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Latest</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/pages/start-here">Start Here</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/cpp/">C/C&#43;&#43;</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/linux-system-programming/">Linux System Programming</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/misc/">Misc</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/move-constructor-assignment-operator-with-shared-ptr/">
              Move Constructor &amp; Assignment Operator With std::shared_ptr
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2019-09-15T00:00:00Z">
                September 15, 2019
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              4-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/cpp/">Cpp</a></div>

          
        </div>
      </header>

      <div class="post-content">
        
          <img src="/images/20-new-features-of-Modern-C-to-use-in-your-project.png" alt="Featured image"/>
        
        <p>In an earlier <a href="/posts/understanding-unique-ptr-with-example-in-cpp11/" >article</a>, we have seen how move constructor &amp; move assignment operators helped us in creating our own <code>unique_ptr</code>. Here we will use move constructor &amp; assignment operator to implement unsophisticated shared_ptr.</p>
<h2 id="implementing-our-shared_ptr-with-move-constructor--assignment-operator">
  Implementing Our shared_ptr with Move Constructor &amp; Assignment Operator
  <a class="heading-link" href="#implementing-our-shared_ptr-with-move-constructor--assignment-operator">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by <code>std::unique_ptr</code>. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time. And when the reference count goes to zero which means nobody is using that resource, we will deallocate that resource.</li>
<li>Unlike <code>std::unique_ptr</code>, which is designed to singly own and manage a resource, <code>std::shared_ptr</code> is meant to solve the case where you need multiple smart pointers co-owning a resource.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">smart_ptr</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">*</span> m_ptr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>m_refCount;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    smart_ptr(T<span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>)<span style="color:#f92672">:</span>m_ptr(ptr)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(m_ptr)
</span></span><span style="display:flex;"><span>            m_refCount <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">uint32_t</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            m_refCount <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>smart_ptr()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(m_refCount <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>){
</span></span><span style="display:flex;"><span>            (<span style="color:#f92672">*</span>m_refCount)<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>((<span style="color:#f92672">*</span>m_refCount) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">delete</span> m_ptr;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">delete</span> m_refCount;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Copy constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    smart_ptr(<span style="color:#66d9ef">const</span> smart_ptr<span style="color:#f92672">&amp;</span> a)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        m_ptr <span style="color:#f92672">=</span> a.m_ptr;
</span></span><span style="display:flex;"><span>        m_refCount <span style="color:#f92672">=</span> a.m_refCount;
</span></span><span style="display:flex;"><span>        (<span style="color:#f92672">*</span>m_refCount)<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Move constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    smart_ptr(smart_ptr<span style="color:#f92672">&amp;&amp;</span> a)<span style="color:#f92672">:</span> m_ptr(a.m_ptr), m_refCount(a.m_refCount)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        a.m_ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        a.m_refCount <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Copy assignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    smart_ptr<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> smart_ptr<span style="color:#f92672">&amp;</span> a)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        m_ptr <span style="color:#f92672">=</span> a.m_ptr;
</span></span><span style="display:flex;"><span>        m_refCount <span style="color:#f92672">=</span> a.m_refCount;
</span></span><span style="display:flex;"><span>        (<span style="color:#f92672">*</span>m_refCount)<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Move assignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    smart_ptr<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(smart_ptr<span style="color:#f92672">&amp;&amp;</span> a)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">&amp;</span>a <span style="color:#f92672">==</span> <span style="color:#66d9ef">this</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> m_ptr;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> m_refCount;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        m_ptr <span style="color:#f92672">=</span> a.m_ptr;
</span></span><span style="display:flex;"><span>        a.m_ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        m_refCount <span style="color:#f92672">=</span> a.m_refCount;
</span></span><span style="display:flex;"><span>        a.m_refCount <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>m_ptr; }
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">-&gt;</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> m_ptr; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Resource</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Resource() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Resource acquired</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>Resource() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Resource destroyed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>smart_ptr<span style="color:#f92672">&lt;</span>Resource<span style="color:#f92672">&gt;</span> func(smart_ptr<span style="color:#f92672">&lt;</span>Resource<span style="color:#f92672">&gt;</span> temp) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Do something
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Resource <span style="color:#f92672">*</span>res <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Resource;
</span></span><span style="display:flex;"><span>    smart_ptr<span style="color:#f92672">&lt;</span>Resource<span style="color:#f92672">&gt;</span> ptr1(res);
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        smart_ptr<span style="color:#f92672">&lt;</span>Resource<span style="color:#f92672">&gt;</span> ptr2(ptr1); 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> ptr3 <span style="color:#f92672">=</span> func(ptr1);     
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Killing one shared pointer</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Killing another shared pointer</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Unlike <code>std::unique_ptr</code>, which uses a single pointer internally, <code>std::shared_ptr</code> uses two pointers internally. One pointer points at the managed resource. The other points at a &ldquo;control block&rdquo;, which is a dynamically allocated object that tracks of a bunch of stuff, including how many <code>std::shared_ptr</code> are pointing at the resource.</li>
<li>Here I have only used a single variable to keep track of references pointing to resource for simplicity. The actual implementation is a bit bulky for more feature &amp; security purpose.</li>
</ul>
<h2 id="a-bit-about-move-constructor--move-assignment-operator">
  A bit about move constructor &amp; move assignment operator
  <a class="heading-link" href="#a-bit-about-move-constructor--move-assignment-operator">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>When does the move constructor &amp; move assignment operator get called?</strong></p>
<p>The move constructor and move assignment are called when those functions have been defined, and the argument for construction or assignment is an <code>r-value</code>. Most typically, this <code>r-value</code> will be a literal or temporary value.</p>
<ul>
<li>In most cases, a move constructor and move assignment operator will not be provided by default, unless the class does not have any defined copy constructors, copy assignment, move assignment, or destructors. However, the default move constructor and move assignment do the same thing as the default copy constructor and copy assignment (<strong>make copies, not do moves</strong>).</li>
</ul>
<h3 id="l-value-reference--r-value-reference">
  <code>l-value</code> reference &amp; <code>r-value</code> reference
  <a class="heading-link" href="#l-value-reference--r-value-reference">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>I have already written a separate <a href="/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/" >article</a> for that.</li>
</ul>
<h2 id="stdmove">
  std::move
  <a class="heading-link" href="#stdmove">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>In C++11, <code>std::move</code> is a standard library function that serves a single purpose &ndash; <strong>to convert its argument into an <code>r-value</code></strong>.</li>
<li>Once you start using <a href="https://stackoverflow.com/questions/3106110/what-is-move-semantics"  class="external-link" target="_blank" rel="noopener">move semantics</a> more regularly, you&rsquo;ll start to find cases where you want to invoke move semantics, but the objects you have to work with are <code>l-values</code>, not <code>r-values</code>.</li>
</ul>
<h3 id="use-case-or-benefit-of-stdmove">
  Use case or benefit of std::move
  <a class="heading-link" href="#use-case-or-benefit-of-stdmove">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Consider the following <code>swap()</code>function as an example:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> swap(T<span style="color:#f92672">&amp;</span> a, T<span style="color:#f92672">&amp;</span> b) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>  T tmp { a }; <span style="color:#75715e">// invokes copy constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  a <span style="color:#f92672">=</span> b; <span style="color:#75715e">// invokes copy assignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  b <span style="color:#f92672">=</span> tmp; <span style="color:#75715e">// invokes copy assignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string x{ <span style="color:#e6db74">&#34;abc&#34;</span> };
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string y{ <span style="color:#e6db74">&#34;de&#34;</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    swap(x, y);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Above <code>swap()</code>function makes 3 copies. That leads to a lot of excessive string creation and destruction, which is slow.</li>
<li>However, doing copies isn&rsquo;t necessary here. All we&rsquo;re really trying to do is swap the values of <code>a</code> and <code>b</code>, which can be accomplished just as well using 3 moves instead! So if we switch from copy semantics to move semantics, we can make our code more performant.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> swap(T<span style="color:#f92672">&amp;</span> a, T<span style="color:#f92672">&amp;</span> b) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>  T tmp { std<span style="color:#f92672">::</span>move(a) }; <span style="color:#75715e">// invokes move constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  a <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(b); <span style="color:#75715e">// invokes move assignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  b <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(tmp); <span style="color:#75715e">// invokes move assignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li><code>std::move</code> can also be useful when sorting an array of elements. Many sorting algorithms (such as selection sort and bubble sort) work by swapping pairs of elements. Here we can use move semantics, which is more efficient.</li>
</ul>

      </div>


      <footer>
        


        
        
        
        
        

        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2024
     Vishal Chovatiya 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  
  



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
