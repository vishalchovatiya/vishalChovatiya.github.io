<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ Template: A Quick UpToDate Look(C++11/14/17/20) | Vishal Chovatiya</title>
<meta name=keywords content="c-template-return-type,c-alternative-to-partial-function-template-specialization,c-c-template-reference-collapsing-rules,c-capturing-containers-value-type-explicitly,c-class-template,c-class-template-argument-deduction-ctad,c-class-template-specialization,c-curiously-recurring-template-pattern,c-default-template-arguments,c-explicit-template-instantiation,c-fold-expressions-vs-variadic-template,c-forwarding-reference,c-full-template-specialization,c-function-template,c-function-template-argument-deduction,c-function-template-specialization,c-generic-class,c-generic-solution-using-variadic-template,c-how-does-variadic-class-template-works,c-how-does-variadic-function-template-works,c-inferring-template-argument-through-function-template,c-naive-way-to-capture-containers-value-type,c-nested-template-template-template-parameter,c-non-type-template-parameter,c-overriding-template-argument-deduction,c-parameter-pack,c-partial-class-template-specialization,c-partial-function-template-specialization,c-partial-template-specialization,c-passing-any-container-to-c-template-function,c-passing-container-of-container-or-2d-std-vector-as-c-template-argument,c-passing-function-to-class-template-argument,c-passing-std-container-as-c-template-argument,c-passing-std-vector-to-c-template-function,c-perfect-forwarding,c-template-argument,c-template-argument-deduction,c-template-argument-forwarding,c-template-class-constructor,c-template-class-definition,c-template-example-use-cases,c-template-method,c-template-programming,c-template-struct,c-template-terminology-jargon-idiom,c-template-the-complete-guide,c-template-typename-vs-class,c-template-types,c-template-variable-number-of-arguments,c-union-template,c-universal-reference,c-using-typename,c-vararg,c-variadic-arguments,c-variadic-class-template,c-variadic-constructor,c-variadic-function-template,c-variadic-template,c-why-do-we-need-forwarding-reference-in-first-place,c11-template-type-alias,c14-implementing-unsophisticated-tuple-class,c14-or-c17-template-and-auto-keyword,c20-template-lambda-expression,difference-between-function-template-and-class-template-in-c,explicit-instantiation-c,sizeof-parameter-pack,template-typename-t,variadic-templates-c-example"><meta name=description content="I know, it’s been a while since the last time I published something newbies-friendly on my blog. The main reason is that most of my readers are either experienced devs or from C background having modest C++ encounter. But while programming in C++ you need a completely different mindset as both C & C++ belongs to different programming paradigm. And I always strive to show them a better way of doing things in C++."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/c-template-a-quick-uptodate-look/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/c-template-a-quick-uptodate-look/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="C++ Template: A Quick UpToDate Look(C++11/14/17/20)"><meta property="og:description" content="I know, it’s been a while since the last time I published something newbies-friendly on my blog. The main reason is that most of my readers are either experienced devs or from C background having modest C++ encounter. But while programming in C++ you need a completely different mindset as both C & C++ belongs to different programming paradigm. And I always strive to show them a better way of doing things in C++."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/c-template-a-quick-uptodate-look/"><meta property="og:image" content="https://vishalchovatiya.github.io/images/Cpp-Template-Vishal-Chovatiya.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-17T00:00:00+00:00"><meta property="article:modified_time" content="2020-05-17T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/images/Cpp-Template-Vishal-Chovatiya.webp"><meta name=twitter:title content="C++ Template: A Quick UpToDate Look(C++11/14/17/20)"><meta name=twitter:description content="I know, it’s been a while since the last time I published something newbies-friendly on my blog. The main reason is that most of my readers are either experienced devs or from C background having modest C++ encounter. But while programming in C++ you need a completely different mindset as both C & C++ belongs to different programming paradigm. And I always strive to show them a better way of doing things in C++."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ Template: A Quick UpToDate Look(C++11/14/17/20)","item":"https://vishalchovatiya.github.io/posts/c-template-a-quick-uptodate-look/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ Template: A Quick UpToDate Look(C++11/14/17/20)","name":"C\u002b\u002b Template: A Quick UpToDate Look(C\u002b\u002b11\/14\/17\/20)","description":"I know, it’s been a while since the last time I published something newbies-friendly on my blog. The main reason is that most of my readers are either experienced devs or from C background having modest C++ encounter. But while programming in C++ you need a completely different mindset as both C \u0026amp; C++ belongs to different programming paradigm. And I always strive to show them a better way of doing things in C++.","keywords":["c-template-return-type","c-alternative-to-partial-function-template-specialization","c-c-template-reference-collapsing-rules","c-capturing-containers-value-type-explicitly","c-class-template","c-class-template-argument-deduction-ctad","c-class-template-specialization","c-curiously-recurring-template-pattern","c-default-template-arguments","c-explicit-template-instantiation","c-fold-expressions-vs-variadic-template","c-forwarding-reference","c-full-template-specialization","c-function-template","c-function-template-argument-deduction","c-function-template-specialization","c-generic-class","c-generic-solution-using-variadic-template","c-how-does-variadic-class-template-works","c-how-does-variadic-function-template-works","c-inferring-template-argument-through-function-template","c-naive-way-to-capture-containers-value-type","c-nested-template-template-template-parameter","c-non-type-template-parameter","c-overriding-template-argument-deduction","c-parameter-pack","c-partial-class-template-specialization","c-partial-function-template-specialization","c-partial-template-specialization","c-passing-any-container-to-c-template-function","c-passing-container-of-container-or-2d-std-vector-as-c-template-argument","c-passing-function-to-class-template-argument","c-passing-std-container-as-c-template-argument","c-passing-std-vector-to-c-template-function","c-perfect-forwarding","c-template-argument","c-template-argument-deduction","c-template-argument-forwarding","c-template-class-constructor","c-template-class-definition","c-template-example-use-cases","c-template-method","c-template-programming","c-template-struct","c-template-terminology-jargon-idiom","c-template-the-complete-guide","c-template-typename-vs-class","c-template-types","c-template-variable-number-of-arguments","c-union-template","c-universal-reference","c-using-typename","c-vararg","c-variadic-arguments","c-variadic-class-template","c-variadic-constructor","c-variadic-function-template","c-variadic-template","c-why-do-we-need-forwarding-reference-in-first-place","c11-template-type-alias","c14-implementing-unsophisticated-tuple-class","c14-or-c17-template-and-auto-keyword","c20-template-lambda-expression","difference-between-function-template-and-class-template-in-c","explicit-instantiation-c","sizeof-parameter-pack","template-typename-t","variadic-templates-c-example"],"articleBody":"I know, it’s been a while since the last time I published something newbies-friendly on my blog. The main reason is that most of my readers are either experienced devs or from C background having modest C++ encounter. But while programming in C++ you need a completely different mindset as both C \u0026 C++ belongs to different programming paradigm. And I always strive to show them a better way of doing things in C++. Anyway, I found the topic which is lengthy, reasonably complex(at least it was for me), newbies-friendly as well as energizing for experienced folks(if Modern C++ jargons, rules \u0026 features added) i.e. C++ Template.\nI will start with a simple class/function template and as we move along, will increase the complexity. And also cover the advance topics like the variadic template, nested template, CRTP, template vs fold-expression, etc. But, yes! we would not take deeper dive otherwise this would become a book rather than an article.\nNote: I would recommend you to use cppinsights online tool wherever you feel confused. It helps you to see Template Instances, Template Argument Deduction, etc. Basically, it helps you to see code from the compiler’s perspective.\nTerminology/Jargon/Idiom You May Face Template Instantiation: It is a process of generating a concrete class/struct/union/function out of templated class/struct/union/function for a particular combination of template arguments. For example, if you use vector \u0026 vector, it will create two different concrete classes during compilation. This process of creating concrete classes is known as Template Instantiation. Template Instances: Outcome of Template Instantiation is Template Instances i.e. concrete classes. Explicit Template Instantiation: Usually template instantiation done at the time of object declaration. But you can also force the compiler to instantiate class/struct/union/function with particular type without even creating the object. It may appear in the program anywhere after the template definition, and for a given argument-list. Will see this later in the article. Template Argument vs Template Parameter: In expression template void print(_T a_){ };, T is parameter \u0026 when you call print(5);, 5 which is of type int is template argument. This is a trivial thing for some pips. But not for non-native English speaker or beginners. So, this ambiguity has to be clear. C++ Template Types Class Template template \u003ctypename T1, typename T2\u003e class pair { public: T1 first; T2 second; }; pair\u003cint, char\u003e p1; pair\u003cfloat, float\u003e p2; The basic idea of a class template is that the template parameter i.e. T1 \u0026 T2 gets substituted by an appropriate deduced type at compile time. The result is that the same class can be reused for multiple types. And the user has to specify which type they want to use when an object of the class is declared. Function Template template \u003ctypename T\u003e T min(T a, T b) { return a \u003c b ? a : b; } min\u003cint\u003e(4, 5); // Case 1 min\u003cfloat\u003e(4.1f, 5.1f); // Case 2 In both of the above case, the template arguments used to replace the types of the parameters i.e. T. One additional property of template functions (unlike class template till C++17) is that the compiler can infer the template parameters based on the parameters passed to the function. So, passing \u0026 after the function name is redundant. Union Template Yes! a union can also be templatized. In fact, the standard library provides some utilities like std::optional, std::variant, etc. which directly or indirectly uses templatized union. template \u003ctypename T\u003e union test { uint8_t ch[sizeof(T)]; T variable; }; As you can see above, templatized unions are also particularly useful to represent a type simultaneously as a byte array. Variable Template Yes! This may a bit socking. But, you can templatise the variable also since C++14. template \u003cclass T\u003e constexpr T pi = T(3.1415926535897932385L); // variable template cout \u003c\u003c pi\u003cfloat\u003e \u003c\u003c endl; // 3.14159 cout \u003c\u003c pi\u003cint\u003e \u003c\u003c endl; // 3 Now, you might be wondering that what is the point of the templatizing variable. But, consider the following example: template \u003cuint32_t val\u003e constexpr auto fib = fib\u003cval - 1\u003e + fib\u003cval - 2\u003e; template \u003c\u003e constexpr auto fib\u003c0\u003e = 0; template \u003c\u003e constexpr auto fib\u003c1\u003e = 1; cout \u003c\u003c fib\u003c10\u003e \u003c\u003c endl; // 55 Above code gives you 10th Fibonacci term at compile time, without even creating class or function. C++ Template Argument Overriding Template Argument Deduction template \u003ctypename T\u003e T min(T a, T b) { cout \u003c\u003c typeid(T).name() \u003c\u003c endl; // T will be deduce as `int` return a \u003c b ? a : b; } min\u003cint\u003e(5.5f, 6.6f); // Implicit conversion happens here Default Template Arguments template \u003cclass T, size_t N = 10\u003e struct array { T arr[N]; }; array\u003cint\u003e arr; Just like in case of the function arguments, template parameters can also have their default values. All template parameters with a default value have to be declared at the end of the template parameter list. Template Argument Deduction Function Template Argument Deduction Function template argument deduction is done by comparing the types of function arguments to function parameters, according to rules in the Standard. Which makes function templates far more usable than they would otherwise be. For example, given a function template like: template \u003ctypename RanIt\u003e void sort(RanIt first, RanIt last){ // . . . } You can and should sort a std::vector without explicitly specifying that RanIt is std::vector::iterator. When the compiler sees sort(v.begin(), v.end());, it knows what the types of v.begin() and v.end()are, so it can determine what RanIt` should be. Class Template Argument Deduction(CTAD) Until C++17, template classes could not apply type deduction in their initialization as template function do. For example //... pair p4{1, 'A'}; // Not OK until C++17: Can't deduce type in initialization //... But from C++17, the compiler can deduce types in class/struct initialization \u0026 this to work, class/struct must have an appropriate constructor. But this limitation is also relaxed in C++20. So technically from C++20, you can construct the object with aggregate initialization \u0026 without specifying types explicitly. Until C++17, the standard provided some std::make_ utility functions to counter such situations as below. Inferring Template Argument Through Function Template You might have seen many functions like std::make_pair(), std::make_unique(), `std::make_share(), etc. Which can typically \u0026 unsophistically implement as: template \u003ctypename T1, typename T2\u003e pair\u003cT1, T2\u003e make_pair(T1\u0026\u0026 t1, T2\u0026\u0026 t2) { return {forward\u003cT1\u003e(t1), forward\u003cT2\u003e(t2)}; } But have you ever wonder why these helper functions are there in the standard library? How does this even help? pair\u003cint, char\u003e p1{1, 'A'}; // Rather using this auto p2 = make_pair(1, 2); // Use this instead auto p3 = make_pair\u003cfloat\u003e(1, 2.4f); // Or specify types explicitly Rather than specifying the arguments explicitly, you can leverage the feature of inferring template argument from function template to construct the object. In the above case, template argument deduction is done by the utility function make_pair. As a result, we have created the object of pair without specifying the type explicitly. And as discussed earlier from C++17, you can construct the object without even specifying types explicitly so std::vector v{1,2,3,4}; is perfectly valid statement. Template Argument Forwarding C++ Template Reference Collapsing Rules Apart from accepting type \u0026 value in the template parameter. You can enable the template to accept both lvalue and rvalue references. And to do this you need to adhere to the rules of reference collapsing as follows: T\u0026 \u0026 becomes T\u0026 T\u0026 \u0026\u0026 become T\u0026 T\u0026\u0026 \u0026 becomes T\u0026 T\u0026\u0026 \u0026\u0026 becomes T\u0026\u0026 template \u003ctypename T\u003e void f(T \u0026\u0026t); In the above case, the real type of t depends on the context. For example: int x = 0; f(0); // deduces as rvalue reference i.e. f(int\u0026\u0026) f(x); // deduces as lvalue reference i.e. f(int\u0026) In case of f(0);, 0 is rvalue of type int, hence T = int\u0026\u0026, thus f(int\u0026\u0026 \u0026\u0026t) becomes f(int\u0026\u0026 t). In case of f(x);, x is lvalue of type int, hence T = int\u0026, thus f(int\u0026 \u0026\u0026t) becomes f(int\u0026 t). Perfect Forwarding | Forwarding Reference | Universal Reference In order to perfectly forward t to another function, one must use std::forward as: template \u003ctypename T\u003e void func1(T \u0026\u0026t) { func2(std::forward\u003cT\u003e(t)); // Forward appropriate lvalue or rvalue reference to another function } Forwarding references can also be used with variadic templates: template \u003ctypename... Args\u003e void func1(Args\u0026\u0026... args) { func2(std::forward\u003cArgs\u003e(args)...); } Why Do We Need Forwarding Reference in First Place? Answer to this question lies in move semantics. Though, short answer to this question is “To perform copy/move depending upon value category type”. C++ Template Category Full Template Specialization Template has a facility to define implementation for specific instantiations of a template class/struct/union/function/method. Function Template Specialization template \u003ctypename T\u003e T sqrt(T t) { /* Some generic implementation */ } template\u003c\u003e int sqrt\u003cint\u003e(int i) { /* Highly optimized integer implementation */ } In the above case, a user that writes sqrt(4.0) will get the generic implementation whereas sqrt(4) will get the specialized implementation. Class Template Specialization template \u003ctypename T\u003e // Common case struct Vector { void print() {} }; template \u003c\u003e // Special case struct Vector\u003cbool\u003e { void print_bool() {} }; Vector\u003cint\u003e v1; v1.print_bool(); // Not OK: Chose common case Vector v1.print() // OK Vector\u003cbool\u003e v2; // OK : Chose special case Vector Partial Template Specialization Partial Class Template Specialization In contrast of a full template specialization, you can also specialise template partially with some of the arguments of existing template fixed. Partial template specialization is only available for template class/structs/union: template \u003ctypename T1, typename T2\u003e // Common case struct Pair { T1 first; T2 second; void print_first() {} }; template \u003ctypename T\u003e // Partial specialization on first argument as int struct Pair\u003cint, T\u003e { void print() {} }; // Use case 1 ---------------------------------------------------------- Pair\u003cchar, float\u003e p1; // Chose common case p1.print_first(); // OK // p1.print(); // Not OK: p1 is common case \u0026 it doesn't have print() method // Use case 2 ---------------------------------------------------------- Pair\u003cint, float\u003e p2; // Chose special case p2.print(); // OK // p2.print_first(); // Not OK: p2 is special case \u0026 it does not have print_first() // Use case 3 ---------------------------------------------------------- // Pair p3; // Not OK: Number of argument should be same as Primary template Partial Function Template Specialization You cannot partially specialize method/function. Function templates may only be fully specialized template \u003ctypename T, typename U\u003e void foo(T t, U u) { cout \u003c\u003c \"Common case\" \u003c\u003c endl; } // OK. template \u003c\u003e void foo\u003cint, int\u003e(int a1, int a2) { cout \u003c\u003c \"Fully specialized case\" \u003c\u003c endl; } // Compilation error: partial function specialization is not allowed. template \u003ctypename U\u003e void foo\u003cstring, U\u003e(string t, U u) { cout \u003c\u003c \"Partial specialized case\" \u003c\u003c endl; } foo(1, 2.1); // Common case foo(1, 2); // Fully specialized case Alternative To Partial Function Template Specialization As I have mentioned earlier, partial specialization of function templates is not allowed. You can use SFINAE with std::enable_if for work around as follows: template \u003ctypename T, typename std::enable_if_t\u003c!std::is_pointer\u003cT\u003e::value\u003e * = nullptr\u003e void func(T val) { cout \u003c\u003c \"Value\" \u003c\u003c endl; } template \u003ctypename T, typename std::enable_if_t\u003cstd::is_pointer\u003cT\u003e::value\u003e * = nullptr\u003e void func(T val) { // NOTE: function signature is NOT-MODIFIED cout \u003c\u003c \"Pointer\" \u003c\u003c endl; } int a = 0; func(a); func(\u0026a); Non-Type Template Parameter As the name suggests, apart from types, you can also declare the template parameter as constant expressions like addresses, references, integrals, std::nullptr_t, enums, etc. Like all other template parameters, non-type template parameters can be explicitly specified, defaulted, or derived implicitly via Template Argument Deduction. The more specific use case of a non-type template is passing a plain array into a function without specifying its size explicitly. A more relevant example of this is std::begin \u0026 std::end specialisation for array literal from the standard library: template \u003c class T, size_t size\u003e // Non Type Template T* begin(T (\u0026arr)[size]) { // Array size deduced implicitly return arr; } int arr[] = {1,2,3,4}; begin(arr); // Do not have to pass size explicitly Non-type template parameters are one of the ways to achieve template recurrence \u0026 enables Template Meta-programming. Nested Template: Template Template Parameter Sometimes we have to pass templated type into another templated type. And in such case, you not only have to take care of main template type but also a nested template type. Very simple template- template parameter examples is: template\u003c template \u003ctypename\u003e class C, typename T \u003e void print_container(C\u003cT\u003e \u0026c) { // . . . } template \u003ctypename T\u003e class My_Type { // . . . }; My_Type\u003cint\u003e t; print_container(t); Variadic Template It is often useful to define class/struct/union/function that accepts a variable number and type of arguments. If you have already used C you’ll know that printf function can accept any number of arguments. Such functions are entirely implemented through macros or ellipses operator. And because of that it has several disadvantages like type-safety, cannot accept references as arguments, etc. Variadic Class Template Implementing Unsophisticated Tuple Class(\u003e=C++14) Since C++11 standard library introduced std::tuple class that accept variable data members at compile time using the variadic template. And to understand its working, we will build our own ADT same as std::tuple `` The variadic template usually starts with the general (empty) definition, that also serves as the base-case for recursion termination in the later specialisation: template \u003ctypename... T\u003e struct Tuple { }; This already allows us to define an empty structure i.e. Tuple\u003c\u003e object;, albeit that isn’t very useful yet. Next comes the recursive case specialisation: template\u003c typename T, typename... Rest \u003e struct Tuple\u003cT, Rest...\u003e { T first; Tuple\u003cRest...\u003e rest; Tuple(const T\u0026 f, const Rest\u0026 ... r) : first(f) , rest(r...) { } }; Tuple\u003cbool\u003e t1(false); // Case 1 Tuple\u003cint, char, string\u003e t2(1, 'a', \"ABC\"); // Case 2 How Does Variadic Class Template Works? To understand variadic class template, consider use case 2 above i.e. Tuple t2(1, 'a', \"ABC\");\nThe declaration first matches against the specialization, yielding a structure with int first; and Tuple rest; data members. The rest definition again matches with specialization, yielding a structure with char first; and Tuple rest; data members. The rest definition again matches this specialization, creating its own string first; and Tuple\u003c\u003e rest; members. Finally, this last rest matches against the base-case definition, producing an empty structure. You can visualize this as follows:\nTuple\u003cint, char, string\u003e -\u003e int first -\u003e Tuple\u003cchar, string\u003e rest -\u003e char first -\u003e Tuple\u003cstring\u003e rest -\u003e string first -\u003e Tuple\u003c\u003e rest -\u003e (empty) I have written a separate article on Variadic Template C++: Implementing Unsophisticated Tuple, if you are interested more in the variadic temple.\nVariadic Function Template As we have seen earlier, variadic template starts with empty definition i.e. base case for recursion. void print() {} Then the recursive case specialisation: template\u003c typename First, typename... Rest // Template parameter pack \u003e void print(First first, Rest... rest) { // Function parameter pack cout \u003c\u003c first \u003c\u003c endl; print(rest...); // Parameter pack expansion } This is now sufficient for us to use the print function with variable number and type of arguments. For example: print(500, 'a', \"ABC\"); You can further optimize the print function with forwarding reference, if constexpr() \u0026 sizeof()`operator as: template\u003c typename First, typename... Rest \u003e void print(First\u0026\u0026 first, Rest\u0026\u0026... rest) { if constexpr(sizeof...(rest) \u003e 0) { // Size of parameter pack cout \u003c\u003c first \u003c\u003c endl; print(std::forward\u003cRest\u003e(rest)...); // Forwarding reference } else { cout \u003c\u003c first \u003c\u003c endl; } } How Does Variadic Function Template Works? As you can see we have called print with 3 arguments i.e. print(500, 'a', \"ABC\"); At the time of compilation compiler instantiate 3 different print function as follows: `void print(int first, char __rest1, const char* __rest2) `void print(char first, const char* __rest1) `void print(const char* first) The first print(i.e. accept 3 arguments) will be called which prints the first argument \u0026 line print(rest…); expand with second print(i.e. accept 2 arguments). This will go on till argument count reaches to zero. That means in each call to print, the number of arguments is reduced by one \u0026 the rest of the arguments will be handled by a subsequent instance of print. Thus, the number of print instance after compilation is equal to the number of arguments, plus the base case instance of print. Hence, the variadic template also contributes to more code bloating. You can get this much better if you put the above example in cppinsights. And try to understand all the template instances. Fold Expressions vs Variadic Template As we saw, from C++11, the variadic template is a great addition to C++ Template. But it has nuisance like you need base case \u0026 recursive template implementation, etc. So, with C++17 standard introduced a new feature named as Fold Expression. Which you can use with parameter pack as follows: template \u003ctypename... Args\u003e void print(Args \u0026\u0026... args) { (void(cout \u003c\u003c std::forward\u003cArgs\u003e(args) \u003c\u003c endl), ...); } See, no cryptic boilerplate required. Isn’t this solution looks neater? There are total 3 types of folding: Unary fold, Binary fold \u0026 Fold over a comma. Here we have done left folding over a comma. You can read more about Fold Expression here. Misc C++ Template `typename` vs `class` typename and class are interchangeable in most of the cases. A general convention is typename used with the concrete type(i.e. in turn, does not depend on further template parameter) while class used with dependent type. But there are cases where either typename or class has to be certain. For example To Refer Dependent Types template\u003ctypename container\u003e class Example { using t1 = typename container::value_type; // value_type depends on template argument of container using t2 = std::vector\u003cint\u003e::value_type; // value_type is concrete type, so doesn't require typename }; typename is a must while referencing a nested type that depends on template parameter. To Specify Template Template Type template\u003c template \u003ctypename, typename\u003e class C, // `class` is must prior to C++17 typename T, typename Allocator \u003e void print_container(C\u003cT, Allocator\u003e container) { for (const T\u0026 v : container) cout \u003c\u003c v \u003c\u003c endl; } vector\u003cint\u003e v; print_container(v); This is rectified in C++17, So now you can use typename also. C++11: Template Type Alias template\u003ctypename T\u003e using pointer = T*; pointer\u003cint\u003e p = new int; // Equivalent to: int* p = new int; template \u003ctypename T\u003e using v = vector\u003cT\u003e; v\u003cint\u003e dynamic_arr; // Equivalent to: vector dynamic_arr; typedef will also work fine, but would not encourage you to use. As it isn’t part of Modern C++. C++14/17: Template \u0026 auto Keyword Since C++14, you can use auto in function argument. It’s kind of template shorthand as follows: void print(auto \u0026c) { /*. . .*/ } // Equivalent to template \u003ctypename T\u003e void print(T \u0026c) { /*. . .*/ } Although auto in function return-type is supported from C++11. But, you have to mention the trailing return type. Which is rectified in C++14 \u0026 now return type is automatically deduced by compiler. From C++17, you can also use auto in non-type template(I will cover this in later part this article) parameters. C++20: Template Lambda Expression A generic lambda expression is supported since C++14 which declare parameters as auto. But there was no way to change this template parameter and use real template arguments. For example: template \u003ctypename T\u003e void f(std::vector\u003cT\u003e\u0026\tvec) { //. . . } How do you write the lambda for the above function which takes std::vector of type T? This was the limitation till C++17, but with C++20 it is possible templatized lambda as : auto f = []\u003ctypename T\u003e(std::vector\u003cT\u003e\u0026 vec) { // . . . }; std::vector\u003cint\u003e v; f(v); Explicit Template Instantiation An explicit instantiation creates and declares a concrete class/struct/union/function/variable from a template, without using it just yet. Generally, you have to implement the template in header files only. You can not put the implementation/definition of template methods in implementation files(i.e. cpp or .cc). If this seems new to you, then consider following minimalist example: value.hpp\n#pragma once template \u003ctypename T\u003e class value { T val; public: T get_value(); }; value.cpp\n#include \"value.hpp\" template \u003ctypename T\u003e T value\u003cT\u003e::get_value() { return val; } main.cpp\n#include \"value.hpp\" int main() { value\u003cint\u003e v1{9}; cout \u003c\u003c v1.get_value() \u003c\u003c endl; return 0; } If you compile above code you will get following error: /tmp/main-4b4bef.o: In function `main': main.cpp:(.text+0x1e): undefined reference to `value::get_value()` clang: error: linker command failed with exit code 1 (use -v to see invocation) compiler exit status 1 If you do explicit initialization i.e. add template class value; line at the end of value.cpp. Then the compilation gets successful. The “template class” command causes the compiler to explicitly instantiate the template class. In the above case, the compiler will stencil out value inside of value.cpp. There are other solutions as well. Check out this StackOverflow link. C++ Template Example Use Cases Curiously Recurring Template Pattern CRTP widely employed for static polymorphism or code reusability without bearing the cost of virtual dispatch mechanism. Consider the following code: template \u003ctypename specific_animal\u003e struct animal { void who() { implementation().who(); } private: specific_animal \u0026implementation() { return *static_cast\u003cspecific_animal *\u003e(this); } }; struct dog : animal\u003cdog\u003e { void who() { cout \u003c\u003c \"dog\" \u003c\u003c endl; } }; struct cat : animal\u003ccat\u003e { void who() { cout \u003c\u003c \"cat\" \u003c\u003c endl; } }; template \u003ctypename specific_animal\u003e void who_am_i(animal\u003cspecific_animal\u003e *animal) { animal-\u003ewho(); } who_am_i(new dog); // Prints `dog` who_am_i(new cat); // Prints `cat` We have not used virtual keyword \u0026 still achieved the functionality of polymorphism(more-specifically static polymorphism). I have written a separate article covering practical Examples of Curiously Recurring Template Pattern(CRTP). Passing `std` Container as C++ Template Argument If you wanted to accept anything and figure it out later, you could write: template \u003ctypename C\u003e void print_container(const C \u0026container) { for (const auto \u0026v : container) cout \u003c\u003c v \u003c\u003c endl; } This naive way may fail if you pass anything other than standard container as other types may not have begin \u0026 end iterator. Passing std::vector to C++ Template Function Naive Way to Capture Container’s Value Type But let say, you want to pass container \u0026 want to work with container’s storage type also. You can do: template\u003c typename C, typename T = typename C::value_type \u003e void print_container(const C \u0026container) { for (const T \u0026v : container) cout \u003c\u003c v \u003c\u003c endl; } We can provide the second type parameter to our function that uses SFINAE to verify that the thing is actually a container. All standard containers have a member type named value_type which is the type of the thing inside the container. We sniff for that type, and if no such type exists, then SFINAE kicks in, and that overload is removed from consideration. Capturing Container’s Value Type Explicitly But what if you are passing vector class which doesn’t has value_type member? std::vector is defined as: template\u003c class T, class Allocator = std::allocator\u003cT\u003e \u003e class vector; And you can capture two template arguments of std::vector container explicitly as: template\u003c template \u003ctypename, typename\u003e class C, typename T, typename Allocator \u003e void print_container(C\u003cT, Allocator\u003e container) { for (const T\u0026 v : container) cout \u003c\u003c v \u003c\u003c endl; } Above template pattern would be same if you want pass container to class/struct/union. Passing Any Container to C++ Template Function You see if you pass any other containers to the above solution. It won’t work. So to make it generic we can use variadic template: template\u003c template \u003ctypename...\u003e class C, typename... Args \u003e void print_container(C\u003cArgs...\u003e container) { for (const auto \u0026v : container) cout \u003c\u003c v \u003c\u003c endl; } vector\u003cint\u003e v{1, 2, 3, 4}; // takes total 2 template type argument print_container(v); set\u003cint\u003e s{1, 2, 3, 4}; // takes total 3 template type argument print_container(s); Passing Container-of-Container/2D-std::vector as C++ Template Argument This is the case of nested template i.e. template-template parameter. And there are the following solutions: Explicit \u0026 Complex Solution template\u003c template \u003ctypename, typename\u003e class C1, template \u003ctypename, typename\u003e class C2, typename Alloc_C1, typename Alloc_C2, typename T \u003e void print_container(const C1\u003cC2\u003cT, Alloc_C2\u003e, Alloc_C1\u003e \u0026container) { for (const C2\u003cT, Alloc_C2\u003e \u0026container_in : container) for (const T \u0026v : container_in) cout \u003c\u003c v \u003c\u003c endl; } I know this is ugly, but seems more explicit. Neat Solution template\u003c typename T1, typename T2 = typename T1::value_type, typename T3 = typename T2::value_type \u003e void print_container(const T1 \u0026container) { for (const T2 \u0026e : container) for (const T3 \u0026x : e) cout \u003c\u003c x \u003c\u003c endl; } As seen earlier including SFINAE. Generic Solution: Using Variadic Template template\u003c template \u003ctypename...\u003e class C, typename... Args \u003e void print_container(C\u003cArgs...\u003e container) { for (const auto \u0026container_2nd : container) for (const auto \u0026v : container_2nd) cout \u003c\u003c v \u003c\u003c endl; } This is our standard solution using the variadic template will work for a single container or any number of the nested container. Passing Function to Class Template Argument Passing class/struct/union to another class/struct/union as template argument is common thing. But passing function to class/struct/union as template argument is bit rare. But yes it’s possible indeed. Consider the Functional Decorator using a variadic class template. // Need partial specialization for this to work template \u003ctypename T\u003e struct Logger; // Return type and argument list template \u003ctypename R, typename... Args\u003e struct Logger\u003cR(Args...)\u003e { function\u003cR(Args...)\u003e m_func; string m_name; Logger(function\u003cR(Args...)\u003e f, const string \u0026n) : m_func{f}, m_name{n} { } R operator()(Args... args) { cout \u003c\u003c \"Entering \" \u003c\u003c m_name \u003c\u003c endl; R result = m_func(args...); cout \u003c\u003c \"Exiting \" \u003c\u003c m_name \u003c\u003c endl; return result; } }; template \u003ctypename R, typename... Args\u003e auto make_logger(R (*func)(Args...), const string \u0026name) { return Logger\u003cR(Args...)\u003e(function\u003cR(Args...)\u003e(func), name); } double add(double a, double b) { return a + b; } int main() { auto logged_add = make_logger(add, \"Add\"); auto result = logged_add(2, 3); return EXIT_SUCCESS; } Above example may seem a bit complex to you at first sight. But if you have a clear understanding of variadic class temple then it won’t take more than 30 seconds to understand what’s going on here. Conclusion I hope I have covered most of the topics around C++ Template. And yes, this was a very long \u0026 intense article. But I bet you that if you do master the C++ template well, it will really give you an edge. And also open a door to sub-world of C++ i.e. template meta-programming.\nC++ Template: C++’s its own interpreted sub language\n","wordCount":"4328","inLanguage":"en","image":"https://vishalchovatiya.github.io/images/Cpp-Template-Vishal-Chovatiya.webp","datePublished":"2020-05-17T00:00:00Z","dateModified":"2020-05-17T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/c-template-a-quick-uptodate-look/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ Template: A Quick UpToDate Look(C++11/14/17/20)</h1><div class=post-meta><span title='2020-05-17 00:00:00 +0000 UTC'>May 17, 2020</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;4328 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/c-template-a-quick-uptodate-look.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://vishalchovatiya.github.io/images/Cpp-Template-Vishal-Chovatiya.webp alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#terminologyjargonidiom-you-may-face>Terminology/Jargon/Idiom You May Face</a></li><li><a href=#c-template-types>C++ Template Types</a><ul><li><a href=#class-template>Class Template</a></li><li><a href=#function-template>Function Template</a></li><li><a href=#union-template>Union Template</a></li><li><a href=#variable-template>Variable Template</a></li></ul></li><li><a href=#c-template-argument>C++ Template Argument</a><ul><li><a href=#overriding-template-argument-deduction>Overriding Template Argument Deduction</a></li><li><a href=#default-template-arguments>Default Template Arguments</a></li><li><a href=#template-argument-deduction>Template Argument Deduction</a></li><li><a href=#template-argument-forwarding>Template Argument Forwarding</a></li></ul></li><li><a href=#c-template-category>C++ Template Category</a><ul><li><a href=#full-template-specialization>Full Template Specialization</a></li><li><a href=#partial-template-specialization>Partial Template Specialization</a></li><li><a href=#non-type-template-parameter>Non-Type Template Parameter</a></li><li><a href=#nested-template-template-template-parameter>Nested Template: Template Template Parameter</a></li><li><a href=#variadic-template>Variadic Template</a></li></ul></li><li><a href=#misc>Misc</a><ul><li><a href=#c-template-typename-vs-class>C++ Template `typename` vs `class`</a></li><li><a href=#c11-template-type-alias>C++11: Template Type Alias</a></li><li><a href=#c1417-template--auto-keyword>C++14/17: Template & auto Keyword</a></li><li><a href=#c20-template-lambda-expression>C++20: Template Lambda Expression</a></li><li><a href=#explicit-template-instantiation>Explicit Template Instantiation</a></li></ul></li><li><a href=#c-template-example-use-cases>C++ Template Example Use Cases</a><ul><li><a href=#curiously-recurring-template-pattern>Curiously Recurring Template Pattern</a></li><li><a href=#passing-std-container-as-c-template-argument>Passing `std` Container as C++ Template Argument</a></li><li><a href=#passing-stdvector-to-c-template-function>Passing std::vector to C++ Template Function</a></li><li><a href=#passing-any-container-to-c-template-function>Passing Any Container to C++ Template Function</a></li><li><a href=#passing-container-of-container2d-stdvector-as-c-template-argument>Passing Container-of-Container/2D-std::vector as C++ Template Argument</a></li><li><a href=#passing-function-to-class-template-argument>Passing Function to Class Template Argument</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>I know, it’s been a while since the last time I published something newbies-friendly on my blog. The main reason is that most of my readers are either experienced devs or from C background having modest C++ encounter. But while programming in C++ you need a completely different mindset as both C & C++ belongs to different programming paradigm. And I always strive to show them a better way of doing things in C++. Anyway, I found the topic which is lengthy, reasonably complex(at least it was for me), newbies-friendly as well as energizing for experienced folks(if <a href=/posts/21-new-features-of-modern-cpp-to-use-in-your-project/>Modern C++</a> jargons, rules & features added) i.e. C++ Template.</p><p>I will start with a simple class/function template and as we move along, will increase the complexity. And also cover the advance topics like the <a href=/posts/variadic-template-cpp-implementing-unsophisticated-tuple/>variadic template</a>, nested template, CRTP, template vs fold-expression, etc. But, yes! we would not take deeper dive otherwise this would become a book rather than an article.</p><p><em><strong>Note:</strong> I would recommend you to use <a href=https://cppinsights.io/>cppinsights</a> online tool wherever you feel confused. It helps you to see Template Instances, Template Argument Deduction, etc. Basically, it helps you to see code from the compiler&rsquo;s perspective.</em></p><h2 id=terminologyjargonidiom-you-may-face>Terminology/Jargon/Idiom You May Face<a hidden class=anchor aria-hidden=true href=#terminologyjargonidiom-you-may-face>#</a></h2><ul><li><strong>Template Instantiation</strong>: It is a process of generating a concrete class/struct/union/function out of templated class/struct/union/function for a particular combination of template arguments. For example, if you use <code>vector&lt;int></code> & <code>vector&lt;char></code>, it will create two different concrete classes during compilation. This process of creating concrete classes is known as Template Instantiation.</li><li><strong>Template Instances</strong>: Outcome of Template Instantiation is Template Instances i.e. concrete classes.</li><li><strong>Explicit Template Instantiation</strong>: Usually template instantiation done at the time of object declaration. But you can also force the compiler to instantiate class/struct/union/function with particular type without even creating the object. It may appear in the program anywhere after the template definition, and for a given argument-list. Will see this later in the article.</li><li><strong>Template Argument vs Template Parameter</strong>: In expression <code>template&lt;typename _T_> void print(_T a_){ };</code>, <code>T</code> is parameter & when you call <code>print(5);</code>, <code>5</code> which is of type <code>int</code> is template argument. This is a trivial thing for some pips. But not for non-native English speaker or beginners. So, this ambiguity has to be clear.</li></ul><h2 id=c-template-types>C++ Template Types<a hidden class=anchor aria-hidden=true href=#c-template-types>#</a></h2><h3 id=class-template>Class Template<a hidden class=anchor aria-hidden=true href=#class-template>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>pair</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T1</span>  <span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T2</span>  <span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span><span class=o>&gt;</span> <span class=n>p1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span> <span class=kt>float</span><span class=o>&gt;</span> <span class=n>p2</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>The basic idea of a class template is that the template parameter i.e. <code>T1</code> & <code>T2</code> gets substituted by an appropriate deduced type at compile time. The result is that the same class can be reused for multiple types.</li><li>And the user has to specify which type they want to use when an object of the class is declared.</li></ul><h3 id=function-template>Function Template<a hidden class=anchor aria-hidden=true href=#function-template>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>min</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>min</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>              <span class=c1>// Case 1 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>min</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=mf>4.1f</span><span class=p>,</span> <span class=mf>5.1f</span><span class=p>);</span>      <span class=c1>// Case 2
</span></span></span></code></pre></div><ul><li>In both of the above case, the template arguments used to replace the types of the parameters i.e. <code>T</code>.</li><li>One additional property of template functions (unlike class template till C++17) is that the compiler can infer the template parameters based on the parameters passed to the function. So, passing <code>&lt;int></code> & <code>&lt;float></code> after the function name is redundant.</li></ul><h3 id=union-template>Union Template<a hidden class=anchor aria-hidden=true href=#union-template>#</a></h3><ul><li>Yes! a union can also be templatized. In fact, the standard library provides some utilities like <a href=https://en.cppreference.com/w/cpp/utility/optional><code>std::optional</code></a>, <a href=https://en.cppreference.com/w/cpp/utility/variant><code>std::variant</code></a>, etc. which directly or indirectly uses templatized union.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nc>test</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span>     <span class=n>ch</span><span class=p>[</span><span class=k>sizeof</span><span class=p>(</span><span class=n>T</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span>           <span class=n>variable</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>As you can see above, <strong><em>templatized unions are also particularly useful to represent a type simultaneously as a byte array</em></strong>.</li></ul><h3 id=variable-template>Variable Template<a hidden class=anchor aria-hidden=true href=#variable-template>#</a></h3><ul><li>Yes! This may a bit socking. But, <strong><em>you can templatise the variable also since C++14</em></strong>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>T</span> <span class=n>pi</span> <span class=o>=</span> <span class=n>T</span><span class=p>(</span><span class=mf>3.1415926535897932385</span><span class=n>L</span><span class=p>);</span> <span class=c1>// variable template
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// 3.14159
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pi</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>   <span class=c1>// 3
</span></span></span></code></pre></div><ul><li>Now, you might be wondering that what is the point of the templatizing variable. But, consider the following example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>uint32_t</span> <span class=n>val</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=k>auto</span> <span class=n>fib</span> <span class=o>=</span> <span class=n>fib</span><span class=o>&lt;</span><span class=n>val</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&gt;</span> <span class=o>+</span> <span class=n>fib</span><span class=o>&lt;</span><span class=n>val</span> <span class=o>-</span> <span class=mi>2</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=k>auto</span> <span class=n>fib</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=k>auto</span> <span class=n>fib</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>fib</span><span class=o>&lt;</span><span class=mi>10</span><span class=o>&gt;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>    <span class=c1>// 55
</span></span></span></code></pre></div><ul><li>Above code gives you 10th Fibonacci term at compile time, without even creating class or function.</li></ul><h2 id=c-template-argument>C++ Template Argument<a hidden class=anchor aria-hidden=true href=#c-template-argument>#</a></h2><h3 id=overriding-template-argument-deduction>Overriding Template Argument Deduction<a hidden class=anchor aria-hidden=true href=#overriding-template-argument-deduction>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>min</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=k>typeid</span><span class=p>(</span><span class=n>T</span><span class=p>).</span><span class=n>name</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// T will be deduce as `int`
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>min</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=mf>5.5f</span><span class=p>,</span> <span class=mf>6.6f</span><span class=p>);</span>     <span class=c1>// Implicit conversion happens here
</span></span></span></code></pre></div><h3 id=default-template-arguments>Default Template Arguments<a hidden class=anchor aria-hidden=true href=#default-template-arguments>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>N</span> <span class=o>=</span> <span class=mi>10</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>array</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>arr</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>arr</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Just like in case of the function arguments, template parameters can also have their default values.</li><li>All template parameters with a default value have to be declared at the end of the template parameter list.</li></ul><h3 id=template-argument-deduction>Template Argument Deduction<a hidden class=anchor aria-hidden=true href=#template-argument-deduction>#</a></h3><h4 id=function-template-argument-deduction>Function Template Argument Deduction<a hidden class=anchor aria-hidden=true href=#function-template-argument-deduction>#</a></h4><ul><li>Function template argument deduction is done by comparing the types of function arguments to function parameters, according to rules in the <a href=https://en.cppreference.com/w/cpp/language/template_argument_deduction>Standard</a>. Which makes function templates far more usable than they would otherwise be. For example, given a function template like:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>RanIt</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>sort</span><span class=p>(</span><span class=n>RanIt</span> <span class=n>first</span><span class=p>,</span> <span class=n>RanIt</span> <span class=n>last</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// . . .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>You can and should sort a <code>std::vector&lt;int></code> without explicitly specifying that <code>RanIt</code> is <code>std::vector&lt;int>::iterator</code>. When the compiler sees <code>sort(v.begin(), v.end());</code>, it knows what the types of <code>v.begin() and </code>v.end()<code>are, so it can determine what </code>RanIt` should be.</li></ul><h4 id=class-template-argument-deductionctad>Class Template Argument Deduction(CTAD)<a hidden class=anchor aria-hidden=true href=#class-template-argument-deductionctad>#</a></h4><ul><li>Until C++17, template classes could not apply type deduction in their initialization as template function do. For example</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pair</span> <span class=n>p4</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=sc>&#39;A&#39;</span><span class=p>};</span>               <span class=c1>// Not OK until C++17: Can&#39;t deduce type in initialization 
</span></span></span><span class=line><span class=cl><span class=c1>//...
</span></span></span></code></pre></div><ul><li>But <strong><em>from C++17, the compiler can deduce types in class/struct initialization</em></strong> & this to work, class/struct must have an appropriate constructor. But this limitation is also relaxed in C++20. So technically <strong><em>from C++20, you can construct the object with <a href=https://en.cppreference.com/w/cpp/language/aggregate_initialization>aggregate initialization</a> & without specifying types explicitly</em></strong>.</li><li>Until C++17, the standard provided some <code>std::make_</code> utility functions to counter such situations as below.</li></ul><h5 id=inferring-template-argument-through-function-template>Inferring Template Argument Through Function Template<a hidden class=anchor aria-hidden=true href=#inferring-template-argument-through-function-template>#</a></h5><ul><li>You might have seen many functions like <code>std::make_pair(), </code>std::make_unique(), `std::make_share(), etc. Which can typically & unsophistically implement as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>pair</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=o>&gt;</span> <span class=n>make_pair</span><span class=p>(</span><span class=n>T1</span><span class=o>&amp;&amp;</span> <span class=n>t1</span><span class=p>,</span> <span class=n>T2</span><span class=o>&amp;&amp;</span> <span class=n>t2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T1</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t1</span><span class=p>),</span> <span class=n>forward</span><span class=o>&lt;</span><span class=n>T2</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t2</span><span class=p>)};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>But have you ever wonder why these helper functions are there in the standard library? How does this even help?</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span><span class=o>&gt;</span> <span class=n>p1</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=sc>&#39;A&#39;</span><span class=p>};</span>          <span class=c1>// Rather using this
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>make_pair</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>           <span class=c1>// Use this instead
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>p3</span> <span class=o>=</span> <span class=n>make_pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mf>2.4f</span><span class=p>);</span> <span class=c1>// Or specify types explicitly
</span></span></span></code></pre></div><ul><li>Rather than specifying the arguments explicitly, you can leverage the feature of inferring template argument from function template to construct the object. In the above case, template argument deduction is done by the utility function <code>make_pair</code>. As a result, we have created the object of pair without specifying the type explicitly.</li><li>And as discussed earlier from C++17, you can construct the object without even specifying types explicitly so <code>std::vector v{1,2,3,4};</code> is perfectly valid statement.</li></ul><h3 id=template-argument-forwarding>Template Argument Forwarding<a hidden class=anchor aria-hidden=true href=#template-argument-forwarding>#</a></h3><h4 id=c-template-reference-collapsing-rules>C++ Template Reference Collapsing Rules<a hidden class=anchor aria-hidden=true href=#c-template-reference-collapsing-rules>#</a></h4><ul><li>Apart from accepting type & value in the template parameter. You can enable the template to accept both <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>lvalue and rvalue references</a>. And to do this you need to adhere to the rules of reference collapsing as follows:<ol><li><code>T& &</code> becomes <code>T&</code></li><li><code>T& &&</code> become <code>T&</code></li><li><code>T&& &</code> becomes <code>T&</code></li><li><code>T&& &&</code> becomes <code>T&&</code></li></ol></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>In the above case, the real type of <code>t</code> depends on the context. For example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// deduces as rvalue reference i.e. f(int&amp;&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=c1>// deduces as lvalue reference i.e. f(int&amp;)
</span></span></span></code></pre></div><ul><li>In case of <code>f(0);</code>, <code>0</code> is rvalue of type <code>int</code>, hence <code>T = int&&</code>, thus <code>f(int&& &&amp;t) becomes </code>f(int&& t).</li><li>In case of <code>f(x);</code>, <code>x</code> is lvalue of type <code>int</code>, hence <code>T = int&</code>, thus <code>f(int& &&amp;t) becomes </code>f(int& t).</li></ul><h4 id=perfect-forwarding--forwarding-reference--universal-reference>Perfect Forwarding | Forwarding Reference | Universal Reference<a hidden class=anchor aria-hidden=true href=#perfect-forwarding--forwarding-reference--universal-reference>#</a></h4><ul><li>In order to perfectly forward <code>t</code> to another function<a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/></a>, one must use <code>std::forward</code> as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>func1</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>func2</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span><span class=p>));</span>  <span class=c1>// Forward appropriate lvalue or rvalue reference to another function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>Forwarding references can also be used with variadic templates:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>func1</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>func2</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=why-do-we-need-forwarding-reference-in-first-place>Why Do We Need Forwarding Reference in First Place?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-forwarding-reference-in-first-place>#</a></h4><ul><li>Answer to this question lies in <a href=/posts/move-constructor-assignment-operator-with-shared-ptr/>move semantics</a>. Though, short answer to this question is &ldquo;To perform copy/move depending upon value category type&rdquo;.</li></ul><h2 id=c-template-category>C++ Template Category<a hidden class=anchor aria-hidden=true href=#c-template-category>#</a></h2><h3 id=full-template-specialization>Full Template Specialization<a hidden class=anchor aria-hidden=true href=#full-template-specialization>#</a></h3><ul><li>Template has a facility to define implementation for specific instantiations of a template class/struct/union/function/method.</li></ul><h4 id=function-template-specialization>Function Template Specialization<a hidden class=anchor aria-hidden=true href=#function-template-specialization>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>T</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* Some generic implementation */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sqrt</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* Highly optimized integer implementation */</span> <span class=p>}</span>
</span></span></code></pre></div><ul><li>In the above case, a user that writes <code>sqrt(4.0) will get the generic implementation whereas </code>sqrt(4) will get the specialized implementation.</li></ul><h4 id=class-template-specialization>Class Template Specialization<a hidden class=anchor aria-hidden=true href=#class-template-specialization>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>       <span class=c1>// Common case
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Vector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;&gt;</span>                 <span class=c1>// Special case
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>print_bool</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>v1</span><span class=p>.</span><span class=n>print_bool</span><span class=p>();</span>    <span class=c1>// Not OK: Chose common case Vector&lt;T&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v1</span><span class=p>.</span><span class=n>print</span><span class=p>()</span>          <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>v2</span><span class=p>;</span>    <span class=c1>// OK : Chose special case Vector&lt;bool&gt;
</span></span></span></code></pre></div><h3 id=partial-template-specialization>Partial Template Specialization<a hidden class=anchor aria-hidden=true href=#partial-template-specialization>#</a></h3><h4 id=partial-class-template-specialization>Partial Class Template Specialization<a hidden class=anchor aria-hidden=true href=#partial-class-template-specialization>#</a></h4><ul><li>In contrast of a full template specialization, you can also specialise template partially with some of the arguments of existing template fixed. Partial template specialization is only available for template class/structs/union:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span>     <span class=c1>// Common case
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Pair</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T1</span> <span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T2</span> <span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>print_first</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>    <span class=c1>// Partial specialization on first argument as int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Use case 1 ----------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Pair</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=kt>float</span><span class=o>&gt;</span> <span class=n>p1</span><span class=p>;</span>    <span class=c1>// Chose common case
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>p1</span><span class=p>.</span><span class=n>print_first</span><span class=p>();</span>        <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1>// p1.print();           // Not OK: p1 is common case &amp; it doesn&#39;t have print() method
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Use case 2 ----------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>float</span><span class=o>&gt;</span> <span class=n>p2</span><span class=p>;</span>     <span class=c1>// Chose special case
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>p2</span><span class=p>.</span><span class=n>print</span><span class=p>();</span>              <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1>// p2.print_first();     // Not OK: p2 is special case &amp; it does not have print_first()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Use case 3 ----------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1>// Pair&lt;int&gt; p3;         // Not OK: Number of argument should be same as Primary template
</span></span></span></code></pre></div><h4 id=partial-function-template-specialization>Partial Function Template Specialization<a hidden class=anchor aria-hidden=true href=#partial-function-template-specialization>#</a></h4><ul><li><strong><em>You cannot partially specialize method/function</em></strong>. Function templates may only be fully specialized</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>foo</span><span class=p>(</span><span class=n>T</span> <span class=n>t</span><span class=p>,</span> <span class=n>U</span> <span class=n>u</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Common case&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// OK.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>foo</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>int</span> <span class=n>a1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>a2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Fully specialized case&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Compilation error: partial function specialization is not allowed.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>foo</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=n>U</span><span class=o>&gt;</span><span class=p>(</span><span class=n>string</span> <span class=n>t</span><span class=p>,</span> <span class=n>U</span> <span class=n>u</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Partial specialized case&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>foo</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mf>2.1</span><span class=p>);</span> <span class=c1>// Common case
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>foo</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>   <span class=c1>// Fully specialized case
</span></span></span></code></pre></div><h5 id=alternative-to-partial-function-template-specialization>Alternative To Partial Function Template Specialization<a hidden class=anchor aria-hidden=true href=#alternative-to-partial-function-template-specialization>#</a></h5><ul><li>As I have mentioned earlier, partial specialization of function templates is not allowed. You can use <a href=/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/>SFINAE</a> with <code>std::enable_if</code> for work around as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;!</span><span class=n>std</span><span class=o>::</span><span class=n>is_pointer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=o>&gt;</span> <span class=o>*</span> <span class=o>=</span> <span class=k>nullptr</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=n>T</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Value&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>is_pointer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=o>&gt;</span> <span class=o>*</span> <span class=o>=</span> <span class=k>nullptr</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=n>T</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// NOTE: function signature is NOT-MODIFIED
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Pointer&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=non-type-template-parameter>Non-Type Template Parameter<a hidden class=anchor aria-hidden=true href=#non-type-template-parameter>#</a></h3><ul><li>As the name suggests, apart from types, you can also declare the template parameter as constant expressions like addresses, <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>references</a>, integrals, <a href=/posts/what-exactly-nullptr-is-in-cpp/>std::nullptr_t</a>, enums, etc.</li><li>Like all other template parameters, non-type template parameters can be explicitly specified, defaulted, or derived implicitly via Template Argument Deduction.</li><li>The <strong><em>more specific use case of a non-type template is passing a plain array into a function without specifying its size explicitly</em></strong>. A more relevant example of this is <code>std::begin</code> & <code>std::end</code> specialisation for array literal from the standard library:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span>  <span class=k>class</span> <span class=nc>T</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=n>size_t</span> <span class=n>size</span><span class=o>&gt;</span>     <span class=c1>// Non Type Template
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>T</span><span class=o>*</span> <span class=n>begin</span><span class=p>(</span><span class=n>T</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>arr</span><span class=p>)[</span><span class=n>size</span><span class=p>])</span> <span class=p>{</span>   <span class=c1>// Array size deduced implicitly
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>begin</span><span class=p>(</span><span class=n>arr</span><span class=p>);</span>                  <span class=c1>// Do not have to pass size explicitly 
</span></span></span></code></pre></div><ul><li>Non-type template parameters are one of the ways to achieve template recurrence & enables <a href=https://en.wikipedia.org/wiki/Template_metaprogramming>Template Meta-programming</a>.</li></ul><h3 id=nested-template-template-template-parameter>Nested Template: Template Template Parameter<a hidden class=anchor aria-hidden=true href=#nested-template-template-template-parameter>#</a></h3><ul><li>Sometimes we have to pass templated type into another templated type. And in such case, you not only have to take care of main template type but also a nested template type. Very simple template- template parameter examples is:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>   
</span></span><span class=line><span class=cl>            <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print_container</span><span class=p>(</span><span class=n>C</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// . . .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>My_Type</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// . . .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>My_Type</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>print_container</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=variadic-template>Variadic Template<a hidden class=anchor aria-hidden=true href=#variadic-template>#</a></h3><ul><li>It is often useful to define class/struct/union/function that accepts a variable number and type of arguments.</li><li>If you have already used C you&rsquo;ll know that <code>printf</code> function can accept any number of arguments. Such functions are entirely implemented through macros or <a href=https://stackoverflow.com/questions/3792761/what-is-ellipsis-operator-in-c>ellipses operator</a>. And because of that it has several disadvantages like <a href=/posts/cpp-type-casting-with-example-for-c-developers/>type-safety</a>, cannot accept references as arguments, etc.</li></ul><h4 id=variadic-class-template>Variadic Class Template<a hidden class=anchor aria-hidden=true href=#variadic-class-template>#</a></h4><h5 id=implementing-unsophisticated-tuple-classc14>Implementing Unsophisticated Tuple Class(>=C++14)<a hidden class=anchor aria-hidden=true href=#implementing-unsophisticated-tuple-classc14>#</a></h5><ul><li>Since C++11 standard library introduced <a href=/posts/variadic-template-cpp-implementing-unsophisticated-tuple/><code>std::tuple</code></a> class that accept variable data members at compile time using the variadic template. And to understand its working, we will build our own ADT same as <a href=/posts/variadic-template-cpp-implementing-unsophisticated-tuple/><code>std::tuple</code></a> ``</li><li>The variadic template usually starts with the general (empty) definition, that also serves as the base-case for recursion termination in the later specialisation:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Tuple</span> <span class=p>{</span> <span class=p>};</span>
</span></span></code></pre></div><ul><li>This already allows us to define an empty structure i.e. <code>Tuple&lt;> object;</code>, albeit that isn&rsquo;t very useful yet. Next comes the recursive case specialisation:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span><span class=p>...</span> <span class=n>Rest</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Tuple</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>Rest</span><span class=p>...</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span>               <span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Tuple</span><span class=o>&lt;</span><span class=n>Rest</span><span class=p>...</span><span class=o>&gt;</span>  <span class=n>rest</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Tuple</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>f</span><span class=p>,</span> <span class=k>const</span> <span class=n>Rest</span><span class=o>&amp;</span> <span class=p>...</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>first</span><span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>rest</span><span class=p>(</span><span class=n>r</span><span class=p>...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Tuple</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>t1</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>                      <span class=c1>// Case 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span> <span class=n>t2</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=sc>&#39;a&#39;</span><span class=p>,</span> <span class=s>&#34;ABC&#34;</span><span class=p>);</span> <span class=c1>// Case 2
</span></span></span></code></pre></div><h5 id=how-does-variadic-class-template-works>How Does Variadic Class Template Works?<a hidden class=anchor aria-hidden=true href=#how-does-variadic-class-template-works>#</a></h5><p>To understand variadic class template, consider use case 2 above i.e. <code>Tuple&lt;int, char, string> t2(1, 'a', "ABC");</code></p><ul><li>The declaration first matches against the specialization, yielding a structure with <code>int first;</code> and <code>Tuple&lt;char, string> rest;</code> data members.</li><li>The rest definition again matches with specialization, yielding a structure with <code>char first;</code> and <code>Tuple&lt;string> rest;</code> data members.</li><li>The rest definition again matches this specialization, creating its own <code>string first;</code> and <code>Tuple&lt;> rest;</code> members.</li><li>Finally, this last rest matches against the base-case definition, producing an empty structure.</li></ul><p>You can visualize this as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=o>-&gt;</span> <span class=kt>int</span> <span class=n>first</span>
</span></span><span class=line><span class=cl><span class=o>-&gt;</span> <span class=n>Tuple</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span> <span class=n>rest</span>
</span></span><span class=line><span class=cl>    <span class=o>-&gt;</span> <span class=kt>char</span> <span class=n>first</span>
</span></span><span class=line><span class=cl>    <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>rest</span>
</span></span><span class=line><span class=cl>        <span class=o>-&gt;</span> <span class=n>string</span> <span class=n>first</span>
</span></span><span class=line><span class=cl>        <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=o>&lt;&gt;</span> <span class=n>rest</span>
</span></span><span class=line><span class=cl>            <span class=o>-&gt;</span> <span class=p>(</span><span class=n>empty</span><span class=p>)</span>
</span></span></code></pre></div><p>I have written a separate article on <a href=/posts/variadic-template-cpp-implementing-unsophisticated-tuple/>Variadic Template C++: Implementing Unsophisticated Tuple</a>, if you are interested more in the variadic temple.</p><h4 id=variadic-function-template>Variadic Function Template<a hidden class=anchor aria-hidden=true href=#variadic-function-template>#</a></h4><ul><li>As we have seen earlier, variadic template starts with empty definition i.e. base case for recursion.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=p>{}</span>
</span></span></code></pre></div><ul><li>Then the recursive case specialisation:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>   
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>First</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span><span class=p>...</span> <span class=n>Rest</span>                    <span class=c1>// Template parameter pack
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>&gt;</span>     
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=n>First</span> <span class=n>first</span><span class=p>,</span> <span class=n>Rest</span><span class=p>...</span> <span class=n>rest</span><span class=p>)</span> <span class=p>{</span>         <span class=c1>// Function parameter pack
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>rest</span><span class=p>...);</span>                             <span class=c1>// Parameter pack expansion
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> 
</span></span></code></pre></div><ul><li>This is now sufficient for us to use the print function with variable number and type of arguments. For example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>print</span><span class=p>(</span><span class=mi>500</span><span class=p>,</span> <span class=sc>&#39;a&#39;</span><span class=p>,</span> <span class=s>&#34;ABC&#34;</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>You can further optimize the print function with forwarding reference, <code>if constexpr() & </code>sizeof()`operator as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>   
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>First</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span><span class=p>...</span> <span class=n>Rest</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>     
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=n>First</span><span class=o>&amp;&amp;</span> <span class=n>first</span><span class=p>,</span> <span class=n>Rest</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>rest</span><span class=p>)</span> <span class=p>{</span>         
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nf>constexpr</span><span class=p>(</span><span class=k>sizeof</span><span class=p>...(</span><span class=n>rest</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>             <span class=c1>// Size of parameter pack
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>print</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Rest</span><span class=o>&gt;</span><span class=p>(</span><span class=n>rest</span><span class=p>)...);</span>         <span class=c1>// Forwarding reference
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></div><h5 id=how-does-variadic-function-template-works>How Does Variadic Function Template Works?<a hidden class=anchor aria-hidden=true href=#how-does-variadic-function-template-works>#</a></h5><ul><li>As you can see we have called print with 3 arguments i.e. <code>print(500, 'a', "ABC");</code></li><li>At the time of compilation compiler instantiate 3 different print function as follows:<ol><li>`void print(int first, char __rest1, const char* __rest2)</li><li>`void print(char first, const char* __rest1)</li><li>`void print(const char* first)</li></ol></li><li>The first print(i.e. accept 3 arguments) will be called which prints the first argument & line <code>print(rest…);</code> expand with second print(i.e. accept 2 arguments). This will go on till argument count reaches to zero.</li><li>That means in each call to print, the number of arguments is reduced by one & the rest of the arguments will be handled by a subsequent instance of print.</li><li>Thus, the number of print instance after compilation is equal to the number of arguments, plus the base case instance of print. Hence, the <strong><em>variadic template also contributes to more code bloating</em></strong>.</li><li>You can get this much better if you put the above example in <a href=https://cppinsights.io/>cppinsights</a>. And try to understand all the template instances.</li></ul><h4 id=fold-expressions-vs-variadic-template>Fold Expressions vs Variadic Template<a hidden class=anchor aria-hidden=true href=#fold-expressions-vs-variadic-template>#</a></h4><ul><li>As we saw, from C++11, the variadic template is a great addition to C++ Template. But it has nuisance like you need base case & recursive template implementation, etc.</li><li>So, with <strong><em>C++17 standard introduced a new feature named as Fold Expression</em></strong>. Which you can use with parameter pack as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=n>Args</span> <span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=kt>void</span><span class=p>(</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>),</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>See, no cryptic boilerplate required. Isn&rsquo;t this solution looks neater?</li><li>There are total 3 types of folding: Unary fold, Binary fold & Fold over a comma. Here we have done left folding over a comma. You can read more about Fold Expression <a href=https://www.codingame.com/playgrounds/2205/7-features-of-c17-that-will-simplify-your-code/fold-expressions>here</a>.</li></ul><h2 id=misc>Misc<a hidden class=anchor aria-hidden=true href=#misc>#</a></h2><h3 id=c-template-typename-vs-class>C++ Template `typename` vs `class`<a hidden class=anchor aria-hidden=true href=#c-template-typename-vs-class>#</a></h3><ul><li><code>typename</code> and <code>class</code> are interchangeable in most of the cases.</li><li>A general convention is <code>typename</code> used with the concrete type(i.e. in turn, does not depend on further template parameter) while <code>class</code> used with dependent type.</li><li>But there are cases where either <code>typename</code> or <code>class</code> has to be certain. For example</li></ul><h4 id=to-refer-dependent-types>To Refer Dependent Types<a hidden class=anchor aria-hidden=true href=#to-refer-dependent-types>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>container</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Example</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>t1</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>container</span><span class=o>::</span><span class=n>value_type</span><span class=p>;</span> <span class=c1>// value_type depends on template argument of container
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>t2</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>value_type</span><span class=p>;</span>   <span class=c1>// value_type is concrete type, so doesn&#39;t require typename
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><ul><li><code>typename</code> is a must while referencing a nested type that depends on template parameter.</li></ul><h4 id=to-specify-template-template-type>To Specify Template Template Type<a hidden class=anchor aria-hidden=true href=#to-specify-template-template-type>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>            <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>,</span> <span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>,</span> <span class=c1>// `class` is must prior to C++17
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>typename</span> <span class=n>T</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>Allocator</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print_container</span><span class=p>(</span><span class=n>C</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>Allocator</span><span class=o>&gt;</span> <span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=nl>v</span> <span class=p>:</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>print_container</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>This is rectified in C++17, So now you can use <code>typename</code> also.</li></ul><h3 id=c11-template-type-alias>C++11: Template Type Alias<a hidden class=anchor aria-hidden=true href=#c11-template-type-alias>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>pointer</span> <span class=o>=</span> <span class=n>T</span><span class=o>*</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pointer</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>;</span>   <span class=c1>// Equivalent to: int* p = new int;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>v</span> <span class=o>=</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>v</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dynamic_arr</span><span class=p>;</span>         <span class=c1>// Equivalent to: vector&lt;int&gt; dynamic_arr;
</span></span></span></code></pre></div><ul><li><code>typedef</code> will also work fine, but would not encourage you to use. As it isn&rsquo;t part of <a href=/posts/21-new-features-of-modern-cpp-to-use-in-your-project/>Modern C++</a>.</li></ul><h3 id=c1417-template--auto-keyword>C++14/17: Template & auto Keyword<a hidden class=anchor aria-hidden=true href=#c1417-template--auto-keyword>#</a></h3><ul><li><strong><em>Since C++14, you can use <code>auto</code> in function argument</em></strong>. It&rsquo;s kind of template shorthand as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/*. . .*/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Equivalent to
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/*. . .*/</span> <span class=p>}</span>
</span></span></code></pre></div><ul><li>Although <strong><em><code>auto</code> in function return-type is supported from C++11</em></strong>. But, you have to mention the trailing return type. Which is rectified in C++14 & now return type is automatically deduced by compiler.</li><li><strong><em>From C++17, you can also use <code>auto</code> in non-type template</em></strong>(I will cover this in later part this article) parameters.</li></ul><h3 id=c20-template-lambda-expression>C++20: Template Lambda Expression<a hidden class=anchor aria-hidden=true href=#c20-template-lambda-expression>#</a></h3><ul><li>A <a href=/posts/learn-lambda-function-in-cpp-with-example/>generic lambda expression</a> is supported since C++14 which declare parameters as <code>auto</code>. But there was no way to change this template parameter and use real template arguments. For example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span>	<span class=n>vec</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//. . .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>How do you write the lambda for the above function which takes <code>std::vector</code> of type <code>T</code>? This was the limitation till C++17, but <strong><em>with C++20 it is possible templatized lambda</em></strong> as :</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>f</span> <span class=o>=</span> <span class=p>[]</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span>  <span class=n>vec</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// . . .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=explicit-template-instantiation>Explicit Template Instantiation<a hidden class=anchor aria-hidden=true href=#explicit-template-instantiation>#</a></h3><ul><li>An explicit instantiation creates and declares a concrete class/struct/union/function/variable from a template, without using it just yet.</li><li>Generally, you have to implement the template in header files only. You can not put the implementation/definition of template methods in implementation files(i.e. cpp or .cc). If this seems new to you, then consider following minimalist example:</li></ul><p><strong>value.hpp</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#pragma once
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>value</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>get_value</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>value.cpp</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;value.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>value</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>get_value</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>val</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>main.cpp</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;value.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>value</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v1</span><span class=p>{</span><span class=mi>9</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v1</span><span class=p>.</span><span class=n>get_value</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>If you compile above code you will get following error:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/tmp/main-4b4bef.o: In <span class=k>function</span> <span class=sb>`</span>main<span class=err>&#39;</span>:
</span></span><span class=line><span class=cl>main.cpp:<span class=o>(</span>.text+0x1e<span class=o>)</span>: undefined reference to <span class=sb>`</span>value&lt;int&gt;::get_value<span class=o>()</span><span class=sb>`</span>
</span></span><span class=line><span class=cl>clang: error: linker <span class=nb>command</span> failed with <span class=nb>exit</span> code <span class=m>1</span> <span class=o>(</span>use -v to see invocation<span class=o>)</span>
</span></span><span class=line><span class=cl>compiler <span class=nb>exit</span> status <span class=m>1</span>
</span></span></code></pre></div><ul><li>If you do explicit initialization i.e. add <code>template class value&lt;int>;</code> line at the end of <code>value.cpp</code>. Then the compilation gets successful.</li><li>The &ldquo;template class&rdquo; command causes the compiler to explicitly instantiate the template class. In the above case, the compiler will stencil out <code>value&lt;int></code> inside of <code>value.cpp</code>.</li><li>There are other solutions as well. Check out this <a href=https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file>StackOverflow link</a>.</li></ul><h2 id=c-template-example-use-cases>C++ Template Example Use Cases<a hidden class=anchor aria-hidden=true href=#c-template-example-use-cases>#</a></h2><h3 id=curiously-recurring-template-pattern>Curiously Recurring Template Pattern<a hidden class=anchor aria-hidden=true href=#curiously-recurring-template-pattern>#</a></h3><ul><li><a href=/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/#CRTP>CRTP</a> widely employed for static polymorphism or code reusability without bearing the cost of <a href=/posts/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/>virtual dispatch mechanism</a>. Consider the following code:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>specific_animal</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>who</span><span class=p>()</span> <span class=p>{</span> <span class=n>implementation</span><span class=p>().</span><span class=n>who</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>specific_animal</span> <span class=o>&amp;</span><span class=n>implementation</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>specific_animal</span> <span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>dog</span> <span class=o>:</span> <span class=n>animal</span><span class=o>&lt;</span><span class=n>dog</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>who</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;dog&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>cat</span> <span class=o>:</span> <span class=n>animal</span><span class=o>&lt;</span><span class=n>cat</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>who</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;cat&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>specific_animal</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>who_am_i</span><span class=p>(</span><span class=n>animal</span><span class=o>&lt;</span><span class=n>specific_animal</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>animal</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>animal</span><span class=o>-&gt;</span><span class=n>who</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>who_am_i</span><span class=p>(</span><span class=k>new</span> <span class=n>dog</span><span class=p>);</span> <span class=c1>// Prints `dog`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>who_am_i</span><span class=p>(</span><span class=k>new</span> <span class=n>cat</span><span class=p>);</span> <span class=c1>// Prints `cat`
</span></span></span></code></pre></div><ul><li>We have not used <a href=/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/>virtual keyword</a> & still achieved the functionality of polymorphism(more-specifically static polymorphism).</li><li>I have written a separate article covering practical <a href=/posts/crtp-c-examples/>Examples of Curiously Recurring Template Pattern(CRTP)</a>.</li></ul><h3 id=passing-std-container-as-c-template-argument>Passing `std` Container as C++ Template Argument<a hidden class=anchor aria-hidden=true href=#passing-std-container-as-c-template-argument>#</a></h3><ul><li>If you wanted to accept anything and figure it out later, you could write:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>C</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print_container</span><span class=p>(</span><span class=k>const</span> <span class=n>C</span> <span class=o>&amp;</span><span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>v</span> <span class=p>:</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>This naive way may fail if you pass anything other than standard container as other types may not have <code>begin</code> & <code>end</code> iterator.</li></ul><h3 id=passing-stdvector-to-c-template-function>Passing std::vector to C++ Template Function<a hidden class=anchor aria-hidden=true href=#passing-stdvector-to-c-template-function>#</a></h3><h4 id=naive-way-to-capture-containers-value-type>Naive Way to Capture Container&rsquo;s Value Type<a hidden class=anchor aria-hidden=true href=#naive-way-to-capture-containers-value-type>#</a></h4><ul><li>But let say, you want to pass container & want to work with container&rsquo;s storage type also. You can do:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>C</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>C</span><span class=o>::</span><span class=n>value_type</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print_container</span><span class=p>(</span><span class=k>const</span> <span class=n>C</span> <span class=o>&amp;</span><span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=nl>v</span> <span class=p>:</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>We can provide the second type parameter to our function that uses <a href=/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/>SFINAE</a> to verify that the thing is actually a container.</li><li>All standard containers have a member type named <code>value_type</code> which is the type of the thing inside the container. We sniff for that type, and if no such type exists, then <a href=/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/>SFINAE</a> kicks in, and that overload is removed from consideration.</li></ul><h4 id=capturing-containers-value-type-explicitly>Capturing Container&rsquo;s Value Type Explicitly<a hidden class=anchor aria-hidden=true href=#capturing-containers-value-type-explicitly>#</a></h4><ul><li>But what if you are passing vector class which doesn&rsquo;t has <code>value_type</code> member?</li><li><code>std::vector</code> is defined as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>            <span class=k>class</span> <span class=nc>T</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>class</span> <span class=nc>Allocator</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>allocator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span> 
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>vector</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>And you can capture two template arguments of <code>std::vector</code> container explicitly as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>            <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>,</span> <span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>Allocator</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print_container</span><span class=p>(</span><span class=n>C</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>Allocator</span><span class=o>&gt;</span> <span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=nl>v</span> <span class=p>:</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Above template pattern would be same if you want pass container to class/struct/union.</li></ul><h3 id=passing-any-container-to-c-template-function>Passing Any Container to C++ Template Function<a hidden class=anchor aria-hidden=true href=#passing-any-container-to-c-template-function>#</a></h3><ul><li>You see if you pass any other containers to the above solution. It won&rsquo;t work. So to make it generic we can use <a href=/posts/variadic-template-cpp-implementing-unsophisticated-tuple/>variadic template</a>:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>            <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print_container</span><span class=p>(</span><span class=n>C</span><span class=o>&lt;</span><span class=n>Args</span><span class=p>...</span><span class=o>&gt;</span> <span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>v</span> <span class=p>:</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>     <span class=n>v</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>};</span> <span class=c1>// takes total 2 template type argument
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print_container</span><span class=p>(</span><span class=n>v</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>        <span class=n>s</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>};</span> <span class=c1>// takes total 3 template type argument
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print_container</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=passing-container-of-container2d-stdvector-as-c-template-argument>Passing Container-of-Container/2D-std::vector as C++ Template Argument<a hidden class=anchor aria-hidden=true href=#passing-container-of-container2d-stdvector-as-c-template-argument>#</a></h3><ul><li>This is the case of nested template i.e. template-template parameter. And there are the following solutions:</li></ul><h4 id=explicit--complex-solution>Explicit & Complex Solution<a hidden class=anchor aria-hidden=true href=#explicit--complex-solution>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>            <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>,</span> <span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>C1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>,</span> <span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>C2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>Alloc_C1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Alloc_C2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print_container</span><span class=p>(</span><span class=k>const</span> <span class=n>C1</span><span class=o>&lt;</span><span class=n>C2</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>Alloc_C2</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>Alloc_C1</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>C2</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>Alloc_C2</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=nl>container_in</span> <span class=p>:</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=nl>v</span> <span class=p>:</span> <span class=n>container_in</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>I know this is ugly, but seems more explicit.</li></ul><h4 id=neat-solution>Neat Solution<a hidden class=anchor aria-hidden=true href=#neat-solution>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>   
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T2</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>T1</span><span class=o>::</span><span class=n>value_type</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T3</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>T2</span><span class=o>::</span><span class=n>value_type</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print_container</span><span class=p>(</span><span class=k>const</span> <span class=n>T1</span> <span class=o>&amp;</span><span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>T2</span> <span class=o>&amp;</span><span class=nl>e</span> <span class=p>:</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>T3</span> <span class=o>&amp;</span><span class=nl>x</span> <span class=p>:</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>As seen earlier including <a href=/posts/7-advance-cpp-concepts-idiom-examples-you-should-know>SFINAE</a>.</li></ul><h4 id=generic-solution-using-variadic-template>Generic Solution: Using Variadic Template<a hidden class=anchor aria-hidden=true href=#generic-solution-using-variadic-template>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>            <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span>
</span></span><span class=line><span class=cl>        <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print_container</span><span class=p>(</span><span class=n>C</span><span class=o>&lt;</span><span class=n>Args</span><span class=p>...</span><span class=o>&gt;</span> <span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>container_2nd</span> <span class=p>:</span> <span class=n>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>v</span> <span class=p>:</span> <span class=n>container_2nd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>This is our standard solution using the variadic template will work for a single container or any number of the nested container.</li></ul><h3 id=passing-function-to-class-template-argument>Passing Function to Class Template Argument<a hidden class=anchor aria-hidden=true href=#passing-function-to-class-template-argument>#</a></h3><ul><li>Passing class/struct/union to another class/struct/union as template argument is common thing. But passing function to class/struct/union as template argument is bit rare. But yes it&rsquo;s possible indeed. Consider the <a href=/posts/decorator-design-pattern-in-modern-cpp/>Functional Decorator</a> using a <a href=/posts/variadic-template-cpp-implementing-unsophisticated-tuple/>variadic class template</a>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Need partial specialization for this to work
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Logger</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Return type and argument list
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>R</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Logger</span><span class=o>&lt;</span><span class=n>R</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>function</span><span class=o>&lt;</span><span class=n>R</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;</span>    <span class=n>m_func</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span>                  <span class=n>m_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Logger</span><span class=p>(</span><span class=n>function</span><span class=o>&lt;</span><span class=n>R</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;</span> <span class=n>f</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>n</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_func</span><span class=p>{</span><span class=n>f</span><span class=p>},</span> <span class=n>m_name</span><span class=p>{</span><span class=n>n</span><span class=p>}</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=nf>operator</span><span class=p>()(</span><span class=n>Args</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Entering &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>m_name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>R</span> <span class=n>result</span> <span class=o>=</span> <span class=n>m_func</span><span class=p>(</span><span class=n>args</span><span class=p>...);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Exiting &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>m_name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>R</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>make_logger</span><span class=p>(</span><span class=n>R</span> <span class=p>(</span><span class=o>*</span><span class=n>func</span><span class=p>)(</span><span class=n>Args</span><span class=p>...),</span> <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Logger</span><span class=o>&lt;</span><span class=n>R</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;</span><span class=p>(</span><span class=n>function</span><span class=o>&lt;</span><span class=n>R</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;</span><span class=p>(</span><span class=n>func</span><span class=p>),</span> <span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>add</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>logged_add</span> <span class=o>=</span> <span class=n>make_logger</span><span class=p>(</span><span class=n>add</span><span class=p>,</span> <span class=s>&#34;Add&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>logged_add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Above example may seem a bit complex to you at first sight. But if you have a clear understanding of <a href=/posts/variadic-template-cpp-implementing-unsophisticated-tuple/>variadic class temple</a> then it won&rsquo;t take more than 30 seconds to understand what&rsquo;s going on here.</li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I hope I have covered most of the topics around C++ Template. And yes, this was a very long & intense article. But I bet you that if you do master the C++ template well, it will really give you an edge. And also open a door to sub-world of C++ i.e. template meta-programming.</p><blockquote><p><strong><em>C++ Template: C++&rsquo;s its own interpreted sub language</em></strong></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/c-template-return-type/>C-Template-Return-Type</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-alternative-to-partial-function-template-specialization/>C-Alternative-to-Partial-Function-Template-Specialization</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-c-template-reference-collapsing-rules/>C-C-Template-Reference-Collapsing-Rules</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-capturing-containers-value-type-explicitly/>C-Capturing-Containers-Value-Type-Explicitly</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-class-template/>C-Class-Template</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-class-template-argument-deduction-ctad/>C-Class-Template-Argument-Deduction-Ctad</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-class-template-specialization/>C-Class-Template-Specialization</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-curiously-recurring-template-pattern/>C-Curiously-Recurring-Template-Pattern</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-default-template-arguments/>C-Default-Template-Arguments</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-explicit-template-instantiation/>C-Explicit-Template-Instantiation</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-fold-expressions-vs-variadic-template/>C-Fold-Expressions-vs-Variadic-Template</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-forwarding-reference/>C-Forwarding-Reference</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-full-template-specialization/>C-Full-Template-Specialization</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-function-template/>C-Function-Template</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-function-template-argument-deduction/>C-Function-Template-Argument-Deduction</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-function-template-specialization/>C-Function-Template-Specialization</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-generic-class/>C-Generic-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-generic-solution-using-variadic-template/>C-Generic-Solution-Using-Variadic-Template</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-how-does-variadic-class-template-works/>C-How-Does-Variadic-Class-Template-Works</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-how-does-variadic-function-template-works/>C-How-Does-Variadic-Function-Template-Works</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-inferring-template-argument-through-function-template/>C-Inferring-Template-Argument-Through-Function-Template</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-naive-way-to-capture-containers-value-type/>C-Naive-Way-to-Capture-Containers-Value-Type</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-nested-template-template-template-parameter/>C-Nested-Template-Template-Template-Parameter</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-non-type-template-parameter/>C-Non-Type-Template-Parameter</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-overriding-template-argument-deduction/>C-Overriding-Template-Argument-Deduction</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-parameter-pack/>C-Parameter-Pack</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-partial-class-template-specialization/>C-Partial-Class-Template-Specialization</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-partial-function-template-specialization/>C-Partial-Function-Template-Specialization</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-partial-template-specialization/>C-Partial-Template-Specialization</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-passing-any-container-to-c-template-function/>C-Passing-Any-Container-to-C-Template-Function</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-passing-container-of-container-or-2d-std-vector-as-c-template-argument/>C-Passing-Container-of-Container-or-2d-Std-Vector-as-C-Template-Argument</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-passing-function-to-class-template-argument/>C-Passing-Function-to-Class-Template-Argument</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-passing-std-container-as-c-template-argument/>C-Passing-Std-Container-as-C-Template-Argument</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-passing-std-vector-to-c-template-function/>C-Passing-Std-Vector-to-C-Template-Function</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-perfect-forwarding/>C-Perfect-Forwarding</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-argument/>C-Template-Argument</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-argument-deduction/>C-Template-Argument-Deduction</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-argument-forwarding/>C-Template-Argument-Forwarding</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-class-constructor/>C-Template-Class-Constructor</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-class-definition/>C-Template-Class-Definition</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-example-use-cases/>C-Template-Example-Use-Cases</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-method/>C-Template-Method</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-programming/>C-Template-Programming</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-struct/>C-Template-Struct</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-terminology-jargon-idiom/>C-Template-Terminology-Jargon-Idiom</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-the-complete-guide/>C-Template-the-Complete-Guide</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-typename-vs-class/>C-Template-Typename-vs-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-types/>C-Template-Types</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-template-variable-number-of-arguments/>C-Template-Variable-Number-of-Arguments</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-union-template/>C-Union-Template</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-universal-reference/>C-Universal-Reference</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-using-typename/>C-Using-Typename</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-vararg/>C-Vararg</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-variadic-arguments/>C-Variadic-Arguments</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-variadic-class-template/>C-Variadic-Class-Template</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-variadic-constructor/>C-Variadic-Constructor</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-variadic-function-template/>C-Variadic-Function-Template</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-variadic-template/>C-Variadic-Template</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-why-do-we-need-forwarding-reference-in-first-place/>C-Why-Do-We-Need-Forwarding-Reference-in-First-Place</a></li><li><a href=https://vishalchovatiya.github.io/tags/c11-template-type-alias/>C11-Template-Type-Alias</a></li><li><a href=https://vishalchovatiya.github.io/tags/c14-implementing-unsophisticated-tuple-class/>C14-Implementing-Unsophisticated-Tuple-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/c14-or-c17-template-and-auto-keyword/>C14-or-C17-Template-and-Auto-Keyword</a></li><li><a href=https://vishalchovatiya.github.io/tags/c20-template-lambda-expression/>C20-Template-Lambda-Expression</a></li><li><a href=https://vishalchovatiya.github.io/tags/difference-between-function-template-and-class-template-in-c/>Difference-Between-Function-Template-and-Class-Template-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/explicit-instantiation-c/>Explicit-Instantiation-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/sizeof-parameter-pack/>Sizeof-Parameter-Pack</a></li><li><a href=https://vishalchovatiya.github.io/tags/template-typename-t/>Template-Typename-T</a></li><li><a href=https://vishalchovatiya.github.io/tags/variadic-templates-c-example/>Variadic-Templates-C-Example</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/crtp-c-examples/><span class=title>« Prev</span><br><span>CRTP C++ Examples</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/variadic-template-cpp-implementing-unsophisticated-tuple/><span class=title>Next »</span><br><span>Variadic Template C++: Implementing Unsophisticated Tuple</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Template: A Quick UpToDate Look(C++11/14/17/20) on x" href="https://x.com/intent/tweet/?text=C%2b%2b%20Template%3a%20A%20Quick%20UpToDate%20Look%28C%2b%2b11%2f14%2f17%2f20%29&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fc-template-a-quick-uptodate-look%2f&amp;hashtags=c-template-return-type%2cc-alternative-to-partial-function-template-specialization%2cc-c-template-reference-collapsing-rules%2cc-capturing-containers-value-type-explicitly%2cc-class-template%2cc-class-template-argument-deduction-ctad%2cc-class-template-specialization%2cc-curiously-recurring-template-pattern%2cc-default-template-arguments%2cc-explicit-template-instantiation%2cc-fold-expressions-vs-variadic-template%2cc-forwarding-reference%2cc-full-template-specialization%2cc-function-template%2cc-function-template-argument-deduction%2cc-function-template-specialization%2cc-generic-class%2cc-generic-solution-using-variadic-template%2cc-how-does-variadic-class-template-works%2cc-how-does-variadic-function-template-works%2cc-inferring-template-argument-through-function-template%2cc-naive-way-to-capture-containers-value-type%2cc-nested-template-template-template-parameter%2cc-non-type-template-parameter%2cc-overriding-template-argument-deduction%2cc-parameter-pack%2cc-partial-class-template-specialization%2cc-partial-function-template-specialization%2cc-partial-template-specialization%2cc-passing-any-container-to-c-template-function%2cc-passing-container-of-container-or-2d-std-vector-as-c-template-argument%2cc-passing-function-to-class-template-argument%2cc-passing-std-container-as-c-template-argument%2cc-passing-std-vector-to-c-template-function%2cc-perfect-forwarding%2cc-template-argument%2cc-template-argument-deduction%2cc-template-argument-forwarding%2cc-template-class-constructor%2cc-template-class-definition%2cc-template-example-use-cases%2cc-template-method%2cc-template-programming%2cc-template-struct%2cc-template-terminology-jargon-idiom%2cc-template-the-complete-guide%2cc-template-typename-vs-class%2cc-template-types%2cc-template-variable-number-of-arguments%2cc-union-template%2cc-universal-reference%2cc-using-typename%2cc-vararg%2cc-variadic-arguments%2cc-variadic-class-template%2cc-variadic-constructor%2cc-variadic-function-template%2cc-variadic-template%2cc-why-do-we-need-forwarding-reference-in-first-place%2cc11-template-type-alias%2cc14-implementing-unsophisticated-tuple-class%2cc14-or-c17-template-and-auto-keyword%2cc20-template-lambda-expression%2cdifference-between-function-template-and-class-template-in-c%2cexplicit-instantiation-c%2csizeof-parameter-pack%2ctemplate-typename-t%2cvariadic-templates-c-example"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Template: A Quick UpToDate Look(C++11/14/17/20) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fc-template-a-quick-uptodate-look%2f&amp;title=C%2b%2b%20Template%3a%20A%20Quick%20UpToDate%20Look%28C%2b%2b11%2f14%2f17%2f20%29&amp;summary=C%2b%2b%20Template%3a%20A%20Quick%20UpToDate%20Look%28C%2b%2b11%2f14%2f17%2f20%29&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fc-template-a-quick-uptodate-look%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Template: A Quick UpToDate Look(C++11/14/17/20) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fc-template-a-quick-uptodate-look%2f&title=C%2b%2b%20Template%3a%20A%20Quick%20UpToDate%20Look%28C%2b%2b11%2f14%2f17%2f20%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Template: A Quick UpToDate Look(C++11/14/17/20) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fc-template-a-quick-uptodate-look%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Template: A Quick UpToDate Look(C++11/14/17/20) on whatsapp" href="https://api.whatsapp.com/send?text=C%2b%2b%20Template%3a%20A%20Quick%20UpToDate%20Look%28C%2b%2b11%2f14%2f17%2f20%29%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fc-template-a-quick-uptodate-look%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Template: A Quick UpToDate Look(C++11/14/17/20) on telegram" href="https://telegram.me/share/url?text=C%2b%2b%20Template%3a%20A%20Quick%20UpToDate%20Look%28C%2b%2b11%2f14%2f17%2f20%29&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fc-template-a-quick-uptodate-look%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Template: A Quick UpToDate Look(C++11/14/17/20) on ycombinator" href="https://news.ycombinator.com/submitlink?t=C%2b%2b%20Template%3a%20A%20Quick%20UpToDate%20Look%28C%2b%2b11%2f14%2f17%2f20%29&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fc-template-a-quick-uptodate-look%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>