<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding unique_ptr with Example in C++11 | Vishal Chovatiya</title>
<meta name=keywords content="assign-pointer-to-unique_ptr,auto_ptr,boost-unique_ptr,boost-unique_ptr-example,c-11-unique_ptr,c-pass-unique_ptr-as-argument,c-pimpl-unique_ptr,c-unique_ptr,c-unique_ptr-example,c-unique_ptr-vector,c-using-unique_ptr,c-vector-of-unique_ptr,c11,keyword-ideas,nderstanding-unique_ptr,pass-unique_ptr-to-function,pass-unique_ptr-to-lambda,push_back-unique_ptr,understanding-unique_ptr-with-example-in-c11,unique_ptr,unique_ptr-c,unique_ptr-c-11,unique_ptr-c-example,unique_ptr-cplusplus,unique_ptr-example,unique_ptr-example-c,unique_ptr-in-c,unique_ptr-tutorial,unique_ptr-with-example"><meta name=description content="The smart pointers are a really good mechanism to manage dynamically allocated resources. In this article, we will see unique_ptr with example in C++11. But we don&rsquo;t discuss standard smart pointers from a library. Rather, we implement our own smart pointer equivalent to it. This will give us an idea of inside working of smart pointers.
Brief Prior to C++11, the standard provided std::auto_ptr. Which had some limitations. But from C++11, standard provided many smart pointers classes."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=http://localhost:1313/posts/unique_ptr-with-example-in-c/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/unique_ptr-with-example-in-c/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Understanding unique_ptr with Example in C++11"><meta property="og:description" content="The smart pointers are a really good mechanism to manage dynamically allocated resources. In this article, we will see unique_ptr with example in C++11. But we don&rsquo;t discuss standard smart pointers from a library. Rather, we implement our own smart pointer equivalent to it. This will give us an idea of inside working of smart pointers.
Brief Prior to C++11, the standard provided std::auto_ptr. Which had some limitations. But from C++11, standard provided many smart pointers classes."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/unique_ptr-with-example-in-c/"><meta property="og:image" content="http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-15T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-15T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png"><meta name=twitter:title content="Understanding unique_ptr with Example in C++11"><meta name=twitter:description content="The smart pointers are a really good mechanism to manage dynamically allocated resources. In this article, we will see unique_ptr with example in C++11. But we don&rsquo;t discuss standard smart pointers from a library. Rather, we implement our own smart pointer equivalent to it. This will give us an idea of inside working of smart pointers.
Brief Prior to C++11, the standard provided std::auto_ptr. Which had some limitations. But from C++11, standard provided many smart pointers classes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Understanding unique_ptr with Example in C++11","item":"http://localhost:1313/posts/unique_ptr-with-example-in-c/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding unique_ptr with Example in C++11","name":"Understanding unique_ptr with Example in C\u002b\u002b11","description":"The smart pointers are a really good mechanism to manage dynamically allocated resources. In this article, we will see unique_ptr with example in C++11. But we don\u0026rsquo;t discuss standard smart pointers from a library. Rather, we implement our own smart pointer equivalent to it. This will give us an idea of inside working of smart pointers.\nBrief Prior to C++11, the standard provided std::auto_ptr. Which had some limitations. But from C++11, standard provided many smart pointers classes.","keywords":["assign-pointer-to-unique_ptr","auto_ptr","boost-unique_ptr","boost-unique_ptr-example","c-11-unique_ptr","c-pass-unique_ptr-as-argument","c-pimpl-unique_ptr","c-unique_ptr","c-unique_ptr-example","c-unique_ptr-vector","c-using-unique_ptr","c-vector-of-unique_ptr","c11","keyword-ideas","nderstanding-unique_ptr","pass-unique_ptr-to-function","pass-unique_ptr-to-lambda","push_back-unique_ptr","understanding-unique_ptr-with-example-in-c11","unique_ptr","unique_ptr-c","unique_ptr-c-11","unique_ptr-c-example","unique_ptr-cplusplus","unique_ptr-example","unique_ptr-example-c","unique_ptr-in-c","unique_ptr-tutorial","unique_ptr-with-example"],"articleBody":"The smart pointers are a really good mechanism to manage dynamically allocated resources. In this article, we will see unique_ptr with example in C++11. But we don’t discuss standard smart pointers from a library. Rather, we implement our own smart pointer equivalent to it. This will give us an idea of inside working of smart pointers.\nBrief Prior to C++11, the standard provided std::auto_ptr. Which had some limitations. But from C++11, standard provided many smart pointers classes. Understanding unique_ptr with example in C++ requires an understanding of move semantics which I have discussed here \u0026 here.\nBut before all these nuisances, we will see “Why do we need smart pointer in 1st place?”:\nWhy do we need smart pointers? void func() { Resource *ptr = new Resource; int x; std::cout \u003c\u003c \"Enter an integer: \"; std::cin \u003e\u003e x; if (x == 0) throw 0; // the function returns early, and ptr won't be deleted! if (x \u003c 0) return; // the function returns early, and ptr won't be deleted! // do stuff with ptr here delete ptr; } In the above code, the early return or throw statement, causing the function to terminate without variable ptr being deleted. Consequently, the memory allocated for variable ptr is now leaked (and leaked again every time this function is called and returns early). These kinds of issues occur because pointer variables have no inherent mechanism to clean up after themselves. Following class cleans-up automatically when sources are no longer in use: smart_ptr aka std::auto_ptr from C++98 template\u003cclass T\u003e class smart_ptr { T* m_ptr; public: smart_ptr(T* ptr=nullptr):m_ptr(ptr){} ~smart_ptr() { delete m_ptr; } T\u0026 operator*() const { return *m_ptr; } T* operator-\u003e() const { return m_ptr; } }; Now, let’s go back to our func()example above, and show how a smart pointer class can solve our challenge: class Resource { public: Resource() { std::cout \u003c\u003c \"Resource acquired\\n\"; } ~Resource() { std::cout \u003c\u003c \"Resource destroyed\\n\"; } }; void func() { smart_ptr\u003cResource\u003e ptr(new Resource); // ptr now owns the Resource int x; std::cout \u003c\u003c \"Enter an integer: \"; std::cin \u003e\u003e x; if (x == 0) throw 0; if (x \u003c 0) return; // do stuff with ptr here // dont care about deallocation } int main() { try{ func(); } catch(int val){} return 0; } Output Resource acquired Hi! Resource destroyed Note that even in the case where the user enters zero and the function terminates early, the Resource is still properly deallocated. Because of the ptr variable is a local variable. ptr destroys when the function terminates (regardless of how it terminates). And because of the smart_ptr destructor will clean up the Resource, we are assured that the Resource will be properly cleaned up. There is still some problem with our code. Like: int main() { smart_ptr\u003cResource\u003e res1(new Resource); smart_ptr\u003cResource\u003e res2(res1); // Alternatively, don't initialize res2 and then assign res2 = res1; return 0; } Output Resource acquired Resource destroyed Resource destroyed In this case destructor of our Resource object will be called twice which can crash the program. What if, instead of having our copy constructor and assignment operator copy the pointer (“copy semantics”), we instead transfer/move ownership of the pointer from the source to the destination object? This is the core idea behind move semantics. Move semantics means the class will transfer ownership of the object rather than making a copy. Let’s update our smart_ptr class to show how this can be done: template\u003cclass T\u003e class smart_ptr { T* m_ptr; public: smart_ptr(T* ptr=nullptr) :m_ptr(ptr) {} ~smart_ptr() { delete m_ptr; } // copy constructor that implements move semantics smart_ptr(smart_ptr\u0026 a) // note: not const { m_ptr = a.m_ptr; // transfer our dumb pointer from the source to our local object a.m_ptr = nullptr; // make sure the source no longer owns the pointer } // assignment operator that implements move semantics smart_ptr\u0026 operator=(smart_ptr\u0026 a) // note: not const { if (\u0026a == this) return *this; delete m_ptr; // make sure we deallocate any pointer the destination is already holding first m_ptr = a.m_ptr; // then transfer our dumb pointer from the source to the local object a.m_ptr = nullptr; // make sure the source no longer owns the pointer return *this; } T\u0026 operator*() const { return *m_ptr; } T* operator-\u003e() const { return m_ptr; } }; class Resource { public: Resource() { std::cout \u003c\u003c \"Resource acquired\\n\"; } ~Resource() { std::cout \u003c\u003c \"Resource destroyed\\n\"; } }; int main() { smart_ptr\u003cResource\u003e res1(new Resource); smart_ptr\u003cResource\u003e res2(res1); return 0; } Output Resource acquired Resource destroyed std::auto_ptr, and why to avoid it What we have seen above as smart_ptr is basically an std::auto_ptr which was introduced in C++98, was C++’s first attempt at a standardized smart pointer. However, std::auto_ptr (and our smart_ptr class) has a number of problems that make using it dangerous. Because std::auto_ptr implements move semantics through the copy constructor and assignment operator, passing an std::auto_ptr by value to a function will cause your resource to get moved to the function parameter (and be destroyed at the end of the function when the function parameters go out of scope). Then when you go to access your std::auto_ptr argument from the caller (not realizing it was transferred and deleted), you’re suddenly dereferencing a null pointer. Crash! std::auto_ptr always deletes its contents using non-array delete. This means std::auto_ptr won’t work correctly with dynamically allocated arrays, because it uses the wrong kind of deallocation. Worse, it won’t prevent you from passing it a dynamic array, which it will then mismanage, leading to memory leaks. Because of the above-mentioned shortcomings, std::auto_ptr has been deprecated in C++11, and it should not used. In fact, std::auto_ptr slated for complete removal from the standard library as part of C++17! Overriding the copy semantics to implement move semantics leads to weird edge cases and inadvertent bugs. Because of this, in C++11, the concept of “move” formally defined. And “move semantics” added to the language to properly differentiate copying from moving. In C++11, std::auto_ptr has been replaced by a bunch of other types of “move-aware” smart pointers: std::scoped_ptr, std::unique_ptr, std::weak_ptr, and std::shared_ptr. We’ll also explore the two most popular of these: std::unique_ptr (which is a direct replacement for std::auto_ptr) and std::shared_ptr. std::unique_ptr with example in C++11 std::unique_ptr is the C++11 replacement for std::auto_ptr. It is used to manage use to manage any dynamically allocated object not shared by multiple objects. That is, std::unique_ptr should completely own the object it manages, not share that ownership with other classes. We can convert our smart_ptr we designed above into std::unique_ptr. And for that one thing, we can do is delete the copy constructor \u0026 assignment operator so that no one can copy smart pointer. As we are not allowing a copy of smart pointer we can’t pass our smart pointer to any function by value or return by value. And this is not good design. To pass or return by value, we can add move constructor \u0026 move assignment operator, so that while passing or returning by value, we would have to transfer ownership through move semantics. This way we can also ensure single ownership throughout the lifetime of the object. template\u003cclass T\u003e class smart_ptr { T* m_ptr; public: smart_ptr(T* ptr = nullptr) : m_ptr(ptr){} ~smart_ptr() { delete m_ptr; } // Copy constructor smart_ptr(const smart_ptr\u0026 a) = delete; // Move constructor smart_ptr(smart_ptr\u0026\u0026 a) : m_ptr(a.m_ptr) { a.m_ptr = nullptr; } // Copy assignment smart_ptr\u0026 operator=(const smart_ptr\u0026 a) = delete; // Move assignment smart_ptr\u0026 operator=(smart_ptr\u0026\u0026 a) { if (\u0026a == this) return *this; delete m_ptr; m_ptr = a.m_ptr; a.m_ptr = nullptr; return *this; } T\u0026 operator*() const { return *m_ptr; } T* operator-\u003e() const { return m_ptr; } }; class Resource { public: Resource() { std::cout \u003c\u003c \"Resource acquired\\n\"; } ~Resource() { std::cout \u003c\u003c \"Resource destroyed\\n\"; } }; smart_ptr\u003cResource\u003e func(smart_ptr\u003cResource\u003e temp) { // Do something return temp; } int main() { smart_ptr\u003cResource\u003e res1(new Resource); // smart_ptr res3 = res1; // Won't compile, as copy contructor is deleted smart_ptr\u003cResource\u003e res3 = func(std::move(res1)); // calls move semantics return 0; } Output Resource acquired Resource destroyed This is not the exact implementation of std::unique_ptr as there is deleter, implicit cast to bool \u0026 other security features included in an actual implementation, but this gives you a bigger picture of how std::unique_ptr is implemented. References https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/ https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=vs-2017 ","wordCount":"1374","inLanguage":"en","image":"http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png","datePublished":"2019-09-15T00:00:00Z","dateModified":"2019-09-15T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/unique_ptr-with-example-in-c/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=http://localhost:1313/posts/ title=Latest><span>Latest</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Understanding unique_ptr with Example in C++11</h1><div class=post-meta><span title='2019-09-15 00:00:00 +0000 UTC'>September 15, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1374 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/unique_ptr-with-example-in-c.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#brief>Brief</a></li><li><a href=#why-do-we-need-smart-pointers>Why do we need smart pointers?</a></li><li><a href=#smart_ptr-aka-stdauto_ptr-from-c98><code>smart_ptr</code> aka <code>std::auto_ptr</code> from C++98</a></li><li><a href=#stdauto_ptr-and-why-to-avoid-it><code>std::auto_ptr</code>, and why to avoid it</a></li><li><a href=#stdunique_ptr-with-example-in-c11>std::unique_ptr with example in C++11</a></li><li><a href=#references>References</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>The smart pointers are a really good mechanism to manage dynamically allocated resources. In this article, we will see unique_ptr with example in C++11. But we don&rsquo;t discuss standard smart pointers from a library. Rather, we implement our own smart pointer equivalent to it. This will give us an idea of inside working of smart pointers.</p><h3 id=brief>Brief<a hidden class=anchor aria-hidden=true href=#brief>#</a></h3><p>Prior to C++11, the standard provided <code>std::auto_ptr</code>. Which had some limitations. But from C++11, standard provided many smart pointers classes. Understanding unique_ptr with example in C++ requires an understanding of move semantics which I have discussed <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>here</a> & <a href=/posts/move-constructor-assignment-operator-with-shared_ptr/>here</a>.</p><p>But before all these nuisances, we will see &ldquo;Why do we need smart pointer in 1st place?&rdquo;:</p><h3 id=why-do-we-need-smart-pointers>Why do we need smart pointers?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-smart-pointers>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Resource</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Resource</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Enter an integer: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// the function returns early, and ptr won&#39;t be deleted!
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span> <span class=c1>// the function returns early, and ptr won&#39;t be deleted!
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// do stuff with ptr here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>In the above code, the early <code>return</code> or <code>throw</code> statement, causing the function to terminate without variable <code>ptr</code> being deleted.</li><li>Consequently, the memory allocated for variable <code>ptr</code> is now leaked (and leaked again every time this function is called and returns early).</li><li>These kinds of issues occur because pointer variables have no inherent mechanism to clean up after themselves.</li><li>Following class cleans-up automatically when sources are no longer in use:</li></ul><h3 id=smart_ptr-aka-stdauto_ptr-from-c98><code>smart_ptr</code> aka <code>std::auto_ptr</code> from C++98<a hidden class=anchor aria-hidden=true href=#smart_ptr-aka-stdauto_ptr-from-c98>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>smart_ptr</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>ptr</span><span class=o>=</span><span class=k>nullptr</span><span class=p>)</span><span class=o>:</span><span class=n>m_ptr</span><span class=p>(</span><span class=n>ptr</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>smart_ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>*</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=k>operator</span><span class=o>-&gt;</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>Now, let&rsquo;s go back to our <code>func()</code>example above, and show how a smart pointer class can solve our challenge:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Resource</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Resource</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Resource acquired</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Resource</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Resource destroyed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>(</span><span class=k>new</span> <span class=n>Resource</span><span class=p>);</span> <span class=c1>// ptr now owns the Resource
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Enter an integer: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// do stuff with ptr here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// dont care about deallocation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span><span class=p>(</span><span class=kt>int</span> <span class=n>val</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Output</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Resource acquired
</span></span><span class=line><span class=cl>Hi!
</span></span><span class=line><span class=cl>Resource destroyed
</span></span></code></pre></div><ul><li>Note that even in the case where the user enters zero and the function terminates early, the <code>Resource</code> is still properly deallocated.</li><li>Because of the <code>ptr</code> variable is a local variable. <code>ptr</code> destroys when the function terminates (regardless of how it terminates). And because of the <code>smart_ptr</code> destructor will clean up the <code>Resource</code>, we are assured that the <code>Resource</code> will be properly cleaned up.</li><li>There is still some problem with our code. Like:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>res1</span><span class=p>(</span><span class=k>new</span> <span class=n>Resource</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>res2</span><span class=p>(</span><span class=n>res1</span><span class=p>);</span> <span class=c1>// Alternatively, don&#39;t initialize res2 and then assign res2 = res1;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Output</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Resource acquired
</span></span><span class=line><span class=cl>Resource destroyed
</span></span><span class=line><span class=cl>Resource destroyed
</span></span></code></pre></div><ul><li>In this case destructor of our <code>Resource</code> object will be called twice which can crash the program.</li><li>What if, instead of having our copy constructor and assignment operator copy the pointer (&ldquo;copy semantics&rdquo;), we instead transfer/move ownership of the pointer from the source to the destination object? This is the core idea behind move semantics. Move semantics means the class will transfer ownership of the object rather than making a copy.</li><li>Let&rsquo;s update our <code>smart_ptr</code> class to show how this can be done:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>smart_ptr</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>ptr</span><span class=o>=</span><span class=k>nullptr</span><span class=p>)</span> <span class=o>:</span><span class=n>m_ptr</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>smart_ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// copy constructor that implements move semantics
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>)</span> <span class=c1>// note: not const
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>m_ptr</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>;</span> <span class=c1>// transfer our dumb pointer from the source to our local object
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// make sure the source no longer owns the pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// assignment operator that implements move semantics
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>)</span> <span class=c1>// note: not const
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>a</span> <span class=o>==</span> <span class=k>this</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>m_ptr</span><span class=p>;</span> <span class=c1>// make sure we deallocate any pointer the destination is already holding first
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>m_ptr</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>;</span> <span class=c1>// then transfer our dumb pointer from the source to the local object
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// make sure the source no longer owns the pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>*</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=k>operator</span><span class=o>-&gt;</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Resource</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Resource</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Resource acquired</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Resource</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Resource destroyed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>res1</span><span class=p>(</span><span class=k>new</span> <span class=n>Resource</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>res2</span><span class=p>(</span><span class=n>res1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Output</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Resource acquired
</span></span><span class=line><span class=cl>Resource destroyed
</span></span></code></pre></div><h3 id=stdauto_ptr-and-why-to-avoid-it><code>std::auto_ptr</code>, and why to avoid it<a hidden class=anchor aria-hidden=true href=#stdauto_ptr-and-why-to-avoid-it>#</a></h3><ul><li>What we have seen above as <code>smart_ptr</code> is basically an <code>std::auto_ptr</code> which was introduced in C++98, was C++&rsquo;s first attempt at a standardized smart pointer.</li><li>However, <code>std::auto_ptr</code> (and our <code>smart_ptr</code> class) has a number of problems that make using it dangerous.</li></ul><ol><li>Because <code>std::auto_ptr</code> implements move semantics through the copy constructor and assignment operator, passing an <code>std::auto_ptr</code> by value to a function will cause your resource to get moved to the function parameter (and be destroyed at the end of the function when the function parameters go out of scope). Then when you go to access your <code>std::auto_ptr</code> argument from the caller (not realizing it was transferred and deleted), you&rsquo;re suddenly dereferencing a null pointer. Crash!</li><li><code>std::auto_ptr</code> always deletes its contents using non-array delete. This means <code>std::auto_ptr</code> won&rsquo;t work correctly with dynamically allocated arrays, because it uses the wrong kind of deallocation. Worse, it won&rsquo;t prevent you from passing it a dynamic array, which it will then mismanage, leading to memory leaks.</li></ol><ul><li>Because of the above-mentioned shortcomings, <code>std::auto_ptr</code> has been deprecated in C++11, and it should not used. In fact, <code>std::auto_ptr</code> slated for complete removal from the standard library as part of C++17!</li><li>Overriding the copy semantics to implement move semantics leads to weird edge cases and inadvertent bugs. Because of this, in C++11, the concept of &ldquo;move&rdquo; formally defined. And &ldquo;move semantics&rdquo; added to the language to properly differentiate copying from moving. In C++11, <code>std::auto_ptr</code> has been replaced by a bunch of other types of &ldquo;move-aware&rdquo; smart pointers: <code>std::scoped_ptr</code>, <code>std::unique_ptr</code>, <code>std::weak_ptr</code>, and <code>std::shared_ptr</code>.</li><li>We&rsquo;ll also explore the two most popular of these: <code>std::unique_ptr</code> (which is a direct replacement for <code>std::auto_ptr</code>) and <code>std::shared_ptr</code>.</li></ul><h3 id=stdunique_ptr-with-example-in-c11>std::unique_ptr with example in C++11<a hidden class=anchor aria-hidden=true href=#stdunique_ptr-with-example-in-c11>#</a></h3><ul><li><code>std::unique_ptr</code> is the C++11 replacement for <code>std::auto_ptr</code>. It is used to manage use to manage any dynamically allocated object not shared by multiple objects. That is, <code>std::unique_ptr</code> should completely own the object it manages, not share that ownership with other classes.</li><li>We can convert our <code>smart_ptr</code> we designed above into <code>std::unique_ptr</code>. And for that one thing, we can do is delete the copy constructor & assignment operator so that no one can copy smart pointer.</li><li>As we are not allowing a copy of smart pointer we can&rsquo;t pass our smart pointer to any function by value or return by value. And this is not good design.</li><li>To pass or return by value, we can add move constructor & move assignment operator, so that while passing or returning by value, we would have to transfer ownership through move semantics. This way we can also ensure single ownership throughout the lifetime of the object.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>smart_ptr</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_ptr</span><span class=p>(</span><span class=n>ptr</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>smart_ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Copy constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=p>(</span><span class=k>const</span> <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Move constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&amp;&amp;</span> <span class=n>a</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_ptr</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Copy assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Move assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&amp;&amp;</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>a</span> <span class=o>==</span> <span class=k>this</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>m_ptr</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>m_ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>*</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=k>operator</span><span class=o>-&gt;</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Resource</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Resource</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Resource acquired</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Resource</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Resource destroyed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>func</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>temp</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>res1</span><span class=p>(</span><span class=k>new</span> <span class=n>Resource</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// smart_ptr&lt;Resource&gt; res3 = res1; // Won&#39;t compile, as copy contructor is deleted
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>Resource</span><span class=o>&gt;</span> <span class=n>res3</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>res1</span><span class=p>));</span> <span class=c1>// calls move semantics
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Output</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Resource acquired
</span></span><span class=line><span class=cl>Resource destroyed
</span></span></code></pre></div><ul><li>This is not the exact implementation of <code>std::unique_ptr</code> as there is deleter, implicit cast to bool & other security features included in an actual implementation, but this gives you a bigger picture of how <code>std::unique_ptr</code> is implemented.</li></ul><h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><ul><li><a href=https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/>https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/</a></li><li><a href=https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one>https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=vs-2017">https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=vs-2017</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/assign-pointer-to-unique_ptr/>Assign-Pointer-to-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/auto_ptr/>Auto_ptr</a></li><li><a href=http://localhost:1313/tags/boost-unique_ptr/>Boost-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/boost-unique_ptr-example/>Boost-Unique_ptr-Example</a></li><li><a href=http://localhost:1313/tags/c-11-unique_ptr/>C-11-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/c-pass-unique_ptr-as-argument/>C-Pass-Unique_ptr-as-Argument</a></li><li><a href=http://localhost:1313/tags/c-pimpl-unique_ptr/>C-Pimpl-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/c-unique_ptr/>C-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/c-unique_ptr-example/>C-Unique_ptr-Example</a></li><li><a href=http://localhost:1313/tags/c-unique_ptr-vector/>C-Unique_ptr-Vector</a></li><li><a href=http://localhost:1313/tags/c-using-unique_ptr/>C-Using-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/c-vector-of-unique_ptr/>C-Vector-of-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/c11/>C11</a></li><li><a href=http://localhost:1313/tags/keyword-ideas/>Keyword-Ideas</a></li><li><a href=http://localhost:1313/tags/nderstanding-unique_ptr/>Nderstanding-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/pass-unique_ptr-to-function/>Pass-Unique_ptr-to-Function</a></li><li><a href=http://localhost:1313/tags/pass-unique_ptr-to-lambda/>Pass-Unique_ptr-to-Lambda</a></li><li><a href=http://localhost:1313/tags/push_back-unique_ptr/>Push_back-Unique_ptr</a></li><li><a href=http://localhost:1313/tags/understanding-unique_ptr-with-example-in-c11/>Understanding-Unique_ptr-With-Example-in-C11</a></li><li><a href=http://localhost:1313/tags/unique_ptr/>Unique_ptr</a></li><li><a href=http://localhost:1313/tags/unique_ptr-c/>Unique_ptr-C</a></li><li><a href=http://localhost:1313/tags/unique_ptr-c-11/>Unique_ptr-C-11</a></li><li><a href=http://localhost:1313/tags/unique_ptr-c-example/>Unique_ptr-C-Example</a></li><li><a href=http://localhost:1313/tags/unique_ptr-cplusplus/>Unique_ptr-Cplusplus</a></li><li><a href=http://localhost:1313/tags/unique_ptr-example/>Unique_ptr-Example</a></li><li><a href=http://localhost:1313/tags/unique_ptr-example-c/>Unique_ptr-Example-C</a></li><li><a href=http://localhost:1313/tags/unique_ptr-in-c/>Unique_ptr-in-C</a></li><li><a href=http://localhost:1313/tags/unique_ptr-tutorial/>Unique_ptr-Tutorial</a></li><li><a href=http://localhost:1313/tags/unique_ptr-with-example/>Unique_ptr-With-Example</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/move-constructor-assignment-operator-with-shared-ptr/><span class=title>« Prev</span><br><span>Move Constructor & Assignment Operator With std::shared_ptr</span>
</a><a class=next href=http://localhost:1313/posts/cpp-type-casting-with-example-for-c-developers/><span class=title>Next »</span><br><span>C++ Type Casting With Example for C Developers</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding unique_ptr with Example in C++11 on x" href="https://x.com/intent/tweet/?text=Understanding%20unique_ptr%20with%20Example%20in%20C%2b%2b11&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2funique_ptr-with-example-in-c%2f&amp;hashtags=assign-pointer-to-unique_ptr%2cauto_ptr%2cboost-unique_ptr%2cboost-unique_ptr-example%2cc-11-unique_ptr%2cc-pass-unique_ptr-as-argument%2cc-pimpl-unique_ptr%2cc-unique_ptr%2cc-unique_ptr-example%2cc-unique_ptr-vector%2cc-using-unique_ptr%2cc-vector-of-unique_ptr%2cc11%2ckeyword-ideas%2cnderstanding-unique_ptr%2cpass-unique_ptr-to-function%2cpass-unique_ptr-to-lambda%2cpush_back-unique_ptr%2cunderstanding-unique_ptr-with-example-in-c11%2cunique_ptr%2cunique_ptr-c%2cunique_ptr-c-11%2cunique_ptr-c-example%2cunique_ptr-cplusplus%2cunique_ptr-example%2cunique_ptr-example-c%2cunique_ptr-in-c%2cunique_ptr-tutorial%2cunique_ptr-with-example"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding unique_ptr with Example in C++11 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2funique_ptr-with-example-in-c%2f&amp;title=Understanding%20unique_ptr%20with%20Example%20in%20C%2b%2b11&amp;summary=Understanding%20unique_ptr%20with%20Example%20in%20C%2b%2b11&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2funique_ptr-with-example-in-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding unique_ptr with Example in C++11 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2funique_ptr-with-example-in-c%2f&title=Understanding%20unique_ptr%20with%20Example%20in%20C%2b%2b11"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding unique_ptr with Example in C++11 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2funique_ptr-with-example-in-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding unique_ptr with Example in C++11 on whatsapp" href="https://api.whatsapp.com/send?text=Understanding%20unique_ptr%20with%20Example%20in%20C%2b%2b11%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2funique_ptr-with-example-in-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding unique_ptr with Example in C++11 on telegram" href="https://telegram.me/share/url?text=Understanding%20unique_ptr%20with%20Example%20in%20C%2b%2b11&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2funique_ptr-with-example-in-c%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding unique_ptr with Example in C++11 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Understanding%20unique_ptr%20with%20Example%20in%20C%2b%2b11&u=http%3a%2f%2flocalhost%3a1313%2fposts%2funique_ptr-with-example-in-c%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>