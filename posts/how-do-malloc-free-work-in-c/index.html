<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How Do malloc & free Work in C! | Vishal Chovatiya</title>
<meta name=keywords content="brk,how-does-free-know-how-much-to-free,program-break,sbrk,will-malloc-allocates-contiguously-in-memory-or-it-scattered"><meta name=description content="As we know, the process can allocate & deallocate memory using malloc & free in C language. But do you ever consider what happens behind the scene ? or How do malloc & free work? Let see
Allocating Memory on the Heap A process can allocate memory by increasing the size of the heap.
Heap is a variable-size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows & shrinks as memory allocated and freed."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=http://localhost:1313/posts/how-do-malloc-free-work-in-c/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/trident_favicon.webp><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/images/trident_favicon.webp><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/images/trident_favicon.webp><link rel=apple-touch-icon href=http://localhost:1313/images/trident_favicon.webp><link rel=mask-icon href=http://localhost:1313/images/trident_favicon.webp><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/how-do-malloc-free-work-in-c/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How Do malloc & free Work in C!"><meta property="og:description" content="As we know, the process can allocate & deallocate memory using malloc & free in C language. But do you ever consider what happens behind the scene ? or How do malloc & free work? Let see
Allocating Memory on the Heap A process can allocate memory by increasing the size of the heap.
Heap is a variable-size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows & shrinks as memory allocated and freed."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/how-do-malloc-free-work-in-c/"><meta property="og:image" content="http://localhost:1313/images/How-do-malloc-free-work-vishal-chovatiya.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-10-08T00:00:00+00:00"><meta property="article:modified_time" content="2016-10-08T00:00:00+00:00"><meta property="og:site_name" content="Vishal Chovatiya"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/How-do-malloc-free-work-vishal-chovatiya.png"><meta name=twitter:title content="How Do malloc & free Work in C!"><meta name=twitter:description content="As we know, the process can allocate & deallocate memory using malloc & free in C language. But do you ever consider what happens behind the scene ? or How do malloc & free work? Let see
Allocating Memory on the Heap A process can allocate memory by increasing the size of the heap.
Heap is a variable-size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows & shrinks as memory allocated and freed."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"How Do malloc \u0026 free Work in C!","item":"http://localhost:1313/posts/how-do-malloc-free-work-in-c/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How Do malloc \u0026 free Work in C!","name":"How Do malloc \u0026 free Work in C!","description":"As we know, the process can allocate \u0026amp; deallocate memory using malloc \u0026amp; free in C language. But do you ever consider what happens behind the scene ? or How do malloc \u0026amp; free work? Let see\nAllocating Memory on the Heap A process can allocate memory by increasing the size of the heap.\nHeap is a variable-size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows \u0026amp; shrinks as memory allocated and freed.","keywords":["brk","how-does-free-know-how-much-to-free","program-break","sbrk","will-malloc-allocates-contiguously-in-memory-or-it-scattered"],"articleBody":"As we know, the process can allocate \u0026 deallocate memory using malloc \u0026 free in C language. But do you ever consider what happens behind the scene ? or How do malloc \u0026 free work? Let see\nAllocating Memory on the Heap A process can allocate memory by increasing the size of the heap.\nHeap is a variable-size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows \u0026 shrinks as memory allocated and freed.\nThe current limit of the heap referred to as the program break which is just at the end of the uninitialized data segment in process address space.\nResizing the heap (i.e., allocating or de-allocating memory) is as simple as telling the kernel to adjust its idea of where the process’s program break is.\nTo allocate memory, C programs normally use the malloc family of functions, which we describe shortly. However, we begin with a description of brk()\u0026 `sbrk(), upon which the malloc functions are based.\nPre-requisites: Memory layout of C program OR Understanding of process address space\nbrk()\u0026 `sbrk() 1 2 3 4 5 #include int brk(void end_data_segment); void *sbrk(intptr_t increment); The brk()is a system call which sets the program break to the location specified by end_data_segment. Since virtual memory is located in units of pages, end_data_segment is effectively rounded up to the next page boundary. A call to sbrk() adjusts the program break by adding an increment to it. On Linux, sbrk() is a library function implemented on top of brk(). On success, sbrk()returns the previous address of the program break. In other words, if we have increased the program break, then the return value is a pointer to the start of the newly allocated block of memory. The call sbrk(0) returns the current setting of the program break without changing it. This can be useful if we want to track the size of the heap, perhaps to monitor the behaviour of a memory allocation package. After the program break increased, the program may access any address in the newly allocated area, but no physical memory pages allocated yet. The kernel automatically allocates new physical pages on the first attempt by the process to access addresses in those pages. How Does malloc \u0026 free Work? malloc When you malloc a block, it first checks how much memory you requested. There are 2 ways to get memory from the system: 1. mmap(), 2. brk() When you request some byte to be allocated by malloc it checks for MMAP_THRESHOLD limit(this also depends upon library implementations). If you request more than that limit, then mmap()system call used to obtain the requested memory. Else it uses brk()syscall, increments the program break size \u0026 gives you a pointer to start of newly allocate contiguous block. Whichever procedure it follows, it allocates a bit more memory than you asked for. This extra memory(also known as meta-data) used to store information such as the size of the allocated block. And a link to the next free/used a block in a chain of blocks, and sometimes some guard data(that helps the system to detect if you write past the end of your allocated block). Also, most allocators will round-up the total size and/or the start of your part of the memory to a multiple of bytes (e.g. on a 64-bit system may align the data to a multiple of 64 bits (8 bytes) as accessing data from non-aligned addresses can be more difficult and inefficient for the processor/bus), so you may also end up with some “padding” (unused bytes). free As we know so far that we allocate the memory just by increasing the program’s break. And upon your intellect, you must be thinking that free will lower this program break. But it’s not, free simply adds the block of memory to list of free blocks that are recycled by future calls to malloc() But why? Well, the block of memory being freed is typically somewhere in the middle of the heap, rather than at the end, so that lowering the program break is not possible. Will malloc Allocates Contiguously in Memory or It Scattered? Yes \u0026 no both, Here is why! In a typical OS, there exists the concepts of virtual memory and physical memory. Each process has its virtual memory range which is contiguous. When you allocate memory through malloc, the program break increased with respect to virtual memory. So your allocated byte is contiguous. But the OS, behind the scenes, is busy mapping virtual memory allocations onto real blocks of physical memory which do not be contiguous because this is how VMM(Virtual Memory Manager) works. You can read more about it here. How Does free Know How Much to Free? If you still can not figure out the answer to this question, you may read the above topics again. Anyway. When you call `malloc(), you specify the amount of memory to allocate. The amount of memory used is slightly more than this and includes extra information that records (at least) how big the block is. You can’t (reliably) access that other information - and nor should you. When you call `free(), it simply looks at the extra information to find out how big the block is. ","wordCount":"876","inLanguage":"en","image":"http://localhost:1313/images/How-do-malloc-free-work-vishal-chovatiya.png","datePublished":"2016-10-08T00:00:00Z","dateModified":"2016-10-08T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/how-do-malloc-free-work-in-c/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/trident_favicon.webp"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=http://localhost:1313/posts/ title=Latest><span>Latest</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How Do malloc & free Work in C!</h1><div class=post-meta><span title='2016-10-08 00:00:00 +0000 UTC'>October 8, 2016</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;876 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/blob/main/vishalchovatiya/content/posts/how-do-malloc-free-work-in-c.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/images/How-do-malloc-free-work-vishal-chovatiya.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#allocating-memory-on-the-heap>Allocating Memory on the Heap</a><ul><li><a href=#brk-sbrk><code>brk()</code>& `sbrk()</a></li></ul></li><li><a href=#how-does-malloc--free-work>How Does malloc & free Work?</a><ul><li><a href=#malloc>malloc</a></li><li><a href=#free>free</a></li></ul></li><li><a href=#will-malloc-allocates-contiguously-in-memory-or-it-scattered>Will malloc Allocates Contiguously in Memory or It Scattered?</a></li><li><a href=#how-does-free-know-how-much-to-free>How Does free Know How Much to Free?</a></li></ul></nav></div></details></div><div class=post-content><p>As we know, the process can allocate & deallocate memory using malloc & free in C language. But do you ever consider what happens behind the scene ? or How do malloc & free work?  Let see</p><h2 id=allocating-memory-on-the-heap>Allocating Memory on the Heap<a hidden class=anchor aria-hidden=true href=#allocating-memory-on-the-heap>#</a></h2><p><img loading=lazy src=/images/program-break-malloc-free-in-c.png#center alt="How do malloc &amp;amp; free work in C"></p><ul><li><p>A process can allocate memory by increasing the size of the heap.</p></li><li><p>Heap is a variable-size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows & shrinks as memory allocated and freed.</p></li><li><p>The current limit of the heap referred to as the program break which is just at the end of the uninitialized data segment in process address space.</p></li><li><p>Resizing the heap (i.e., allocating or de-allocating memory) is as simple as telling the kernel to adjust its idea of where the process’s program break is.</p></li><li><p>To allocate memory, <a href=/posts/how-c-program-converted-into-assembly/>C programs</a> normally use the malloc family of functions, which we describe shortly. However, we begin with a description of <code>brk()</code>& `sbrk(), upon which the malloc functions are based.</p></li><li><p><strong>Pre-requisites:</strong> <a href=/posts/how-c-program-stored-in-ram-memory/>Memory layout of C program</a> OR <a href=https://www.kernel.org/doc/gorman/html/understand/understand007.html>Understanding of process address space</a></p></li></ul><h3 id=brk-sbrk><code>brk()</code>& `sbrk()<a hidden class=anchor aria-hidden=true href=#brk-sbrk>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>brk</span><span class=p>(</span><span class=kt>void</span> <span class=n>end_data_segment</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>sbrk</span><span class=p>(</span><span class=kt>intptr_t</span> <span class=n>increment</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The <code>brk()</code>is a system call which sets the program break to the location specified by <code>end_data_segment</code>. Since virtual memory is located in units of pages, <code>end_data_segment</code> is effectively rounded up to the next page boundary.</li><li>A call to <code>sbrk()</code> adjusts the program break by adding an increment to it. On Linux, <code>sbrk()</code> is a library function implemented on top of <code>brk()</code>. On success, <code>sbrk()</code>returns the previous address of the program break. In other words, if we have increased the program break, then the return value is a pointer to the start of the newly allocated block of memory. The call <code>sbrk(0)</code> returns the current setting of the program break without changing it. This can be useful if we want to track the size of the heap, perhaps to monitor the behaviour of a memory allocation package.</li><li>After the program break increased, the program may access any address in the newly allocated area, but no physical memory pages allocated yet. The kernel automatically allocates new physical pages on the first attempt by the process to access addresses in those pages.</li></ul><h2 id=how-does-malloc--free-work>How Does malloc & free Work?<a hidden class=anchor aria-hidden=true href=#how-does-malloc--free-work>#</a></h2><h3 id=malloc>malloc<a hidden class=anchor aria-hidden=true href=#malloc>#</a></h3><ul><li>When you malloc a block, it first checks how much memory you requested.</li><li>There are 2 ways to get memory from the system: 1. <code>mmap()</code>, 2. <code>brk()</code></li><li>When you request some byte to be allocated by malloc it checks for <code>MMAP_THRESHOLD</code> limit(this also depends upon library implementations). If you request more than that limit, then <code>mmap()</code>system call used to obtain the requested memory.</li><li>Else it uses <code>brk()</code>syscall, increments the program break size & gives you a pointer to start of newly allocate contiguous block.</li><li>Whichever procedure it follows, it allocates a bit more memory than you asked for. This extra memory(also known as meta-data) used to store information such as the size of the allocated block. And a link to the next free/used a block in a chain of blocks, and sometimes some guard data(that helps the system to detect if you write past the end of your allocated block).</li><li>Also, most allocators will round-up the total size and/or the start of your part of the memory to a multiple of bytes (e.g. on a 64-bit system may align the data to a multiple of 64 bits (8 bytes) as accessing data from non-aligned addresses can be more difficult and inefficient for the processor/bus), so you may also end up with some &ldquo;padding&rdquo; (unused bytes).</li></ul><h3 id=free>free<a hidden class=anchor aria-hidden=true href=#free>#</a></h3><ul><li>As we know so far that we allocate the memory just by increasing the program&rsquo;s break.</li><li>And upon your intellect, you must be thinking that free will lower this program break.</li><li>But it&rsquo;s not, free simply adds the block of memory to list of free blocks that are recycled by future calls to <code>malloc()</code> But why?</li><li>Well, the block of memory being freed is typically somewhere in the middle of the heap, rather than at the end, so that lowering the program break is not possible.</li></ul><h2 id=will-malloc-allocates-contiguously-in-memory-or-it-scattered>Will malloc Allocates Contiguously in Memory or It Scattered?<a hidden class=anchor aria-hidden=true href=#will-malloc-allocates-contiguously-in-memory-or-it-scattered>#</a></h2><ul><li>Yes & no both, Here is why!</li><li>In a typical OS, there exists the concepts of virtual memory and physical memory.</li><li>Each process has its virtual memory range which is contiguous.</li><li>When you allocate memory through malloc, the program break increased with respect to virtual memory. So your allocated byte is contiguous.</li><li>But the OS, behind the scenes, is busy mapping virtual memory allocations onto real blocks of physical memory which do not be contiguous because this is how VMM(Virtual Memory Manager) works. You can read more about it <a href=/posts/how-does-virtual-memory-work/>here</a>.</li></ul><h2 id=how-does-free-know-how-much-to-free>How Does free Know How Much to Free?<a hidden class=anchor aria-hidden=true href=#how-does-free-know-how-much-to-free>#</a></h2><ul><li>If you still can not figure out the answer to this question, you may read the <a href=#How-do-malloc-&-free-work>above topics</a> again.</li><li>Anyway. When you call `malloc(), you specify the amount of memory to allocate. The amount of memory used is slightly more than this and includes extra information that records (at least) how big the block is.</li><li>You can&rsquo;t (reliably) access that other information - and nor should you.</li><li>When you call `free(), it simply looks at the extra information to find out how big the block is.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/brk/>Brk</a></li><li><a href=http://localhost:1313/tags/how-does-free-know-how-much-to-free/>How-Does-Free-Know-How-Much-to-Free</a></li><li><a href=http://localhost:1313/tags/program-break/>Program-Break</a></li><li><a href=http://localhost:1313/tags/sbrk/>Sbrk</a></li><li><a href=http://localhost:1313/tags/will-malloc-allocates-contiguously-in-memory-or-it-scattered/>Will-Malloc-Allocates-Contiguously-in-Memory-or-It-Scattered</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/how-does-virtual-memory-work/><span class=title>« Prev</span><br><span>How Does Virtual Memory Work?</span>
</a><a class=next href=http://localhost:1313/posts/dynamic-linking-example/><span class=title>Next »</span><br><span>Dynamic Linking Example</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How Do malloc & free Work in C! on x" href="https://x.com/intent/tweet/?text=How%20Do%20malloc%20%26%20free%20Work%20in%20C%21&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-do-malloc-free-work-in-c%2f&amp;hashtags=brk%2chow-does-free-know-how-much-to-free%2cprogram-break%2csbrk%2cwill-malloc-allocates-contiguously-in-memory-or-it-scattered"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Do malloc & free Work in C! on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-do-malloc-free-work-in-c%2f&amp;title=How%20Do%20malloc%20%26%20free%20Work%20in%20C%21&amp;summary=How%20Do%20malloc%20%26%20free%20Work%20in%20C%21&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-do-malloc-free-work-in-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Do malloc & free Work in C! on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-do-malloc-free-work-in-c%2f&title=How%20Do%20malloc%20%26%20free%20Work%20in%20C%21"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Do malloc & free Work in C! on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-do-malloc-free-work-in-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Do malloc & free Work in C! on whatsapp" href="https://api.whatsapp.com/send?text=How%20Do%20malloc%20%26%20free%20Work%20in%20C%21%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-do-malloc-free-work-in-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Do malloc & free Work in C! on telegram" href="https://telegram.me/share/url?text=How%20Do%20malloc%20%26%20free%20Work%20in%20C%21&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-do-malloc-free-work-in-c%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Do malloc & free Work in C! on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20Do%20malloc%20%26%20free%20Work%20in%20C%21&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-do-malloc-free-work-in-c%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>