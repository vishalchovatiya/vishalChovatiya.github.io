<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CRTP C++ Examples | Vishal Chovatiya</title>
<meta name=keywords content="c-crtp,c20-solution-spaceship-operator,c20-spaceship-operator-with-the-help-of-crtp,crtp-and-static-polymorphism-in-c,crtp-c,crtp-c-example,crtp-pattern,crtp-to-avoid-code-duplication,curiously-recurring-template-pattern,dynamic-polymorphism,enabling-polymorphic-copy-construction-in-c-with-crtp,enabling-polymorphic-method-chaining,limiting-object-count-with-crtp,modern-c-composite-design-pattern-leveraging-crtp,solution-till-c17-with-crtp,static-polymorphism"><meta name=description content="Curiously Recurring Template Pattern(CRTP) in C++ is definitely a powerful technique & static alternative to virtual functions. But at the same time, learning it may seem a bit weird at first. If you are like me who struggled to grasp anything in one go. Then this article might help you to provide a thought process on where CRTP fits in day-to-day coding. And, if you are an Embedded Programmer, you may run into CRTP more often."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/crtp-c-examples/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/crtp-c-examples/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="CRTP C++ Examples"><meta property="og:description" content="Curiously Recurring Template Pattern(CRTP) in C++ is definitely a powerful technique & static alternative to virtual functions. But at the same time, learning it may seem a bit weird at first. If you are like me who struggled to grasp anything in one go. Then this article might help you to provide a thought process on where CRTP fits in day-to-day coding. And, if you are an Embedded Programmer, you may run into CRTP more often."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/crtp-c-examples/"><meta property="og:image" content="https://vishalchovatiya.github.io/images/CRTP-C-Examples.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-03T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-03T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/images/CRTP-C-Examples.webp"><meta name=twitter:title content="CRTP C++ Examples"><meta name=twitter:description content="Curiously Recurring Template Pattern(CRTP) in C++ is definitely a powerful technique & static alternative to virtual functions. But at the same time, learning it may seem a bit weird at first. If you are like me who struggled to grasp anything in one go. Then this article might help you to provide a thought process on where CRTP fits in day-to-day coding. And, if you are an Embedded Programmer, you may run into CRTP more often."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"CRTP C++ Examples","item":"https://vishalchovatiya.github.io/posts/crtp-c-examples/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CRTP C++ Examples","name":"CRTP C\u002b\u002b Examples","description":"Curiously Recurring Template Pattern(CRTP) in C++ is definitely a powerful technique \u0026amp; static alternative to virtual functions. But at the same time, learning it may seem a bit weird at first. If you are like me who struggled to grasp anything in one go. Then this article might help you to provide a thought process on where CRTP fits in day-to-day coding. And, if you are an Embedded Programmer, you may run into CRTP more often.","keywords":["c-crtp","c20-solution-spaceship-operator","c20-spaceship-operator-with-the-help-of-crtp","crtp-and-static-polymorphism-in-c","crtp-c","crtp-c-example","crtp-pattern","crtp-to-avoid-code-duplication","curiously-recurring-template-pattern","dynamic-polymorphism","enabling-polymorphic-copy-construction-in-c-with-crtp","enabling-polymorphic-method-chaining","limiting-object-count-with-crtp","modern-c-composite-design-pattern-leveraging-crtp","solution-till-c17-with-crtp","static-polymorphism"],"articleBody":"Curiously Recurring Template Pattern(CRTP) in C++ is definitely a powerful technique \u0026 static alternative to virtual functions. But at the same time, learning it may seem a bit weird at first. If you are like me who struggled to grasp anything in one go. Then this article might help you to provide a thought process on where CRTP fits in day-to-day coding. And, if you are an Embedded Programmer, you may run into CRTP more often. Although, std::variant + std::visit will also help but 90% of the compilers for embedded processors are either not up to date with standard or dumb.\nThere is various material effectively accessible for “How” and “What” on CRTP. So, I won’t centre there rather address “Where” part i.e. CRTP Applicability.\nCRTP and Static Polymorphism In C++ template\u003ctypename specific_animal\u003e struct animal { void who() { static_cast\u003cspecific_animal*\u003e(this)-\u003ewho(); } }; struct dog : animal\u003cdog\u003e { void who() { cout \u003c\u003c \"dog\" \u003c\u003c endl; } }; struct cat : animal\u003ccat\u003e { void who() { cout \u003c\u003c \"cat\" \u003c\u003c endl; } }; template\u003ctypename specific_animal\u003e void who_am_i(animal\u003cspecific_animal\u003e \u0026animal) { animal.who(); } cat c; who_am_i(c); // prints `cat` dog d; who_am_i(d); // prints `dog` Curiously Recurring Template Pattern widely employed for static polymorphism without bearing the cost of virtual dispatch mechanism. Consider the above code, we haven’t used virtual keyword \u0026 still achieved the functionality of polymorphism. How it works is not the topic of this article. So, I am leaving it to you to figure out. Limiting Object Count with CRTP There are times when you have to manage the critical resource with single or predefined object count. And we have Singleton \u0026 Monotone Design Patterns for this. But this works as long as your object counts are smaller in number. When you want to limit the arbitrary type to be limited with an arbitrary number of instances. CRTP will come to rescue: template \u003cclass ToBeLimited, uint32_t maxInstance\u003e struct LimitNoOfInstances { static atomic\u003cuint32_t\u003e cnt; LimitNoOfInstances() { if (cnt \u003e= maxInstance) throw logic_error{\"Too Many Instances\"}; ++cnt; } ~LimitNoOfInstances() { --cnt; } }; // Copy, move \u0026 other sanity checks to be complete struct One : LimitNoOfInstances\u003cOne, 1\u003e {}; struct Two : LimitNoOfInstances\u003cTwo, 2\u003e {}; template \u003cclass T, uint32_t maxNoOfInstace\u003e atomic\u003cuint32_t\u003e LimitNoOfInstances\u003cT, maxNoOfInstace\u003e::cnt(0); void use_case() { Two _2_0, _2_1; try { One _1_0, _1_1; } catch (exception \u0026e) { cout \u003c\u003c e.what() \u003c\u003c endl; } } You might be wondering that what is the point of the template parameter ToBeLimited, if it isn’t used. In that case, you should have brush up your C++ Template fundamentals or use cppinsights.io. As it isn’t useless. CRTP to Avoid Code Duplication Let say you have a set of containers that support the functions begin() \u0026 end() But, the standard library’s requirements for containers require more functionalities like front(), back(), size(), etc. We can design such functionalities with a CRTP base class that provides common utilities solely based on derived class member function i.e. begin() \u0026 end()in our cases: template \u003ctypename T\u003e class Container { T \u0026actual() { return *static_cast\u003cT *\u003e(this); } T const \u0026actual() const { return *static_cast\u003cT const *\u003e(this); } public: decltype(auto) front() { return *actual().begin(); } decltype(auto) back() { return *std::prev(actual().end()); } decltype(auto) size() const { return std::distance(actual().begin(), actual().end()); } decltype(auto) operator[](size_t i) { return *std::next(actual().begin(), i); } }; The above class provides the functions front(), back(), size() and operator[ ] for any subclass that has begin() \u0026 end() For example, subclass could be a simple dynamically allocated array as: template \u003ctypename T\u003e class DynArray : public Container\u003cDynArray\u003cT\u003e\u003e { size_t m_size; unique_ptr\u003cT[]\u003e m_data; public: DynArray(size_t s) : m_size{s}, m_data{make_unique\u003cT[]\u003e(s)} {} T *begin() { return m_data.get(); } const T *begin() const { return m_data.get(); } T *end() { return m_data.get() + m_size; } const T *end() const { return m_data.get() + m_size; } }; DynArray\u003cint\u003e arr(10); arr.front() = 2; arr[2]\t= 5; asssert(arr.size() == 10); Modern C++ Composite Design Pattern Leveraging CRTP Composite Design Pattern states that we should treat the group of objects in the same manner as a single object. And to implement such pattern we can leverage the CRTP. For example, as a part of machine learning, we have to deal with Neuron which for simplicity defined as: struct Neuron { vector\u003cNeuron*\u003e in, out; // Stores the input-output connnections to other Neurons uint32_t id; Neuron() { static int id = 1; this-\u003eid = id++; } void connect_to(Neuron \u0026other) { out.push_back(\u0026other); other.in.push_back(this); } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Neuron \u0026obj) { for (Neuron *n : obj.in) os \u003c\u003c n-\u003eid \u003c\u003c \"\\t--\u003e\\t[\" \u003c\u003c obj.id \u003c\u003c \"]\" \u003c\u003c endl; for (Neuron *n : obj.out) os \u003c\u003c \"[\" \u003c\u003c obj.id \u003c\u003c \"]\\t--\u003e\\t\" \u003c\u003c n-\u003eid \u003c\u003c endl; return os; } }; Neuron n1, n2; n1.connect_to(n2); cout \u003c\u003c n1 \u003c\u003c n2 \u003c\u003c endl; /* Output [1]\t--\u003e\t2 1\t--\u003e\t[2] */ And there is also a NeuronLayer i.e. collection of Neuron which for simplicity defined as: struct NeuronLayer : vector\u003cNeuron\u003e { NeuronLayer(int count) { while (count --\u003e 0) emplace_back(Neuron{}); } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, NeuronLayer \u0026obj) { for (auto \u0026n : obj) os \u003c\u003c n; return os; } }; Now, if you want to connect the Neuron with NeuronLayer and vice-versa. You’re going to have a total of four different functions as follows: Neuron::connect_to(Neuron\u0026) Neuron::connect_to(NeuronLayer\u0026) NeuronLayer::connect_to(NeuronLayer\u0026) NeuronLayer::connect_to(Neuron\u0026) You see this is state-space explosion(permutation in layman terms) problem and it’s not good. Because we want a single function that enumerable both the layer as well as individual neurons. CRTP comes handy here as: template \u003ctypename Self\u003e struct SomeNeurons { template \u003ctypename T\u003e void connect_to(T \u0026other); }; struct Neuron : SomeNeurons\u003cNeuron\u003e { vector\u003cNeuron*\u003e in, out; uint32_t id; Neuron() { static int id = 1; this-\u003eid = id++; } Neuron* begin() { return this; } Neuron* end() { return this + 1; } }; struct NeuronLayer : vector\u003cNeuron\u003e, SomeNeurons\u003cNeuronLayer\u003e { NeuronLayer(int count) { while (count-- \u003e 0) emplace_back(Neuron{}); } }; /* ----------------------------------------------------------------------- */ template \u003ctypename Self\u003e template \u003ctypename T\u003e void SomeNeurons\u003cSelf\u003e::connect_to(T \u0026other) { for (Neuron \u0026from : *static_cast\u003cSelf *\u003e(this)) { for (Neuron \u0026to : other) { from.out.push_back(\u0026to); to.in.push_back(\u0026from); } } } /* ----------------------------------------------------------------------- */ template \u003ctypename Self\u003e ostream \u0026operator\u003c\u003c(ostream \u0026os, SomeNeurons\u003cSelf\u003e \u0026object) { for (Neuron \u0026obj : *static_cast\u003cSelf *\u003e(\u0026object)) { for (Neuron *n : obj.in) os \u003c\u003c n-\u003eid \u003c\u003c \"\\t--\u003e\\t[\" \u003c\u003c obj.id \u003c\u003c \"]\" \u003c\u003c endl; for (Neuron *n : obj.out) os \u003c\u003c \"[\" \u003c\u003c obj.id \u003c\u003c \"]\\t--\u003e\\t\" \u003c\u003c n-\u003eid \u003c\u003c endl; } return os; } int main() { Neuron n1, n2; NeuronLayer l1{1}, l2{2}; n1.connect_to(l1); // Scenario 1: Neuron connects to Layer l2.connect_to(n2); // Scenario 2: Layer connects to Neuron l1.connect_to(l2); // Scenario 3: Layer connects to Layer n1.connect_to(n2); // Scenario 4: Neuron connects to Neuron cout \u003c\u003c \"Neuron \" \u003c\u003c n1.id \u003c\u003c endl \u003c\u003c n1 \u003c\u003c endl; cout \u003c\u003c \"Neuron \" \u003c\u003c n2.id \u003c\u003c endl \u003c\u003c n2 \u003c\u003c endl; cout \u003c\u003c \"Layer \" \u003c\u003c endl \u003c\u003c l1 \u003c\u003c endl; cout \u003c\u003c \"Layer \" \u003c\u003c endl \u003c\u003c l2 \u003c\u003c endl; return EXIT_SUCCESS; } /* Output Neuron 1 [1] --\u003e 3 [1] --\u003e 2 Neuron 2 4 --\u003e [2] 5 --\u003e [2] 1 --\u003e [2] Layer 1 --\u003e [3] [3] --\u003e 4 [3] --\u003e 5 Layer 3 --\u003e [4] [4] --\u003e 2 3 --\u003e [5] [5] --\u003e 2 */ As you can see we have covered all four different permutation scenarios using a single SomeNeurons::connect_to method. And both Neuron \u0026 NeuronLayer conforms to this interface via self templatization. C++20 Spaceship Operator With the Help of CRTP Problem struct obj_type_1 { bool operator\u003c(const value \u0026rhs) const { return m_x \u003c rhs.m_x; } // bool operator==(const value \u0026rhs) const; // bool operator!=(const value \u0026rhs) const; // List goes on. . . . . . . . . . . . . . . . . . . . private: // data members to compare }; struct obj_type_2 { bool operator\u003c(const value \u0026rhs) const { return m_x \u003c rhs.m_x; } // bool operator==(const value \u0026rhs) const; // bool operator!=(const value \u0026rhs) const; // List goes on. . . . . . . . . . . . . . . . . . . . private: // data members to compare }; struct obj_type_3 { ... struct obj_type_4 { ... // List goes on. . . . . . . . . . . . . . . . . . . . For each comparable objects, you need to define respective comparison operators. This is redundant because if we have an operator \u003c , we can overload other operators on the basis of it. Thus, operator \u003c is the only one operator having type information, other operators can be made type independent for reusability purpose. Solution till C++17 with CRTP template \u003cclass derived\u003e struct compare {}; struct value : compare\u003cvalue\u003e { int m_x; value(int x) : m_x(x) {} bool operator \u003c (const value \u0026rhs) const { return m_x \u003c rhs.m_x; } }; template \u003cclass derived\u003e bool operator \u003e (const compare\u003cderived\u003e \u0026lhs, const compare\u003cderived\u003e \u0026rhs) { // static_assert(std::is_base_of_v","wordCount":"2366","inLanguage":"en","image":"https://vishalchovatiya.github.io/images/CRTP-C-Examples.webp","datePublished":"2020-07-03T00:00:00Z","dateModified":"2020-07-03T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/crtp-c-examples/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">CRTP C++ Examples</h1><div class=post-meta><span title='2020-07-03 00:00:00 +0000 UTC'>July 3, 2020</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2366 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/crtp-c-examples.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://vishalchovatiya.github.io/images/CRTP-C-Examples.webp alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#crtp-and-static-polymorphism-in-c>CRTP and Static Polymorphism In C++</a></li><li><a href=#limiting-object-count-with-crtp>Limiting Object Count with CRTP</a></li><li><a href=#crtp-to-avoid-code-duplication>CRTP to Avoid Code Duplication</a></li><li><a href=#modern-c-composite-design-pattern-leveraging-crtp>Modern C++ Composite Design Pattern Leveraging CRTP</a></li><li><a href=#c20-spaceship-operator-with-the-help-of-crtp>C++20 Spaceship Operator With the Help of CRTP</a><ul><li><a href=#problem><strong>Problem</strong></a></li><li><a href=#solution-till-c17-with-crtp>Solution till C++17 with CRTP</a></li><li><a href=#c20-solution--spaceship-operator>C++20 Solution : Spaceship Operator</a></li></ul></li><li><a href=#enabling-polymorphic-method-chaining>Enabling Polymorphic Method Chaining</a></li><li><a href=#enabling-polymorphic-copy-construction-in-c-with-crtp>Enabling Polymorphic Copy Construction in C++ with CRTP</a><ul><li><a href=#problem-1>Problem</a></li><li><a href=#solution-1--dynamic-polymorphism>Solution 1 : Dynamic Polymorphism</a></li><li><a href=#solution-2--static-polymorphism>Solution 2 : Static Polymorphism</a></li></ul></li><li><a href=#wrap-up>Wrap-Up</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>Curiously Recurring Template Pattern(CRTP) in C++ is definitely a powerful technique & static alternative to virtual functions. But at the same time, learning it may seem a bit weird at first. If you are like me who struggled to grasp anything in one go. Then this article might help you to provide a thought process on where CRTP fits in day-to-day coding. And, if you are an Embedded Programmer, you may run into CRTP more often. Although, <code>std::variant</code> + <code>std::visit</code> will also help but 90% of the compilers for embedded processors are either not up to date with standard or dumb.</p><p>There is various material effectively accessible for &ldquo;How&rdquo; and &ldquo;What&rdquo; on CRTP. So, I won&rsquo;t centre there rather address &ldquo;Where&rdquo; part i.e. CRTP Applicability.</p><h2 id=crtp-and-static-polymorphism-in-c>CRTP and Static Polymorphism In C++<a hidden class=anchor aria-hidden=true href=#crtp-and-static-polymorphism-in-c>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>specific_animal</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>who</span><span class=p>()</span> <span class=p>{</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>specific_animal</span><span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>who</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>dog</span> <span class=o>:</span> <span class=n>animal</span><span class=o>&lt;</span><span class=n>dog</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>who</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;dog&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>cat</span> <span class=o>:</span> <span class=n>animal</span><span class=o>&lt;</span><span class=n>cat</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>who</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;cat&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>specific_animal</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>who_am_i</span><span class=p>(</span><span class=n>animal</span><span class=o>&lt;</span><span class=n>specific_animal</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>animal</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>animal</span><span class=p>.</span><span class=n>who</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cat</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>who_am_i</span><span class=p>(</span><span class=n>c</span><span class=p>);</span> <span class=c1>// prints `cat`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>dog</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>who_am_i</span><span class=p>(</span><span class=n>d</span><span class=p>);</span> <span class=c1>// prints `dog`
</span></span></span></code></pre></div><ul><li><strong><em>Curiously Recurring Template Pattern widely employed for static polymorphism</em></strong> without bearing the cost of virtual dispatch mechanism. Consider the above code, we haven&rsquo;t used virtual keyword & still achieved the functionality of polymorphism.</li><li>How it works is not the topic of this article. So, I am leaving it to you to figure out.</li></ul><h2 id=limiting-object-count-with-crtp>Limiting Object Count with CRTP<a hidden class=anchor aria-hidden=true href=#limiting-object-count-with-crtp>#</a></h2><ul><li>There are times when you have to manage the critical resource with single or predefined object count. And we have <a href=/posts/singleton-design-pattern-in-modern-cpp/>Singleton & Monotone Design Patterns</a> for this. But this works as long as your object counts are smaller in number.</li><li><strong><em>When you want to limit the arbitrary type to be limited with an arbitrary number of instances</em></strong>. CRTP will come to rescue:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ToBeLimited</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>maxInstance</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>LimitNoOfInstances</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=n>atomic</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>LimitNoOfInstances</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>cnt</span> <span class=o>&gt;=</span> <span class=n>maxInstance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>throw</span> <span class=n>logic_error</span><span class=p>{</span><span class=s>&#34;Too Many Instances&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>		<span class=o>++</span><span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>LimitNoOfInstances</span><span class=p>()</span> <span class=p>{</span> <span class=o>--</span><span class=n>cnt</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span> <span class=c1>// Copy, move &amp; other sanity checks to be complete
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>One</span> <span class=o>:</span> <span class=n>LimitNoOfInstances</span><span class=o>&lt;</span><span class=n>One</span><span class=p>,</span> <span class=mi>1</span><span class=o>&gt;</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Two</span> <span class=o>:</span> <span class=n>LimitNoOfInstances</span><span class=o>&lt;</span><span class=n>Two</span><span class=p>,</span> <span class=mi>2</span><span class=o>&gt;</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>maxNoOfInstace</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>LimitNoOfInstances</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>maxNoOfInstace</span><span class=o>&gt;::</span><span class=n>cnt</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>use_case</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Two</span> <span class=n>_2_0</span><span class=p>,</span> <span class=n>_2_1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>One</span> <span class=n>_1_0</span><span class=p>,</span> <span class=n>_1_1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>exception</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>You might be wondering that what is the point of the template parameter <code>ToBeLimited</code>, if it isn&rsquo;t used. In that case, you should have brush up your <a href=/posts/c-template-a-quick-uptodate-look/>C++ Template</a> fundamentals or use <a href=https://cppinsights.io/>cppinsights.io</a>. As it isn&rsquo;t useless.</li></ul><h2 id=crtp-to-avoid-code-duplication>CRTP to Avoid Code Duplication<a hidden class=anchor aria-hidden=true href=#crtp-to-avoid-code-duplication>#</a></h2><ul><li>Let say you have a set of containers that support the functions <code>begin()</code> & <code>end()</code> But, the standard library&rsquo;s requirements for containers require more functionalities like <code>front()</code>, <code>back()</code>, <code>size()</code>, etc.</li><li>We can design such functionalities with a <strong><em>CRTP base class that provides common utilities solely based on derived class member function</em></strong> i.e. <code>begin()</code> & <code>end()</code>in our cases:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>&amp;</span><span class=n>actual</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span> <span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>actual</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span> <span class=k>const</span> <span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>decltype</span><span class=p>(</span><span class=k>auto</span><span class=p>)</span> <span class=n>front</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=nf>actual</span><span class=p>().</span><span class=n>begin</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>decltype</span><span class=p>(</span><span class=k>auto</span><span class=p>)</span> <span class=n>back</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=n>std</span><span class=o>::</span><span class=n>prev</span><span class=p>(</span><span class=n>actual</span><span class=p>().</span><span class=n>end</span><span class=p>());</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>decltype</span><span class=p>(</span><span class=k>auto</span><span class=p>)</span> <span class=n>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>distance</span><span class=p>(</span><span class=n>actual</span><span class=p>().</span><span class=n>begin</span><span class=p>(),</span> <span class=n>actual</span><span class=p>().</span><span class=n>end</span><span class=p>());</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>decltype</span><span class=p>(</span><span class=k>auto</span><span class=p>)</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=n>std</span><span class=o>::</span><span class=n>next</span><span class=p>(</span><span class=n>actual</span><span class=p>().</span><span class=n>begin</span><span class=p>(),</span> <span class=n>i</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>The above class provides the functions <code>front()</code>, <code>back()</code>, <code>size()</code> and <code>operator[ ]</code> for any subclass that has <code>begin()</code> & <code>end()</code></li><li>For example, subclass could be a simple dynamically allocated array as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DynArray</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Container</span><span class=o>&lt;</span><span class=n>DynArray</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>m_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=p>[]</span><span class=o>&gt;</span> <span class=n>m_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>DynArray</span><span class=p>(</span><span class=n>size_t</span> <span class=n>s</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_size</span><span class=p>{</span><span class=n>s</span><span class=p>},</span> <span class=n>m_data</span><span class=p>{</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>T</span><span class=p>[]</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span><span class=p>)}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=o>*</span><span class=nf>begin</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_data</span><span class=p>.</span><span class=n>get</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>T</span> <span class=o>*</span><span class=nf>begin</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_data</span><span class=p>.</span><span class=n>get</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=o>*</span><span class=nf>end</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_data</span><span class=p>.</span><span class=n>get</span><span class=p>()</span> <span class=o>+</span> <span class=n>m_size</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>T</span> <span class=o>*</span><span class=nf>end</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_data</span><span class=p>.</span><span class=n>get</span><span class=p>()</span> <span class=o>+</span> <span class=n>m_size</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DynArray</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>arr</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>arr</span><span class=p>.</span><span class=n>front</span><span class=p>()</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>arr</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>		<span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>asssert</span><span class=p>(</span><span class=n>arr</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>10</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=modern-c-composite-design-pattern-leveraging-crtp>Modern C++ Composite Design Pattern Leveraging CRTP<a hidden class=anchor aria-hidden=true href=#modern-c-composite-design-pattern-leveraging-crtp>#</a></h2><ul><li><a href=/posts/composite-design-pattern-in-modern-cpp/>Composite Design Pattern</a> states that we should <strong><em>treat the group of objects in the same manner as a single object</em></strong>. And to implement such pattern we can leverage the CRTP.</li><li>For example, as a part of machine learning, we have to deal with <code>Neuron</code> which for simplicity defined as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Neuron</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>Neuron</span><span class=o>*&gt;</span>     <span class=n>in</span><span class=p>,</span> <span class=n>out</span><span class=p>;</span>    <span class=c1>// Stores the input-output connnections to other Neurons
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span>            <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Neuron</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>int</span> <span class=n>id</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>connect_to</span><span class=p>(</span><span class=n>Neuron</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>out</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=o>&amp;</span><span class=n>other</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>other</span><span class=p>.</span><span class=n>in</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>ostream</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Neuron</span> <span class=o>&amp;</span><span class=n>obj</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Neuron</span> <span class=o>*</span><span class=nl>n</span> <span class=p>:</span> <span class=n>obj</span><span class=p>.</span><span class=n>in</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\t</span><span class=s>--&gt;</span><span class=se>\t</span><span class=s>[&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>obj</span><span class=p>.</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;]&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Neuron</span> <span class=o>*</span><span class=nl>n</span> <span class=p>:</span> <span class=n>obj</span><span class=p>.</span><span class=n>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;[&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>obj</span><span class=p>.</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;]</span><span class=se>\t</span><span class=s>--&gt;</span><span class=se>\t</span><span class=s>&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Neuron</span> <span class=n>n1</span><span class=p>,</span> <span class=n>n2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>n1</span><span class=p>.</span><span class=n>connect_to</span><span class=p>(</span><span class=n>n2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>n1</span> <span class=o>&lt;&lt;</span> <span class=n>n2</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Output
</span></span></span><span class=line><span class=cl><span class=cm>[1]	--&gt;	2
</span></span></span><span class=line><span class=cl><span class=cm>1	--&gt;	[2]
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><ul><li>And there is also a <code>NeuronLayer</code> i.e. collection of <code>Neuron</code> which for simplicity defined as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>NeuronLayer</span> <span class=o>:</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Neuron</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NeuronLayer</span><span class=p>(</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>--&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>emplace_back</span><span class=p>(</span><span class=n>Neuron</span><span class=p>{});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>ostream</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>os</span><span class=p>,</span> <span class=n>NeuronLayer</span> <span class=o>&amp;</span><span class=n>obj</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>n</span> <span class=p>:</span> <span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>Now, if you want to connect the <code>Neuron</code> with <code>NeuronLayer</code> and vice-versa. You&rsquo;re going to have a total of four different functions as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Neuron</span><span class=o>::</span><span class=n>connect_to</span><span class=p>(</span><span class=n>Neuron</span><span class=o>&amp;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Neuron</span><span class=o>::</span><span class=n>connect_to</span><span class=p>(</span><span class=n>NeuronLayer</span><span class=o>&amp;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>NeuronLayer</span><span class=o>::</span><span class=n>connect_to</span><span class=p>(</span><span class=n>NeuronLayer</span><span class=o>&amp;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>NeuronLayer</span><span class=o>::</span><span class=n>connect_to</span><span class=p>(</span><span class=n>Neuron</span><span class=o>&amp;</span><span class=p>)</span>
</span></span></code></pre></div><ul><li>You see this is state-space explosion(permutation in layman terms) problem and it&rsquo;s not good. Because we want a single function that enumerable both the layer as well as individual neurons. CRTP comes handy here as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Self</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>SomeNeurons</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>connect_to</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Neuron</span> <span class=o>:</span> <span class=n>SomeNeurons</span><span class=o>&lt;</span><span class=n>Neuron</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>Neuron</span><span class=o>*&gt;</span>     <span class=n>in</span><span class=p>,</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span>            <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Neuron</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>int</span> <span class=n>id</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Neuron</span><span class=o>*</span> <span class=nf>begin</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=k>this</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Neuron</span><span class=o>*</span> <span class=nf>end</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=k>this</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>NeuronLayer</span> <span class=o>:</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Neuron</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>SomeNeurons</span><span class=o>&lt;</span><span class=n>NeuronLayer</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NeuronLayer</span><span class=p>(</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>count</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>emplace_back</span><span class=p>(</span><span class=n>Neuron</span><span class=p>{});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* ----------------------------------------------------------------------- */</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Self</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SomeNeurons</span><span class=o>&lt;</span><span class=n>Self</span><span class=o>&gt;::</span><span class=n>connect_to</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>Neuron</span> <span class=o>&amp;</span><span class=nl>from</span> <span class=p>:</span> <span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Self</span> <span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Neuron</span> <span class=o>&amp;</span><span class=nl>to</span> <span class=p>:</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>from</span><span class=p>.</span><span class=n>out</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=o>&amp;</span><span class=n>to</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>to</span><span class=p>.</span><span class=n>in</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=o>&amp;</span><span class=n>from</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* ----------------------------------------------------------------------- */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Self</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>ostream</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>os</span><span class=p>,</span> <span class=n>SomeNeurons</span><span class=o>&lt;</span><span class=n>Self</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>object</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>Neuron</span> <span class=o>&amp;</span><span class=nl>obj</span> <span class=p>:</span> <span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Self</span> <span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>object</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Neuron</span> <span class=o>*</span><span class=nl>n</span> <span class=p>:</span> <span class=n>obj</span><span class=p>.</span><span class=n>in</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\t</span><span class=s>--&gt;</span><span class=se>\t</span><span class=s>[&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>obj</span><span class=p>.</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;]&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Neuron</span> <span class=o>*</span><span class=nl>n</span> <span class=p>:</span> <span class=n>obj</span><span class=p>.</span><span class=n>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;[&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>obj</span><span class=p>.</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;]</span><span class=se>\t</span><span class=s>--&gt;</span><span class=se>\t</span><span class=s>&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Neuron</span> <span class=n>n1</span><span class=p>,</span> <span class=n>n2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NeuronLayer</span> <span class=n>l1</span><span class=p>{</span><span class=mi>1</span><span class=p>},</span> <span class=n>l2</span><span class=p>{</span><span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>n1</span><span class=p>.</span><span class=n>connect_to</span><span class=p>(</span><span class=n>l1</span><span class=p>);</span> <span class=c1>// Scenario 1: Neuron connects to Layer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>l2</span><span class=p>.</span><span class=n>connect_to</span><span class=p>(</span><span class=n>n2</span><span class=p>);</span> <span class=c1>// Scenario 2: Layer connects to Neuron
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>l1</span><span class=p>.</span><span class=n>connect_to</span><span class=p>(</span><span class=n>l2</span><span class=p>);</span> <span class=c1>// Scenario 3: Layer connects to Layer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>n1</span><span class=p>.</span><span class=n>connect_to</span><span class=p>(</span><span class=n>n2</span><span class=p>);</span> <span class=c1>// Scenario 4: Neuron connects to Neuron
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Neuron &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n1</span><span class=p>.</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>n1</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Neuron &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n2</span><span class=p>.</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>n2</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Layer &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>l1</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Layer &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>l2</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* Output
</span></span></span><span class=line><span class=cl><span class=cm>Neuron 1
</span></span></span><span class=line><span class=cl><span class=cm>[1]    --&gt;    3
</span></span></span><span class=line><span class=cl><span class=cm>[1]    --&gt;    2
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>Neuron 2
</span></span></span><span class=line><span class=cl><span class=cm>4    --&gt;    [2]
</span></span></span><span class=line><span class=cl><span class=cm>5    --&gt;    [2]
</span></span></span><span class=line><span class=cl><span class=cm>1    --&gt;    [2]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>Layer 
</span></span></span><span class=line><span class=cl><span class=cm>1    --&gt;    [3]
</span></span></span><span class=line><span class=cl><span class=cm>[3]    --&gt;    4
</span></span></span><span class=line><span class=cl><span class=cm>[3]    --&gt;    5
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>Layer 
</span></span></span><span class=line><span class=cl><span class=cm>3    --&gt;    [4]
</span></span></span><span class=line><span class=cl><span class=cm>[4]    --&gt;    2
</span></span></span><span class=line><span class=cl><span class=cm>3    --&gt;    [5]
</span></span></span><span class=line><span class=cl><span class=cm>[5]    --&gt;    2
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><ul><li>As you can see we have covered all four different permutation scenarios using a single <code>SomeNeurons::connect_to</code> method. And both <code>Neuron</code> & <code>NeuronLayer</code> conforms to this interface via self templatization.</li></ul><h2 id=c20-spaceship-operator-with-the-help-of-crtp>C++20 Spaceship Operator With the Help of CRTP<a hidden class=anchor aria-hidden=true href=#c20-spaceship-operator-with-the-help-of-crtp>#</a></h2><h3 id=problem><strong>Problem</strong><a hidden class=anchor aria-hidden=true href=#problem>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>obj_type_1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=n>value</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_x</span> <span class=o>&lt;</span> <span class=n>rhs</span><span class=p>.</span><span class=n>m_x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// bool operator==(const value &amp;rhs) const;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// bool operator!=(const value &amp;rhs) const;    
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// List goes on. . . . . . . . . . . . . . . . . . . .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// data members to compare
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>obj_type_2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=n>value</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_x</span> <span class=o>&lt;</span> <span class=n>rhs</span><span class=p>.</span><span class=n>m_x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// bool operator==(const value &amp;rhs) const;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// bool operator!=(const value &amp;rhs) const;    
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// List goes on. . . . . . . . . . . . . . . . . . . .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// data members to compare
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>obj_type_3</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>obj_type_4</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// List goes on. . . . . . . . . . . . . . . . . . . .
</span></span></span></code></pre></div><ul><li>For each comparable objects, you need to define respective comparison operators. This is redundant because if we have an <code>operator &lt;</code> , we can overload other operators on the basis of it.</li><li>Thus, <code>operator &lt;</code> is the only one operator having type information, other operators can be made type independent for <strong><em>reusability purpose</em></strong>.</li></ul><h3 id=solution-till-c17-with-crtp>Solution till C++17 with CRTP<a hidden class=anchor aria-hidden=true href=#solution-till-c17-with-crtp>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>derived</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>compare</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>value</span> <span class=o>:</span> <span class=n>compare</span><span class=o>&lt;</span><span class=n>value</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>m_x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>value</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_x</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span> <span class=o>&lt;</span> <span class=p>(</span><span class=k>const</span> <span class=n>value</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_x</span> <span class=o>&lt;</span> <span class=n>rhs</span><span class=p>.</span><span class=n>m_x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>derived</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=k>operator</span> <span class=o>&gt;</span> <span class=p>(</span><span class=k>const</span> <span class=n>compare</span><span class=o>&lt;</span><span class=n>derived</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>compare</span><span class=o>&lt;</span><span class=n>derived</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// static_assert(std::is_base_of_v&lt;compare&lt;derived&gt;, derived&gt;); // Compile time safety measures
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>derived</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>rhs</span><span class=p>)</span> <span class=o>&lt;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>derived</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>lhs</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*  Same goes with other operators
</span></span></span><span class=line><span class=cl><span class=cm>    == :: returns !(lhs &lt; rhs) and !(rhs &lt; lhs)
</span></span></span><span class=line><span class=cl><span class=cm>    != :: returns !(lhs == rhs)
</span></span></span><span class=line><span class=cl><span class=cm>    &gt;= :: returns (rhs &lt; lhs) or (rhs == lhs)
</span></span></span><span class=line><span class=cl><span class=cm>    &lt;= :: returns (lhs &lt; rhs) or (rhs == lhs) 
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>   
</span></span><span class=line><span class=cl>    <span class=n>value</span> <span class=n>v1</span><span class=p>{</span><span class=mi>5</span><span class=p>},</span> <span class=n>v2</span><span class=p>{</span><span class=mi>10</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>boolalpha</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;v1 &gt; v2: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>v1</span> <span class=o>&gt;</span> <span class=n>v2</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Now no need to write comparator operators for all the classes, 
</span></span></span><span class=line><span class=cl><span class=c1>// Write only type dependent `operator &lt;` &amp; inherit with `compare&lt;T&gt;`
</span></span></span></code></pre></div><h3 id=c20-solution--spaceship-operator>C++20 Solution : Spaceship Operator<a hidden class=anchor aria-hidden=true href=#c20-solution--spaceship-operator>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>value</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>m_x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>value</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_x</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>operator</span><span class=o>&lt;=&gt;</span><span class=p>(</span><span class=k>const</span> <span class=n>value</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// Defaulted equality comparisons
</span></span></span><span class=line><span class=cl><span class=c1>// More Info: https://en.cppreference.com/w/cpp/language/default_comparisons
</span></span></span></code></pre></div><h2 id=enabling-polymorphic-method-chaining>Enabling Polymorphic Method Chaining<a hidden class=anchor aria-hidden=true href=#enabling-polymorphic-method-chaining>#</a></h2><ul><li><em>Method Chaining</em> is a common syntax for invoking multiple methods on a single object back to back. That too, in a single statement without requiring variables to store the intermediate results. For example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Printer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ostream</span> <span class=o>&amp;</span><span class=n>m_stream</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Printer</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_stream</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Printer</span> <span class=o>&amp;</span><span class=n>print</span><span class=p>(</span><span class=k>auto</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>m_stream</span> <span class=o>&lt;&lt;</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Printer</span> <span class=o>&amp;</span><span class=n>println</span><span class=p>(</span><span class=k>auto</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>m_stream</span> <span class=o>&lt;&lt;</span> <span class=n>t</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Printer</span><span class=p>{</span><span class=n>cout</span><span class=p>}.</span><span class=n>println</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>).</span><span class=n>println</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>     <span class=c1>// Method Chaining
</span></span></span></code></pre></div><ul><li>But, when method chaining applied to an object hierarchy, things can go wrong. For example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ColorPrinter</span> <span class=o>:</span> <span class=n>Printer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=nc>Color</span><span class=p>{</span><span class=n>red</span><span class=p>,</span> <span class=n>blue</span><span class=p>,</span> <span class=n>green</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>ColorPrinter</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span> <span class=o>:</span> <span class=n>Printer</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ColorPrinter</span> <span class=o>&amp;</span><span class=n>SetConsoleColor</span><span class=p>(</span><span class=n>Color</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ColorPrinter</span><span class=p>(</span><span class=n>cout</span><span class=p>).</span><span class=n>print</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>).</span><span class=n>SetConsoleColor</span><span class=p>(</span><span class=n>ColorPrinter</span><span class=o>::</span><span class=n>Color</span><span class=o>::</span><span class=n>red</span><span class=p>).</span><span class=n>println</span><span class=p>(</span><span class=s>&#34;Printer!&#34;</span><span class=p>);</span> <span class=c1>// Not OK
</span></span></span></code></pre></div><ul><li>Compiling above code prompt you with the following error:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>error: <span class=s1>&#39;class Printer&#39;</span> has no member named <span class=s1>&#39;SetConsoleColor&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ColorPrinter<span class=o>(</span>cout<span class=o>)</span>.print<span class=o>(</span><span class=s2>&#34;Hello&#34;</span><span class=o>)</span>.SetConsoleColor<span class=o>(</span>ColorPrinter::Color::red<span class=o>)</span>.println<span class=o>(</span><span class=s2>&#34;Printer!&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                                  ^
</span></span><span class=line><span class=cl>                                  <span class=p>|</span>____________ We have a <span class=s1>&#39;Printer&#39;</span> here, not a <span class=s1>&#39;ColorPrinter&#39;</span>
</span></span></code></pre></div><ul><li>This happens because we &ldquo;lose&rdquo; the concrete class as soon as we invoke a function of the base class.</li><li>The CRTP can be useful to avoid such problem and to enable Polymorphic Method Chaining.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ConcretePrinter</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Printer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ostream</span> <span class=o>&amp;</span><span class=n>m_stream</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Printer</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_stream</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ConcretePrinter</span> <span class=o>&amp;</span><span class=n>print</span><span class=p>(</span><span class=k>auto</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>m_stream</span> <span class=o>&lt;&lt;</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>ConcretePrinter</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ConcretePrinter</span> <span class=o>&amp;</span><span class=n>println</span><span class=p>(</span><span class=k>auto</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>m_stream</span> <span class=o>&lt;&lt;</span> <span class=n>t</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>ConcretePrinter</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ColorPrinter</span> <span class=o>:</span> <span class=n>Printer</span><span class=o>&lt;</span><span class=n>ColorPrinter</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span> <span class=n>red</span><span class=p>,</span> <span class=n>blue</span><span class=p>,</span> <span class=n>green</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>ColorPrinter</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span> <span class=o>:</span> <span class=n>Printer</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ColorPrinter</span> <span class=o>&amp;</span><span class=n>SetConsoleColor</span><span class=p>(</span><span class=n>Color</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ColorPrinter</span><span class=p>(</span><span class=n>cout</span><span class=p>).</span><span class=n>print</span><span class=p>(</span><span class=s>&#34;Hello &#34;</span><span class=p>).</span><span class=n>SetConsoleColor</span><span class=p>(</span><span class=n>ColorPrinter</span><span class=o>::</span><span class=n>Color</span><span class=o>::</span><span class=n>red</span><span class=p>).</span><span class=n>println</span><span class=p>(</span><span class=s>&#34;Printer!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=enabling-polymorphic-copy-construction-in-c-with-crtp>Enabling Polymorphic Copy Construction in C++ with CRTP<a hidden class=anchor aria-hidden=true href=#enabling-polymorphic-copy-construction-in-c-with-crtp>#</a></h2><h3 id=problem-1>Problem<a hidden class=anchor aria-hidden=true href=#problem-1>#</a></h3><ul><li>C++ has the support of polymorphic object destruction using it’s base class’s <a href=/posts/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/>virtual destructor</a>. But, equivalent support for creation and copying of objects is missing as С++ doesn’t support virtual constructor/<a href=/posts/all-about-copy-constructor-in-cpp-with-example/>copy-constructors</a>.</li><li>Moreover, you can’t create an object unless you know its static type, because the compiler must know the amount of space it needs to allocate. For the same reason, copy of an object also requires its type to known at compile-time.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal</span> <span class=p>{</span>  <span class=k>virtual</span> <span class=o>~</span><span class=n>animal</span><span class=p>(){</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~animal</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>dog</span> <span class=o>:</span> <span class=n>animal</span>  <span class=p>{</span> <span class=o>~</span><span class=n>dog</span><span class=p>(){</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~dog</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>cat</span> <span class=o>:</span> <span class=n>animal</span>  <span class=p>{</span> <span class=o>~</span><span class=n>cat</span><span class=p>(){</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~cat</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>who_am_i</span><span class=p>(</span><span class=n>animal</span> <span class=o>*</span><span class=n>who</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// not sure whether `dog` would be passed here or `cat`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// How to `copy` object of the same type i.e. pointed by who?
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>who</span><span class=p>;</span> <span class=c1>// you can delete object pointed by who
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=solution-1--dynamic-polymorphism>Solution 1 : Dynamic Polymorphism<a hidden class=anchor aria-hidden=true href=#solution-1--dynamic-polymorphism>#</a></h3><ul><li>As the name suggests, we will use virtual methods to delegate the act of copying(and/or creation) of the object as below:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>clone</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>dog</span> <span class=o>:</span> <span class=n>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>clone</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=k>return</span> <span class=n>make_unique</span><span class=o>&lt;</span><span class=n>dog</span><span class=o>&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>cat</span> <span class=o>:</span> <span class=n>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>clone</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=k>return</span> <span class=n>make_unique</span><span class=o>&lt;</span><span class=n>cat</span><span class=o>&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>who_am_i</span><span class=p>(</span><span class=n>animal</span> <span class=o>*</span><span class=n>who</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>duplicate_who</span> <span class=o>=</span> <span class=n>who</span><span class=o>-&gt;</span><span class=n>clone</span><span class=p>();</span> <span class=c1>// `copy` object of same type i.e. pointed by who ?    
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=solution-2--static-polymorphism>Solution 2 : Static Polymorphism<a hidden class=anchor aria-hidden=true href=#solution-2--static-polymorphism>#</a></h3><ul><li>Same thing can be accomplished with CRTP as below:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>specific</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>clone</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>make_unique</span><span class=o>&lt;</span><span class=n>specific</span><span class=o>&gt;</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>specific</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span> <span class=c1>// Forcing animal class to be inherited
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>animal</span><span class=p>(</span><span class=k>const</span> <span class=n>animal</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>dog</span> <span class=o>:</span> <span class=n>animal</span><span class=o>&lt;</span><span class=n>dog</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>dog</span><span class=p>(</span><span class=k>const</span> <span class=n>dog</span> <span class=o>&amp;</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;copied dog&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>cat</span> <span class=o>:</span> <span class=n>animal</span><span class=o>&lt;</span><span class=n>cat</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cat</span><span class=p>(</span><span class=k>const</span> <span class=n>cat</span> <span class=o>&amp;</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;copied cat&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>specific</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>who_am_i</span><span class=p>(</span><span class=n>animal</span><span class=o>&lt;</span><span class=n>specific</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>who</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>duplicate_who</span> <span class=o>=</span> <span class=n>who</span><span class=o>-&gt;</span><span class=n>clone</span><span class=p>();</span> <span class=c1>// `copy` object of same type i.e. pointed by who ?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=wrap-up>Wrap-Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>Everything comes with its own price. And CRTP is no exception. For example, if you are using CRTP with run time object creation, your code may behave weird. Moreover,</p><ul><li>As the base class is templated, you can not point derived class object with the base class pointer.</li><li>Also, you can not create generic container like <code>std::vector&lt;animal*></code> because <code>animal</code> is not a class, but a template needing specialization. A container defined as <code>std::vector&lt;animal&lt;dog>*></code> can only store <code>dog</code>s, not <code>cat</code>s. This is because each of the classes derived from the CRTP base class <code>animal</code> is a unique type. A common solution to this problem is to add one more layer of indirection i.e. abstract class with a virtual destructor, like the <code>abstract_animal</code> & inherit <code>animal</code> class, allowing for the creation of a <code>std::vector&lt;`abstract_animal`*></code>.</li></ul><p>There are other useful application of CRTP as well. If you think I am missing any major one & have any suggestion you can always reach me <a href=/posts/contact-2/>here</a>.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://www.wikiwand.com/en/Curiously_recurring_template_pattern>wikipedia</a></li><li><a href=https://books.goalkicker.com/CPlusPlusBook/>C++ Notes for Professionals Stack Overflow Documentation</a></li><li><a href=/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/>Advanced C++ Concepts</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/c-crtp/>C-Crtp</a></li><li><a href=https://vishalchovatiya.github.io/tags/c20-solution-spaceship-operator/>C20-Solution-Spaceship-Operator</a></li><li><a href=https://vishalchovatiya.github.io/tags/c20-spaceship-operator-with-the-help-of-crtp/>C20-Spaceship-Operator-With-the-Help-of-Crtp</a></li><li><a href=https://vishalchovatiya.github.io/tags/crtp-and-static-polymorphism-in-c/>Crtp-and-Static-Polymorphism-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/crtp-c/>Crtp-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/crtp-c-example/>Crtp-C-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/crtp-pattern/>Crtp-Pattern</a></li><li><a href=https://vishalchovatiya.github.io/tags/crtp-to-avoid-code-duplication/>Crtp-to-Avoid-Code-Duplication</a></li><li><a href=https://vishalchovatiya.github.io/tags/curiously-recurring-template-pattern/>Curiously-Recurring-Template-Pattern</a></li><li><a href=https://vishalchovatiya.github.io/tags/dynamic-polymorphism/>Dynamic-Polymorphism</a></li><li><a href=https://vishalchovatiya.github.io/tags/enabling-polymorphic-copy-construction-in-c-with-crtp/>Enabling-Polymorphic-Copy-Construction-in-C-With-Crtp</a></li><li><a href=https://vishalchovatiya.github.io/tags/enabling-polymorphic-method-chaining/>Enabling-Polymorphic-Method-Chaining</a></li><li><a href=https://vishalchovatiya.github.io/tags/limiting-object-count-with-crtp/>Limiting-Object-Count-With-Crtp</a></li><li><a href=https://vishalchovatiya.github.io/tags/modern-c-composite-design-pattern-leveraging-crtp/>Modern-C-Composite-Design-Pattern-Leveraging-Crtp</a></li><li><a href=https://vishalchovatiya.github.io/tags/solution-till-c17-with-crtp/>Solution-Till-C17-With-Crtp</a></li><li><a href=https://vishalchovatiya.github.io/tags/static-polymorphism/>Static-Polymorphism</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/using-std-map-wisely-with-modern-cpp/><span class=title>« Prev</span><br><span>Using std::map Wisely With Modern C++</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/c-template-a-quick-uptodate-look/><span class=title>Next »</span><br><span>C++ Template: A Quick UpToDate Look(C++11/14/17/20)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share CRTP C++ Examples on x" href="https://x.com/intent/tweet/?text=CRTP%20C%2b%2b%20Examples&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcrtp-c-examples%2f&amp;hashtags=c-crtp%2cc20-solution-spaceship-operator%2cc20-spaceship-operator-with-the-help-of-crtp%2ccrtp-and-static-polymorphism-in-c%2ccrtp-c%2ccrtp-c-example%2ccrtp-pattern%2ccrtp-to-avoid-code-duplication%2ccuriously-recurring-template-pattern%2cdynamic-polymorphism%2cenabling-polymorphic-copy-construction-in-c-with-crtp%2cenabling-polymorphic-method-chaining%2climiting-object-count-with-crtp%2cmodern-c-composite-design-pattern-leveraging-crtp%2csolution-till-c17-with-crtp%2cstatic-polymorphism"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CRTP C++ Examples on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcrtp-c-examples%2f&amp;title=CRTP%20C%2b%2b%20Examples&amp;summary=CRTP%20C%2b%2b%20Examples&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcrtp-c-examples%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CRTP C++ Examples on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcrtp-c-examples%2f&title=CRTP%20C%2b%2b%20Examples"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CRTP C++ Examples on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcrtp-c-examples%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CRTP C++ Examples on whatsapp" href="https://api.whatsapp.com/send?text=CRTP%20C%2b%2b%20Examples%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcrtp-c-examples%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CRTP C++ Examples on telegram" href="https://telegram.me/share/url?text=CRTP%20C%2b%2b%20Examples&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcrtp-c-examples%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CRTP C++ Examples on ycombinator" href="https://news.ycombinator.com/submitlink?t=CRTP%20C%2b%2b%20Examples&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcrtp-c-examples%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>