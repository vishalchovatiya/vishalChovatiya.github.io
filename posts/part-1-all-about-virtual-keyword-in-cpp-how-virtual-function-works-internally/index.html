<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? | Vishal Chovatiya</title>
<meta name=keywords content="all-about-virtual-keyword-in-c,dynamic-method-dispatch-virtual-function,example-of-virtual-function-in-c-plus-plus,how-do-we-know-at-runtime-that-pointer-protocol-will-execute-a-right-function,how-pure-virtual-function-works,how-to-implement-virtual-function-concept-in-c,how-virtual-function-works,how-virtual-function-works-internally,is-virtual-table-per-object-or-per-class,place-holder-pure_virtual_called,pure-virtual-function,pure-virtual-function-c,pure-virtual-function-called,pure-virtual-function-in-c-plus-plus,pure-virtual-function-in-c,pure-virtual-function-in-c-example,pure-virtual-function-in-c-pdf,pure-virtual-function-in-c-with-simple-example-program,pure-virtual-function-in-cpp,pure-virtual-function-objective-c,virtual-function,virtual-function-c-plus-plus,virtual-function-c-multiple-inheritance,virtual-function-call,virtual-function-code-in-c,virtual-function-concept-in-c,virtual-function-dynamic-dispatch,virtual-function-in-c-plus-plus,virtual-function-pointer-c,virtual-function-support-under-multiple-inheritances,virtual-function-table-in-c-plus-plus,virtual-keyword,virtual-table,what-is-pure-virtual-function-in-c-plus-plus,where-how-virtual-table-code-augments-by-the-compiler,why-do-we-need-a-virtual-function,why-we-need-a-virtual-function"><meta name=description content="&ldquo;All About Virtual Keyword in C++&rdquo; is a series of articles(total of three, PART 1, PART 2, PART 3) describe working of the virtual keyword in different scenarios. This article mostly focuses on &ldquo;How Does Virtual Function Works Internally?&rdquo;. In other words, How dynamic dispatch done in C++! Although I am not a compiler writer, but this is what I have learned so far from various sources, courses, books & disassembly of C++ program."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally?"><meta property="og:description" content="&ldquo;All About Virtual Keyword in C++&rdquo; is a series of articles(total of three, PART 1, PART 2, PART 3) describe working of the virtual keyword in different scenarios. This article mostly focuses on &ldquo;How Does Virtual Function Works Internally?&rdquo;. In other words, How dynamic dispatch done in C++! Although I am not a compiler writer, but this is what I have learned so far from various sources, courses, books & disassembly of C++ program."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/"><meta property="og:image" content="https://vishalchovatiya.github.io/images/memory-layout-of-C-objects.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-11T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-11T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/images/memory-layout-of-C-objects.png"><meta name=twitter:title content="Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally?"><meta name=twitter:description content="&ldquo;All About Virtual Keyword in C++&rdquo; is a series of articles(total of three, PART 1, PART 2, PART 3) describe working of the virtual keyword in different scenarios. This article mostly focuses on &ldquo;How Does Virtual Function Works Internally?&rdquo;. In other words, How dynamic dispatch done in C++! Although I am not a compiler writer, but this is what I have learned so far from various sources, courses, books & disassembly of C++ program."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally?","item":"https://vishalchovatiya.github.io/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally?","name":"Part 1: All About Virtual Keyword in C\u002b\u002b: How Does Virtual Function Works Internally?","description":"\u0026ldquo;All About Virtual Keyword in C++\u0026rdquo; is a series of articles(total of three, PART 1, PART 2, PART 3) describe working of the virtual keyword in different scenarios. This article mostly focuses on \u0026ldquo;How Does Virtual Function Works Internally?\u0026rdquo;. In other words, How dynamic dispatch done in C++! Although I am not a compiler writer, but this is what I have learned so far from various sources, courses, books \u0026amp; disassembly of C++ program.","keywords":["all-about-virtual-keyword-in-c","dynamic-method-dispatch-virtual-function","example-of-virtual-function-in-c-plus-plus","how-do-we-know-at-runtime-that-pointer-protocol-will-execute-a-right-function","how-pure-virtual-function-works","how-to-implement-virtual-function-concept-in-c","how-virtual-function-works","how-virtual-function-works-internally","is-virtual-table-per-object-or-per-class","place-holder-pure_virtual_called","pure-virtual-function","pure-virtual-function-c","pure-virtual-function-called","pure-virtual-function-in-c-plus-plus","pure-virtual-function-in-c","pure-virtual-function-in-c-example","pure-virtual-function-in-c-pdf","pure-virtual-function-in-c-with-simple-example-program","pure-virtual-function-in-cpp","pure-virtual-function-objective-c","virtual-function","virtual-function-c-plus-plus","virtual-function-c-multiple-inheritance","virtual-function-call","virtual-function-code-in-c","virtual-function-concept-in-c","virtual-function-dynamic-dispatch","virtual-function-in-c-plus-plus","virtual-function-pointer-c","virtual-function-support-under-multiple-inheritances","virtual-function-table-in-c-plus-plus","virtual-keyword","virtual-table","what-is-pure-virtual-function-in-c-plus-plus","where-how-virtual-table-code-augments-by-the-compiler","why-do-we-need-a-virtual-function","why-we-need-a-virtual-function"],"articleBody":"“All About Virtual Keyword in C++” is a series of articles(total of three, PART 1, PART 2, PART 3) describe working of the virtual keyword in different scenarios. This article mostly focuses on “How Does Virtual Function Works Internally?”. In other words, How dynamic dispatch done in C++! Although I am not a compiler writer, but this is what I have learned so far from various sources, courses, books \u0026 disassembly of C++ program.\nBefore diving into the How virtual function works internally!, I would like to clarify two things\nImplementation of dynamic dispatch(i.e. virtual function) is purely compiler dependent. C++ standard does not define the implementation. It only states the behaviour. I always ask my self before learning anything new “Why do we need it in the first place?”. So, let’s start there:\nWhy Do We Need a Virtual Function? Let’s understand it with an example. Suppose you want to connect to the network or to other mobile using your smartphone. So, you have two choices Bluetooth or Wifi. Although these two are completely different technologies, still some things are common in them at an abstract/behavioural level like both are communication protocol, both need authentication, etc. For example, we have a class of them as follows: class wifi_t{ private: char _pass[15]; // storage ... public: void authenticate(); void connect(); // operations ... }; class bluetooth_t{ private: char _pass[15]; // storage ... public: void authenticate(); void connect(); // operations ... }; Now, below is the main application in which you want to connect your device to others. int main() { wifi_t *wifi = new wifi_t; bluetooth_t *bluetooth = new bluetooth_t; int pt = selectProtocol(); if(pt == BLUETOOTH){ bluetooth-\u003eauthenticate(); bluetooth-\u003econnect(); } else if(pt == WIFI){ wifi-\u003eauthenticate(); wifi-\u003econnect(); } return 0; } If you observe above code then you will find that despite selecting any protocol some steps are the same. In such case, you can leverage virtual functions of C++ as follows: class protocol_t { private: uint8_t _type; // storage ... public: virtual void authenticate(){}; virtual void connect(){}; // operations ... }; class wifi_t : public protocol_t { private: char _pass[15]; // storage ... public: void authenticate(){}; void connect(){}; // operations ... }; class bluetooth_t : public protocol_t { private: char _pass[15]; // storage ... public: void authenticate(){}; void connect(){}; // operations ... }; void makeConnection(protocol_t *protocol) { protocol-\u003eauthenticate(); protocol-\u003econnect(); } int main() { int pt = selectProtocol(); // You can not compile this line, but i have kept it that way for simplicity makeConnection( (pt == WIFI) ? new wifi_t : new bluetooth_t); return 0; } Following are the benefits we have achieved through virtual keywords:\nRun time polymorphism: Behavioural functions identified automatically at runtime \u0026 would called by their type like if protocol is wifi then execute wifi_t::authenticate() \u0026 wifi_t::connect()` Reusability of code: Observe makeConnection function there is an only single call to behavioural functions we have removed the redundant code from main. Code would be compact: Observe earlier main function \u0026 newer one. How Does Virtual Function Works Internally? When you declare any function virtual, the compiler will transform(augment is the precise word here) some of your code at compile time. For instance, in our case class protocol_t the class object will be augmented by a pointer called _vptr which points to the virtual table. In other words, this is nothing but a pointer(_vptr) which points to an array of a function pointer. That includes offset/address of your virtual functions. So that it can call your function through that table rather than calling it directly. So if you call the function authenticate()using a pointer of type protocol_t as below:\nprotocol_t *protocol; // .... assignment to `protocol` protocol-\u003eauthenticate(); then it would probably augmented by a compiler like this\n(*protocol-\u003evptr[ 1 ])( protocol ); Where the following holds:\n_vptr represents the internally generated virtual table pointer inserted within each object whose class\ndeclares or inherits one or more virtual functions. In practice, its name mangled. There may be multiple _vptrs within a complex class derivation. 1 in _vptr[ 1 ] is the index into the virtual table slot associated with authenticate() This index is decided by compiler \u0026 fixed throughout the inheritance tree. protocol in its second occurrence(i.e. in the argument) represents the this pointer. When we inherit wifi_t class from protocol_t class, a new virtual table will be created by the compiler with overridden polymorphic function slot. Each virtual function has a fixed index in the virtual table, no matter how long the inheritance hierarchy is.\nIf derived class introduce a new virtual function not present in the base class, the virtual table will be grown by a slot and the address of the function is placed within that slot.\nIf you want to summarize virtual keyword functionality in two words then its indirect calling of a polymorphic function. And to visualize virtual function footprint you can take a look at my earlier article memory layout of a C++ object.\nLet’s Address Some of the FAQs Around Virtual Function \u0026 Virtual Table Q. Is virtual table per object or per class?\nThis usually depends on compiler implementation. But Generally, a virtual table is per class and the virtual table pointers(_vptr) is to object. There might be more than one virtual table pointers too depending upon type of inheritance. Q. Where \u0026 how does virtual table/pointer code augments by the compiler?\nThe code necessary to fill/override virtual table slot generated by the compiler at the time of compilation. To reiterate it in short, the virtual table is generated statically at the compile time by the compiler.\nin constructors right before user-written code. Virtual table pointer(i.e. _vptr) has fixed offset. And the code to override _**_vptr**_ is generated at the time of object construction by the compiler. This is the reason that you should not call the virtual function in constructor. Read more about it here. Q. How do we know at runtime that pointer protocol will execute a right function(of the object pointed to)?\nIn general, we don’t know the exact type of the object protocol addresses at each invocation of authenticate() However, we do know the virtual table pointer(_vptr) offset(which is fixed) associated with the object’s class. And using this _vptr, we can access the virtual table of the object pointed by protocol pointer. Again the index of function authenticate() in a virtual table fixed throughout the inheritance hierarchy. This way right authenticate()`function execution guaranteed. How `Pure` Virtual Function Works? When you declare any function as pure virtual, the compiler automatically fills the slot of that pure virtual function with dummy function or so-called place holder pure_virtual_called()library instance. And the run-time exception placed if somehow this place holder called. In addition, rest of calling \u0026 virtual table slot mechanism would be the same as a normal virtual function. Virtual Function Support Under Multiple Inheritances Now with multiple inheritance things will get a little bit tricky. To understand this behaviour let us take another simplified example as follow : struct base1 { int base1_var; virtual void base1_func() { } virtual void print() { } }; struct base2 { int base2_var; virtual void base2_func() { } virtual void print() { } }; struct derived : base1, base2 { int derived_var; void print() { } }; Here we have derived class with two base classes. In such a case, when we declare an object of the derived class, two virtual table pointers(_vptr) created in the derived class object. One for base1 \u0026 other for base2, which are overridden with the address of derived class virtual table. | | |------------------------| \u003c------ derived object memory layout | base1::base1_var | |------------------------| |---------\u003e|----------------------| | base1::_vptr_base1 |----------| | type_info derived | |------------------------| |----------------------| | base2::base2_var | | base1::base1_func | |------------------------| |----------------------| | base2::_vptr_base2 |----------| | derived:::print | |------------------------| | |----------------------| | derived::derived_var | | |------GUARD_AREA------| |------------------------| |---------\u003e|----------------------| | | | type_info derived | | | |----------------------| | | | base2::base2_func | | | |----------------------| | derived::print | |----------------------| To understand that, first, let’s assign a base2 pointer with the address of a derived class object allocated on the heap: base2 *pb = new derived; The address of the new derived object must be adjusted to address its base2 subobject. The code augmentation done by compiler would look like: base2* pb = static_cast\u003cbase2 *\u003e(new derived()); // Equivalent to \"address of derived object + sizeof(base1)\" Visualizing memory object of above adjustment. | | |------------------------| \u003c------ derived object memory layout | base1::base1_var | |------------------------| |---------\u003e|----------------------| | base1::_vptr_base1 |----------| | type_info derived | pb ---\u003e |------------------------| |----------------------| | base2::base2_var | | base1::base1_func | |------------------------| |----------------------| | base2::_vptr_base2 |----------| | derived:::print | |------------------------| | |----------------------| | derived::derived_var | | |------GUARD_AREA------| |------------------------| |---------\u003e|----------------------| | | | type_info derived | | | |----------------------| | | | base2::base2_func | | | |----------------------| | derived:::print | |----------------------| Without this adjustment, any nonpolymorphic use of the pointer would fail, such as pb-\u003ebase2_var = 5; And the call to the polymorphic function `print() pb-\u003eprint(); would probably transforms into\n( * pb-\u003e_vptr_base2[ 2 ])( pb ); Summary I hope you liked this material \u0026 helps you to clarify many doubt around virtual function. There is one extraordinary case of virtual destructor which we will see in-depth in PART-3 of this series. Followings are the points which sum up this article in concise way:\nC++ standard does not define implementation \u0026 it only states the behaviour of the dynamic dispatch(i.e. virtual function) virtual table pointers(_vptr) is to object virtual table pointer(_vptr) has fixed offset code to override _vptr is generated at the time of object construction virtual table is per class virtual table is generated statically at the compile time ","wordCount":"1600","inLanguage":"en","image":"https://vishalchovatiya.github.io/images/memory-layout-of-C-objects.png","datePublished":"2019-09-11T00:00:00Z","dateModified":"2019-09-11T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally?</h1><div class=post-meta><span title='2019-09-11 00:00:00 +0000 UTC'>September 11, 2019</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1600 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://vishalchovatiya.github.io/images/memory-layout-of-C-objects.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#why-do-we-need-a-virtual-function>Why Do We Need a Virtual Function?</a></li><li><a href=#how-does-virtual-function-works-internally>How Does Virtual Function Works Internally?</a><ul><li><a href=#lets-address-some-of-the-faqs-around-virtual-function--virtual-table>Let&rsquo;s Address Some of the FAQs Around Virtual Function & Virtual Table</a></li></ul></li><li><a href=#how-pure-virtual-function-works>How `Pure` Virtual Function Works?</a></li><li><a href=#virtual-function-support-under-multiple-inheritances>Virtual Function Support Under Multiple Inheritances</a></li><li><a href=#summary>Summary</a></li></ul></nav></div></details></div><div class=post-content><p>&ldquo;All About Virtual Keyword in C++&rdquo; is a series of articles(total of three, <a href=/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/>PART 1</a>, <a href=/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/>PART 2</a>, <a href=/posts/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/>PART 3</a>) describe working of the virtual keyword in different scenarios. This article mostly focuses on &ldquo;How Does Virtual Function Works Internally?&rdquo;. In other words, How dynamic dispatch done in C++! Although I am not a compiler writer, but this is what I have learned so far from various sources, courses, books & disassembly of C++ program.</p><p>Before diving into the How virtual function works internally!, I would like to clarify two things</p><ol><li>Implementation of dynamic dispatch(i.e. virtual function) is purely compiler dependent.</li><li>C++ standard does not define the implementation. It only states the behaviour.</li></ol><p>I always ask my self before learning anything new &ldquo;Why do we need it in the first place?&rdquo;. So, let&rsquo;s start there:</p><h2 id=why-do-we-need-a-virtual-function>Why Do We Need a Virtual Function?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-a-virtual-function>#</a></h2><ul><li>Let&rsquo;s understand it with an example. Suppose you want to connect to the network or to other mobile using your smartphone.</li><li>So, you have two choices Bluetooth or Wifi. Although these two are completely different technologies, still some things are common in them at an abstract/behavioural level like both are communication protocol, both need authentication, etc.</li><li>For example, we have a class of them as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>wifi_t</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>_pass</span><span class=p>[</span><span class=mi>15</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>// storage ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=n>authenticate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>connect</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>// operations ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>bluetooth_t</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>_pass</span><span class=p>[</span><span class=mi>15</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>// storage ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=n>authenticate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>connect</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>// operations ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><ul><li>Now, below is the main application in which you want to connect your device to others.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>wifi_t</span>          <span class=o>*</span><span class=n>wifi</span> <span class=o>=</span> <span class=k>new</span> <span class=n>wifi_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>bluetooth_t</span>     <span class=o>*</span><span class=n>bluetooth</span> <span class=o>=</span> <span class=k>new</span> <span class=n>bluetooth_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pt</span> <span class=o>=</span> <span class=n>selectProtocol</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pt</span> <span class=o>==</span> <span class=n>BLUETOOTH</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>bluetooth</span><span class=o>-&gt;</span><span class=n>authenticate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>bluetooth</span><span class=o>-&gt;</span><span class=n>connect</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pt</span> <span class=o>==</span> <span class=n>WIFI</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>wifi</span><span class=o>-&gt;</span><span class=n>authenticate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>wifi</span><span class=o>-&gt;</span><span class=n>connect</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>If you observe above code then you will find that despite selecting any protocol some steps are the same.</li><li>In such case, you can leverage virtual functions of C++ as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>protocol_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=n>_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// storage ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=kt>void</span> <span class=n>authenticate</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>connect</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>        <span class=c1>// operations ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>wifi_t</span> <span class=o>:</span> <span class=k>public</span> <span class=n>protocol_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>_pass</span><span class=p>[</span><span class=mi>15</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>// storage ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=n>authenticate</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>connect</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>        <span class=c1>// operations ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>bluetooth_t</span> <span class=o>:</span> <span class=k>public</span> <span class=n>protocol_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>_pass</span><span class=p>[</span><span class=mi>15</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>// storage ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=n>authenticate</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>connect</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>        <span class=c1>// operations ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>makeConnection</span><span class=p>(</span><span class=n>protocol_t</span> <span class=o>*</span><span class=n>protocol</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>protocol</span><span class=o>-&gt;</span><span class=n>authenticate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>protocol</span><span class=o>-&gt;</span><span class=n>connect</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pt</span> <span class=o>=</span> <span class=n>selectProtocol</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// You can not compile this line, but i have kept it that way for simplicity
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>makeConnection</span><span class=p>(</span> <span class=p>(</span><span class=n>pt</span> <span class=o>==</span> <span class=n>WIFI</span><span class=p>)</span> <span class=o>?</span> <span class=k>new</span> <span class=nl>wifi_t</span> <span class=p>:</span> <span class=k>new</span> <span class=n>bluetooth_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Following are the benefits we have achieved through virtual keywords:</p><ol><li><strong>Run time polymorphism</strong>: Behavioural functions identified automatically at runtime & would called by their type like if <code>protocol</code> is wifi then execute <code>wifi_t::authenticate() & </code>wifi_t::connect()`</li><li><strong>Reusability of code</strong>: Observe <code>makeConnection</code> function there is an only single call to behavioural functions we have removed the redundant code from main.</li><li><strong>Code would be compact</strong>: Observe earlier <code>main</code> function & newer one.</li></ol><h2 id=how-does-virtual-function-works-internally>How Does Virtual Function Works Internally?<a hidden class=anchor aria-hidden=true href=#how-does-virtual-function-works-internally>#</a></h2><ul><li>When you declare any function virtual, the compiler will transform(augment is the precise word here) some of your code at compile time.</li><li>For instance, in our case class <code>protocol_t</code> the class object will be augmented by a pointer called <code>_vptr</code> which points to the virtual table.</li><li>In other words, this is nothing but a pointer(<code>_vptr</code>) which points to an array of a function pointer. That includes offset/address of your virtual functions. So that it can call your function through that table rather than calling it directly.</li></ul><p>So if you call the function <code>authenticate()</code>using a pointer of type <code>protocol_t</code> as below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>protocol_t</span> <span class=o>*</span><span class=n>protocol</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// .... assignment to `protocol`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>protocol</span><span class=o>-&gt;</span><span class=n>authenticate</span><span class=p>();</span>
</span></span></code></pre></div><p>then it would probably augmented by a compiler like this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=o>*</span><span class=n>protocol</span><span class=o>-&gt;</span><span class=n>vptr</span><span class=p>[</span> <span class=mi>1</span> <span class=p>])(</span> <span class=n>protocol</span> <span class=p>);</span> 
</span></span></code></pre></div><p>Where the following holds:</p><ol><li><code>_vptr</code> represents the internally generated virtual table pointer inserted within each object whose class<br>declares or inherits one or more virtual functions. In practice, its name mangled. There may be multiple _vptrs within a complex class derivation.</li><li>1 in _vptr[ 1 ] is the index into the virtual table slot associated with <code>authenticate()</code> This index is decided by compiler & fixed throughout the inheritance tree.</li><li><code>protocol</code> in its second occurrence(i.e. in the argument) represents the <code>this</code> pointer.</li></ol><p>When we inherit <code>wifi_t</code> class from <code>protocol_t</code> class, a new virtual table will be created by the compiler with overridden polymorphic function slot. Each virtual function has a fixed index in the virtual table, no matter how long the inheritance hierarchy is.</p><p>If <code>derived</code> class introduce a new virtual function not present in the base class, the virtual table will be grown by a slot and the address of the function is placed within that slot.</p><p>If you want to summarize virtual keyword functionality in two words then its <code>indirect calling</code> of a polymorphic function. And to visualize virtual function footprint you can take a look at my earlier article <a href=/posts/memory-layout-of-cpp-object/>memory layout of a C++ object</a>.</p><h3 id=lets-address-some-of-the-faqs-around-virtual-function--virtual-table>Let&rsquo;s Address Some of the FAQs Around Virtual Function & Virtual Table<a hidden class=anchor aria-hidden=true href=#lets-address-some-of-the-faqs-around-virtual-function--virtual-table>#</a></h3><p><strong>Q. Is virtual table per object or per class?</strong></p><ul><li>This usually depends on compiler implementation.</li><li>But Generally, a <strong><em>virtual table is per class</em></strong> and the <strong><em>virtual table pointers(<code>_vptr</code>) is to object</em></strong>.</li><li>There might be more than one virtual table pointers too depending upon type of inheritance.</li></ul><p><strong>Q. Where & how does virtual table/pointer code augments by the compiler?</strong></p><ul><li>The code necessary to fill/override virtual table slot generated by the compiler at the time of compilation. To reiterate it in short, the <strong><em>virtual table is generated statically at the compile time</em></strong> by the compiler.<br>in constructors right before user-written code.</li><li>Virtual table pointer(i.e. <code>_vptr</code>) has fixed offset. And the <strong><em>code to override</em></strong> <code>_**_vptr**_</code> <strong><em>is generated at the time of object construction</em></strong> by the compiler.</li><li>This is the reason that you should not call the virtual function in constructor. Read more about it <a href=https://stackoverflow.com/questions/962132/calling-virtual-functions-inside-constructors>here</a>.</li></ul><p><strong>Q. How do we know at runtime that pointer <code>protocol</code> will execute a right function(of the object pointed to)?</strong></p><ul><li>In general, we don&rsquo;t know the exact type of the object <code>protocol</code> addresses at each invocation of <code>authenticate()</code> However, we do know the virtual table pointer(<code>_vptr</code>) offset(which is fixed) associated with the object&rsquo;s class.</li><li>And using this <code>_vptr</code>, we can access the virtual table of the object pointed by <code>protocol</code> pointer. Again the index of function <code>authenticate() in a virtual table fixed throughout the inheritance hierarchy. This way right </code>authenticate()`function execution guaranteed.</li></ul><h2 id=how-pure-virtual-function-works>How `Pure` Virtual Function Works?<a hidden class=anchor aria-hidden=true href=#how-pure-virtual-function-works>#</a></h2><ul><li>When you declare any function as pure virtual, the compiler automatically fills the slot of that pure virtual function with dummy function or so-called place holder <code>pure_virtual_called()</code>library instance. And the run-time exception placed if somehow this place holder called.</li><li>In addition, rest of calling & virtual table slot mechanism would be the same as a normal virtual function.</li></ul><h2 id=virtual-function-support-under-multiple-inheritances>Virtual Function Support Under Multiple Inheritances<a hidden class=anchor aria-hidden=true href=#virtual-function-support-under-multiple-inheritances>#</a></h2><ul><li>Now with multiple inheritance things will get a little bit tricky. To understand this behaviour let us take another simplified example as follow :</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>base1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>base1_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>base1_func</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>            
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>base2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>base2_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>base2_func</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>derived</span> <span class=o>:</span> <span class=n>base1</span><span class=p>,</span> <span class=n>base2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>derived_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>Here we have <code>derived</code> class with two base classes. In such a case, when we declare an object of the <code>derived</code> class, two virtual table pointers(<code>_vptr</code>) created in the <code>derived</code> class object. One for <code>base1</code> & other for <code>base2</code>, which are overridden with the address of <code>derived</code> class virtual table.</li></ul><pre tabindex=0><code>|                        |          
|------------------------| &lt;------ derived object memory layout
|  base1::base1_var      |          
|------------------------|          |---------&gt;|----------------------|
|  base1::_vptr_base1    |----------|          |   type_info derived  |
|------------------------|                     |----------------------|
|  base2::base2_var      |                     |   base1::base1_func  |
|------------------------|                     |----------------------|
|  base2::_vptr_base2    |----------|          |    derived:::print   |
|------------------------|          |          |----------------------|
|  derived::derived_var  |          |          |------GUARD_AREA------|
|------------------------|          |---------&gt;|----------------------|
|                        |                     |   type_info derived  |
|                        |                     |----------------------|
|                        |                     |   base2::base2_func  |
|                        |                     |----------------------|
                                               |    derived::print    |
                                               |----------------------|
</code></pre><ul><li>To understand that, first, let&rsquo;s assign a <code>base2</code> pointer with the address of a <code>derived</code> class object allocated on the heap:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>base2</span> <span class=o>*</span><span class=n>pb</span> <span class=o>=</span> <span class=k>new</span> <span class=n>derived</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>The address of the new <code>derived</code> object must be adjusted to address its <code>base2</code> <a href=/posts/memory-layout-of-cpp-object/>subobject</a>. The code augmentation done by compiler would look like:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>base2</span><span class=o>*</span> <span class=n>pb</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>base2</span> <span class=o>*&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>derived</span><span class=p>());</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Equivalent to &#34;address of derived object + sizeof(base1)&#34;
</span></span></span></code></pre></div><ul><li>Visualizing memory object of above adjustment.</li></ul><pre tabindex=0><code>        |                        |          
        |------------------------| &lt;------ derived object memory layout
        |  base1::base1_var      |          
        |------------------------|          |---------&gt;|----------------------|
        |  base1::_vptr_base1    |----------|          |   type_info derived  |
pb ---&gt; |------------------------|                     |----------------------|
        |  base2::base2_var      |                     |   base1::base1_func  |
        |------------------------|                     |----------------------|
        |  base2::_vptr_base2    |----------|          |    derived:::print   |
        |------------------------|          |          |----------------------|
        |  derived::derived_var  |          |          |------GUARD_AREA------|
        |------------------------|          |---------&gt;|----------------------|
        |                        |                     |   type_info derived  |
        |                        |                     |----------------------|
        |                        |                     |   base2::base2_func  |
        |                        |                     |----------------------|
                                                       |    derived:::print   |
                                                       |----------------------|
</code></pre><ul><li>Without this adjustment, any nonpolymorphic use of the pointer would fail, such as</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>pb</span><span class=o>-&gt;</span><span class=n>base2_var</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>And the call to the polymorphic function `print()</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>pb</span><span class=o>-&gt;</span><span class=n>print</span><span class=p>();</span>
</span></span></code></pre></div><p>would probably transforms into</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span> <span class=o>*</span> <span class=n>pb</span><span class=o>-&gt;</span><span class=n>_vptr_base2</span><span class=p>[</span> <span class=mi>2</span> <span class=p>])(</span> <span class=n>pb</span> <span class=p>);</span> 
</span></span></code></pre></div><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>I hope you liked this material & helps you to clarify many doubt around virtual function. There is one extraordinary case of <a href=/posts/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/>virtual destructor</a> which we will see in-depth in PART-3 of this series. Followings are the points which sum up this article in concise way:</p><ol><li>C++ standard does not define implementation & it only states the behaviour of the dynamic dispatch(i.e. virtual function)</li><li>virtual table pointers(<code>_vptr</code>) is to object</li><li>virtual table pointer(<code>_vptr</code>) has fixed offset</li><li>code to override <code>_vptr</code> is generated at the time of object construction</li><li>virtual table is per class</li><li>virtual table is generated statically at the compile time</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/all-about-virtual-keyword-in-c/>All-About-Virtual-Keyword-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/dynamic-method-dispatch-virtual-function/>Dynamic-Method-Dispatch-Virtual-Function</a></li><li><a href=https://vishalchovatiya.github.io/tags/example-of-virtual-function-in-c-plus-plus/>Example-of-Virtual-Function-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-do-we-know-at-runtime-that-pointer-protocol-will-execute-a-right-function/>How-Do-We-Know-at-Runtime-That-Pointer-Protocol-Will-Execute-a-Right-Function</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-pure-virtual-function-works/>How-Pure-Virtual-Function-Works</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-to-implement-virtual-function-concept-in-c/>How-to-Implement-Virtual-Function-Concept-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-virtual-function-works/>How-Virtual-Function-Works</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-virtual-function-works-internally/>How-Virtual-Function-Works-Internally</a></li><li><a href=https://vishalchovatiya.github.io/tags/is-virtual-table-per-object-or-per-class/>Is-Virtual-Table-per-Object-or-per-Class</a></li><li><a href=https://vishalchovatiya.github.io/tags/place-holder-pure_virtual_called/>Place-Holder-Pure_virtual_called</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function/>Pure-Virtual-Function</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function-c/>Pure-Virtual-Function-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function-called/>Pure-Virtual-Function-Called</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function-in-c-plus-plus/>Pure-Virtual-Function-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function-in-c/>Pure-Virtual-Function-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function-in-c-example/>Pure-Virtual-Function-in-C-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function-in-c-pdf/>Pure-Virtual-Function-in-C-Pdf</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function-in-c-with-simple-example-program/>Pure-Virtual-Function-in-C-With-Simple-Example-Program</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function-in-cpp/>Pure-Virtual-Function-in-Cpp</a></li><li><a href=https://vishalchovatiya.github.io/tags/pure-virtual-function-objective-c/>Pure-Virtual-Function-Objective-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function/>Virtual-Function</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-c-plus-plus/>Virtual-Function-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-c-multiple-inheritance/>Virtual-Function-C-Multiple-Inheritance</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-call/>Virtual-Function-Call</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-code-in-c/>Virtual-Function-Code-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-concept-in-c/>Virtual-Function-Concept-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-dynamic-dispatch/>Virtual-Function-Dynamic-Dispatch</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-in-c-plus-plus/>Virtual-Function-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-pointer-c/>Virtual-Function-Pointer-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-support-under-multiple-inheritances/>Virtual-Function-Support-Under-Multiple-Inheritances</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-function-table-in-c-plus-plus/>Virtual-Function-Table-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-keyword/>Virtual-Keyword</a></li><li><a href=https://vishalchovatiya.github.io/tags/virtual-table/>Virtual-Table</a></li><li><a href=https://vishalchovatiya.github.io/tags/what-is-pure-virtual-function-in-c-plus-plus/>What-Is-Pure-Virtual-Function-in-C-Plus-Plus</a></li><li><a href=https://vishalchovatiya.github.io/tags/where-how-virtual-table-code-augments-by-the-compiler/>Where-How-Virtual-Table-Code-Augments-by-the-Compiler</a></li><li><a href=https://vishalchovatiya.github.io/tags/why-do-we-need-a-virtual-function/>Why-Do-We-Need-a-Virtual-Function</a></li><li><a href=https://vishalchovatiya.github.io/tags/why-we-need-a-virtual-function/>Why-We-Need-a-Virtual-Function</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/memory-layout-of-cpp-object/><span class=title>« Prev</span><br><span>Memory Layout of C++ Object in Different Scenarios</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/><span class=title>Next »</span><br><span>Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally?</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? on x" href="https://x.com/intent/tweet/?text=Part%201%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Function%20Works%20Internally%3f&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally%2f&amp;hashtags=all-about-virtual-keyword-in-c%2cdynamic-method-dispatch-virtual-function%2cexample-of-virtual-function-in-c-plus-plus%2chow-do-we-know-at-runtime-that-pointer-protocol-will-execute-a-right-function%2chow-pure-virtual-function-works%2chow-to-implement-virtual-function-concept-in-c%2chow-virtual-function-works%2chow-virtual-function-works-internally%2cis-virtual-table-per-object-or-per-class%2cplace-holder-pure_virtual_called%2cpure-virtual-function%2cpure-virtual-function-c%2cpure-virtual-function-called%2cpure-virtual-function-in-c-plus-plus%2cpure-virtual-function-in-c%2cpure-virtual-function-in-c-example%2cpure-virtual-function-in-c-pdf%2cpure-virtual-function-in-c-with-simple-example-program%2cpure-virtual-function-in-cpp%2cpure-virtual-function-objective-c%2cvirtual-function%2cvirtual-function-c-plus-plus%2cvirtual-function-c-multiple-inheritance%2cvirtual-function-call%2cvirtual-function-code-in-c%2cvirtual-function-concept-in-c%2cvirtual-function-dynamic-dispatch%2cvirtual-function-in-c-plus-plus%2cvirtual-function-pointer-c%2cvirtual-function-support-under-multiple-inheritances%2cvirtual-function-table-in-c-plus-plus%2cvirtual-keyword%2cvirtual-table%2cwhat-is-pure-virtual-function-in-c-plus-plus%2cwhere-how-virtual-table-code-augments-by-the-compiler%2cwhy-do-we-need-a-virtual-function%2cwhy-we-need-a-virtual-function"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally%2f&amp;title=Part%201%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Function%20Works%20Internally%3f&amp;summary=Part%201%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Function%20Works%20Internally%3f&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally%2f&title=Part%201%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Function%20Works%20Internally%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? on whatsapp" href="https://api.whatsapp.com/send?text=Part%201%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Function%20Works%20Internally%3f%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? on telegram" href="https://telegram.me/share/url?text=Part%201%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Function%20Works%20Internally%3f&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? on ycombinator" href="https://news.ycombinator.com/submitlink?t=Part%201%3a%20All%20About%20Virtual%20Keyword%20in%20C%2b%2b%3a%20How%20Does%20Virtual%20Function%20Works%20Internally%3f&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fpart-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>