<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What Exactly nullptr Is in C++? | Vishal Chovatiya</title>
<meta name=keywords content="c-11-nullptr,c-check-nullptr,c-if-nullptr,c-nullptr,c-reference-nullptr,can-i-convert-nullptr-to-bool,conversion-to-bool-from-nullptr_t,cpp-nullptr,how-is-nullptr-defined,if-nullptr,is-null-in-c-equal-to-nullptr-from-c11,is-nullptr-a-keyword-or-an-instance-of-a-type-stdnullptr_t,null-nullptr,null-vs-nullptr-c,nullptr,nullptr-cpp,nullptr-in-c,nullptr-vs-null,nullptr_t-is-comparable,qt-nullptr,reinterpret_cast-on-nullptr,return-nullptr-c,sizeofnullptr_t,template-argument-is-of-type-stdnullptr_t,this-was-nullptr-c,typecasting-on-nullptr_t,use-cases-of-nullptr,what-are-the-advantages-of-using-nullptr,what-exactly-nullptr-is-in-c,when-was-nullptr-introduced"><meta name=description content="The answer to &ldquo;What exactly nullptr is in C++?&rdquo; would be a piece of cake for experienced C++ eyes & for those who are aware of Modern C++ i.e. keyword. But nullptr is more than just a keyword in C++ & to explain that, I have written this article. But before jump-into it, we will see issues with NULL & then we&rsquo;ll dive into the unsophisticated implementation of nullptr & some use-cases of nullptr."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/what-exactly-nullptr-is-in-cpp/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/images/trident_favicon.webp><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/images/trident_favicon.webp><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/images/trident_favicon.webp><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/images/trident_favicon.webp><link rel=mask-icon href=https://vishalchovatiya.github.io/images/trident_favicon.webp><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/what-exactly-nullptr-is-in-cpp/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="What Exactly nullptr Is in C++?"><meta property="og:description" content="The answer to &ldquo;What exactly nullptr is in C++?&rdquo; would be a piece of cake for experienced C++ eyes & for those who are aware of Modern C++ i.e. keyword. But nullptr is more than just a keyword in C++ & to explain that, I have written this article. But before jump-into it, we will see issues with NULL & then we&rsquo;ll dive into the unsophisticated implementation of nullptr & some use-cases of nullptr."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/what-exactly-nullptr-is-in-cpp/"><meta property="og:image" content="https://vishalchovatiya.github.io/images/What-exactly-nullptr-is-in-C-vishal-chovatiya.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-11-30T00:00:00+00:00"><meta property="article:modified_time" content="2019-11-30T00:00:00+00:00"><meta property="og:site_name" content="Vishal Chovatiya"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/images/What-exactly-nullptr-is-in-C-vishal-chovatiya.png"><meta name=twitter:title content="What Exactly nullptr Is in C++?"><meta name=twitter:description content="The answer to &ldquo;What exactly nullptr is in C++?&rdquo; would be a piece of cake for experienced C++ eyes & for those who are aware of Modern C++ i.e. keyword. But nullptr is more than just a keyword in C++ & to explain that, I have written this article. But before jump-into it, we will see issues with NULL & then we&rsquo;ll dive into the unsophisticated implementation of nullptr & some use-cases of nullptr."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"What Exactly nullptr Is in C++?","item":"https://vishalchovatiya.github.io/posts/what-exactly-nullptr-is-in-cpp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What Exactly nullptr Is in C++?","name":"What Exactly nullptr Is in C\u002b\u002b?","description":"The answer to \u0026ldquo;What exactly nullptr is in C++?\u0026rdquo; would be a piece of cake for experienced C++ eyes \u0026amp; for those who are aware of Modern C++ i.e. keyword. But nullptr is more than just a keyword in C++ \u0026amp; to explain that, I have written this article. But before jump-into it, we will see issues with NULL \u0026amp; then we\u0026rsquo;ll dive into the unsophisticated implementation of nullptr \u0026amp; some use-cases of nullptr.","keywords":["c-11-nullptr","c-check-nullptr","c-if-nullptr","c-nullptr","c-reference-nullptr","can-i-convert-nullptr-to-bool","conversion-to-bool-from-nullptr_t","cpp-nullptr","how-is-nullptr-defined","if-nullptr","is-null-in-c-equal-to-nullptr-from-c11","is-nullptr-a-keyword-or-an-instance-of-a-type-stdnullptr_t","null-nullptr","null-vs-nullptr-c","nullptr","nullptr-cpp","nullptr-in-c","nullptr-vs-null","nullptr_t-is-comparable","qt-nullptr","reinterpret_cast-on-nullptr","return-nullptr-c","sizeofnullptr_t","template-argument-is-of-type-stdnullptr_t","this-was-nullptr-c","typecasting-on-nullptr_t","use-cases-of-nullptr","what-are-the-advantages-of-using-nullptr","what-exactly-nullptr-is-in-c","when-was-nullptr-introduced"],"articleBody":"The answer to “What exactly nullptr is in C++?” would be a piece of cake for experienced C++ eyes \u0026 for those who are aware of Modern C++ i.e. keyword. But nullptr is more than just a keyword in C++ \u0026 to explain that, I have written this article. But before jump-into it, we will see issues with NULL \u0026 then we’ll dive into the unsophisticated implementation of nullptr \u0026 some use-cases of nullptr.\nWhy do we need nullptr? To distinguish between an integer 0(zero) i.e. NULL \u0026 actual null of type pointer.\nnullptr vs NULL NULL is 0(zero) i.e. integer constant zero with C-style typecast to void*, while nullptr is prvalue of type nullptr_t which is integer literal evaluates to zero. For those of you who believe that NULL is same i.e. (void*)0 in C \u0026 C++. I would like to clarify that no it’s not: NULL - cppreference.com (C)\nNULL - cppreference.com (C++)\nC++ requires that macro NULL to be defined as an integral constant expression having the value of 0. So unlike in C, NULL cannot be defined as (void *)0 in the C++ standard library. Issues with NULL Implicit conversion 1 2 char *str = NULL; // Implicit conversion from void * to char * int i = NULL; // OK, but `i` is not pointer type Function calling ambiguity 1 2 3 4 5 void func(int) {} void func(int*){} void func(bool){} func(NULL); // Which one to call? Compilation produces the following error:\n1 2 3 4 5 6 7 8 9 10 11 error: call to 'func' is ambiguous func(NULL); ^~~~ note: candidate function void func(bool){} ^ note: candidate function void func(int*){} ^ note: candidate function void func(int){} ^ 1 error generated. compiler exit status 1 Constructor overload 1 2 3 4 5 6 7 8 struct String { String(uint32_t) { /* size of string */ } String(const char*) { /* string */ } }; String s1( NULL ); String s2( 5 ); In such cases, you need explicit cast (i.e., `String s((char*)0)). Implementation of unsophisticated nullptr nullptr is a subtle example of Return Type Resolver idiom to automatically deduce a null pointer of the correct type depending upon the type of the instance it is assigning to. Consider the following simplest \u0026 unsophisticated nullptr implementation: 1 2 3 4 5 6 7 8 9 10 11 12 struct nullptr_t { void operator\u0026() const = delete; // Can't take address of nullptr template\u003cclass T\u003e inline operator T*() const { return 0; } template\u003cclass C, class T\u003e inline operator T C::*() const { return 0; } }; nullptr_t nullptr; If the above code seems strange \u0026 weird to you(although it should not), then I would suggest you go through my earlier article on advanced C++ concepts. The magic here is just the templatized conversion operator. If you are into a more authoritative source, then, here is a concrete implementation of nullptr from LLVM header. Use-cases of nullptr 1 2 3 4 5 6 7 8 9 10 11 struct C { void func(); }; int main(void) { int *ptr = nullptr; // OK void (C::*method_ptr)() = nullptr; // OK nullptr_t n1, n2; n1 = n2; //nullptr_t *null = \u0026n1; // Address can't be taken. } As shown in the above example, when nullptr is being assigned to an integer pointer, a int type instantiation of the templatized conversion function is created. And same goes for method pointers too. This way by leveraging C++ template functionality, we are actually creating the appropriate type of null pointer every time we do, a new type assignment. As nullptr is an integer literal with value zero, you can not able to use its address which we accomplished by deleting \u0026 operator. Function calling clarity with nullptr 1 2 3 4 5 void func(int) { /* ... */} void func(int *) { /* ... */} void func(bool) { /* ... */} func(nullptr); Now, func( int* ) will be called as nullptr will implicitly be deduced to int*`. Typecasting on nullptr_t A cast of nullptr_t to an integral type needs a reinterpret_cast, and has the same semantics as a cast of (void*)0 to an integral type. Casting nullptr_t to an integral type holds true as long as destination type is large enough. Consider this: 1 2 // int ptr_not_ok = reinterpret_cast(nullptr); // Not OK long ptr_ok = reinterpret_cast\u003clong long\u003e(nullptr); // OK A reinterpret_cast cannot convert nullptr_t to any pointer type. Use static_cast instead. 1 2 3 4 5 6 7 void func(int*) { /*...*/ } void func(double*) { /*...*/ } func(nullptr); // compilation error, ambiguous call! // func(reinterpret_cast(nullptr)); // error: invalid cast from type 'std::nullptr_t' to type 'int*' func(static_cast\u003cint*\u003e(nullptr)); // OK nullptr is implicitly convertible to any pointer type so explicit conversion with static_cast is only valid. nullptr_t is comparable 1 2 3 4 5 6 int *ptr = nullptr; if (ptr == 0); // OK if (ptr \u003c= nullptr); // OK int a = 0; if (a == nullptr); // error: invalid operands of types 'int' and 'std::nullptr_t' to binary 'operator==' From Wikipedia article:\n…null pointer constant: nullptr. It is of type nullptr_t, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. It is not implicitly convertible or comparable to integral types, except for bool. 1 2 3 4 5 const int a = 0; if (a == nullptr); // OK const int b = 5; if (b == nullptr); // error: invalid operands of types 'const int' and 'std::nullptr_t' to binary 'operator==' Template-argument is of type std::nullptr_t 1 2 3 4 template \u003ctypename T\u003e void ptr_func(T *t) {} ptr_func(nullptr); // Can not deduce T As discussed earlier, Return Type Resolver needs an assignee to deduce the type. 1 2 3 4 5 template \u003ctypename T\u003e void val_func(T t) {} val_func(nullptr); // deduces T = nullptr_t val_func((int*)nullptr); // deduces T = int*, prefer static_cast though Conversion to bool from nullptr_t From cppreference :\nIn the context of a direct-initialization, a bool object may be initialized from a prvalue of type std::nullptr_t, including nullptr. The resulting value is false. However, this is not considered to be an implicit conversion.\nThe conversion is only allowed for direct-initialization, but not copy-intialization, which including the case for passing an argument to a function by value. e.g.\n1 2 3 4 5 6 bool b1 = nullptr; // Not OK bool b2 {nullptr}; // OK void func(bool){} func(nullptr); // Not OK, need to do func(static_cast(nullptr)); Misc 1 2 3 4 5 typeid(nullptr); // OK throw nullptr; // OK char *ptr = expr ? nullptr : nullptr; // OK // char *ptr1 = expr ? 0 : nullptr; // Not OK, types are not compatible static_assert(sizeof(NULL) == sizeof(nullptr_t)); Summary by FAQs When was nullptr introduced?\nC++11\nIs nullptr a keyword or an instance of a type std::nullptr_t?\nBoth true and false are keywords \u0026 literals, as they have a type ( bool ). nullptr is a pointer literal of type std::nullptr_t, \u0026 it’s a prvalue (i.e. pure rvalue, you cannot take the address of it using \u0026). For more.\nWhat are the advantages of using nullptr?\nNo function calling ambiguity between overload sets. You can do template specialization with nullptr_t. Code will become more safe, intuitive \u0026 expressive. if (ptr == nullptr); rather than if (ptr == 0);. Is NULL in C++ equal to nullptr from C++11?\nNot at all. The following line does not even compile:\ncout\u003c","wordCount":"1325","inLanguage":"en","image":"https://vishalchovatiya.github.io/images/What-exactly-nullptr-is-in-C-vishal-chovatiya.png","datePublished":"2019-11-30T00:00:00Z","dateModified":"2019-11-30T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/what-exactly-nullptr-is-in-cpp/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/images/trident_favicon.webp"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">What Exactly nullptr Is in C++?</h1><div class=post-meta><span title='2019-11-30 00:00:00 +0000 UTC'>November 30, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1325 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/blob/main/vishalchovatiya/content/posts/what-exactly-nullptr-is-in-cpp.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://vishalchovatiya.github.io/images/What-exactly-nullptr-is-in-C-vishal-chovatiya.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#why-do-we-need-nullptr>Why do we need nullptr?</a></li><li><a href=#nullptr-vs-null>nullptr vs NULL</a></li><li><a href=#issues-with-null>Issues with NULL</a><ul><li><a href=#implicit-conversion><strong>Implicit conversion</strong></a></li><li><a href=#function-calling-ambiguity><strong>Function calling ambiguity</strong></a></li><li><a href=#constructor-overload><strong>Constructor overload</strong></a></li></ul></li><li><a href=#implementation-of-unsophisticated-nullptr>Implementation of unsophisticated nullptr</a></li><li><a href=#use-cases-of-nullptr>Use-cases of nullptr</a><ul><li><a href=#function-calling-clarity-with-nullptr>Function calling clarity with nullptr</a></li><li><a href=#typecasting-on-nullptr_t>Typecasting on nullptr_t</a></li><li><a href=#nullptr_t-is-comparable>nullptr_t is comparable</a></li><li><a href=#template-argument-is-of-type-stdnullptr_t>Template-argument is of type std::nullptr_t</a></li><li><a href=#conversion-to-bool-from-nullptr_t>Conversion to bool from nullptr_t</a></li><li><a href=#misc>Misc</a></li></ul></li><li><a href=#summary-by-faqs>Summary by FAQs</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>The answer to &ldquo;What exactly nullptr is in C++?&rdquo; would be a piece of cake for experienced C++ eyes & for those who are aware of <a href=/posts/21-new-features-of-modern-cpp-to-use-in-your-project/>Modern C++</a> i.e. keyword. But <code>nullptr</code> is more than just a keyword in C++ & to explain that, I have written this article. But before jump-into it, we will see issues with <code>NULL</code> & then we&rsquo;ll dive into the unsophisticated implementation of  <code>nullptr</code> & some use-cases of <code>nullptr</code>.</p><h2 id=why-do-we-need-nullptr>Why do we need nullptr?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-nullptr>#</a></h2><p><strong><em>To distinguish between an integer 0(zero) i.e. NULL & actual null of type pointer.</em></strong></p><h2 id=nullptr-vs-null>nullptr vs NULL<a hidden class=anchor aria-hidden=true href=#nullptr-vs-null>#</a></h2><ul><li><code>NULL</code> is <code>0</code>(zero) i.e. <strong>integer constant zero</strong> with <a href=/posts/cpp-type-casting-with-example-for-c-developers/>C-style typecast</a> to <code>void*</code>, while <code>nullptr</code> is <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>prvalue</a> of type <code>nullptr_t</code> which is <strong><em><a href=https://en.cppreference.com/w/cpp/language/integer_literal>integer literal</a></em></strong> <strong><em>evaluates to zero</em></strong>.</li><li>For those of you who believe that <code>NULL</code> is same i.e. <code>(void*)0</code> in C & C++. I would like to clarify that no it&rsquo;s not:</li></ul><p><a href=http://en.cppreference.com/w/c/types/NULL>NULL - cppreference.com</a> (C)</p><p><a href=http://en.cppreference.com/w/cpp/types/NULL>NULL - cppreference.com</a> (C++)</p><ul><li>C++ requires that macro <code>NULL</code> to be defined as an integral constant expression having the value of <code>0</code>. So unlike in C, <code>NULL</code> cannot be defined as <code>(void *)0</code> in the C++ standard library.</li></ul><h2 id=issues-with-null>Issues with NULL<a hidden class=anchor aria-hidden=true href=#issues-with-null>#</a></h2><h3 id=implicit-conversion><strong>Implicit conversion</strong><a hidden class=anchor aria-hidden=true href=#implicit-conversion>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=c1>// Implicit conversion from void * to char *
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>     <span class=c1>// OK, but `i` is not pointer type
</span></span></span></code></pre></td></tr></table></div></div><h3 id=function-calling-ambiguity><strong>Function calling ambiguity</strong><a hidden class=anchor aria-hidden=true href=#function-calling-ambiguity>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>){}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>bool</span><span class=p>){}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>     <span class=c1>// Which one to call?
</span></span></span></code></pre></td></tr></table></div></div><p>Compilation produces the following error:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>error: call to <span class=s1>&#39;func&#39;</span> is ambiguous
</span></span><span class=line><span class=cl>    func<span class=o>(</span>NULL<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    ^~~~
</span></span><span class=line><span class=cl>note: candidate <span class=k>function</span> void func<span class=o>(</span>bool<span class=o>){}</span>
</span></span><span class=line><span class=cl>                              ^
</span></span><span class=line><span class=cl>note: candidate <span class=k>function</span> void func<span class=o>(</span>int*<span class=o>){}</span>
</span></span><span class=line><span class=cl>                              ^
</span></span><span class=line><span class=cl>note: candidate <span class=k>function</span> void func<span class=o>(</span>int<span class=o>){}</span>
</span></span><span class=line><span class=cl>                              ^
</span></span><span class=line><span class=cl><span class=m>1</span> error generated.
</span></span><span class=line><span class=cl>compiler <span class=nb>exit</span> status <span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=constructor-overload><strong>Constructor overload</strong><a hidden class=anchor aria-hidden=true href=#constructor-overload>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>String</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span>    <span class=p>{</span>   <span class=cm>/* size of string */</span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=p>{</span>       <span class=cm>/* string */</span>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=nf>s1</span><span class=p>(</span> <span class=nb>NULL</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=nf>s2</span><span class=p>(</span> <span class=mi>5</span> <span class=p>);</span> 
</span></span></code></pre></td></tr></table></div></div><ul><li>In such cases, you need explicit cast (i.e., `String s((char*)0)).</li></ul><h2 id=implementation-of-unsophisticated-nullptr>Implementation of unsophisticated nullptr<a hidden class=anchor aria-hidden=true href=#implementation-of-unsophisticated-nullptr>#</a></h2><ul><li><code>nullptr</code> is a subtle example of <a href=/posts/7-advanced-cpp-concepts-idiom-examples-you-should-know/#Return-Type-Resolver>Return Type Resolver</a> idiom to automatically deduce a null pointer of the correct type depending upon the type of the instance it is assigning to.</li><li>Consider the following simplest & unsophisticated <code>nullptr</code> implementation:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>nullptr_t</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=k>operator</span><span class=o>&amp;</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>  <span class=c1>// Can&#39;t take address of nullptr
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kr>inline</span> <span class=k>operator</span> <span class=n>T</span><span class=o>*</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>C</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kr>inline</span> <span class=k>operator</span> <span class=n>T</span> <span class=n>C</span><span class=o>::*</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>nullptr_t</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>If the above code seems strange & weird to you(although it should not), then I would suggest you go through my earlier article on <a href=/posts/7-advanced-cpp-concepts-idiom-examples-you-should-know/#Return-Type-Resolver>advanced C++ concepts</a>. The magic here is just the templatized conversion operator.</li><li>If you are into a more authoritative source, then, here is a <a href=https://github.com/llvm-mirror/libcxx/blob/master/include/__nullptr>concrete implementation of nullptr from LLVM header</a>.</li></ul><h2 id=use-cases-of-nullptr>Use-cases of nullptr<a hidden class=anchor aria-hidden=true href=#use-cases-of-nullptr>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>C</span> <span class=p>{</span> <span class=kt>void</span> <span class=nf>func</span><span class=p>();</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>                <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=p>(</span><span class=n>C</span><span class=o>::*</span><span class=n>method_ptr</span><span class=p>)()</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>nullptr_t</span> <span class=n>n1</span><span class=p>,</span> <span class=n>n2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>n1</span> <span class=o>=</span> <span class=n>n2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//nullptr_t *null = &amp;n1;           // Address can&#39;t be taken.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>As shown in the above example, when <code>nullptr</code> is being assigned to an integer pointer, a <code>int</code> type instantiation of the templatized conversion function is created. And same goes for method pointers too.</li><li>This way by leveraging <a href=/posts/c-template-a-quick-uptodate-look/>C++ template</a> functionality, we are actually creating the appropriate type of null pointer every time we do, a new type assignment.</li><li>As <code>nullptr</code> is an <a href=https://en.cppreference.com/w/cpp/language/integer_literal>integer literal</a> with value zero, you can not able to use its address which we accomplished by deleting & operator.</li></ul><h3 id=function-calling-clarity-with-nullptr>Function calling clarity with nullptr<a hidden class=anchor aria-hidden=true href=#function-calling-clarity-with-nullptr>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>   <span class=p>{</span> <span class=cm>/* ... */</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>bool</span><span class=p>)</span>  <span class=p>{</span> <span class=cm>/* ... */</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>func</span><span class=p>(</span><span class=n>nullptr</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Now, <code>func( int* ) will be called as </code>nullptr<code> will implicitly be deduced to </code>int*`.</li></ul><h3 id=typecasting-on-nullptr_t>Typecasting on nullptr_t<a hidden class=anchor aria-hidden=true href=#typecasting-on-nullptr_t>#</a></h3><ul><li>A cast of <code>nullptr_t</code> to an integral type needs a <code>reinterpret_cast</code>, and has the same semantics as a cast of <code>(void*)0</code> to an integral type.</li><li>Casting <code>nullptr_t</code> to an integral type holds true as long as destination type is large enough. Consider this:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// int ptr_not_ok = reinterpret_cast&lt;int&gt;(nullptr); // Not OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>long</span> <span class=n>ptr_ok</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>long</span> <span class=kt>long</span><span class=o>&gt;</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span> <span class=c1>// OK
</span></span></span></code></pre></td></tr></table></div></div><ul><li>A <code>reinterpret_cast</code> cannot convert <code>nullptr_t</code> to any pointer type. Use <code>static_cast</code> instead.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span>    <span class=p>{</span> <span class=cm>/*...*/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>double</span><span class=o>*</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/*...*/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>                            <span class=c1>// compilation error, ambiguous call!
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// func(reinterpret_cast&lt;int*&gt;(nullptr)); // error: invalid cast from type &#39;std::nullptr_t&#39; to type &#39;int*&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>func</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=k>nullptr</span><span class=p>));</span>         <span class=c1>// OK
</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>nullptr</code> is implicitly convertible to any pointer type so explicit conversion with <code>static_cast</code> is only valid.</li></ul><h3 id=nullptr_t-is-comparable>nullptr_t is comparable<a hidden class=anchor aria-hidden=true href=#nullptr_t-is-comparable>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>          <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;=</span> <span class=k>nullptr</span><span class=p>);</span>    <span class=c1>// OK        
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>);</span>      <span class=c1>// error: invalid operands of types &#39;int&#39; and &#39;std::nullptr_t&#39; to binary &#39;operator==&#39;
</span></span></span></code></pre></td></tr></table></div></div><p>From <a href=https://en.wikipedia.org/wiki/C%2B%2B11#Null_pointer_constant>Wikipedia article</a>:</p><ul><li>…null pointer constant: <code>nullptr</code>. It is of type <code>nullptr_t</code>, which is implicitly convertible and comparable to any pointer type or pointer-to-member type.</li><li>It is not implicitly convertible or comparable to integral types, except for <code>bool</code>.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>);</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>);</span> <span class=c1>// error: invalid operands of types &#39;const int&#39; and &#39;std::nullptr_t&#39; to binary &#39;operator==&#39;
</span></span></span></code></pre></td></tr></table></div></div><h3 id=template-argument-is-of-type-stdnullptr_t>Template-argument is of type std::nullptr_t<a hidden class=anchor aria-hidden=true href=#template-argument-is-of-type-stdnullptr_t>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ptr_func</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=n>t</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ptr_func</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>         <span class=c1>// Can not deduce T
</span></span></span></code></pre></td></tr></table></div></div><ul><li>As discussed earlier, <a href=/posts/7-advanced-cpp-concepts-idiom-examples-you-should-know/#Return-Type-Resolver>Return Type Resolver</a> needs an assignee to deduce the type.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>val_func</span><span class=p>(</span><span class=n>T</span> <span class=n>t</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>val_func</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>         <span class=c1>// deduces T = nullptr_t
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>val_func</span><span class=p>((</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span><span class=k>nullptr</span><span class=p>);</span>   <span class=c1>// deduces T = int*, prefer static_cast though
</span></span></span></code></pre></td></tr></table></div></div><h3 id=conversion-to-bool-from-nullptr_t>Conversion to bool from nullptr_t<a hidden class=anchor aria-hidden=true href=#conversion-to-bool-from-nullptr_t>#</a></h3><p>From <a href=https://en.cppreference.com/w/cpp/language/implicit_conversion#Boolean_conversions>cppreference</a> :</p><ul><li><p>In the context of a <a href=https://en.cppreference.com/w/cpp/language/direct_initialization>direct-initialization</a>, a <code>bool</code> object may be initialized from a prvalue of type <a href=https://en.cppreference.com/w/cpp/types/nullptr_t><code>std::nullptr_t</code></a>, including <code>nullptr</code>. The resulting value is false. However, this is not considered to be an implicit conversion.</p></li><li><p>The conversion is only allowed for <a href=http://en.cppreference.com/w/cpp/language/direct_initialization>direct-initialization</a>, but not <a href=http://en.cppreference.com/w/cpp/language/copy_initialization>copy-intialization</a>, which including the case for passing an argument to a function by value. e.g.</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4>4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5>5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=n>b1</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// Not OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>b2</span> <span class=p>{</span><span class=k>nullptr</span><span class=p>};</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>bool</span><span class=p>){}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>     <span class=c1>// Not OK, need to do func(static_cast&lt;bool&gt;(nullptr));
</span></span></span></code></pre></td></tr></table></div></div><h3 id=misc>Misc<a hidden class=anchor aria-hidden=true href=#misc>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typeid</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>                            <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>throw</span> <span class=k>nullptr</span><span class=p>;</span>                              <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>expr</span> <span class=o>?</span> <span class=k>nullptr</span> <span class=o>:</span> <span class=k>nullptr</span><span class=p>;</span>       <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1>// char *ptr1 = expr ? 0 : nullptr;         // Not OK, types are not compatible
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static_assert</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>nullptr_t</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=summary-by-faqs>Summary by FAQs<a hidden class=anchor aria-hidden=true href=#summary-by-faqs>#</a></h2><p><strong>When was <code>nullptr</code> introduced?</strong></p><p>C++11</p><p><strong>Is <code>nullptr</code> a keyword or an instance of a type <code>std::nullptr_t</code>?</strong></p><p>Both <code>true</code> and <code>false</code> are keywords & literals, as they have a type ( <code>bool</code> ). <code>nullptr</code> is a <em>pointer literal</em> of type <code>std::nullptr_t</code>, & it&rsquo;s a prvalue (i.e. pure <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>rvalue</a>, you cannot take the address of it using <code>&</code>). <a href=https://stackoverflow.com/questions/1282295/what-exactly-is-nullptr>For more</a>.</p><p><strong>What are the advantages of using nullptr?</strong></p><ul><li>No function calling ambiguity between overload sets.</li><li>You can do <a href=/posts/c-template-a-quick-uptodate-look/>template specialization</a> with <code>nullptr_t</code>.</li><li>Code will become more safe, intuitive & expressive. <code>if (ptr == nullptr);</code> rather than <code>if (ptr == 0);</code>.</li></ul><p><strong>Is <code>NULL</code> in C++ equal to <code>nullptr</code> from C++11?</strong></p><p>Not at all. The following line does not even compile:</p><p><code>cout&lt;&lt;is_same_v&lt;nullptr, NULL>&lt;&lt;endl;</code></p><p><strong>Can I convert <code>nullptr</code> to bool?</strong></p><p>Yes. But only if you <a href=http://en.cppreference.com/w/cpp/language/direct_initialization>direct-initialization</a>. i.e. <code>bool is_false{nullptr};</code>. Else need to use <code>static_cast</code>.</p><p><strong>How is <code>nullptr</code> defined?</strong></p><p>It&rsquo;s just the templatized conversion operator known as <a href=/posts/7-advanced-cpp-concepts-idiom-examples-you-should-know/#Return-Type-Resolver>Return Type Resolver</a>.</p><p>What exactly nullptr is in C++?</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>You can find similar resources <a href=https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/nullptr>here</a>, <a href=https://stackoverflow.com/questions/1282295/what-exactly-is-nullptr/>here</a>, and in <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf>nullptr proposal(N2431)</a>; however, this post will walk you through the ins and outs of the spec step-by-step in a more friendly way so that you come away with a full understanding of the concept without any needless confusion</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/c-11-nullptr/>C-11-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-check-nullptr/>C-Check-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-if-nullptr/>C-if-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-nullptr/>C-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-reference-nullptr/>C-Reference-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/can-i-convert-nullptr-to-bool/>Can-I-Convert-Nullptr-to-Bool</a></li><li><a href=https://vishalchovatiya.github.io/tags/conversion-to-bool-from-nullptr_t/>Conversion-to-Bool-From-Nullptr_t</a></li><li><a href=https://vishalchovatiya.github.io/tags/cpp-nullptr/>Cpp-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-is-nullptr-defined/>How-Is-Nullptr-Defined</a></li><li><a href=https://vishalchovatiya.github.io/tags/if-nullptr/>If-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/is-null-in-c-equal-to-nullptr-from-c11/>Is-Null-in-C-Equal-to-Nullptr-From-C11</a></li><li><a href=https://vishalchovatiya.github.io/tags/is-nullptr-a-keyword-or-an-instance-of-a-type-stdnullptr_t/>Is-Nullptr-a-Keyword-or-an-Instance-of-a-Type-Stdnullptr_t</a></li><li><a href=https://vishalchovatiya.github.io/tags/null-nullptr/>Null-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/null-vs-nullptr-c/>Null-vs-Nullptr-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/nullptr/>Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/nullptr-cpp/>Nullptr-Cpp</a></li><li><a href=https://vishalchovatiya.github.io/tags/nullptr-in-c/>Nullptr-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/nullptr-vs-null/>Nullptr-vs-Null</a></li><li><a href=https://vishalchovatiya.github.io/tags/nullptr_t-is-comparable/>Nullptr_t-Is-Comparable</a></li><li><a href=https://vishalchovatiya.github.io/tags/qt-nullptr/>Qt-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/reinterpret_cast-on-nullptr/>Reinterpret_cast-on-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/return-nullptr-c/>Return-Nullptr-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/sizeofnullptr_t/>Sizeofnullptr_t</a></li><li><a href=https://vishalchovatiya.github.io/tags/template-argument-is-of-type-stdnullptr_t/>Template-Argument-Is-of-Type-Stdnullptr_t</a></li><li><a href=https://vishalchovatiya.github.io/tags/this-was-nullptr-c/>This-Was-Nullptr-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/typecasting-on-nullptr_t/>Typecasting-on-Nullptr_t</a></li><li><a href=https://vishalchovatiya.github.io/tags/use-cases-of-nullptr/>Use-Cases-of-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/what-are-the-advantages-of-using-nullptr/>What-Are-the-Advantages-of-Using-Nullptr</a></li><li><a href=https://vishalchovatiya.github.io/tags/what-exactly-nullptr-is-in-c/>What-Exactly-Nullptr-Is-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/when-was-nullptr-introduced/>When-Was-Nullptr-Introduced</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/template-method-design-pattern-in-modern-cpp/><span class=title>« Prev</span><br><span>Template Method Design Pattern in Modern C++</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/><span class=title>Next »</span><br><span>7 Advance C++ Concepts & Idiom Examples You Should Know</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share What Exactly nullptr Is in C++? on x" href="https://x.com/intent/tweet/?text=What%20Exactly%20nullptr%20Is%20in%20C%2b%2b%3f&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fwhat-exactly-nullptr-is-in-cpp%2f&amp;hashtags=c-11-nullptr%2cc-check-nullptr%2cc-if-nullptr%2cc-nullptr%2cc-reference-nullptr%2ccan-i-convert-nullptr-to-bool%2cconversion-to-bool-from-nullptr_t%2ccpp-nullptr%2chow-is-nullptr-defined%2cif-nullptr%2cis-null-in-c-equal-to-nullptr-from-c11%2cis-nullptr-a-keyword-or-an-instance-of-a-type-stdnullptr_t%2cnull-nullptr%2cnull-vs-nullptr-c%2cnullptr%2cnullptr-cpp%2cnullptr-in-c%2cnullptr-vs-null%2cnullptr_t-is-comparable%2cqt-nullptr%2creinterpret_cast-on-nullptr%2creturn-nullptr-c%2csizeofnullptr_t%2ctemplate-argument-is-of-type-stdnullptr_t%2cthis-was-nullptr-c%2ctypecasting-on-nullptr_t%2cuse-cases-of-nullptr%2cwhat-are-the-advantages-of-using-nullptr%2cwhat-exactly-nullptr-is-in-c%2cwhen-was-nullptr-introduced"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What Exactly nullptr Is in C++? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fwhat-exactly-nullptr-is-in-cpp%2f&amp;title=What%20Exactly%20nullptr%20Is%20in%20C%2b%2b%3f&amp;summary=What%20Exactly%20nullptr%20Is%20in%20C%2b%2b%3f&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fwhat-exactly-nullptr-is-in-cpp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What Exactly nullptr Is in C++? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fwhat-exactly-nullptr-is-in-cpp%2f&title=What%20Exactly%20nullptr%20Is%20in%20C%2b%2b%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What Exactly nullptr Is in C++? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fwhat-exactly-nullptr-is-in-cpp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What Exactly nullptr Is in C++? on whatsapp" href="https://api.whatsapp.com/send?text=What%20Exactly%20nullptr%20Is%20in%20C%2b%2b%3f%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fwhat-exactly-nullptr-is-in-cpp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What Exactly nullptr Is in C++? on telegram" href="https://telegram.me/share/url?text=What%20Exactly%20nullptr%20Is%20in%20C%2b%2b%3f&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fwhat-exactly-nullptr-is-in-cpp%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What Exactly nullptr Is in C++? on ycombinator" href="https://news.ycombinator.com/submitlink?t=What%20Exactly%20nullptr%20Is%20in%20C%2b%2b%3f&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fwhat-exactly-nullptr-is-in-cpp%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>