<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>7 Advance C++ Concepts & Idiom Examples You Should Know | Vishal Chovatiya</title>
<meta name=keywords content="a-function-cannot-be-overloaded-only-by-its-return-type,abstract-factory-design-pattern-c,advanced-c-concepts,advanced-c-metaprogramming,c-metaprogramming,c-sfinae,c-sfinae-examples,c-stdfunction-type-erasure,c-template-base-class-polymorphism,c-template-interface,c-template-metaprogramming,c-template-proxy-class,c-type-erasure-without-dynamic-allocation,c17-type-erasure,container-class-and-proxy-class-in-c,crtp,crtp-c,crtp-example-c,double-operator-overloading-c,factory-design-pattern,factory-method,factory-pattern-c,function-overloading-return-type,proxy-class-example-c,proxy-class-in-c,pure-virtual-constructor-c,raii-c,raii-example,raii-idiom,resource-acquisition-is-initialization,return-type-resolver,return-type-resolver-c-example,return-type-resolver-idiom,sfinae,sfinae-stdenable_if,sfinae-c,sfinae-enable_if-function,sfinae-example-c,sfinae-example-enable_if,sfinae-member-function,static-and-dynamic-polymorphism,static-polymorphism,stdany-implementation,substitution-failure-is-not-an-error,temporary-proxy,type-erasure,type-erasure-c-shared_ptr,type-erasure-c-stackoverflow,type-erasure-using-polymorphism,type-erasure-using-templates,type-erasure-using-union,unique_ptr-type-erasure,upside-down-inheritance,virtual-constructor,virtual-constructor-clone,virtual-constructor-c,virtual-constructor-example,virtual-copy-constructor,virtual-copy-constructor-c,virtual-destructor-in-c"><meta name=description content="So I have started updating myself with Modern C++ a while ago & since my post 21 new features of Modern C++ to use in your project & All about lambda function in C++ was popular I decided to write about advance C++ concepts & idioms which I have learned from this wikibook & course.
There are many other advance C++ concepts & idioms as well but I consider these 7 as &ldquo;should-know&rdquo;."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=http://localhost:1313/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="7 Advance C++ Concepts & Idiom Examples You Should Know"><meta property="og:description" content="So I have started updating myself with Modern C++ a while ago & since my post 21 new features of Modern C++ to use in your project & All about lambda function in C++ was popular I decided to write about advance C++ concepts & idioms which I have learned from this wikibook & course.
There are many other advance C++ concepts & idioms as well but I consider these 7 as &ldquo;should-know&rdquo;."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/"><meta property="og:image" content="http://localhost:1313/images/7-Advanced-C-programming-styles-and-idiom-examples-you-should-know-vishal-chovatiya.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-11-16T00:00:00+00:00"><meta property="article:modified_time" content="2019-11-16T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/7-Advanced-C-programming-styles-and-idiom-examples-you-should-know-vishal-chovatiya.png"><meta name=twitter:title content="7 Advance C++ Concepts & Idiom Examples You Should Know"><meta name=twitter:description content="So I have started updating myself with Modern C++ a while ago & since my post 21 new features of Modern C++ to use in your project & All about lambda function in C++ was popular I decided to write about advance C++ concepts & idioms which I have learned from this wikibook & course.
There are many other advance C++ concepts & idioms as well but I consider these 7 as &ldquo;should-know&rdquo;."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"7 Advance C++ Concepts \u0026 Idiom Examples You Should Know","item":"http://localhost:1313/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"7 Advance C++ Concepts \u0026 Idiom Examples You Should Know","name":"7 Advance C\u002b\u002b Concepts \u0026 Idiom Examples You Should Know","description":"So I have started updating myself with Modern C++ a while ago \u0026amp; since my post 21 new features of Modern C++ to use in your project \u0026amp; All about lambda function in C++ was popular I decided to write about advance C++ concepts \u0026amp; idioms which I have learned from this wikibook \u0026amp; course.\nThere are many other advance C++ concepts \u0026amp; idioms as well but I consider these 7 as \u0026ldquo;should-know\u0026rdquo;.","keywords":["a-function-cannot-be-overloaded-only-by-its-return-type","abstract-factory-design-pattern-c","advanced-c-concepts","advanced-c-metaprogramming","c-metaprogramming","c-sfinae","c-sfinae-examples","c-stdfunction-type-erasure","c-template-base-class-polymorphism","c-template-interface","c-template-metaprogramming","c-template-proxy-class","c-type-erasure-without-dynamic-allocation","c17-type-erasure","container-class-and-proxy-class-in-c","crtp","crtp-c","crtp-example-c","double-operator-overloading-c","factory-design-pattern","factory-method","factory-pattern-c","function-overloading-return-type","proxy-class-example-c","proxy-class-in-c","pure-virtual-constructor-c","raii-c","raii-example","raii-idiom","resource-acquisition-is-initialization","return-type-resolver","return-type-resolver-c-example","return-type-resolver-idiom","sfinae","sfinae-stdenable_if","sfinae-c","sfinae-enable_if-function","sfinae-example-c","sfinae-example-enable_if","sfinae-member-function","static-and-dynamic-polymorphism","static-polymorphism","stdany-implementation","substitution-failure-is-not-an-error","temporary-proxy","type-erasure","type-erasure-c-shared_ptr","type-erasure-c-stackoverflow","type-erasure-using-polymorphism","type-erasure-using-templates","type-erasure-using-union","unique_ptr-type-erasure","upside-down-inheritance","virtual-constructor","virtual-constructor-clone","virtual-constructor-c","virtual-constructor-example","virtual-copy-constructor","virtual-copy-constructor-c","virtual-destructor-in-c"],"articleBody":"So I have started updating myself with Modern C++ a while ago \u0026 since my post 21 new features of Modern C++ to use in your project \u0026 All about lambda function in C++ was popular I decided to write about advance C++ concepts \u0026 idioms which I have learned from this wikibook \u0026 course.\nThere are many other advance C++ concepts \u0026 idioms as well but I consider these 7 as “should-know”. To explain them, I have taken a more pragmatic approach than sophistication. So, I have weighed more on readability, simplicity over other fancy features, syntax sugars and complexity.\nNote: There are also drawbacks of using some of these techniques which I have not discussed here or maybe I am not qualified enough.\n1. RAII Intent: To guarantee the release of resource(s) at the end of a scope.\nImplementation: Wrap resource into a class; resource acquired in the constructor immediately after its allocation; and automatically released in the destructor; resource used via an interface of the class;\nAlso known as: Execute-around object, Resource release is finalization, Scope-bound resource management\nProblem Resource Acquisition Is Initialization idiom is the most powerful \u0026 vastly used idiom although the name is really terrible as the idiom is rather about resource release than acquisition. RAII guarantee the release of resource at the end of a scope/destruction. It thus ensures no resource leaks and provides basic exception safety guarantee. struct resource { resource(int x, int y) { cout \u003c\u003c \"resource acquired\\n\"; } ~resource() { cout \u003c\u003c \"resource destroyed\\n\"; } }; void func() { resource *ptr = new resource(1, 2); int x; std::cout \u003c\u003c \"Enter an integer: \"; std::cin \u003e\u003e x; if (x == 0) throw 0; // the function returns early, and ptr won't be deleted! if (x \u003c 0) return; // the function returns early, and ptr won't be deleted! // do stuff with ptr here delete ptr; } In the above code, the early return or throw statement, causing the function to terminate without ptr being deleted. In addition, the memory allocated for variable ptr is now leaked (and leaked again every time this function is called and returns early). Solution template\u003cclass T\u003e class smart_ptr { T* m_ptr; public: template\u003ctypename... Args\u003e smart_ptr(Args\u0026\u0026... args) : m_ptr(new T(std::forward\u003cArgs\u003e(args)...)){} ~smart_ptr() { delete m_ptr; } smart_ptr(const smart_ptr\u0026 rhs) = delete; smart_ptr\u0026 operator=(const smart_ptr\u0026 rhs) = delete; smart_ptr(smart_ptr\u0026\u0026 rhs) : m_ptr(exchange(rhs.m_ptr, nullptr)){} smart_ptr\u0026 operator=(smart_ptr\u0026\u0026 rhs){ if (\u0026rhs == this) return *this; delete m_ptr; m_ptr = exchange(rhs.m_ptr,nullptr); return *this; } T\u0026 operator*() const { return *m_ptr; } T* operator-\u003e() const { return m_ptr; } }; void func() { auto ptr = smart_ptr\u003cresource\u003e(1, 2); // now ptr guarantee the release of resource // ... } Note that no matter what happens after ptr declaration, ptr will be destroyed when the function terminates (regardless of how it terminates). As the ptr is a local object, the destructor will be called while the function stack frame rewinds. Hence, we are assured that the resource will be properly cleaned up. Usecases Using RAII, resources like new/delete, malloc/free, acquire/release, mutex lock/unlock, file open/close, count ++/--, database connect/disconnect or anything else that exists in limited supply can easily be managed. Examples from C++ Standard Library include std::unique_ptr, std::ofstream, std::lock_guard, etc. 2. Return Type Resolver Intent: To deduce the type of the object being initialize or assign to.\nImplementation: Uses templatized conversion operator.\nAlso known as: Return type overloading\nIssue int from_string(const char *str) { return std::stoi(str); } float from_string(const char *str) { return std::stof(str); } // error A function can not overloaded only by its return type. Solution class from_string { const string m_str; public: from_string(const char *str) : m_str(str) {} template \u003ctypename type\u003e operator type(){ if constexpr(is_same_v\u003ctype, float\u003e) return stof(m_str); else if (is_same_v\u003ctype, int\u003e) return stoi(m_str); } }; int n_int = from_string(\"123\"); float n_float = from_string(\"123.111\"); // Will only work with C++17 due to `is_same_v` If you are unaware of constexpr, I have written a short post on when to use const vs constexpr in c++.\nUsecases So, when you use nullptr(introduced in C++11), this is the technique that runs under the hood to deduce the correct type depending upon the pointer variable it is assigning to. You can also overcome the function overloading limitation on the basis of a return type as we have seen above. Return Type Resolver can also used to provide a generic interface for assignment, independent of the object assigned to. 3. Type Erasure Intent: To create generic container that can handle a variety of concrete types.\nImplementation: Can be implemented by void*, templates, polymorphism, union, proxy class, etc.\nAlso known as: Duck-typing\nProblem C++ is a statically typed language with strong typing. In statically typed languages, object type known \u0026 set at compile-time. While in dynamically typed languages the type associated with run-time values. In other words, in strongly typed languages the type of an object doesn’t change after compilation. However, to overcome this limitation \u0026 providing a feature like dynamically typed languages, library designers come up with various generic container kind of things like std::any(C++17), std::variant (C++17), std::function(C++11), etc. Different Type Erasure Techniques There is no one strict rule on how to implement this idiom, it can have various forms with its own drawbacks as follows: =\u003e Type erasure using void* (like in C)\nvoid qsort (void* base, size_t num, size_t size, int (*compare)(const void*,const void*)); Drawback: not safe \u0026 separate compare function needed for each type\n=\u003e Type erasure using C++ templates\ntemplate \u003cclass RandomAccessIterator\u003e void sort(RandomAccessIterator first, RandomAccessIterator last); Drawback: may lead to many function template instantiations \u0026 longer compilation time\n=\u003e Type erasure using polymorphism\nstruct base { virtual void method() = 0; }; struct derived_1 : base { void method() { cout \u003c\u003c \"derived_1\\n\"; } }; struct derived_2 : base { void method() { cout \u003c\u003c \"derived_2\\n\"; } }; // We don't see a concrete type (it's erased) though can dynamic_cast void call(base* ptr) { ptr-\u003emethod(); }; Drawback: run-time cost (dynamic dispatch, indirection, vtable, etc.)\n=\u003e Type erasure using union\nstruct Data {}; union U { Data d; // occupies 1 byte std::int32_t n; // occupies 4 bytes char c; // occupies 1 byte ~U() {} // need to know currently active type }; // an instance of U in total occupies 4 bytes. Drawback: not type-safe\nSolution As I mentioned earlier that standard library already has such generic containers. To understand type erasure better let’s implement one i.e. std::any: struct any { struct base {}; template\u003ctypename T\u003e struct inner: base{ inner(T t): m_t{std::move(t)} {} T m_t; static void type() {} }; any(): m_ptr{nullptr}, typePtr{nullptr} {} template\u003ctypename T\u003e any(T \u0026\u0026 t): m_ptr{std::make_unique\u003cinner\u003cT\u003e\u003e(t)}, typePtr{\u0026inner\u003cT\u003e::type} {} template\u003ctypename T\u003e any\u0026 operator=(T\u0026\u0026 t){ m_ptr = std::make_unique\u003cinner\u003cT\u003e\u003e(t); typePtr = \u0026inner\u003cT\u003e::type; return *this; } private: template\u003ctypename T\u003e friend T\u0026 any_cast(const any\u0026 var); std::unique_ptr\u003cbase\u003e m_ptr = nullptr; void (*typePtr)() = nullptr; }; template\u003ctypename T\u003e T\u0026 any_cast(const any\u0026 var) { if(var.typePtr == any::inner\u003cT\u003e::type) return static_cast\u003cany::inner\u003cT\u003e*\u003e(var.m_ptr.get())-\u003em_t; throw std::logic_error{\"Bad cast!\"}; } int main() { any var(10); std::cout \u003c\u003c any_cast\u003cint\u003e(var) \u003c\u003c std::endl; var = std::string{\"some text\"}; std::cout \u003c\u003c any_cast\u003cstd::string\u003e(var) \u003c\u003c std::endl; return 0; } Especially, the thing here to note is how we are leveraging empty static method i.e. inner::type() to determine template instance type in any_cast.\nUsecases Employ to handle multiple types of the return value from function/method(Although that’s not recommended advice). 4. CRTP Intent: To achieve static polymorphism.\nImplementation: Make use of base class template spcialization.\nAlso known as: Upside-down inheritance, Static polymorphism\nProblem struct obj_type_1 { bool operator\u003c(const value \u0026rhs) const {return m_x \u003c rhs.m_x;} // bool operator==(const value \u0026rhs) const; // bool operator!=(const value \u0026rhs) const; // List goes on. . . . . . . . . . . . . . . . . . . . private: // data members to compare }; struct obj_type_2 { bool operator\u003c(const value \u0026rhs) const {return m_x \u003c rhs.m_x;} // bool operator==(const value \u0026rhs) const; // bool operator!=(const value \u0026rhs) const; // List goes on. . . . . . . . . . . . . . . . . . . . private: // data members to compare }; struct obj_type_3 { ... struct obj_type_4 { ... // List goes on. . . . . . . . . . . . . . . . . . . . For each comparable objects, you need to define respective comparison operators. This is redundant because if we have an operator \u003c , we can overload other operators on the basis of it. Thus, operator \u003c is the only one operator having type information, other operators can be made type independent for reusability purpose. Solution Curiously Recurring Template Pattern implementation rule is simple, separate out the type-dependent \u0026 independent functionality and bind type independent functionality with the base class using self-referencing template. Above line may seem cryptic at first. So, consider the below solution to the above problem for more clarity: template \u003cclass derived\u003e struct compare {}; struct value : compare\u003cvalue\u003e { int m_x; value(int x) : m_x(x) {} bool operator\u003c(const value \u0026rhs) const { return m_x \u003c rhs.m_x; } }; template \u003cclass derived\u003e bool operator \u003e (const compare\u003cderived\u003e \u0026lhs, const compare\u003cderived\u003e \u0026rhs) { // static_assert(std::is_base_of_v","wordCount":"3048","inLanguage":"en","image":"http://localhost:1313/images/7-Advanced-C-programming-styles-and-idiom-examples-you-should-know-vishal-chovatiya.png","datePublished":"2019-11-16T00:00:00Z","dateModified":"2019-11-16T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=http://localhost:1313/posts/ title=Latest><span>Latest</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">7 Advance C++ Concepts & Idiom Examples You Should Know</h1><div class=post-meta><span title='2019-11-16 00:00:00 +0000 UTC'>November 16, 2019</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3048 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/7-advance-cpp-concepts-idiom-examples-you-should-know.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/images/7-Advanced-C-programming-styles-and-idiom-examples-you-should-know-vishal-chovatiya.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#1-raii>1. RAII</a></li><li><a href=#2-return-type-resolver>2. Return Type Resolver</a></li><li><a href=#3-type-erasure>3. Type Erasure</a></li><li><a href=#4-crtp>4. CRTP</a></li><li><a href=#5-virtual-constructor>5. Virtual Constructor</a></li><li><a href=#6-sfinae-and-stdenable_if>6. SFINAE and std::enable_if</a></li><li><a href=#7-proxy>7. Proxy</a></li><li><a href=#summary-by-faqs>Summary by FAQs</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>So I have started updating myself with Modern C++ a while ago & since my post <a href=/posts/21-new-features-of-modern-cpp-to-use-in-your-project/>21 new features of Modern C++ to use in your project</a> & <a href=/posts/learn-lambda-function-in-cpp-with-example/>All about lambda function in C++</a> was popular I decided to write about advance C++ concepts & idioms which I have learned from this <a href=https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms>wikibook</a> & <a href=https://www.udemy.com/course/cpp-in-detail-common-idioms/>course</a>.</p><p>There are many other advance C++ concepts & idioms as well but I consider these 7 as &ldquo;should-know&rdquo;. To explain them, I have taken a more pragmatic approach than sophistication. So, I have weighed more on readability, simplicity over other fancy features, syntax sugars and complexity.</p><p><strong><em>Note:</em></strong> There are also drawbacks of using some of these techniques which I have not discussed here or maybe I am not qualified enough.</p><h3 id=1-raii>1. RAII<a hidden class=anchor aria-hidden=true href=#1-raii>#</a></h3><p><strong><em>Intent:</em></strong> To guarantee the release of resource(s) at the end of a scope.<br><strong><em>Implementation:</em></strong> Wrap resource into a class; resource acquired in the constructor immediately after its allocation; and automatically released in the destructor; resource used via an interface of the class;<br><strong><em>Also known as:</em></strong> Execute-around object, Resource release is finalization, Scope-bound resource management</p><h4 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h4><ul><li><strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization idiom is the most powerful & vastly used idiom although the name is really terrible as the idiom is rather about resource release than acquisition.</li><li>RAII guarantee the release of resource at the end of a scope/destruction. It thus ensures no resource leaks and provides basic <a href=/posts/7-best-practices-for-exception-handling-in-cpp-with-example/>exception safety guarantee</a>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>resource</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>resource</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;resource acquired</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>resource</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;resource destroyed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>resource</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>resource</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Enter an integer: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// the function returns early, and ptr won&#39;t be deleted!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span> <span class=c1>// the function returns early, and ptr won&#39;t be deleted!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// do stuff with ptr here
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>delete</span> <span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>In the above code, the early <code>return</code> or <code>throw</code> statement, causing the function to terminate without <code>ptr</code> being deleted.</li><li>In addition, the memory allocated for variable <code>ptr</code> is now leaked (and leaked again every time this function is called and returns early).</li></ul><h4 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>smart_ptr</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_ptr</span><span class=p>(</span><span class=k>new</span> <span class=n>T</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...)){}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>smart_ptr</span><span class=p>()</span> <span class=p>{</span> <span class=k>delete</span> <span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=p>(</span><span class=k>const</span> <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&amp;&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_ptr</span><span class=p>(</span><span class=n>exchange</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>)){}</span>
</span></span><span class=line><span class=cl>    <span class=n>smart_ptr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>smart_ptr</span><span class=o>&amp;&amp;</span> <span class=n>rhs</span><span class=p>){</span>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>rhs</span> <span class=o>==</span> <span class=k>this</span><span class=p>)</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>m_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>m_ptr</span> <span class=o>=</span> <span class=n>exchange</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>,</span><span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>*</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=k>operator</span><span class=o>-&gt;</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_ptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>smart_ptr</span><span class=o>&lt;</span><span class=n>resource</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// now ptr guarantee the release of resource
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>Note that no matter what happens after <code>ptr</code> declaration, <code>ptr</code> will be destroyed when the function terminates (regardless of how it terminates).</li><li>As the <code>ptr</code> is a local <a href=/posts/memory-layout-of-cpp-object/>object</a>, the destructor will be called while the <a href=/posts/how-c-program-convert-into-assembly/>function stack frame</a> rewinds. Hence, we are assured that the <code>resource</code> will be properly cleaned up.</li></ul><h4 id=usecases>Usecases<a hidden class=anchor aria-hidden=true href=#usecases>#</a></h4><ul><li>Using RAII, resources like <code>new</code>/<code>delete</code>, <code>malloc</code>/<code>free</code>, acquire/release, mutex lock/unlock, file open/close, count <code>++</code>/<code>--</code>, database connect/disconnect or anything else that exists in limited supply can easily be managed.</li><li>Examples from C++ Standard Library include <a href=/posts/understanding-unique-ptr-with-example-in-cpp11/><code>std::unique_ptr</code></a>, <code>std::ofstream</code>, <code>std::lock_guard</code>, etc.</li></ul><h3 id=2-return-type-resolver>2. Return Type Resolver<a hidden class=anchor aria-hidden=true href=#2-return-type-resolver>#</a></h3><p><strong><em>Intent:</em></strong> To deduce the type of the object being initialize or assign to.<br><strong><em>Implementation:</em></strong> Uses templatized conversion operator.<br><strong><em>Also known as:</em></strong> Return type overloading</p><h4 id=issue>Issue<a hidden class=anchor aria-hidden=true href=#issue>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>from_string</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>stoi</span><span class=p>(</span><span class=n>str</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>from_string</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>stof</span><span class=p>(</span><span class=n>str</span><span class=p>);</span> <span class=p>}</span> <span class=c1>// error
</span></span></span></code></pre></div><ul><li>A function can not overloaded only by its return type.</li></ul><h4 id=solution-1>Solution<a hidden class=anchor aria-hidden=true href=#solution-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>from_string</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>string</span> <span class=n>m_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>from_string</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_str</span><span class=p>(</span><span class=n>str</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=n>type</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nf>constexpr</span><span class=p>(</span><span class=n>is_same_v</span><span class=o>&lt;</span><span class=n>type</span><span class=p>,</span> <span class=kt>float</span><span class=o>&gt;</span><span class=p>)</span>        <span class=k>return</span> <span class=n>stof</span><span class=p>(</span><span class=n>m_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>is_same_v</span><span class=o>&lt;</span><span class=n>type</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>)</span>              <span class=k>return</span> <span class=n>stoi</span><span class=p>(</span><span class=n>m_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n_int</span> <span class=o>=</span> <span class=n>from_string</span><span class=p>(</span><span class=s>&#34;123&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>n_float</span> <span class=o>=</span> <span class=n>from_string</span><span class=p>(</span><span class=s>&#34;123.111&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Will only work with C++17 due to `is_same_v`
</span></span></span></code></pre></div><p>If you are unaware of constexpr, I have written a short post on <a href=/posts/when-to-use-const-vs-constexpr-in-cpp/>when to use const vs constexpr in c++</a>.</p><h4 id=usecases-1>Usecases<a hidden class=anchor aria-hidden=true href=#usecases-1>#</a></h4><ul><li>So, when you use <a href=/posts/what-exactly-nullptr-is-in-cpp/><code>nullptr</code></a>(introduced in C++11), this is the technique that runs under the hood to deduce the correct type depending upon the pointer variable it is assigning to.</li><li>You can also overcome the function overloading limitation on the basis of a return type as we have seen above.</li><li>Return Type Resolver can also used to provide a generic interface for <a href=/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/>assignment</a>, independent of the object assigned to.</li></ul><h3 id=3-type-erasure>3. Type Erasure<a hidden class=anchor aria-hidden=true href=#3-type-erasure>#</a></h3><p><strong><em>Intent:</em></strong> To create generic container that can handle a variety of concrete types.<br><strong><em>Implementation:</em></strong> Can be implemented by <code>void*</code>, templates, polymorphism, union, proxy class, etc.<br><strong><em>Also known as:</em></strong> Duck-typing</p><h4 id=problem-1>Problem<a hidden class=anchor aria-hidden=true href=#problem-1>#</a></h4><ul><li>C++ is a <a href=/posts/cpp-type-casting-with-example-for-c-developers/>statically typed</a> language with strong typing. In statically typed languages, object type known & set at compile-time. While in dynamically typed languages the type associated with run-time values.</li><li>In other words, in strongly typed languages the type of an object doesn&rsquo;t change after compilation.</li><li>However, to overcome this limitation & providing a feature like dynamically typed languages, library designers come up with various generic container kind of things like <a href=https://en.cppreference.com/w/cpp/utility/any><code>std::any</code></a>(C++17), <a href=https://en.cppreference.com/w/cpp/utility/variant><code>std::variant</code></a> (C++17), <a href=https://en.cppreference.com/w/cpp/utility/functional/function><code>std::function</code></a>(C++11), etc.</li></ul><h4 id=different-type-erasure-techniques>Different Type Erasure Techniques<a hidden class=anchor aria-hidden=true href=#different-type-erasure-techniques>#</a></h4><ul><li>There is no one strict rule on how to implement this idiom, it can have various forms with its own drawbacks as follows:</li></ul><p><strong>=> Type erasure using void* (like in C)</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>qsort</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>base</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>num</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>compare</span><span class=p>)(</span><span class=k>const</span> <span class=kt>void</span><span class=o>*</span><span class=p>,</span><span class=k>const</span> <span class=kt>void</span><span class=o>*</span><span class=p>));</span>
</span></span></code></pre></div><p><em>Drawback:</em> not safe & separate compare function needed for each type</p><p><strong>=> Type erasure using <a href=/posts/c-template-a-quick-uptodate-look/>C++ templates</a></strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>RandomAccessIterator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>sort</span><span class=p>(</span><span class=n>RandomAccessIterator</span> <span class=n>first</span><span class=p>,</span> <span class=n>RandomAccessIterator</span> <span class=n>last</span><span class=p>);</span>
</span></span></code></pre></div><p><em>Drawback:</em> may lead to many function template instantiations & longer compilation time</p><p><strong>=> Type erasure using polymorphism</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>base</span> <span class=p>{</span> <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>method</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>derived_1</span> <span class=o>:</span> <span class=n>base</span> <span class=p>{</span> <span class=kt>void</span> <span class=nf>method</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;derived_1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>derived_2</span> <span class=o>:</span> <span class=n>base</span> <span class=p>{</span> <span class=kt>void</span> <span class=nf>method</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;derived_2</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// We don&#39;t see a concrete type (it&#39;s erased) though can dynamic_cast
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>call</span><span class=p>(</span><span class=n>base</span><span class=o>*</span> <span class=n>ptr</span><span class=p>)</span> <span class=p>{</span> <span class=n>ptr</span><span class=o>-&gt;</span><span class=n>method</span><span class=p>();</span> <span class=p>};</span>
</span></span></code></pre></div><p><em>Drawback:</em> run-time cost (dynamic dispatch, indirection, vtable, etc.)</p><p><strong>=> Type erasure using union</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Data</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nc>U</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Data</span> <span class=n>d</span><span class=p>;</span>         <span class=c1>// occupies 1 byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=kt>int32_t</span> <span class=n>n</span><span class=p>;</span> <span class=c1>// occupies 4 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>c</span><span class=p>;</span>         <span class=c1>// occupies 1 byte
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>U</span><span class=p>()</span> <span class=p>{}</span>         <span class=c1>// need to know currently active type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span> <span class=c1>// an instance of U in total occupies 4 bytes.
</span></span></span></code></pre></div><p><em>Drawback:</em> not <a href=/posts/cpp-type-casting-with-example-for-c-developers/>type-safe</a></p><h4 id=solution-2>Solution<a hidden class=anchor aria-hidden=true href=#solution-2>#</a></h4><ul><li>As I mentioned earlier that standard library already has such generic containers.</li><li>To understand type erasure better let&rsquo;s implement one i.e. <code>std::any</code>:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>any</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>base</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>inner</span><span class=o>:</span> <span class=n>base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>inner</span><span class=p>(</span><span class=n>T</span> <span class=n>t</span><span class=p>)</span><span class=o>:</span> <span class=n>m_t</span><span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>t</span><span class=p>)}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=n>m_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>void</span> <span class=nf>type</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>any</span><span class=p>()</span><span class=o>:</span> <span class=n>m_ptr</span><span class=p>{</span><span class=k>nullptr</span><span class=p>},</span> <span class=n>typePtr</span><span class=p>{</span><span class=k>nullptr</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>any</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;&amp;</span> <span class=n>t</span><span class=p>)</span><span class=o>:</span> <span class=n>m_ptr</span><span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>inner</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>t</span><span class=p>)},</span> <span class=n>typePtr</span><span class=p>{</span><span class=o>&amp;</span><span class=n>inner</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>any</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>t</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>m_ptr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>inner</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>t</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=n>typePtr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>inner</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>any_cast</span><span class=p>(</span><span class=k>const</span> <span class=n>any</span><span class=o>&amp;</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>base</span><span class=o>&gt;</span> <span class=n>m_ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>typePtr</span><span class=p>)()</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span><span class=o>&amp;</span> <span class=n>any_cast</span><span class=p>(</span><span class=k>const</span> <span class=n>any</span><span class=o>&amp;</span> <span class=n>var</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>var</span><span class=p>.</span><span class=n>typePtr</span> <span class=o>==</span> <span class=n>any</span><span class=o>::</span><span class=n>inner</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>any</span><span class=o>::</span><span class=n>inner</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;*&gt;</span><span class=p>(</span><span class=n>var</span><span class=p>.</span><span class=n>m_ptr</span><span class=p>.</span><span class=n>get</span><span class=p>())</span><span class=o>-&gt;</span><span class=n>m_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>logic_error</span><span class=p>{</span><span class=s>&#34;Bad cast!&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>any</span> <span class=n>var</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>any_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>{</span><span class=s>&#34;some text&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>any_cast</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Especially, the thing here to note is how we are leveraging empty static method i.e. <code>inner&lt;T>::type()</code> to determine template instance type in <code>any_cast&lt;T></code>.</p><h4 id=usecases-2>Usecases<a hidden class=anchor aria-hidden=true href=#usecases-2>#</a></h4><ul><li>Employ to handle multiple types of the return value from function/method(Although that&rsquo;s not recommended advice).</li></ul><h3 id=4-crtp>4. CRTP<a hidden class=anchor aria-hidden=true href=#4-crtp>#</a></h3><p><strong><em>Intent:</em></strong> To achieve static polymorphism.<br><strong><em>Implementation:</em></strong> Make use of base class template spcialization.<br><strong><em>Also known as:</em></strong> Upside-down inheritance, Static polymorphism</p><h4 id=problem-2>Problem<a hidden class=anchor aria-hidden=true href=#problem-2>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>obj_type_1</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=n>value</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=n>m_x</span> <span class=o>&lt;</span> <span class=n>rhs</span><span class=p>.</span><span class=n>m_x</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// bool operator==(const value &amp;rhs) const;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// bool operator!=(const value &amp;rhs) const;    
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// List goes on. . . . . . . . . . . . . . . . . . . .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// data members to compare
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>obj_type_2</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=n>value</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=n>m_x</span> <span class=o>&lt;</span> <span class=n>rhs</span><span class=p>.</span><span class=n>m_x</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// bool operator==(const value &amp;rhs) const;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// bool operator!=(const value &amp;rhs) const;    
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// List goes on. . . . . . . . . . . . . . . . . . . .
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// data members to compare
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>obj_type_3</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>obj_type_4</span> <span class=p>{</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// List goes on. . . . . . . . . . . . . . . . . . . .
</span></span></span></code></pre></div><ul><li>For each comparable objects, you need to define respective comparison operators. This is redundant because if we have an <code>operator &lt;</code> , we can overload other operators on the basis of it.</li><li>Thus, <code>operator &lt;</code> is the only one operator having type information, other operators can be made type independent for reusability purpose.</li></ul><h4 id=solution-3>Solution<a hidden class=anchor aria-hidden=true href=#solution-3>#</a></h4><ul><li><strong>C</strong>uriously <strong>R</strong>ecurring <strong>T</strong>emplate <strong>P</strong>attern implementation rule is simple, <strong><em>separate out the type-dependent & independent functionality and bind type</em> <em>independent functionality with the base class using self-referencing template</em></strong>.</li><li>Above line may seem cryptic at first. So, consider the below solution to the above problem for more clarity:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>derived</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>compare</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>value</span> <span class=o>:</span> <span class=n>compare</span><span class=o>&lt;</span><span class=n>value</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>m_x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>value</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_x</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=n>value</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_x</span> <span class=o>&lt;</span> <span class=n>rhs</span><span class=p>.</span><span class=n>m_x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>derived</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=k>operator</span> <span class=o>&gt;</span> <span class=p>(</span><span class=k>const</span> <span class=n>compare</span><span class=o>&lt;</span><span class=n>derived</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>compare</span><span class=o>&lt;</span><span class=n>derived</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// static_assert(std::is_base_of_v&lt;compare&lt;derived&gt;, derived&gt;); // Compile time safety measures
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>derived</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>rhs</span><span class=p>)</span> <span class=o>&lt;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>derived</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>lhs</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*  Same goes with other operators
</span></span></span><span class=line><span class=cl><span class=cm>    == :: returns !(lhs &lt; rhs) and !(rhs &lt; lhs)
</span></span></span><span class=line><span class=cl><span class=cm>    != :: returns !(lhs == rhs)
</span></span></span><span class=line><span class=cl><span class=cm>    &gt;= :: returns (rhs &lt; lhs) or (rhs == lhs)
</span></span></span><span class=line><span class=cl><span class=cm>    &lt;= :: returns (lhs &lt; rhs) or (rhs == lhs) 
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>   
</span></span><span class=line><span class=cl>    <span class=n>value</span> <span class=n>v1</span><span class=p>{</span><span class=mi>5</span><span class=p>},</span> <span class=n>v2</span><span class=p>{</span><span class=mi>10</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>boolalpha</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;v1 &gt; v2: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>v1</span> <span class=o>&gt;</span> <span class=n>v2</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Now no need to write comparator operators for all the classes, 
</span></span></span><span class=line><span class=cl><span class=c1>// Write only type dependent `operator &lt;` &amp;  use CRTP
</span></span></span></code></pre></div><h4 id=usecases-3>Usecases<a hidden class=anchor aria-hidden=true href=#usecases-3>#</a></h4><ul><li>CRTP widely employed for static polymorphism without bearing the cost of virtual dispatch mechanism. Consider the following code we have not used virtual keyword & still achieved the functionality of polymorphism(specifically static polymorphism).</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>specific_animal</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>who</span><span class=p>()</span> <span class=p>{</span> <span class=n>implementation</span><span class=p>().</span><span class=n>who</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>specific_animal</span><span class=o>&amp;</span> <span class=n>implementation</span><span class=p>()</span> <span class=p>{</span><span class=k>return</span> <span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>specific_animal</span><span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>);}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>dog</span> <span class=o>:</span> <span class=k>public</span> <span class=n>animal</span><span class=o>&lt;</span><span class=n>dog</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>who</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;dog&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>cat</span> <span class=o>:</span> <span class=k>public</span> <span class=n>animal</span><span class=o>&lt;</span><span class=n>cat</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>who</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;cat&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>specific_animal</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>who_am_i</span><span class=p>(</span><span class=n>animal</span><span class=o>&lt;</span><span class=n>specific_animal</span><span class=o>&gt;</span> <span class=o>&amp;</span> <span class=n>animal</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>animal</span><span class=p>.</span><span class=n>who</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>CRTP can also used for optimization as we have seen above it also enables code reusability.</li></ul><p>Update: The above hiccup of declaring multiple comparisons operator will permanently be sorted from C++20 by using <a href=https://en.cppreference.com/w/cpp/language/default_comparisons>spaceship</a>(<code>&lt;=></code>)/<a href=https://en.wikipedia.org/wiki/Three-way_comparison>Three-way-comparison operator</a>.</p><h3 id=5-virtual-constructor>5. Virtual Constructor<a hidden class=anchor aria-hidden=true href=#5-virtual-constructor>#</a></h3><p><strong><em>Intent:</em></strong> To create a copy or new object without knowing its concrete type.<br><strong><em>Implementation:</em></strong> Exploits overloaded methods with polymorphic assignment.<br><strong><em>Also known as:</em></strong> <a href=/posts/factory-design-pattern-in-modern-cpp/>Factory method/design-pattern</a>.</p><h4 id=problem-3>Problem<a hidden class=anchor aria-hidden=true href=#problem-3>#</a></h4><ul><li>C++ has the support of polymorphic object destruction using it&rsquo;s base class&rsquo;s <a href=/posts/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/>virtual destructor</a>. But, equivalent support for creation and copying of objects is missing as С++ doesn&rsquo;t support virtual constructor, <a href=/posts/all-about-copy-constructor-in-cpp-with-example/>copy constructors</a>.</li><li>Moreover, you can’t create an object unless you know its static type, because the compiler must know the amount of space it needs to allocate. For the same reason, copy of an object also requires its type to known at compile-time.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>animal</span><span class=p>(){</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;~animal</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>dog</span> <span class=o>:</span> <span class=n>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>dog</span><span class=p>(){</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;~dog</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>cat</span> <span class=o>:</span> <span class=n>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>cat</span><span class=p>(){</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;~cat</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>who_am_i</span><span class=p>(</span><span class=n>animal</span> <span class=o>*</span><span class=n>who</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// not sure whether dog would be passed here or cat
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// How to `create` the object of same type i.e. pointed by who ?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// How to `copy` object of same type i.e. pointed by who ?
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>who</span><span class=p>;</span> <span class=c1>// you can delete object pointed by who
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=solution-4>Solution<a hidden class=anchor aria-hidden=true href=#solution-4>#</a></h4><ul><li>The Virtual Constructor technique allows polymorphic creation & copying of objects in C++ by delegating the act of creation & copying the object to the derived class through the use of virtual methods.</li><li>Following code is not only implement virtual constructor(i.e. <code>create()</code>) but also implements virtual <a href=/posts/all-about-copy-constructor-in-cpp-with-example/>copy constructor</a> (i.e. <code>clone()</code>) .</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>animal</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>create</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>clone</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>dog</span> <span class=o>:</span> <span class=n>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>create</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>dog</span><span class=o>&gt;</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>clone</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>dog</span><span class=o>&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>cat</span> <span class=o>:</span> <span class=n>animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>create</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>cat</span><span class=o>&gt;</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal</span><span class=o>&gt;</span> <span class=n>clone</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>cat</span><span class=o>&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>who_am_i</span><span class=p>(</span><span class=n>animal</span> <span class=o>*</span><span class=n>who</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>new_who</span> <span class=o>=</span> <span class=n>who</span><span class=o>-&gt;</span><span class=n>create</span><span class=p>();</span><span class=c1>// `create` the object of same type i.e. pointed by who ?
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>duplicate_who</span> <span class=o>=</span> <span class=n>who</span><span class=o>-&gt;</span><span class=n>clone</span><span class=p>();</span> <span class=c1>// `copy` object of same type i.e. pointed by who ?    
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>who</span><span class=p>;</span> <span class=c1>// you can delete object pointed by who
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=usecases-4>Usecases<a hidden class=anchor aria-hidden=true href=#usecases-4>#</a></h4><ul><li>To provide a generic interface to produce/copy a variety of classes using only one class.</li></ul><h3 id=6-sfinae-and-stdenable_if>6. SFINAE and std::enable_if<a hidden class=anchor aria-hidden=true href=#6-sfinae-and-stdenable_if>#</a></h3><p><strong><em>Intent:</em></strong> To filter out functions that do not yield valid template instantiations from a set of overloaded functions.<br><strong><em>Implementation:</em></strong> Achieved automatically by compiler or exploited using std::enable_if.<br><strong><em>Also known as:</em></strong></p><h4 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h4><ul><li><strong>S</strong>ubstitution <strong>F</strong>ailure <strong>I</strong>s <strong>N</strong>ot <strong>A</strong>n <strong>E</strong>rror is a language feature(not an idiom) a C++ compiler uses to filter out some templated function overloads during overload resolution.</li><li>During overload resolution of function templates, when substituting the explicitly specified or deduced type for the template parameter fails, the specialization discarded from the overload set instead of causing a compile error.</li><li>Substitution failure happens when type or expression ill-formed.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>t</span><span class=p>){</span> <span class=c1>// Single overload set
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nf>constexpr</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_class_v</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>){</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;T is user-defined type</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;T is primitive type</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>primitive_t</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span><span class=kt>char</span> <span class=n>var</span> <span class=o>=</span> <span class=sc>&#39;4&#39;</span><span class=p>;}</span><span class=n>class_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=o>&amp;</span><span class=n>class_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=o>&amp;</span><span class=n>primitive_t</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>Imagine if you want to create two sets(based on primitive type & user-defined type separately) of a function having the same signature?</li></ul><h4 id=solution-5>Solution<a hidden class=anchor aria-hidden=true href=#solution-5>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=k>typename</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>is_class_v</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>t</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;T is user-defined type</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>is_integral_v</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span> <span class=o>=</span> <span class=mi>0</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>t</span><span class=p>){</span> <span class=c1>// NOTE: function signature is NOT-MODIFIED
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;T is primitive type</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Above code snippet is a short example of exploiting SFINAE using <code>std::enable_if</code>, in which first template instantiation will become equivalent to <code>void func&lt;(anonymous), void>((anonymous) * t) and second, </code>void func(int * t).</li><li>You can read more about <code>std::enable_if</code> <a href=https://en.cppreference.com/w/cpp/types/enable_if>here</a>.</li></ul><h4 id=usecases-5>Usecases<a hidden class=anchor aria-hidden=true href=#usecases-5>#</a></h4><ul><li>Together with <code>std::enable_if</code>, SFINAE is heavily used in template metaprogramming.</li><li>The standard library also leveraged SFINAE in most <a href=https://en.cppreference.com/w/cpp/header/type_traits>type_traits</a> utilities. Consider the following example which checks for the user-defined type or primitive type:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Stolen &amp; trimmed from https://stackoverflow.com/questions/982808/c-sfinae-examples.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>is_class_type</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>C</span><span class=o>&gt;</span> <span class=k>static</span> <span class=kt>char</span> <span class=n>test</span><span class=p>(</span><span class=kt>int</span> <span class=n>C</span><span class=o>::*</span><span class=p>);</span>    
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>C</span><span class=o>&gt;</span> <span class=k>static</span> <span class=kt>double</span> <span class=n>test</span><span class=p>(...);</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=p>{</span> <span class=n>value</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>is_class_type</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>test</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>class_t</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>is_class_type</span><span class=o>&lt;</span><span class=n>class_t</span><span class=o>&gt;::</span><span class=n>value</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>    <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>is_class_type</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>value</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>        <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Without SFINAE, you would get a compiler error, something like &ldquo;<code>0</code> cannot be converted to member pointer for a non-class type <code>int</code>&rdquo; as both the overload of <code>test</code> method only differs in terms of the return type.</li><li>Because <code>int</code> is not a class, so it can&rsquo;t have a member pointer of type <code>int int::*</code> .</li></ul><h3 id=7-proxy>7. Proxy<a hidden class=anchor aria-hidden=true href=#7-proxy>#</a></h3><p><strong><em>Intent:</em></strong> To achieve intuitive functionality using middleware class.<br><strong><em>Implementation:</em></strong> By use of temporary/proxy class.<br><strong><em>Also known as:</em></strong> <code>operator []</code>(i.e. subscript) proxy, double/twice operator overloading</p><h4 id=motivation-1>Motivation<a hidden class=anchor aria-hidden=true href=#motivation-1>#</a></h4><ul><li>Most of the dev believes this is only about the subscript operator (i.e. <code>operator[ ]</code>), but I believe type/class that comes in between exchanging data is proxy.</li><li>We have already seen a nice example of this idiom indirectly above in <a href=#Type-Eraser>type-erasure</a>(i.e. class <code>any::inner&lt;></code>). But still, I think one more example will add concreteness to our understanding.</li></ul><h4 id=operator---solution>operator [ ] solution<a hidden class=anchor aria-hidden=true href=#operator---solution>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span> <span class=o>=</span> <span class=kt>int</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>arr2D</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>proxy_class</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>proxy_class</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=n>arr</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_arr_ptr</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>&amp;</span><span class=k>operator</span><span class=p>[](</span><span class=kt>uint32_t</span> <span class=n>idx</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_arr_ptr</span><span class=p>[</span><span class=n>idx</span><span class=p>];</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>*</span><span class=n>m_arr_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>m_arr</span><span class=p>[</span><span class=mi>10</span><span class=p>][</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>arr2D</span><span class=o>::</span><span class=n>proxy_class</span> <span class=k>operator</span><span class=p>[](</span><span class=kt>uint32_t</span> <span class=n>idx</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>arr2D</span><span class=o>::</span><span class=n>proxy_class</span><span class=p>(</span><span class=n>m_arr</span><span class=p>[</span><span class=n>idx</span><span class=p>]);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>arr2D</span><span class=o>&lt;&gt;</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=usecases-6>Usecases<a hidden class=anchor aria-hidden=true href=#usecases-6>#</a></h4><ul><li>To create intuitive features like double operator overloading, <code>std::any</code> etc.</li></ul><h3 id=summary-by-faqs>Summary by FAQs<a hidden class=anchor aria-hidden=true href=#summary-by-faqs>#</a></h3><p><strong>When to actually use RAII?</strong></p><p>When you have set of steps to carry out a task & two steps are ideal i.e. set-up & clean-up, then that&rsquo;s the place you can employ RAII.</p><p><strong>Why can&rsquo;t functions be overloaded by return type?</strong></p><p>You can&rsquo;t overload on return types as it is not mandatory to use the return value of the functions in a function call expression. For example, I can just say</p><p><code>get_val()</code>;`</p><p>What does the compiler do now?</p><p><strong>When to use return type resolver idiom?</strong></p><p>You can apply return type resolver idiom when your input types are fixed but output types may vary.</p><p><strong>What is type erasure in C++?</strong></p><ul><li>Type erasure technique is used to design generic type which relies on the type of <a href=/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/>assignment</a>(as we do in python).</li><li>By the way, do you know <code>auto</code> or can you design one now?</li></ul><p><strong>Best scenarios to apply type erasure idiom?</strong></p><ul><li>Useful in generic programming.</li><li>Can also be used to handle multiple types of the return value from function/method(Although that&rsquo;s not recommended advice).</li></ul><p><strong>What is the curiously recurring template pattern (CRTP)?</strong></p><p>CRTP is when a class <code>A</code> has a base class. And that base class is a template specialization for the class <code>A</code> itself. E.g.<br><code>template &lt;class T></code><br><code>class X{...};</code><br><code>class A : public X&lt;A> {...};</code><br>It <em>is</em> curiously recurring, isn&rsquo;t it?</p><p><strong>Why Curiously Recurring Template Pattern (CRTP) works?</strong></p><p>I think <a href=https://stackoverflow.com/questions/49708984/why-curiously-recurring-template-pattern-crtp-works>this</a> answer is very appropriate.</p><p><strong>What is SFINAE?</strong></p><p><strong>S</strong>ubstitution <strong>F</strong>ailure <strong>I</strong>s <strong>N</strong>ot <strong>A</strong>n <strong>E</strong>rror is a language feature(not an idiom) a C++ compiler uses to filter out some templated function overloads during overload resolution.</p><p><strong>What is Proxy Class in C++?</strong></p><p>A proxy is a class that provides a modified interface to another class.</p><p><strong>Why do we not have a virtual constructor in C++?</strong></p><ul><li>A virtual-table(vtable) is made for each Class having one or more &lsquo;virtual-functions&rsquo;. Whenever an object is created of such class, it contains a &lsquo;virtual-pointer&rsquo; which points to the base of the corresponding vtable. Whenever there is a virtual function call, the vtable is used to resolve to the function address.</li><li>A constructor can not be virtual, because when the constructor of a class is executed there is no vtable in the memory, means no virtual pointer defined yet. Hence the constructor should always be non-virtual.</li></ul><p><strong>Can we make a class copy constructor virtual in C++?</strong></p><p>Similar to &ldquo;Why do we not have a virtual constructor in C++?&rdquo; which already answered above.</p><p><strong>What are the use cases & need for virtual constructor?</strong></p><p>To create & copy the object(without knowing its concrete type) using a base class polymorphic method.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/a-function-cannot-be-overloaded-only-by-its-return-type/>A-Function-Cannot-Be-Overloaded-Only-by-Its-Return-Type</a></li><li><a href=http://localhost:1313/tags/abstract-factory-design-pattern-c/>Abstract-Factory-Design-Pattern-C</a></li><li><a href=http://localhost:1313/tags/advanced-c-concepts/>Advanced-C-Concepts</a></li><li><a href=http://localhost:1313/tags/advanced-c-metaprogramming/>Advanced-C-Metaprogramming</a></li><li><a href=http://localhost:1313/tags/c-metaprogramming/>C-Metaprogramming</a></li><li><a href=http://localhost:1313/tags/c-sfinae/>C-Sfinae</a></li><li><a href=http://localhost:1313/tags/c-sfinae-examples/>C-Sfinae-Examples</a></li><li><a href=http://localhost:1313/tags/c-stdfunction-type-erasure/>C-Stdfunction-Type-Erasure</a></li><li><a href=http://localhost:1313/tags/c-template-base-class-polymorphism/>C-Template-Base-Class-Polymorphism</a></li><li><a href=http://localhost:1313/tags/c-template-interface/>C-Template-Interface</a></li><li><a href=http://localhost:1313/tags/c-template-metaprogramming/>C-Template-Metaprogramming</a></li><li><a href=http://localhost:1313/tags/c-template-proxy-class/>C-Template-Proxy-Class</a></li><li><a href=http://localhost:1313/tags/c-type-erasure-without-dynamic-allocation/>C-Type-Erasure-Without-Dynamic-Allocation</a></li><li><a href=http://localhost:1313/tags/c17-type-erasure/>C17-Type-Erasure</a></li><li><a href=http://localhost:1313/tags/container-class-and-proxy-class-in-c/>Container-Class-and-Proxy-Class-in-C</a></li><li><a href=http://localhost:1313/tags/crtp/>Crtp</a></li><li><a href=http://localhost:1313/tags/crtp-c/>Crtp-C</a></li><li><a href=http://localhost:1313/tags/crtp-example-c/>Crtp-Example-C</a></li><li><a href=http://localhost:1313/tags/double-operator-overloading-c/>Double-Operator-Overloading-C</a></li><li><a href=http://localhost:1313/tags/factory-design-pattern/>Factory-Design-Pattern</a></li><li><a href=http://localhost:1313/tags/factory-method/>Factory-Method</a></li><li><a href=http://localhost:1313/tags/factory-pattern-c/>Factory-Pattern-C</a></li><li><a href=http://localhost:1313/tags/function-overloading-return-type/>Function-Overloading-Return-Type</a></li><li><a href=http://localhost:1313/tags/proxy-class-example-c/>Proxy-Class-Example-C</a></li><li><a href=http://localhost:1313/tags/proxy-class-in-c/>Proxy-Class-in-C</a></li><li><a href=http://localhost:1313/tags/pure-virtual-constructor-c/>Pure-Virtual-Constructor-C</a></li><li><a href=http://localhost:1313/tags/raii-c/>Raii-C</a></li><li><a href=http://localhost:1313/tags/raii-example/>Raii-Example</a></li><li><a href=http://localhost:1313/tags/raii-idiom/>Raii-Idiom</a></li><li><a href=http://localhost:1313/tags/resource-acquisition-is-initialization/>Resource-Acquisition-Is-Initialization</a></li><li><a href=http://localhost:1313/tags/return-type-resolver/>Return-Type-Resolver</a></li><li><a href=http://localhost:1313/tags/return-type-resolver-c-example/>Return-Type-Resolver-C-Example</a></li><li><a href=http://localhost:1313/tags/return-type-resolver-idiom/>Return-Type-Resolver-Idiom</a></li><li><a href=http://localhost:1313/tags/sfinae/>Sfinae</a></li><li><a href=http://localhost:1313/tags/sfinae-stdenable_if/>Sfinae-Stdenable_if</a></li><li><a href=http://localhost:1313/tags/sfinae-c/>Sfinae-C</a></li><li><a href=http://localhost:1313/tags/sfinae-enable_if-function/>Sfinae-Enable_if-Function</a></li><li><a href=http://localhost:1313/tags/sfinae-example-c/>Sfinae-Example-C</a></li><li><a href=http://localhost:1313/tags/sfinae-example-enable_if/>Sfinae-Example-Enable_if</a></li><li><a href=http://localhost:1313/tags/sfinae-member-function/>Sfinae-Member-Function</a></li><li><a href=http://localhost:1313/tags/static-and-dynamic-polymorphism/>Static-and-Dynamic-Polymorphism</a></li><li><a href=http://localhost:1313/tags/static-polymorphism/>Static-Polymorphism</a></li><li><a href=http://localhost:1313/tags/stdany-implementation/>Stdany-Implementation</a></li><li><a href=http://localhost:1313/tags/substitution-failure-is-not-an-error/>Substitution-Failure-Is-Not-an-Error</a></li><li><a href=http://localhost:1313/tags/temporary-proxy/>Temporary-Proxy</a></li><li><a href=http://localhost:1313/tags/type-erasure/>Type-Erasure</a></li><li><a href=http://localhost:1313/tags/type-erasure-c-shared_ptr/>Type-Erasure-C-Shared_ptr</a></li><li><a href=http://localhost:1313/tags/type-erasure-c-stackoverflow/>Type-Erasure-C-Stackoverflow</a></li><li><a href=http://localhost:1313/tags/type-erasure-using-polymorphism/>Type-Erasure-Using-Polymorphism</a></li><li><a href=http://localhost:1313/tags/type-erasure-using-templates/>Type-Erasure-Using-Templates</a></li><li><a href=http://localhost:1313/tags/type-erasure-using-union/>Type-Erasure-Using-Union</a></li><li><a href=http://localhost:1313/tags/unique_ptr-type-erasure/>Unique_ptr-Type-Erasure</a></li><li><a href=http://localhost:1313/tags/upside-down-inheritance/>Upside-Down-Inheritance</a></li><li><a href=http://localhost:1313/tags/virtual-constructor/>Virtual-Constructor</a></li><li><a href=http://localhost:1313/tags/virtual-constructor-clone/>Virtual-Constructor-Clone</a></li><li><a href=http://localhost:1313/tags/virtual-constructor-c/>Virtual-Constructor-C</a></li><li><a href=http://localhost:1313/tags/virtual-constructor-example/>Virtual-Constructor-Example</a></li><li><a href=http://localhost:1313/tags/virtual-copy-constructor/>Virtual-Copy-Constructor</a></li><li><a href=http://localhost:1313/tags/virtual-copy-constructor-c/>Virtual-Copy-Constructor-C</a></li><li><a href=http://localhost:1313/tags/virtual-destructor-in-c/>Virtual-Destructor-in-C</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/what-exactly-nullptr-is-in-cpp/><span class=title>« Prev</span><br><span>What Exactly nullptr Is in C++?</span>
</a><a class=next href=http://localhost:1313/posts/7-best-practices-for-exception-handling-in-cpp-with-example/><span class=title>Next »</span><br><span>C++ Exception Handling Best Practices: 7 Things To Know</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 7 Advance C++ Concepts & Idiom Examples You Should Know on x" href="https://x.com/intent/tweet/?text=7%20Advance%20C%2b%2b%20Concepts%20%26%20Idiom%20Examples%20You%20Should%20Know&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-advance-cpp-concepts-idiom-examples-you-should-know%2f&amp;hashtags=a-function-cannot-be-overloaded-only-by-its-return-type%2cabstract-factory-design-pattern-c%2cadvanced-c-concepts%2cadvanced-c-metaprogramming%2cc-metaprogramming%2cc-sfinae%2cc-sfinae-examples%2cc-stdfunction-type-erasure%2cc-template-base-class-polymorphism%2cc-template-interface%2cc-template-metaprogramming%2cc-template-proxy-class%2cc-type-erasure-without-dynamic-allocation%2cc17-type-erasure%2ccontainer-class-and-proxy-class-in-c%2ccrtp%2ccrtp-c%2ccrtp-example-c%2cdouble-operator-overloading-c%2cfactory-design-pattern%2cfactory-method%2cfactory-pattern-c%2cfunction-overloading-return-type%2cproxy-class-example-c%2cproxy-class-in-c%2cpure-virtual-constructor-c%2craii-c%2craii-example%2craii-idiom%2cresource-acquisition-is-initialization%2creturn-type-resolver%2creturn-type-resolver-c-example%2creturn-type-resolver-idiom%2csfinae%2csfinae-stdenable_if%2csfinae-c%2csfinae-enable_if-function%2csfinae-example-c%2csfinae-example-enable_if%2csfinae-member-function%2cstatic-and-dynamic-polymorphism%2cstatic-polymorphism%2cstdany-implementation%2csubstitution-failure-is-not-an-error%2ctemporary-proxy%2ctype-erasure%2ctype-erasure-c-shared_ptr%2ctype-erasure-c-stackoverflow%2ctype-erasure-using-polymorphism%2ctype-erasure-using-templates%2ctype-erasure-using-union%2cunique_ptr-type-erasure%2cupside-down-inheritance%2cvirtual-constructor%2cvirtual-constructor-clone%2cvirtual-constructor-c%2cvirtual-constructor-example%2cvirtual-copy-constructor%2cvirtual-copy-constructor-c%2cvirtual-destructor-in-c"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 7 Advance C++ Concepts & Idiom Examples You Should Know on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-advance-cpp-concepts-idiom-examples-you-should-know%2f&amp;title=7%20Advance%20C%2b%2b%20Concepts%20%26%20Idiom%20Examples%20You%20Should%20Know&amp;summary=7%20Advance%20C%2b%2b%20Concepts%20%26%20Idiom%20Examples%20You%20Should%20Know&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-advance-cpp-concepts-idiom-examples-you-should-know%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 7 Advance C++ Concepts & Idiom Examples You Should Know on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-advance-cpp-concepts-idiom-examples-you-should-know%2f&title=7%20Advance%20C%2b%2b%20Concepts%20%26%20Idiom%20Examples%20You%20Should%20Know"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 7 Advance C++ Concepts & Idiom Examples You Should Know on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-advance-cpp-concepts-idiom-examples-you-should-know%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 7 Advance C++ Concepts & Idiom Examples You Should Know on whatsapp" href="https://api.whatsapp.com/send?text=7%20Advance%20C%2b%2b%20Concepts%20%26%20Idiom%20Examples%20You%20Should%20Know%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2f7-advance-cpp-concepts-idiom-examples-you-should-know%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 7 Advance C++ Concepts & Idiom Examples You Should Know on telegram" href="https://telegram.me/share/url?text=7%20Advance%20C%2b%2b%20Concepts%20%26%20Idiom%20Examples%20You%20Should%20Know&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-advance-cpp-concepts-idiom-examples-you-should-know%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 7 Advance C++ Concepts & Idiom Examples You Should Know on ycombinator" href="https://news.ycombinator.com/submitlink?t=7%20Advance%20C%2b%2b%20Concepts%20%26%20Idiom%20Examples%20You%20Should%20Know&u=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-advance-cpp-concepts-idiom-examples-you-should-know%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>