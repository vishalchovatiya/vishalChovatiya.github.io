<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>21 New Features of Modern C++ to Use in Your Project | Vishal Chovatiya</title>
<meta name=keywords content="c-digit-separators,c-smart-pointers,c-uniform-initialization-non-static-member-initialization,c-user-defined-literals,class-template-argument-deduction,forwarding-reference,lambda-expression-in-c,modern-c,modern-c-features,new-features-in-c,nullptr-c,smart-pointers,strongly-typed-enums,strongly-typed-enums-c"><meta name=description content="So, you came across the Modern C++ & overwhelmed by its features in terms of performance, convenience & code expressiveness. But in a dilemma that how you can spot where you can enforce Modern C++ features in your day to day coding job. No worries, here we will see 21 new features of Modern C++ you can use in your project.
C++ community releasing new standards more frequently than iPhone releases."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=http://localhost:1313/posts/21-new-features-of-modern-cpp-to-use-in-your-project/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/21-new-features-of-modern-cpp-to-use-in-your-project/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="21 New Features of Modern C++ to Use in Your Project"><meta property="og:description" content="So, you came across the Modern C++ & overwhelmed by its features in terms of performance, convenience & code expressiveness. But in a dilemma that how you can spot where you can enforce Modern C++ features in your day to day coding job. No worries, here we will see 21 new features of Modern C++ you can use in your project.
C++ community releasing new standards more frequently than iPhone releases."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/21-new-features-of-modern-cpp-to-use-in-your-project/"><meta property="og:image" content="http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-13T00:00:00+00:00"><meta property="article:modified_time" content="2019-10-13T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png"><meta name=twitter:title content="21 New Features of Modern C++ to Use in Your Project"><meta name=twitter:description content="So, you came across the Modern C++ & overwhelmed by its features in terms of performance, convenience & code expressiveness. But in a dilemma that how you can spot where you can enforce Modern C++ features in your day to day coding job. No worries, here we will see 21 new features of Modern C++ you can use in your project.
C++ community releasing new standards more frequently than iPhone releases."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"21 New Features of Modern C++ to Use in Your Project","item":"http://localhost:1313/posts/21-new-features-of-modern-cpp-to-use-in-your-project/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"21 New Features of Modern C++ to Use in Your Project","name":"21 New Features of Modern C\u002b\u002b to Use in Your Project","description":"So, you came across the Modern C++ \u0026amp; overwhelmed by its features in terms of performance, convenience \u0026amp; code expressiveness. But in a dilemma that how you can spot where you can enforce Modern C++ features in your day to day coding job. No worries, here we will see 21 new features of Modern C++ you can use in your project.\nC++ community releasing new standards more frequently than iPhone releases.","keywords":["c-digit-separators","c-smart-pointers","c-uniform-initialization-non-static-member-initialization","c-user-defined-literals","class-template-argument-deduction","forwarding-reference","lambda-expression-in-c","modern-c","modern-c-features","new-features-in-c","nullptr-c","smart-pointers","strongly-typed-enums","strongly-typed-enums-c"],"articleBody":"So, you came across the Modern C++ \u0026 overwhelmed by its features in terms of performance, convenience \u0026 code expressiveness. But in a dilemma that how you can spot where you can enforce Modern C++ features in your day to day coding job. No worries, here we will see 21 new features of Modern C++ you can use in your project.\nC++ community releasing new standards more frequently than iPhone releases. Due to this, C++ now becomes like an elephant and it is impossible to eat the whole elephant in one go. That is why I have written this post to kick start your Modern C++ journey. Here my intended audience is peeps who are moving from older(i.e. 98/03) C++ to Modern(i.e. 2011 onwards) C++.\nI have chosen some of the Modern C++ features \u0026 explained it with the minimalistic example to make you aware that how you can spot the places where you can employ new features.\nDigit separators int no = 1'000'000; // separate units like, thousand, lac, million, etc. long addr = 0xA000'EFFF; // separate 32 bit address uint32_t binary = 0b0001'0010'0111'1111; // now, explanation is not needed i guess Earlier you have to count digits or zeros, but now not anymore from C++14. This will be useful while counting address in word, half-word or digit boundary or let say you have a credit card or social security number. By grouping digits, your code would become more expressive. Type aliases template \u003ctypename T\u003e using dyn_arr = std::vector\u003cT\u003e; dyn_arr\u003cint\u003e nums; // equivalent to std::vector using func_ptr = int (*)(int); Semantically similar to using a typedef , however, type aliases are easier to read and are compatible with C++ templates types also. Thanks to C++11. User-defined literals using ull = unsigned long long; constexpr ull operator\"\" _KB(ull no) { return no * 1024; } constexpr ull operator\"\" _MB(ull no) { return no * (1024_KB); } cout\u003c\u003c1_KB\u003c\u003cendl; cout\u003c\u003c5_MB\u003c\u003cendl; Most of the times you have to deal with real-world jargons like KB, MB, km, cm, rupees, dollars, euros, etc. rather defining functions which do the unit conversion on run-time, you can now treat it as user-defined literals as you do with other primitive types. Very convenient for units \u0026 measurement. Adding constexpr will serve zero cost run-time performance impact which we will see later in this article \u0026 I have written a more detailed article on when to use const vs constexpr in c++. Uniform initialization \u0026 Non-static member initialization Earlier, you have to initialize data members with its default values in the constructor or in the member initialization list. But from C++11, it’s possible to give normal class member variables (those that don’t use the static keyword) a default initialization value directly as shown below:\nclass demo { private: uint32_t m_var_1 = 0; bool m_var_2 = false; string m_var_3 = \"\"; float m_var_4 = 0.0; public: demo(uint32_t var_1, bool var_2, string var_3, float var_4) : m_var_1(var_1), m_var_2(var_2), m_var_3(var_3), m_var_4(var_4) {} }; demo obj{123, true, \"lol\", 1.1}; This is more useful when there are multiple sub-objects defined as data members as follows: class computer { private: cpu_t m_cpu{2, 3.2_GHz}; ram_t m_ram{4_GB, RAM::TYPE::DDR4}; hard_disk_t m_ssd{1_TB, HDD::TYPE::SSD}; public: // ... }; In this case, you do not need to initialize it in initializer list, rather you can directly give default initialization at the time of declaration. class X { const static int m_var = 0; }; // int X::m_var = 0; // not needed for constant static data members You can also provide initialization at the time of declaration if members are const \u0026 static as above. std::initializer_list std::pair\u003cint, int\u003e p = {1, 2}; std::tuple\u003cint, int\u003e t = {1, 2}; std::vector\u003cint\u003e v = {1, 2, 3, 4, 5}; std::set\u003cint\u003e s = {1, 2, 3, 4, 5}; std::list\u003cint\u003e l = {1, 2, 3, 4, 5}; std::deque\u003cint\u003e d = {1, 2, 3, 4, 5}; std::array\u003cint, 5\u003e a = {1, 2, 3, 4, 5}; // Wont work for adapters // std::stack s = {1, 2, 3, 4, 5}; // std::queue q = {1, 2, 3, 4, 5}; // std::priority_queue pq = {1, 2, 3, 4, 5}; Assign values to containers directly by initializer list as do with C-style arrays. This is also true for nested containers. Thanks to C++11. auto \u0026 decltype auto a = 3.14; // double auto b = 1; // int auto\u0026 c = b; // int\u0026 auto g = new auto(123); // int* auto x; // error -- `x` requires initializer auto-typed variables are deduced by the compiler according to the type of their initializer. Extremely useful for readability, especially for complicated types: // std::vector::const_iterator cit = v.cbegin(); auto cit = v.cbegin(); // alternatively // std::shared_ptr","wordCount":"2435","inLanguage":"en","image":"http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png","datePublished":"2019-10-13T00:00:00Z","dateModified":"2019-10-13T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/21-new-features-of-modern-cpp-to-use-in-your-project/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=http://localhost:1313/posts/ title=Latest><span>Latest</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">21 New Features of Modern C++ to Use in Your Project</h1><div class=post-meta><span title='2019-10-13 00:00:00 +0000 UTC'>October 13, 2019</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2435 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/21-new-features-of-modern-cpp-to-use-in-your-project.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/images/20-new-features-of-Modern-C-to-use-in-your-project.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#digit-separators>Digit separators</a></li><li><a href=#type-aliases>Type aliases</a></li><li><a href=#user-defined-literals>User-defined literals</a></li><li><a href=#uniform-initialization--non-static-member-initialization>Uniform initialization & Non-static member initialization</a></li><li><a href=#stdinitializer_list>std::initializer_list</a></li><li><a href=#auto--decltype>auto & decltype</a></li><li><a href=#range-based-for-loops>Range-based for-loops</a></li><li><a href=#smart-pointers>Smart pointers</a></li><li><a href=#nullptrpostswhat-exactly-nullptr-is-in-cpp><a href=/posts/what-exactly-nullptr-is-in-cpp/>nullptr</a></a></li><li><a href=#strongly-typed-enums>Strongly-typed enums</a></li><li><a href=#typecasting>Typecasting</a></li><li><a href=#move-semantics>Move semantics</a></li><li><a href=#forwarding-references>Forwarding references</a></li><li><a href=#variadic-templates>Variadic templates</a></li><li><a href=#constexpr>constexpr</a></li><li><a href=#deleted--defaulted-functions>Deleted & Defaulted functions</a></li><li><a href=#delegating-constructors>Delegating constructors</a></li><li><a href=#lambda-expression>Lambda expression</a></li><li><a href=#selection-statements-with-initializer>Selection statements with initializer</a></li><li><a href=#stdtuple>std::tuple</a></li><li><a href=#class-template-argument-deduction>Class template argument deduction</a></li><li><a href=#closing-words>Closing words</a></li></ul></nav></div></details></div><div class=post-content><p>So, you came across the Modern C++ & overwhelmed by its features in terms of performance, convenience & code expressiveness. But in a dilemma that how you can spot where you can enforce Modern C++ features in your day to day coding job. No worries, here we will see 21 new features of Modern C++ you can use in your project.</p><p>C++ community releasing new standards more frequently than iPhone releases. Due to this, C++ now becomes like an elephant and it is impossible to eat the whole elephant in one go. That is why I have written this post to kick start your Modern C++ journey. Here my intended audience is peeps who are moving from older(i.e. 98/03) C++ to Modern(i.e. 2011 onwards) C++.</p><p>I have chosen some of the Modern C++ features & explained it with the minimalistic example to make you aware that how you can spot the places where you can employ new features.</p><h2 id=digit-separators>Digit separators<a hidden class=anchor aria-hidden=true href=#digit-separators>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>no</span> <span class=o>=</span> <span class=mi>1&#39;000&#39;000</span><span class=p>;</span>                      <span class=c1>// separate units like, thousand, lac, million, etc.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>long</span> <span class=n>addr</span> <span class=o>=</span> <span class=mh>0xA000&#39;EFFF</span><span class=p>;</span>                 <span class=c1>// separate 32 bit address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint32_t</span> <span class=n>binary</span> <span class=o>=</span> <span class=mb>0b0001&#39;0010&#39;0111&#39;1111</span><span class=p>;</span> <span class=c1>// now, explanation is not needed i guess
</span></span></span></code></pre></div><ul><li>Earlier you have to count digits or zeros, but now not anymore from C++14.</li><li>This will be useful while counting address in word, half-word or digit boundary or let say you have a credit card or social security number.</li><li>By grouping digits, your code would become more expressive.</li></ul><h2 id=type-aliases>Type aliases<a hidden class=anchor aria-hidden=true href=#type-aliases>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>dyn_arr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>dyn_arr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>nums</span><span class=p>;</span> <span class=c1>// equivalent to std::vector&lt;int&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>func_ptr</span> <span class=o>=</span> <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>Semantically similar to using a <code>typedef</code> , however, type aliases are easier to read and are compatible with <a href=/posts/c-template-a-quick-uptodate-look/>C++ templates</a> types also. Thanks to C++11.</li></ul><h2 id=user-defined-literals>User-defined literals<a hidden class=anchor aria-hidden=true href=#user-defined-literals>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>ull</span> <span class=o>=</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>ull</span> <span class=k>operator</span><span class=s>&#34;&#34;</span> <span class=n>_KB</span><span class=p>(</span><span class=n>ull</span> <span class=n>no</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>no</span> <span class=o>*</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>ull</span> <span class=k>operator</span><span class=s>&#34;&#34;</span> <span class=n>_MB</span><span class=p>(</span><span class=n>ull</span> <span class=n>no</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>no</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1024</span><span class=n>_KB</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=mi>1</span><span class=n>_KB</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=mi>5</span><span class=n>_MB</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Most of the times you have to deal with real-world jargons like KB, MB, km, cm, rupees, dollars, euros, etc. rather defining functions which do the unit conversion on run-time, you can now treat it as user-defined literals as you do with other primitive types.</li><li>Very convenient for units & measurement.</li><li>Adding constexpr will serve zero cost run-time performance impact which we will see later in this article & I have written a more detailed article on <a href=/posts/when-to-use-const-vs-constexpr-in-cpp/>when to use const vs constexpr in c++</a>.</li></ul><h2 id=uniform-initialization--non-static-member-initialization>Uniform initialization & Non-static member initialization<a hidden class=anchor aria-hidden=true href=#uniform-initialization--non-static-member-initialization>#</a></h2><p>Earlier, you have to initialize data members with its default values in the constructor or in the member initialization list. But from C++11, it’s possible to give normal class member variables (those that don’t use the <code>static</code> keyword) a default initialization value directly as shown below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>m_var_1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>m_var_2</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>m_var_3</span> <span class=o>=</span> <span class=s>&#34;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>m_var_4</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>var_1</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>var_2</span><span class=p>,</span> <span class=n>string</span> <span class=n>var_3</span><span class=p>,</span> <span class=kt>float</span> <span class=n>var_4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>m_var_1</span><span class=p>(</span><span class=n>var_1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>m_var_2</span><span class=p>(</span><span class=n>var_2</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>m_var_3</span><span class=p>(</span><span class=n>var_3</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>m_var_4</span><span class=p>(</span><span class=n>var_4</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>demo</span> <span class=n>obj</span><span class=p>{</span><span class=mi>123</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=s>&#34;lol&#34;</span><span class=p>,</span> <span class=mf>1.1</span><span class=p>};</span>
</span></span></code></pre></div><ul><li>This is more useful when there are multiple <a href=/posts/memory-layout-of-cpp-object/>sub-object</a>s defined as data members as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>computer</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>cpu_t</span>           <span class=n>m_cpu</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mf>3.2</span><span class=n>_GHz</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>ram_t</span>           <span class=n>m_ram</span><span class=p>{</span><span class=mi>4</span><span class=n>_GB</span><span class=p>,</span> <span class=n>RAM</span><span class=o>::</span><span class=n>TYPE</span><span class=o>::</span><span class=n>DDR4</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>hard_disk_t</span>     <span class=n>m_ssd</span><span class=p>{</span><span class=mi>1</span><span class=n>_TB</span><span class=p>,</span> <span class=n>HDD</span><span class=o>::</span><span class=n>TYPE</span><span class=o>::</span><span class=n>SSD</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><ul><li>In this case, you do not need to initialize it in initializer list, rather you can directly give default initialization at the time of declaration.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>X</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>m_var</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// int X::m_var = 0; // not needed for constant static data members
</span></span></span></code></pre></div><ul><li>You can also provide initialization at the time of declaration if members are <code>const</code> & <code>static</code> as above.</li></ul><h2 id=stdinitializer_list>std::initializer_list<a hidden class=anchor aria-hidden=true href=#stdinitializer_list>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>t</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>s</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>deque</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>d</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Wont work for adapters
</span></span></span><span class=line><span class=cl><span class=c1>// std::stack&lt;int&gt; s = {1, 2, 3, 4, 5};
</span></span></span><span class=line><span class=cl><span class=c1>// std::queue&lt;int&gt; q = {1, 2, 3, 4, 5};
</span></span></span><span class=line><span class=cl><span class=c1>// std::priority_queue&lt;int&gt; pq = {1, 2, 3, 4, 5};
</span></span></span></code></pre></div><ul><li>Assign values to containers directly by initializer list as do with C-style arrays.</li><li>This is also true for nested containers. Thanks to C++11.</li></ul><h2 id=auto--decltype>auto & decltype<a hidden class=anchor aria-hidden=true href=#auto--decltype>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>a</span> <span class=o>=</span> <span class=mf>3.14</span><span class=p>;</span> <span class=c1>// double
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span><span class=o>&amp;</span> <span class=n>c</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span> <span class=c1>// int&amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>g</span> <span class=o>=</span> <span class=k>new</span> <span class=k>auto</span><span class=p>(</span><span class=mi>123</span><span class=p>);</span> <span class=c1>// int*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// error -- `x` requires initializer
</span></span></span></code></pre></div><ul><li><code>auto</code>-typed variables are deduced by the compiler according to the type of their initializer.</li><li>Extremely useful for readability, especially for complicated types:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// std::vector&lt;int&gt;::const_iterator cit = v.cbegin();
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>cit</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>cbegin</span><span class=p>();</span> <span class=c1>// alternatively
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// std::shared_ptr&lt;vector&lt;uint32_t&gt;&gt; demo_ptr(new vector&lt;uint32_t&gt;(0);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>demo_ptr</span> <span class=o>=</span> <span class=n>make_shared</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// alternatively
</span></span></span></code></pre></div><ul><li>Functions can also deduce the return type using <code>auto</code>. In C++11, a return type must be specified either explicitly, or using <code>decltype</code> like:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>X</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Y</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>add</span><span class=p>(</span><span class=n>X</span> <span class=n>x</span><span class=p>,</span> <span class=n>Y</span> <span class=n>y</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=k>decltype</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>     <span class=c1>// == 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>);</span>   <span class=c1>// == 3.0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>add</span><span class=p>(</span><span class=mf>1.5</span><span class=p>,</span> <span class=mf>1.5</span><span class=p>);</span> <span class=c1>// == 3.0
</span></span></span></code></pre></div><ul><li>Defining return type as above called trailing return type i.e. <code>-> return-type</code>.</li></ul><h2 id=range-based-for-loops>Range-based for-loops<a hidden class=anchor aria-hidden=true href=#range-based-for-loops>#</a></h2><ul><li>Syntactic sugar for iterating over a container&rsquo;s elements.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=o>&gt;</span> <span class=n>a</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>a</span><span class=p>)</span> <span class=n>x</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// a == { 2, 4, 6, 8, 10 }
</span></span></span></code></pre></div><ul><li>Note the difference when using <code>int</code> as opposed to <code>int&</code>:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=o>&gt;</span> <span class=n>a</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>a</span><span class=p>)</span> <span class=n>x</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// a == { 1, 2, 3, 4, 5 }
</span></span></span></code></pre></div><h2 id=smart-pointers>Smart pointers<a hidden class=anchor aria-hidden=true href=#smart-pointers>#</a></h2><ul><li>C++11 introduces new smart(er) pointers: <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>. </li><li>And <code>std::auto_ptr</code> now become deprecated and then eventually removed in C++17.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>i_ptr1</span><span class=p>{</span><span class=k>new</span> <span class=kt>int</span><span class=p>{</span><span class=mi>5</span><span class=p>}};</span> <span class=c1>// Not recommendate
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>i_ptr2</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>  <span class=c1>// More conviniently
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>m_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=n>T</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_var</span><span class=p>(</span><span class=n>var</span><span class=p>){};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>i_ptr3</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>demo</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>ISO CPP guidelines suggest avoiding the call of <code>new</code> and <code>delete</code> explicitly by the rule of <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new>no naked new</a>.</li><li>I have already written an article on <a href=/posts/understanding-unique-ptr-with-example-in-cpp11/>understanding unique_ptr with example in C++ here</a>.</li></ul><h2 id=nullptrpostswhat-exactly-nullptr-is-in-cpp><a href=/posts/what-exactly-nullptr-is-in-cpp/>nullptr</a><a hidden class=anchor aria-hidden=true href=#nullptrpostswhat-exactly-nullptr-is-in-cpp>#</a></h2><ul><li>C++11 introduces a new null pointer type designed to replace C&rsquo;s <code>NULL</code> macro.</li><li><a href=/posts/what-exactly-nullptr-is-in-cpp/><code>nullptr</code></a> itself is of type <code>std::nullptr_t</code> and can be implicitly converted into pointer types, and unlike <code>NULL</code>, not convertible to integral types except <code>bool</code>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>foo</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span> <span class=c1>// error -- ambiguous
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>foo</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span> <span class=c1>// calls foo(char*)
</span></span></span></code></pre></div><h2 id=strongly-typed-enums>Strongly-typed enums<a hidden class=anchor aria-hidden=true href=#strongly-typed-enums>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>STATUS_t</span> <span class=o>:</span> <span class=kt>uint32_t</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PASS</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FAIL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>HUNG</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>STATUS_t</span> <span class=n>STATUS</span> <span class=o>=</span> <span class=n>STATUS_t</span><span class=o>::</span><span class=n>PASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>STATUS</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// not valid anymore from C++11
</span></span></span></code></pre></div><ul><li>Type-safe enums that solve a variety of problems with C-style enums including implicit conversions, arithmetic operations, inability to specify the underlying type, scope pollution, etc.</li></ul><h2 id=typecasting>Typecasting<a hidden class=anchor aria-hidden=true href=#typecasting>#</a></h2><ul><li>C style casting only change the type without touching underlying data. While older C++ was a bit type-safe and has a feature of specifying type conversion operator/function. But it was implicit type conversion, from C++11, conversion functions can now be made explicit using the <code>explicit</code> specifier as follows.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=k>operator</span> <span class=nf>bool</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>demo</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>d</span><span class=p>);</span>                             <span class=c1>// OK calls demo::operator bool()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>b_d</span> <span class=o>=</span> <span class=n>d</span><span class=p>;</span>                       <span class=c1>// error: cannot convert &#39;demo&#39; to &#39;bool&#39; in initialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>b_d</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>    <span class=c1>// OK, explicit conversion, you know what you are doing
</span></span></span></code></pre></div><ul><li>If the above code looks alien to you, I have written a more detailed article on <a href=/posts/cpp-type-casting-with-example-for-c-developers/>C++ typecasting here</a>.</li></ul><h2 id=move-semantics>Move semantics<a hidden class=anchor aria-hidden=true href=#move-semantics>#</a></h2><ul><li>When an object is going to be destroyed or unused after expression execution, then it is more feasible to move resource rather than copying it.</li><li>Copying includes unnecessary overheads like memory allocation, deallocation & copying memory content, etc.</li><li>Consider the following swap function:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>swap</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>tmp</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>   <span class=c1>// we now have two copies of a
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>      <span class=c1>// we now have two copies of b (+ discarded a copy of a)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>b</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>    <span class=c1>// we now have two copies of tmp (+ discarded a copy of b)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>using move allows you to swap the resources instead of copying them around:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>swap</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>tmp</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>a</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>   
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Think of what happens when <code>T</code> is, say, <code>vector&lt;int></code> of size n. And n is too big.</li><li>In the first version, you read and write 3*n elements, in the second version you basically read and write just the 3 pointers to the vectors&rsquo; buffers, plus the 3 buffers&rsquo; sizes.</li><li>Of course, class <code>T</code> needs to know how to do the moving; your class should have a <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>move-assignment operator and a move-constructor</a> for class <code>T</code> for this to work.</li><li>This feature will give you a significant boost in the performance which is why people use C++ for(i.e. last 2-3 drops of speed).</li></ul><h2 id=forwarding-references>Forwarding references<a hidden class=anchor aria-hidden=true href=#forwarding-references>#</a></h2><ul><li>Also known (unofficially) as <em>universal references</em>. A forwarding reference is created with the syntax <code>T&&</code> where <code>T</code> is a template type parameter, or using <code>auto&&</code>. This enables two major features<ul><li>move semantics</li><li>And <em><a href=https://en.cppreference.com/w/cpp/utility/forward#Example>perfect forwarding</a></em>, the ability to pass arguments that are either lvalues or rvalues.</li></ul></li></ul><p>Forwarding references allow a reference to binding to either an lvalue or rvalue depending on the type. Forwarding references follow the rules of <em>reference collapsing</em>:</p><ol><li><code>T& &</code> becomes <code>T&</code></li><li><code>T& &&</code> become <code>T&</code></li><li><code>T&& &</code> becomes <code>T&</code></li><li><code>T&& &&</code> becomes <code>T&&</code></li></ol><p>Template type parameter deduction with lvalues and rvalues:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Since C++14 or later:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Since C++11 or later:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// deduces as f(int&amp;&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=c1>// deduces as f(int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=n>y</span><span class=p>);</span> <span class=c1>// deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;&amp;</span> <span class=n>z</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// NOTE: `z` is an lvalue with type `int&amp;&amp;`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>z</span><span class=p>);</span> <span class=c1>// deduces as f(int&amp;&amp; &amp;) =&gt; f(int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>z</span><span class=p>));</span> <span class=c1>// deduces as f(int&amp;&amp; &amp;&amp;) =&gt; f(int&amp;&amp;)
</span></span></span></code></pre></div><ul><li>If this seems complex & weird to you then <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>read this first</a> & then come back here.</li></ul><h2 id=variadic-templates>Variadic templates<a hidden class=anchor aria-hidden=true href=#variadic-templates>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>First</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Rest</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=k>const</span> <span class=n>First</span> <span class=o>&amp;</span><span class=n>first</span><span class=p>,</span> <span class=n>Rest</span> <span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>args</span><span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>print</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;lol&#34;</span><span class=p>,</span> <span class=mf>1.1</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>The <code>...</code> syntax creates a <em><a href=https://en.cppreference.com/w/cpp/language/parameter_pack>parameter pack</a></em> or expands one. A template <em>parameter pack</em> is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A <a href=/posts/c-template-a-quick-uptodate-look/>C++ template</a> with at least one parameter pack is called a <em>variadic template</em>.</li></ul><h2 id=constexpr>constexpr<a hidden class=anchor aria-hidden=true href=#constexpr>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>uint32_t</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>1u</span><span class=p>)</span> <span class=o>?</span> <span class=nl>i</span> <span class=p>:</span> <span class=p>(</span><span class=n>fibonacci</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=k>auto</span> <span class=n>fib_5th_term</span> <span class=o>=</span> <span class=n>fibonacci</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span> <span class=c1>// equal to `auto fib_5th_term = 8`
</span></span></span></code></pre></div><ul><li>Constant expressions are expressions evaluated by the compiler at compile-time. In the above case, <code>fibonacci</code> the function is executed/evaluated by the compiler at the time of compilation & result will be substituted at calling the place.</li><li>I have written a detailed article on <a href=/posts/when-to-use-const-vs-constexpr-in-cpp/>when to use const vs constexpr in C++</a>.</li></ul><h2 id=deleted--defaulted-functions>Deleted & Defaulted functions<a hidden class=anchor aria-hidden=true href=#deleted--defaulted-functions>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>demo</span> <span class=n>d</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Now you might be wondering that rather than writing 8+ letters(i.e. <code>= default;</code>), I could simply use {} i.e. empty constructor. That&rsquo;s true! but think about <a href=/posts/all-about-copy-constructor-in-cpp/>copy constructor</a>, <a href=/posts/2-wrong-way-to-learn-copy-assignment-operator-in-c/>copy assignment operator</a>, etc.</li><li>An empty <a href=/posts/all-about-copy-constructor-in-cpp/>copy constructor</a>, for example, will not do the same as a defaulted c<a href=/posts/all-about-copy-constructor-in-cpp/>opy constructor</a> (which will perform a member-wise copy of its members).</li></ul><p>You can limit certain operation or way of <a href=/posts/inside-the-c-object-model/>object instantiation</a> by simply deleting the respective method as follows</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>m_x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_x</span><span class=p>(</span><span class=n>x</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=k>const</span> <span class=n>demo</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>demo</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>demo</span> <span class=n>obj1</span><span class=p>{</span><span class=mi>123</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>demo</span> <span class=n>obj2</span> <span class=o>=</span> <span class=n>obj1</span><span class=p>;</span> <span class=c1>// error -- call to deleted copy constructor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>obj2</span> <span class=o>=</span> <span class=n>obj1</span><span class=p>;</span>      <span class=c1>// error -- operator= deleted
</span></span></span></code></pre></div><p>In older C++ you have to make it private. But now you have <code>delete</code> compiler directive.</p><h2 id=delegating-constructors>Delegating constructors<a hidden class=anchor aria-hidden=true href=#delegating-constructors>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>m_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=kt>int</span> <span class=n>var</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_var</span><span class=p>(</span><span class=n>var</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>()</span> <span class=o>:</span> <span class=n>demo</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>demo</span> <span class=n>d</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>In older C++, you have to create common initialization member function & need to call it from all the constructor to achieve the common initialization.</li><li>But from C++11, now constructors can call other constructors in the same class using an initializer list.</li></ul><h2 id=lambda-expression>Lambda expression<a hidden class=anchor aria-hidden=true href=#lambda-expression>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>generator</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>]()</span> <span class=k>mutable</span> <span class=p>{</span> <span class=k>return</span> <span class=o>++</span><span class=n>i</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>generator</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>generator</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>generator</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// 3
</span></span></span></code></pre></div><ul><li>I think this feature no need any introduction & hot favourite among other features.</li><li>Now you can declare functions wherever you want. That too with zero cost performance impact. </li><li>I wrote a separate article to <a href=/posts/learn-lambda-function-in-cpp-with-example/>learn lambda expression in C++ with example</a>.</li></ul><h2 id=selection-statements-with-initializer>Selection statements with initializer<a hidden class=anchor aria-hidden=true href=#selection-statements-with-initializer>#</a></h2><ul><li>In earlier C++, the initializer is either declared before the statement and leaked into the ambient scope, or an explicit scope is used.</li><li><a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r1.html>With C++17, the new form of</a> <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r1.html>if/switch</a> can be written more compactly, and the improved scope control makes some erstwhile error-prone constructions a bit more robust:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=k>auto</span> <span class=n>STATUS</span> <span class=o>=</span> <span class=n>window</span><span class=p>.</span><span class=n>status</span><span class=p>())</span> <span class=c1>// Declare the object right within selection statement
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>PASS</span><span class=p>:</span><span class=c1>// do this
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>FAIL</span><span class=p>:</span><span class=c1>// do that
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>How it works</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>STATUS</span> <span class=o>=</span> <span class=n>window</span><span class=p>.</span><span class=n>status</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>STATUS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>PASS</span><span class=p>:</span> <span class=c1>// do this
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>FAIL</span><span class=p>:</span> <span class=c1>// do that
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=stdtuple>std::tuple<a hidden class=anchor aria-hidden=true href=#stdtuple>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>employee</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span><span class=mi>32</span><span class=p>,</span> <span class=s>&#34; Vishal Chovatiya&#34;</span><span class=p>,</span> <span class=s>&#34;Bangalore&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span><span class=p>(</span><span class=n>employee</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// 32
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>(</span><span class=n>employee</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// &#34;Vishal Chovatiya&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>2</span><span class=o>&gt;</span><span class=p>(</span><span class=n>employee</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// &#34;Bangalore&#34;
</span></span></span></code></pre></div><ul><li>Tuples are a fixed-size collection of heterogeneous values. Access the elements of a <code>std::tuple</code> by unpacking using <code>std::tie</code>, or using <code>std::get</code>.</li><li>You can also catch arbitrary & heterogeneous return values as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>get_employee_detail</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do something . . . 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span><span class=mi>32</span><span class=p>,</span> <span class=s>&#34; Vishal Chovatiya&#34;</span><span class=p>,</span> <span class=s>&#34;Bangalore&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>tie</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ignore</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ignore</span><span class=p>)</span> <span class=o>=</span> <span class=n>get_employee_detail</span><span class=p>();</span>
</span></span></code></pre></div><ul><li>Use <code>std::ignore</code> as a placeholder for ignored values. In C++17, <a href=https://stackoverflow.com/questions/40673080/stdignore-with-structured-bindings>structured bindings</a> should be used instead.</li></ul><h2 id=class-template-argument-deduction>Class template argument deduction<a hidden class=anchor aria-hidden=true href=#class-template-argument-deduction>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>user</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;M&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>};</span> <span class=c1>// previous
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>pair</span> <span class=n>user</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;M&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>};</span>                   <span class=c1>// C++17
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>user</span><span class=p>(</span><span class=s>&#34;M&#34;</span><span class=p>,</span> <span class=s>&#34;Chy&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>);</span> <span class=c1>// previous
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>tuple</span> <span class=n>user2</span><span class=p>(</span><span class=s>&#34;M&#34;</span><span class=p>,</span> <span class=s>&#34;Chy&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>);</span>                               <span class=c1>// deduction in action!
</span></span></span></code></pre></div><ul><li>Automatic template argument deduction much likes how it&rsquo;s done for functions, but now including class constructors as well.</li></ul><h2 id=closing-words>Closing words<a hidden class=anchor aria-hidden=true href=#closing-words>#</a></h2><p>Here, we have just scratched the surface in terms of <a href=https://github.com/AnthonyCalandra/modern-cpp-features>new feature</a> & the possibility of its application. There are many things to learn in Modern C++, but still, you can consider this as a good starting point. Modern C++ is not only expanding in terms of syntax but there is lot more other features are also added like unordered containers, threads, regex, Chrono, random number generator/distributor, <a href=/posts/7-best-practices-for-exception-handling-in-cpp-with-example/>exception handling</a> and many new STL algos(like <code>all_of()</code>, <code>any_of()</code> and <code>none_of()</code>, etc).</p><p>Happy Modern C++ Coding&mldr;!</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/c-digit-separators/>C-Digit-Separators</a></li><li><a href=http://localhost:1313/tags/c-smart-pointers/>C-Smart-Pointers</a></li><li><a href=http://localhost:1313/tags/c-uniform-initialization-non-static-member-initialization/>C-Uniform-Initialization-Non-Static-Member-Initialization</a></li><li><a href=http://localhost:1313/tags/c-user-defined-literals/>C-User-Defined-Literals</a></li><li><a href=http://localhost:1313/tags/class-template-argument-deduction/>Class-Template-Argument-Deduction</a></li><li><a href=http://localhost:1313/tags/forwarding-reference/>Forwarding-Reference</a></li><li><a href=http://localhost:1313/tags/lambda-expression-in-c/>Lambda-Expression-in-C</a></li><li><a href=http://localhost:1313/tags/modern-c/>Modern-C</a></li><li><a href=http://localhost:1313/tags/modern-c-features/>Modern-C-Features</a></li><li><a href=http://localhost:1313/tags/new-features-in-c/>New-Features-in-C</a></li><li><a href=http://localhost:1313/tags/nullptr-c/>Nullptr-C</a></li><li><a href=http://localhost:1313/tags/smart-pointers/>Smart-Pointers</a></li><li><a href=http://localhost:1313/tags/strongly-typed-enums/>Strongly-Typed-Enums</a></li><li><a href=http://localhost:1313/tags/strongly-typed-enums-c/>Strongly-Typed-Enums-C</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/7-best-practices-for-exception-handling-in-cpp-with-example/><span class=title>« Prev</span><br><span>C++ Exception Handling Best Practices: 7 Things To Know</span>
</a><a class=next href=http://localhost:1313/posts/learn-lambda-function-in-cpp-with-example/><span class=title>Next »</span><br><span>All About Lambda Function in C++(From C++11 to C++20)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 21 New Features of Modern C++ to Use in Your Project on x" href="https://x.com/intent/tweet/?text=21%20New%20Features%20of%20Modern%20C%2b%2b%20to%20Use%20in%20Your%20Project&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f21-new-features-of-modern-cpp-to-use-in-your-project%2f&amp;hashtags=c-digit-separators%2cc-smart-pointers%2cc-uniform-initialization-non-static-member-initialization%2cc-user-defined-literals%2cclass-template-argument-deduction%2cforwarding-reference%2clambda-expression-in-c%2cmodern-c%2cmodern-c-features%2cnew-features-in-c%2cnullptr-c%2csmart-pointers%2cstrongly-typed-enums%2cstrongly-typed-enums-c"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 21 New Features of Modern C++ to Use in Your Project on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f21-new-features-of-modern-cpp-to-use-in-your-project%2f&amp;title=21%20New%20Features%20of%20Modern%20C%2b%2b%20to%20Use%20in%20Your%20Project&amp;summary=21%20New%20Features%20of%20Modern%20C%2b%2b%20to%20Use%20in%20Your%20Project&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2f21-new-features-of-modern-cpp-to-use-in-your-project%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 21 New Features of Modern C++ to Use in Your Project on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2f21-new-features-of-modern-cpp-to-use-in-your-project%2f&title=21%20New%20Features%20of%20Modern%20C%2b%2b%20to%20Use%20in%20Your%20Project"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 21 New Features of Modern C++ to Use in Your Project on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2f21-new-features-of-modern-cpp-to-use-in-your-project%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 21 New Features of Modern C++ to Use in Your Project on whatsapp" href="https://api.whatsapp.com/send?text=21%20New%20Features%20of%20Modern%20C%2b%2b%20to%20Use%20in%20Your%20Project%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2f21-new-features-of-modern-cpp-to-use-in-your-project%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 21 New Features of Modern C++ to Use in Your Project on telegram" href="https://telegram.me/share/url?text=21%20New%20Features%20of%20Modern%20C%2b%2b%20to%20Use%20in%20Your%20Project&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f21-new-features-of-modern-cpp-to-use-in-your-project%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 21 New Features of Modern C++ to Use in Your Project on ycombinator" href="https://news.ycombinator.com/submitlink?t=21%20New%20Features%20of%20Modern%20C%2b%2b%20to%20Use%20in%20Your%20Project&u=http%3a%2f%2flocalhost%3a1313%2fposts%2f21-new-features-of-modern-cpp-to-use-in-your-project%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>