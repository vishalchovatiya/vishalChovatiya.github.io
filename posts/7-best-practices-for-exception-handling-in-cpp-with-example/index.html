<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ Exception Handling Best Practices: 7 Things To Know | Vishal Chovatiya</title>
<meta name=keywords content="best-practices-for-exception-handling-in-c,best-practices-for-exception-handling-in-c-with-example,c-exception-example,c-exception-handling-best-practices,c-throw-exception-example,c-try-catch-example,copy-move-constructor-while-throwing-user-defined-type-object,cpp-exception-example,exception-handling-example-in-c,exception-handling-in-c-example,exception-handling-in-c-example-programs,exception-handling-in-c-simple-program,exception-handling-in-c-using-class,exception_ptr,keyword-ideas,move-semantics-exception-c,noexcept-operator-what-is-it-used-for,noexcept-specifier,noexcept-specifier-vs-operator,performance-cost-of-exceptions-c,rethrowing-nested-exceptions,rethrowing-nested-exceptions-with-stdexception_ptr,simple-exception-handling-program-in-c,simple-program-for-exception-handling-in-c,stdmove_if_noexcept,throw-c-example,throw-exception-c-example,throwing-exception-from-the-constructor,throwing-exception-from-the-constructor-c,throwing-exceptions-out-of-a-destructor,throwing-exceptions-out-of-a-destructor-c,try-catch-c-syntax,try-catch-in-c-example,try-catch-throw-c,try-catch-throw-c-example"><meta name=description content="Exception handling in C++ is a well-unschooled topic if you observe initial stages of the learning curve. There are numerous tutorials available online on exception handling in C++. But few explains what you should not do & intricacies around it. So here I am to bridge the gap & show you some intricacies, from where & why you should not throw an exception and C++ exception handling best practices. Along with some newer features introduced for exception handling in Modern C++ with example."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=http://localhost:1313/posts/7-best-practices-for-exception-handling-in-cpp-with-example/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/7-best-practices-for-exception-handling-in-cpp-with-example/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="C++ Exception Handling Best Practices: 7 Things To Know"><meta property="og:description" content="Exception handling in C++ is a well-unschooled topic if you observe initial stages of the learning curve. There are numerous tutorials available online on exception handling in C++. But few explains what you should not do & intricacies around it. So here I am to bridge the gap & show you some intricacies, from where & why you should not throw an exception and C++ exception handling best practices. Along with some newer features introduced for exception handling in Modern C++ with example."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/7-best-practices-for-exception-handling-in-cpp-with-example/"><meta property="og:image" content="http://localhost:1313/images/exception.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-11-03T00:00:00+00:00"><meta property="article:modified_time" content="2019-11-03T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/exception.jpg"><meta name=twitter:title content="C++ Exception Handling Best Practices: 7 Things To Know"><meta name=twitter:description content="Exception handling in C++ is a well-unschooled topic if you observe initial stages of the learning curve. There are numerous tutorials available online on exception handling in C++. But few explains what you should not do & intricacies around it. So here I am to bridge the gap & show you some intricacies, from where & why you should not throw an exception and C++ exception handling best practices. Along with some newer features introduced for exception handling in Modern C++ with example."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"C++ Exception Handling Best Practices: 7 Things To Know","item":"http://localhost:1313/posts/7-best-practices-for-exception-handling-in-cpp-with-example/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ Exception Handling Best Practices: 7 Things To Know","name":"C\u002b\u002b Exception Handling Best Practices: 7 Things To Know","description":"Exception handling in C++ is a well-unschooled topic if you observe initial stages of the learning curve. There are numerous tutorials available online on exception handling in C++. But few explains what you should not do \u0026amp; intricacies around it. So here I am to bridge the gap \u0026amp; show you some intricacies, from where \u0026amp; why you should not throw an exception and C++ exception handling best practices. Along with some newer features introduced for exception handling in Modern C++ with example.","keywords":["best-practices-for-exception-handling-in-c","best-practices-for-exception-handling-in-c-with-example","c-exception-example","c-exception-handling-best-practices","c-throw-exception-example","c-try-catch-example","copy-move-constructor-while-throwing-user-defined-type-object","cpp-exception-example","exception-handling-example-in-c","exception-handling-in-c-example","exception-handling-in-c-example-programs","exception-handling-in-c-simple-program","exception-handling-in-c-using-class","exception_ptr","keyword-ideas","move-semantics-exception-c","noexcept-operator-what-is-it-used-for","noexcept-specifier","noexcept-specifier-vs-operator","performance-cost-of-exceptions-c","rethrowing-nested-exceptions","rethrowing-nested-exceptions-with-stdexception_ptr","simple-exception-handling-program-in-c","simple-program-for-exception-handling-in-c","stdmove_if_noexcept","throw-c-example","throw-exception-c-example","throwing-exception-from-the-constructor","throwing-exception-from-the-constructor-c","throwing-exceptions-out-of-a-destructor","throwing-exceptions-out-of-a-destructor-c","try-catch-c-syntax","try-catch-in-c-example","try-catch-throw-c","try-catch-throw-c-example"],"articleBody":"Exception handling in C++ is a well-unschooled topic if you observe initial stages of the learning curve. There are numerous tutorials available online on exception handling in C++. But few explains what you should not do \u0026 intricacies around it. So here I am to bridge the gap \u0026 show you some intricacies, from where \u0026 why you should not throw an exception and C++ exception handling best practices. Along with some newer features introduced for exception handling in Modern C++ with example.\nIn the end, we will see the performance cost of using an exception by a quick benchmark code. Finally, we will close the article with a summary of Best practices \u0026 some C++ Core Guidelines on exception handling.\nNote: I would not cover anything regarding a dynamic exception as it deprecated from C++11 and removed in C++17.\nTerminology/Jargon/Idiom You May Face potentially throwing: may or may not throw an exception. noexcept: this is specifier as well as operator depending upon where \u0026 how you use it. Will see that later. RAII: Resource Acquisition Is Initialization is a scope-bound resource management mechanism. Which means resource allocation done with the constructor \u0026 resource deallocation with the destructor during the defined scope of the object. I know it’s a terrible name but very powerful concept. Implicitly-declared special member functions: I think this need not require any introduction. 1. Implement Copy And/Or Move Constructor While Throwing User-Defined Type Object struct demo { demo() = default; demo(demo \u0026\u0026) = delete; demo(const demo \u0026) = delete; }; int main() { throw demo{}; return 0; } Upon throw expression, a copy of the exception object created as the original object goes out of the scope during the stack unwinding process. During that initialization, we may expect copy elision (see this) – omits copy or move constructors (object constructed directly into the storage of the target object). But even though copy elision may or may not apply you should provide proper copy constructor and/or move constructor which is what C++ standard mandates(see 15.1). See below compilation error for reference. error: call to deleted constructor of 'demo' throw demo{}; ^~~~~~ note: 'demo' has been explicitly marked deleted here demo(demo \u0026\u0026) = delete; ^ 1 error generated. compiler exit status 1 Above error stands true till C++14. Since C++17, If the thrown object is a prvalue, the copy/move elision is guaranteed. If we catch an exception by value, we may also expect copy elision(compilers permitted to do so, but it is not mandatory). The exception object is an lvalue argument when initializing catch clause parameters. TL;DR\nclass used for throwing the exception object needs copy and/or move constructors\n2. Be Cautious While Throwing an Exception From the Constructor struct base { base(){cout\u003c\u003c\"base\\n\";} ~base(){cout\u003c\u003c\"~base\\n\";} }; struct derive : base { derive(){cout\u003c\u003c\"derive\\n\"; throw -1;} ~derive(){cout\u003c\u003c\"~derive\\n\";} }; int main() { try{ derive{}; } catch (...){} return 0; } When an exception is thrown from a constructor, stack unwinding begins, destructors for the object will only be called, if an object creation is successful. So be caution with dynamic memory allocation here. In such cases, you should use RAII. base derive ~base As you can see in the above case, the destructor of derive is not executed, Because, it is not created successfully. struct base { base() { cout \u003c\u003c \"base\\n\"; } ~base() { cout \u003c\u003c \"~base\\n\"; } }; struct derive : base { derive() = default; derive(int) : derive{} { cout \u003c\u003c \"derive\\n\"; throw - 1; } ~derive() { cout \u003c\u003c \"~derive\\n\"; } }; int main() { try{ derive{0}; } catch (...){} return 0; } In the case of constructor delegation, it is considered as the creation of object hence destructor of derive will be called. base derive ~derive ~base TL;DR\nWhen an exception is thrown from a constructor, destructors for the object will be called only \u0026 only if an object is created successfully\n3. Avoid Throwing Exceptions out of a Destructor struct demo { ~demo() { throw std::exception{}; } }; int main() { try{ demo d; } catch (const std::exception \u0026){} return 0; } Above code seems straight forward but when you run it, it terminates as shown below rather than catching the exception. Reason for this is destructors are by default noexcept (i.e. non-throwing) $ clang++-7 -o main main.cpp warning: '~demo' has a non-throwing exception specification but can still throw [-Wexceptions] ~demo() { throw std::exception{}; } ^ note: destructor has a implicit non-throwing exception specification ~demo() { throw std::exception{}; } ^ 1 warning generated. $ $ ./main terminate called after throwing an instance of 'std::exception' what(): std::exception exited, aborted `noexcept(false) will solve our problem as below struct X { ~X() noexcept(false) { throw std::exception{}; } }; But don’t do it. Destructors are by default non-throwing for a reason, and we must not throw exceptions in destructors unless we catch them inside the destructor. Why you should not throw an exception from a destructor?\nBecause destructors are called during stack unwinding when an exception is thrown, and we are not allowed to throw another exception while the previous one is not caught – in such a case std::terminate will be called.\nConsider the following example for more clarity. struct base { ~base() noexcept(false) { throw 1; } }; struct derive : base { ~derive() noexcept(false) { throw 2; } }; int main() { try{ derive d; } catch (...){ } return 0; } An exception will be thrown when the object d will be destroyed as a result of RAII. But at the same time destructor of base will also be called as it is sub-object of derive which will again throw an exception. Now we have two exceptions at the same time which is invalid scenario \u0026 std::terminate will be called. There are some type trait utilities like std::is_nothrow_destructible, std::is_nothrow_constructible, etc. from #include by which you can check whether the special member functions are exception-safe or not.\nint main() { cout \u003c\u003c std::boolalpha \u003c\u003c std::is_nothrow_destructible\u003cstd::string\u003e::value \u003c\u003c endl; cout \u003c\u003c std::boolalpha \u003c\u003c std::is_nothrow_constructible\u003cstd::string\u003e::value \u003c\u003c endl; return 0; } TL;DR\n1. Destructors are by default noexcept (i.e. non-throwing).\n2. You should not throw exception out of destructors because destructors are called during stack unwinding when an exception is thrown, and we are not allowed to throw another exception while the previous one is not caught – in such a case std::terminate will be called.\n4. Nested Exception Handling Best Practice With std::exception_ptr( C++11) Example This is more of a demonstration rather the best practice of the nested exception scenario using std::exception_ptr. Although you can simply use std::exception without complicating things much but std::exception_ptr will provide us with the leverage of handling exception out of try / catch clause.\nvoid print_nested_exception(const std::exception_ptr \u0026eptr=std::current_exception(), size_t level=0) { static auto get_nested = [](auto \u0026e) -\u003e std::exception_ptr { try { return dynamic_cast\u003cconst std::nested_exception \u0026\u003e(e).nested_ptr(); } catch (const std::bad_cast\u0026) { return nullptr; } }; try{ if (eptr) std::rethrow_exception(eptr); } catch (const std::exception \u0026e){ std::cerr \u003c\u003c std::string(level, ' ') \u003c\u003c \"exception: \" \u003c\u003c e.what() \u003c\u003c '\\n'; print_nested_exception(get_nested(e), level + 1);// rewind all nested exception } } // ----------------------------------------------------------------------------------------------- void func2(){ try { throw std::runtime_error(\"TESTING NESTED EXCEPTION SUCCESS\"); } catch (...) { std::throw_with_nested(std::runtime_error(\"func2() failed\")); } } void func1(){ try { func2(); } catch (...) { std::throw_with_nested(std::runtime_error(\"func1() failed\")); } } int main() { try { func1(); } catch (const std::exception\u0026) { print_nested_exception(); } return 0; } // Will only work with C++14 or above Above example looks complicated at first, but once you have implemented nested exception handler(i.e. print_nested_exception). Then you only need to focus on throwing the exception using std::throw_with_nested function. exception: func1() failed exception: func2() failed exception: TESTING NESTED EXCEPTION SUCCESS The main thing to focus here is print_nested_exception function in which we are rewinding nested exception using std::rethrow_exception \u0026 std::exception_ptr. std::exception_ptr is a shared pointer like type though dereferencing it is undefined behaviour. It can hold nullptr or point to an exception object and can be constructed as: std::exception_ptr e1; // null std::exception_ptr e2 = std::current_exception(); // null or a current exception std::exception_ptr e3 = std::make_exception_ptr(std::exception{}); // std::exception Once std::exception_ptr is created, we can use it to throw or re-throw exceptions by calling `std::rethrow_exception(exception_ptr) as we did above, which throws the pointed exception object. TL;DR\n1. std::exception_ptr extends the lifetime of a pointed exception object beyond a catch clause.\n2. We may use std::exception_ptr to delay the handling of a current exception and transfer it to some other palaces. Though, practical usecase of std::exception_ptr is between threads.\n5. Use noexcept `Specifier` vs `Operator` Appropriately I think this is an oblivious concept among the other concepts of the C++ exceptions. noexcept specifier \u0026 operator came in C++11 to replace deprecated(removed from C++17) dynamic exception specification. void func() throw(std::exception); // dynamic excpetions, removed from C++17 void potentially_throwing(); // may throw void non_throwing() noexcept; // \"specifier\" specifying non-throwing function void print() {} void (*func_ptr)() noexcept = print; // Not OK from C++17, `print()`should be noexcept too, works in C++11/14 void debug_deep() noexcept(false) {} // specifier specifying throw void debug() noexcept(noexcept(debug_deep())) {} // specifier \u0026 operator, will follow exception rule of `debug_deep` auto l_non_throwing = []() noexcept {}; // Yeah..! lambdas are also in party noexcept Specifier I think this needs no introduction it does what its name suggests. So let’s quickly go through some pointers:\nCan use for normal functions, methods, lambda functions \u0026 function pointer. From C++17, function pointer with noexcept can not points to potentially throwing function. Finally, don’t use noexcept specifier for virtual functions in a base class/interface because it enforces restriction for all overrides. Don’t use noexcept unless you really need it. “Specify it when it is useful and correct” - Google’s cppguide. noexcept Operator \u0026 What Is It Use For? Added in C++11, noexcept operator takes an expression (not necessarily constant) and performs a compile-time check determining if that expression is non-throwing (noexcept) or potentially throwing. The result of such compile-time check can be used, for example, to add noexceptspecifier to the same category, higher-level function `(noexcept(noexcept(expr))) or in if constexpr. We can use noexcept operator to check if some class has noexcept constructor, noexcept copy constructor, noexcept move constructor, and so on as follows: class demo { public: demo() {} demo(const demo \u0026) {} demo(demo \u0026\u0026) {} void method() {} }; int main() { cout \u003c\u003c std::boolalpha \u003c\u003c noexcept(demo()) \u003c\u003c endl; // C cout \u003c\u003c std::boolalpha \u003c\u003c noexcept(demo(demo())) \u003c\u003c endl; // CC cout \u003c\u003c std::boolalpha \u003c\u003c noexcept(demo(std::declval\u003cdemo\u003e())) \u003c\u003c endl; // MC cout \u003c\u003c std::boolalpha \u003c\u003c noexcept(std::declval\u003cdemo\u003e().method()) \u003c\u003c endl; // Methods } // std::declval returns an rvalue reference to a type You must be wondering why \u0026 how this information will be useful?\nThis is more useful when you are using library functions inside your function to suggest compiler that your function is throwing or non-throwing depending upon library implementation. If you remove constructor, copy constructor \u0026 move constructor, it will print true reason being implicitly-declared special member functions are always non-throwing. TL;DR\nnoexcept specifier \u0026 operator are two different things. noexcept operator performs a compile-time check \u0026 doesn’t evaluate the expression. While noexcept specifier can take only constant expressions that evaluate to either true or false.\n6. Move Exception-Safe with std::move_if_noexcept struct demo { demo() = default; demo(const demo \u0026) { cout \u003c\u003c \"Copying\\n\"; } // Exception safe move constructor demo(demo \u0026\u0026) noexcept { cout \u003c\u003c \"Moving\\n\"; } private: std::vector\u003cint\u003e m_v; }; int main() { demo obj1; if (noexcept(demo(std::declval\u003cdemo\u003e()))){ // if moving safe demo obj2(std::move(obj1)); // then move it } else{ demo obj2(obj1); // otherwise copy it } demo obj3(std::move_if_noexcept(obj1)); // Alternatively you can do this---------------- return 0; } We can use noexcept(T(std::declval()) to check if T’s move constructor exists and is noexcept in order to decide if we want to create an instance of T by moving another instance of T (using std::move). Alternatively, we can use std::move_if_noexcept, which uses noexcept operator and casts to either rvalue or lvalue. Such checks are used in std::vector and other containers. This will be useful while you are processing critical data which you don’t want to lose. For example, we have critical data received from the server that we do not want to lose it at any cost while processing. In such a case, we should use std::move_if_noexcept which will move ownership of critical data only and only if move constructor is exception-safe. TL;DR\nMove critical object safely with std::move_if_noexcept\n7. Real Cost of C++ Exception Handling With Benchmark Despite many benefits, most people still do not prefer to use exceptions due to its overhead. So let’s clear it out of the way:\nstatic void without_exception(benchmark::State \u0026state){ for (auto _ : state){ std::vector\u003cuint32_t\u003e v(10000); for (uint32_t i = 0; i \u003c 10000; i++) v.at(i) = i; } } BENCHMARK(without_exception);//---------------------------------------- static void with_exception(benchmark::State \u0026state){ for (auto _ : state){ std::vector\u003cuint32_t\u003e v(10000); for (uint32_t i = 0; i \u003c 10000; i++){ try{ v.at(i) = i; } catch (const std::out_of_range \u0026oor){} } } } BENCHMARK(with_exception);//-------------------------------------------- static void throwing_exception(benchmark::State \u0026state){ for (auto _ : state){ std::vector\u003cuint32_t\u003e v(10000); for (uint32_t i = 1; i \u003c 10001; i++){ try{ v.at(i) = i; } catch (const std::out_of_range \u0026oor){} } } } BENCHMARK(throwing_exception);//----------------------------------------- As you can see above, with_exception \u0026 without_exception has only a single difference i.e. exception syntax. But none of them throws any exceptions. While throwing_exception does the same task except it throws an exception of type std::out_of_range in the last iteration. As you can see in below bar graph, the last bar is slightly high as compared to the previous two which shows the cost of throwing an exception. But the cost of using exception is zero here, as the previous two bars are identical. I am not considering the optimization here which is the separate case as it trims some of the assembly instructions completely. Also, implementation of compiler \u0026 ABI plays a crucial role. But still, it is far better than losing time by setting up a guard(`if(error) strategy) and explicitly checking for the presence of error everywhere. While in case of exception, the compiler generates a side table that maps any point that may throw an exception (program counter) to the list of handlers. When an exception is thrown, this list consults to pick the right handler (if any) and the stack unwound. See this for in-depth knowledge. By the way, I am using a quick benchmark \u0026 which internally uses Google Benchmark, if you want to explore more. First and foremost, remember that using try and catch doesn’t actually decrease performance unless an exception is thrown. It’s “zero cost” exception handling; no instruction related to exception handling executes until one is thrown. But, at the same time, it contributes to the size of executable due to unwinding routines, which may be important to consider for embedded systems. TL;DR\nNo instruction related to exception handling is executed until one is thrown so using try / catch doesn’t actually decrease performance.\nBest Practices \u0026 Some C++ Core Guidelines on Exception Handling C++ Exception Handling Best Practices\nIdeally, you should not throw an exception from the destructor, move constructor or swap like functions.\nPrefer RAII idiom for the exception safety because in case of exception you might be left with\n- data in an invalid state, i.e. data that cannot be further read \u0026 used;\n- leaked resources such as memory, files, ids, or anything else that needs to be allocated and released;\n- corrupted memory;\n- broken invariants, e.g. size function returns more elements than actually held in a container.\nAvoid using raw new \u0026 delete. Use solutions from the standard library, e.g. std::unique_pointer, std::make_unique, std::fstream, std::lock_guard, etc.\nMoreover, it is useful to split your code into modifying and non-modifying parts, where only the non-modifying part can throw exceptions.\nNever throw exceptions while owing some resource.\nSome CPP Core Guidelines\nE.1: Develop an error-handling strategy early in a design E.3: Use exceptions for error handling only E.6: Use RAII to prevent leaks E.13: Never throw while being the direct owner of an object E.16: Destructors, deallocation, and swap must never fail E.17: Don’t try to catch every exception in every function E.18: Minimize the use of explicit try/catch 26: If you can’t throw exceptions, consider failing fast E.31: Properly order your catch-clauses ","wordCount":"2686","inLanguage":"en","image":"http://localhost:1313/images/exception.jpg","datePublished":"2019-11-03T00:00:00Z","dateModified":"2019-11-03T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/7-best-practices-for-exception-handling-in-cpp-with-example/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=http://localhost:1313/posts/ title=Latest><span>Latest</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ Exception Handling Best Practices: 7 Things To Know</h1><div class=post-meta><span title='2019-11-03 00:00:00 +0000 UTC'>November 3, 2019</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2686 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/7-best-practices-for-exception-handling-in-cpp-with-example.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/images/exception.jpg alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#terminologyjargonidiom-you-may-face>Terminology/Jargon/Idiom You May Face</a></li><li><a href=#1-implement-copy-andor-move-constructor-while-throwing-user-defined-type-object>1. Implement Copy And/Or Move Constructor While Throwing User-Defined Type Object</a></li><li><a href=#2-be-cautious-while-throwing-an-exception-from-the-constructor>2. Be Cautious While Throwing an Exception From the Constructor</a></li><li><a href=#3-avoid-throwing-exceptions-out-of-a-destructor>3. Avoid Throwing Exceptions out of a Destructor</a></li><li><a href=#4-nested-exception-handling-best-practice-with-stdexception_ptr-c11-example>4. Nested Exception Handling Best Practice With std::exception_ptr( C++11) Example</a></li><li><a href=#5-use-noexcept-specifier-vs-operator-appropriately>5. Use noexcept `Specifier` vs `Operator` Appropriately</a><ul><li><a href=#noexcept-specifier>noexcept Specifier</a></li><li><a href=#noexcept-operator--what-is-it-use-for>noexcept Operator & What Is It Use For?</a></li></ul></li><li><a href=#6-move-exception-safe-with-stdmove_if_noexcept>6. Move Exception-Safe with std::move_if_noexcept</a></li><li><a href=#7-real-cost-of-c-exception-handling-with-benchmark>7. Real Cost of C++ Exception Handling With Benchmark</a></li><li><a href=#best-practices--some-c-core-guidelines-on-exception-handling>Best Practices & Some C++ Core Guidelines on Exception Handling</a></li></ul></nav></div></details></div><div class=post-content><p>Exception handling in C++ is a well-unschooled topic if you observe initial stages of the learning curve. There are numerous tutorials available online on exception handling in C++. But few explains what you should not do & intricacies around it. So here I am to bridge the gap & show you some intricacies, from where & why you should not throw an exception and C++ exception handling best practices. Along with some newer features introduced for exception handling in <a href=/posts/21-new-features-of-modern-cpp-to-use-in-your-project/>Modern C++</a> with example.</p><p>In the end, we will see the <a href=#Runtime-cost-of-exceptions-with-quick-benchmark>performance cost of using an exception</a> by a quick benchmark code. Finally, we will close the article with a summary of <a href=#Best-practices-&-some-CPP-Core-Guidelines-on-exception-handling>Best practices & some C++ Core Guidelines on exception handling</a>.</p><p><strong><em>Note</em></strong><em>: I would not cover anything regarding a dynamic exception as it deprecated from C++11 and removed in C++17.</em></p><h2 id=terminologyjargonidiom-you-may-face>Terminology/Jargon/Idiom You May Face<a hidden class=anchor aria-hidden=true href=#terminologyjargonidiom-you-may-face>#</a></h2><ul><li><strong>potentially throwing</strong>: may or may not throw an exception.</li><li><strong>noexcept</strong>: this is specifier as well as operator depending upon where & how you use it. Will see that <a href=#noexcept-specifier-vs-operator>later</a>.</li><li><strong><a href=/posts/7-advanced-cpp-programming-styles-and-idiom-examples-you-should-know/#RAII>RAII</a></strong>: <strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization is a scope-bound resource management mechanism. Which means resource allocation done with the constructor & resource deallocation with the destructor during the defined scope of the object. I know it&rsquo;s a terrible name but very powerful concept.</li><li><strong><a href=https://stackoverflow.com/questions/11671282/implicitly-declared-special-member-functions>Implicitly-declared special member functions</a></strong>: I think this need not require any introduction.</li></ul><h2 id=1-implement-copy-andor-move-constructor-while-throwing-user-defined-type-object>1. Implement Copy And/Or Move Constructor While Throwing User-Defined Type Object<a hidden class=anchor aria-hidden=true href=#1-implement-copy-andor-move-constructor-while-throwing-user-defined-type-object>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=n>demo</span> <span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=k>const</span> <span class=n>demo</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>demo</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Upon throw expression, a copy of the exception object created as the original object goes out of the scope during the stack unwinding process.</li><li>During that initialization, we may expect <a href=https://en.wikipedia.org/wiki/Copy_elision>copy elision</a> (see <a href=https://wg21.cmeerw.net/cwg/issue1493>this</a>) – omits <a href=/posts/move-constructor-assignment-operator-with-shared-ptr/>copy or move constructors</a> (object constructed directly into the storage of the target object).</li><li>But even though copy elision may or may not apply you should provide proper copy constructor and/or move constructor which is what <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf>C++ standard mandates(see 15.1)</a>. See below compilation error for reference.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>error: call to deleted constructor of <span class=s1>&#39;demo&#39;</span>
</span></span><span class=line><span class=cl>    throw demo<span class=o>{}</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          ^~~~~~
</span></span><span class=line><span class=cl>note: <span class=s1>&#39;demo&#39;</span> has been explicitly marked deleted here
</span></span><span class=line><span class=cl>    demo<span class=o>(</span>demo <span class=o>&amp;&amp;)</span> <span class=o>=</span> delete<span class=p>;</span>
</span></span><span class=line><span class=cl>    ^
</span></span><span class=line><span class=cl><span class=m>1</span> error generated.
</span></span><span class=line><span class=cl>compiler <span class=nb>exit</span> status <span class=m>1</span>
</span></span></code></pre></div><ul><li>Above error stands true till C++14. Since C++17, If the thrown object is a prvalue, the copy/move elision is guaranteed.</li><li>If we catch an exception by value, we may also expect copy elision(compilers permitted to do so, but it is not mandatory). The exception object is an lvalue argument when initializing catch clause parameters.</li></ul><p><strong>TL;DR</strong><br>class used for throwing the exception object needs copy and/or move constructors</p><h2 id=2-be-cautious-while-throwing-an-exception-from-the-constructor>2. Be Cautious While Throwing an Exception From the Constructor<a hidden class=anchor aria-hidden=true href=#2-be-cautious-while-throwing-an-exception-from-the-constructor>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>base</span><span class=p>(){</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;base</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>base</span><span class=p>(){</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;~base</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>derive</span> <span class=o>:</span> <span class=n>base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>derive</span><span class=p>(){</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;derive</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=k>throw</span> <span class=o>-</span><span class=mi>1</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>derive</span><span class=p>(){</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;~derive</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>derive</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(...){}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>When an exception is thrown from a constructor, stack unwinding begins, destructors for the object will only be called, if an object creation is successful. So be caution with dynamic memory allocation here. In such cases, you should use <a href=/posts/7-advanced-cpp-programming-styles-and-idiom-examples-you-should-know/#RAII>RAII</a>.</li></ul><pre tabindex=0><code>base
derive
~base
</code></pre><ul><li>As you can see in the above case, the destructor of <code>derive</code> is not executed, Because, it is not created successfully.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>base</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;base</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>base</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~base</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>derive</span> <span class=o>:</span> <span class=n>base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>derive</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>derive</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>:</span> <span class=n>derive</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;derive</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>derive</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~derive</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>derive</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(...){}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>In the case of constructor delegation, it is considered as the creation of object hence destructor of <code>derive</code> will be called.</li></ul><pre tabindex=0><code>base
derive
~derive
~base
</code></pre><p><strong>TL;DR</strong><br>When an exception is thrown from a constructor, destructors for the object will be called only & only if an object is created successfully</p><h2 id=3-avoid-throwing-exceptions-out-of-a-destructor>3. Avoid Throwing Exceptions out of a Destructor<a hidden class=anchor aria-hidden=true href=#3-avoid-throwing-exceptions-out-of-a-destructor>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>demo</span><span class=p>()</span> <span class=p>{</span> <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=p>{};</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>demo</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span> <span class=o>&amp;</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Above code seems straight forward but when you run it, it terminates as shown below rather than catching the exception. Reason for this is destructors are by default <code>noexcept</code> (i.e. non-throwing)</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ clang++-7 -o main main.cpp
</span></span><span class=line><span class=cl>warning: <span class=s1>&#39;~demo&#39;</span> has a non-throwing exception specification but can still
</span></span><span class=line><span class=cl>      throw <span class=o>[</span>-Wexceptions<span class=o>]</span>
</span></span><span class=line><span class=cl>    ~demo<span class=o>()</span> <span class=o>{</span> throw std::exception<span class=o>{}</span><span class=p>;</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>              ^
</span></span><span class=line><span class=cl>note: destructor has a implicit non-throwing exception specification
</span></span><span class=line><span class=cl>    ~demo<span class=o>()</span> <span class=o>{</span> throw std::exception<span class=o>{}</span><span class=p>;</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>    ^
</span></span><span class=line><span class=cl><span class=m>1</span> warning generated.
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl>$ ./main
</span></span><span class=line><span class=cl>terminate called after throwing an instance of <span class=s1>&#39;std::exception&#39;</span>
</span></span><span class=line><span class=cl>  what<span class=o>()</span>:  std::exception
</span></span><span class=line><span class=cl>exited, aborted
</span></span></code></pre></div><ul><li>`noexcept(false) will solve our problem as below</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>X</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>X</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>(</span><span class=nb>false</span><span class=p>)</span> <span class=p>{</span> <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=p>{};</span> <span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>But don’t do it. Destructors are by default non-throwing for a reason, and we must not throw exceptions in destructors unless we catch them inside the destructor.</li></ul><p><strong>Why you should not throw an exception from a destructor?</strong></p><p>Because destructors are called during stack unwinding when an exception is thrown, and we are not allowed to throw another exception while the previous one is not caught – in such a case <code>std::terminate</code> will be called.</p><ul><li>Consider the following example for more clarity.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>base</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>(</span><span class=nb>false</span><span class=p>)</span> <span class=p>{</span> <span class=k>throw</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>derive</span> <span class=o>:</span> <span class=n>base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>derive</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>(</span><span class=nb>false</span><span class=p>)</span> <span class=p>{</span> <span class=k>throw</span> <span class=mi>2</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>derive</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(...){</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>An exception will be thrown when the object <code>d</code> will be destroyed as a result of <a href=/posts/7-advanced-cpp-programming-styles-and-idiom-examples-you-should-know/#RAII>RAII</a>. But at the same time destructor of <code>base</code> will also be called as it is <a href=/posts/memory-layout-of-cpp-object/>sub-object</a> of <code>derive</code> which will again throw an exception. Now we have two exceptions at the same time which is invalid scenario & <code>std::terminate</code> will be called.</li></ul><p>There are some type trait utilities like <code>std::is_nothrow_destructible</code>, <code>std::is_nothrow_constructible</code>, etc. from <code>#include&lt;type_traits></code> by which you can check whether the special member functions are exception-safe or not.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>boolalpha</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>is_nothrow_destructible</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;::</span><span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>boolalpha</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>is_nothrow_constructible</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;::</span><span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>TL;DR</strong><br>1. Destructors are by default <code>noexcept</code> (i.e. non-throwing).<br>2. You should not throw exception out of destructors because destructors are called during stack unwinding when an exception is thrown, and we are not allowed to throw another exception while the previous one is not caught – in such a case <code>std::terminate</code> will be called.</p><h2 id=4-nested-exception-handling-best-practice-with-stdexception_ptr-c11-example>4. Nested Exception Handling Best Practice With std::exception_ptr( C++11) Example<a hidden class=anchor aria-hidden=true href=#4-nested-exception-handling-best-practice-with-stdexception_ptr-c11-example>#</a></h2><p>This is more of a demonstration rather the best practice of the nested exception scenario using <code>std::exception_ptr</code>. Although you can simply use <code>std::exception</code> without complicating things much but <code>std::exception_ptr</code> will provide us with the leverage of handling exception out of <code>try</code> / <code>catch</code> clause.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print_nested_exception</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception_ptr</span> <span class=o>&amp;</span><span class=n>eptr</span><span class=o>=</span><span class=n>std</span><span class=o>::</span><span class=n>current_exception</span><span class=p>(),</span> <span class=n>size_t</span> <span class=n>level</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>auto</span> <span class=n>get_nested</span> <span class=o>=</span> <span class=p>[](</span><span class=k>auto</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>exception_ptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=p>{</span> <span class=k>return</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>nested_exception</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>e</span><span class=p>).</span><span class=n>nested_ptr</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>bad_cast</span><span class=o>&amp;</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>eptr</span><span class=p>)</span> <span class=n>std</span><span class=o>::</span><span class=n>rethrow_exception</span><span class=p>(</span><span class=n>eptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=sc>&#39; &#39;</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;exception: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>print_nested_exception</span><span class=p>(</span><span class=n>get_nested</span><span class=p>(</span><span class=n>e</span><span class=p>),</span> <span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span><span class=c1>// rewind all nested exception
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// -----------------------------------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>func2</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span>         <span class=p>{</span> <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;TESTING NESTED EXCEPTION SUCCESS&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(...)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>throw_with_nested</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;func2() failed&#34;</span><span class=p>));</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func1</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span>         <span class=p>{</span> <span class=n>func2</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(...)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>throw_with_nested</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;func1() failed&#34;</span><span class=p>));</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span>                             <span class=p>{</span> <span class=n>func1</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=o>&amp;</span><span class=p>)</span>   <span class=p>{</span> <span class=n>print_nested_exception</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Will only work with C++14 or above
</span></span></span></code></pre></div><ul><li>Above example looks complicated at first, but once you have implemented nested exception handler(i.e. <code>print_nested_exception</code>). Then you only need to focus on throwing the exception using <code>std::throw_with_nested</code> function.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>exception: func1<span class=o>()</span> failed
</span></span><span class=line><span class=cl> exception: func2<span class=o>()</span> failed
</span></span><span class=line><span class=cl>  exception: TESTING NESTED EXCEPTION SUCCESS
</span></span></code></pre></div><ul><li>The main thing to focus here is <code>print_nested_exception</code> function in which we are rewinding nested exception using <code>std::rethrow_exception</code> & <code>std::exception_ptr</code>.</li><li><code>std::exception_ptr</code> is a <a href=/posts/move-constructor-assignment-operator-with-shared-ptr>shared pointer</a> like type though dereferencing it is undefined behaviour. It can hold <a href=/posts/what-exactly-nullptr-is-in-cpp/>nullptr</a> or point to an exception object and can be constructed as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>exception_ptr</span> <span class=n>e1</span><span class=p>;</span>                                             <span class=c1>// null
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>exception_ptr</span> <span class=n>e2</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>current_exception</span><span class=p>();</span>                  <span class=c1>// null or a current exception
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>exception_ptr</span> <span class=n>e3</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_exception_ptr</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=p>{});</span> <span class=c1>// std::exception
</span></span></span></code></pre></div><ul><li>Once <code>std::exception_ptr</code> is created, we can use it to throw or re-throw exceptions by calling `std::rethrow_exception(exception_ptr) as we did above, which throws the pointed exception object.</li></ul><p><strong>TL;DR</strong><br>1. <code>std::exception_ptr</code> extends the lifetime of a pointed exception object beyond a catch clause.<br>2. We may use <code>std::exception_ptr</code> to delay the handling of a current exception and transfer it to some other palaces. Though, practical usecase of <code>std::exception_ptr</code> is between threads.</p><h2 id=5-use-noexcept-specifier-vs-operator-appropriately>5. Use noexcept `Specifier` vs `Operator` Appropriately<a hidden class=anchor aria-hidden=true href=#5-use-noexcept-specifier-vs-operator-appropriately>#</a></h2><ul><li>I think this is an oblivious concept among the other concepts of the C++ exceptions.</li><li><code>noexcept</code> <a href=https://en.cppreference.com/w/cpp/language/noexcept_spec>specifier</a> & <a href=https://en.cppreference.com/w/cpp/language/noexcept>operator</a> came in C++11 to replace deprecated(removed from C++17) dynamic exception specification.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span> <span class=k>throw</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=p>);</span>                   <span class=c1>// dynamic excpetions, removed from C++17
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>potentially_throwing</span><span class=p>();</span>                         <span class=c1>// may throw
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>non_throwing</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span>                        <span class=c1>// &#34;specifier&#34; specifying non-throwing function
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=p>{}</span>                                  
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>func_ptr</span><span class=p>)()</span> <span class=k>noexcept</span> <span class=o>=</span> <span class=n>print</span><span class=p>;</span>                 <span class=c1>// Not OK from C++17, `print()`should be noexcept too, works in C++11/14
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>debug_deep</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>(</span><span class=nb>false</span><span class=p>)</span> <span class=p>{}</span>                 <span class=c1>// specifier specifying throw
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>debug</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>(</span><span class=k>noexcept</span><span class=p>(</span><span class=n>debug_deep</span><span class=p>()))</span> <span class=p>{}</span>     <span class=c1>// specifier &amp; operator, will follow exception rule of `debug_deep`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>l_non_throwing</span> <span class=o>=</span> <span class=p>[]()</span> <span class=k>noexcept</span> <span class=p>{};</span>              <span class=c1>// Yeah..! lambdas are also in party
</span></span></span></code></pre></div><h3 id=noexcept-specifier>noexcept Specifier<a hidden class=anchor aria-hidden=true href=#noexcept-specifier>#</a></h3><p>I think this needs no introduction it does what its name suggests. So let&rsquo;s quickly go through some pointers:</p><ul><li>Can use for normal functions, methods, <a href=/posts/learn-lambda-function-in-cpp-with-example/>lambda functions</a> & function pointer.</li><li>From C++17, function pointer with noexcept can not points to potentially throwing function.</li><li>Finally, don’t use <code>noexcept</code> specifier for <a href=/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/>virtual functions</a> in a base class/interface because it enforces restriction for all overrides.</li><li>Don’t use noexcept unless you really need it. &ldquo;Specify it when it is useful and correct&rdquo; - <a href=https://google.github.io/styleguide/cppguide.html#noexcept>Google’s cppguide</a>.</li></ul><h3 id=noexcept-operator--what-is-it-use-for>noexcept Operator & What Is It Use For?<a hidden class=anchor aria-hidden=true href=#noexcept-operator--what-is-it-use-for>#</a></h3><ul><li>Added in C++11, <code>noexcept</code> operator takes an expression (not necessarily constant) and performs a compile-time check determining if that expression is non-throwing (<code>noexcept</code>) or potentially throwing.</li><li>The result of such compile-time check can be used, for example, to add <code>noexcept</code>specifier to the same category, higher-level function `(noexcept(noexcept(expr))) or in if <a href=/posts/when-to-use-const-vs-constexpr-in-cpp/>constexpr</a>.</li><li>We can use noexcept operator to check if some class has noexcept constructor, noexcept copy constructor, noexcept move constructor, and so on as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=k>const</span> <span class=n>demo</span> <span class=o>&amp;</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=n>demo</span> <span class=o>&amp;&amp;</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>method</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>boolalpha</span> <span class=o>&lt;&lt;</span> <span class=k>noexcept</span><span class=p>(</span><span class=n>demo</span><span class=p>())</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>                        <span class=c1>// C
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>boolalpha</span> <span class=o>&lt;&lt;</span> <span class=k>noexcept</span><span class=p>(</span><span class=n>demo</span><span class=p>(</span><span class=n>demo</span><span class=p>()))</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>                  <span class=c1>// CC
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>boolalpha</span> <span class=o>&lt;&lt;</span> <span class=k>noexcept</span><span class=p>(</span><span class=n>demo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>declval</span><span class=o>&lt;</span><span class=n>demo</span><span class=o>&gt;</span><span class=p>()))</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>    <span class=c1>// MC
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>boolalpha</span> <span class=o>&lt;&lt;</span> <span class=k>noexcept</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>declval</span><span class=o>&lt;</span><span class=n>demo</span><span class=o>&gt;</span><span class=p>().</span><span class=n>method</span><span class=p>())</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// Methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// std::declval&lt;T&gt; returns an rvalue reference to a type
</span></span></span></code></pre></div><ul><li>You must be wondering why & how this information will be useful?<br>This is more useful when you are using library functions inside your function to suggest compiler that your function is throwing or non-throwing depending upon library implementation.</li><li>If you remove constructor, <a href=/posts/all-about-copy-constructor-in-cpp/>copy constructor</a> & <a href=/posts/move-constructor-assignment-operator-with-shared-ptr/>move constructor</a>, it will print <code>true</code> reason being implicitly-declared special member functions are always non-throwing.</li></ul><p><strong>TL;DR</strong><br><code>noexcept</code> specifier & operator are two different things. <code>noexcept</code> operator performs a compile-time check & doesn’t evaluate the expression. While <code>noexcept</code> specifier can take only constant expressions that evaluate to either true or false.</p><h2 id=6-move-exception-safe-with-stdmove_if_noexcept>6. Move Exception-Safe with std::move_if_noexcept<a hidden class=anchor aria-hidden=true href=#6-move-exception-safe-with-stdmove_if_noexcept>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>demo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span><span class=p>(</span><span class=k>const</span> <span class=n>demo</span> <span class=o>&amp;</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Copying</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Exception safe move constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>demo</span><span class=p>(</span><span class=n>demo</span> <span class=o>&amp;&amp;</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Moving</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>    <span class=n>m_v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>demo</span> <span class=n>obj1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>noexcept</span><span class=p>(</span><span class=n>demo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>declval</span><span class=o>&lt;</span><span class=n>demo</span><span class=o>&gt;</span><span class=p>()))){</span>  <span class=c1>// if moving safe
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>demo</span> <span class=n>obj2</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>obj1</span><span class=p>));</span>             <span class=c1>// then move it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>demo</span> <span class=n>obj2</span><span class=p>(</span><span class=n>obj1</span><span class=p>);</span>                        <span class=c1>// otherwise copy it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>demo</span> <span class=n>obj3</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move_if_noexcept</span><span class=p>(</span><span class=n>obj1</span><span class=p>));</span>     <span class=c1>// Alternatively you can do this----------------
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>We can use <code>noexcept(T(std::declval&lt;T>()</code>) to check if <code>T</code>’s move constructor exists and is <code>noexcept</code> in order to decide if we want to create an instance of <code>T</code> by moving another instance of <code>T</code> (using <code>std::move</code>).</li><li>Alternatively, we can use <code>std::move_if_noexcept</code>, which uses <code>noexcept</code> operator and casts to either <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>rvalue or lvalue</a>. Such checks are used in <code>std::vector</code> and other containers.</li><li>This will be useful while you are processing critical data which you don&rsquo;t want to lose. For example, we have critical data received from the server that we do not want to lose it at any cost while processing. In such a case, we should use <code>std::move_if_noexcept</code> which will move ownership of critical data only and only if move constructor is exception-safe.</li></ul><p><strong>TL;DR</strong><br>Move critical object safely with <code>std::move_if_noexcept</code></p><h2 id=7-real-cost-of-c-exception-handling-with-benchmark>7. Real Cost of C++ Exception Handling With Benchmark<a hidden class=anchor aria-hidden=true href=#7-real-cost-of-c-exception-handling-with-benchmark>#</a></h2><p>Despite many benefits, most people still do not prefer to use exceptions due to its overhead. So let&rsquo;s clear it out of the way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>without_exception</span><span class=p>(</span><span class=n>benchmark</span><span class=o>::</span><span class=n>State</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>_</span> <span class=p>:</span> <span class=n>state</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>(</span><span class=mi>10000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10000</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=n>v</span><span class=p>.</span><span class=n>at</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>        
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>BENCHMARK</span><span class=p>(</span><span class=n>without_exception</span><span class=p>);</span><span class=c1>//----------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>with_exception</span><span class=p>(</span><span class=n>benchmark</span><span class=o>::</span><span class=n>State</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>_</span> <span class=p>:</span> <span class=n>state</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>(</span><span class=mi>10000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10000</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>v</span><span class=p>.</span><span class=n>at</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>out_of_range</span> <span class=o>&amp;</span><span class=n>oor</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>BENCHMARK</span><span class=p>(</span><span class=n>with_exception</span><span class=p>);</span><span class=c1>//--------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>throwing_exception</span><span class=p>(</span><span class=n>benchmark</span><span class=o>::</span><span class=n>State</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>_</span> <span class=p>:</span> <span class=n>state</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>(</span><span class=mi>10000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10001</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>v</span><span class=p>.</span><span class=n>at</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>out_of_range</span> <span class=o>&amp;</span><span class=n>oor</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>BENCHMARK</span><span class=p>(</span><span class=n>throwing_exception</span><span class=p>);</span><span class=c1>//-----------------------------------------
</span></span></span></code></pre></div><ul><li>As you can see above, <code>with_exception</code> & <code>without_exception</code> has only a single difference i.e. exception syntax. But none of them throws any exceptions.</li><li>While <code>throwing_exception</code> does the same task except it throws an exception of type <code>std::out_of_range</code> in the last iteration.</li><li>As you can see in below bar graph, the last bar is slightly high as compared to the previous two which shows the cost of throwing an exception.</li><li>But the <strong>cost of using exception is zero</strong> here, as the previous two bars are identical.</li><li>I am not considering the optimization here which is the separate case as it trims some of the assembly instructions completely. Also, implementation of compiler & ABI plays a crucial role. But still, it is far better than losing time by setting up a guard(`if(error) strategy) and explicitly checking for the presence of error everywhere.</li><li>While in case of exception, the compiler generates a side table that maps any point that may throw an exception (program counter) to the list of handlers. When an exception is thrown, this list consults to pick the right handler (if any) and the stack unwound. See <a href=https://monoinfinito.wordpress.com/series/exception-handling-in-c/>this</a> for in-depth knowledge.</li><li>By the way, I am using a <a href=http://quick-bench.com/qgpMiwVmHomfDmoLsPkb_i-Qw7M>quick benchmark</a> & which internally uses <a href=https://github.com/google/benchmark>Google Benchmark</a>, if you want to explore more.</li></ul><p><img loading=lazy src=/images/C-exception-bench-mark-without-optimization-1.png alt></p><ul><li>First and foremost, remember that using <code>try</code> and <code>catch</code> doesn&rsquo;t actually decrease performance unless an exception is thrown.</li><li>It&rsquo;s &ldquo;zero cost&rdquo; exception handling; no instruction related to exception handling executes until one is thrown.</li><li>But, at the same time, it contributes to the size of executable due to unwinding routines, which may be important to consider for embedded systems.</li></ul><p><strong>TL;DR</strong><br>No instruction related to exception handling is executed until one is thrown so using <code>try</code> / <code>catch</code> doesn&rsquo;t actually decrease performance.</p><h2 id=best-practices--some-c-core-guidelines-on-exception-handling>Best Practices & Some C++ Core Guidelines on Exception Handling<a hidden class=anchor aria-hidden=true href=#best-practices--some-c-core-guidelines-on-exception-handling>#</a></h2><p>C++ Exception Handling Best Practices</p><ul><li><p><strong>Ideally, you should not throw an exception from the destructor, move constructor or <a href=https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-throwing_swap>swap</a> like functions.</strong></p></li><li><p><strong>Prefer <a href=/posts/7-advanced-cpp-programming-styles-and-idiom-examples-you-should-know/#RAII>RAII</a> idiom for the exception safety because in case of exception you might be left with</strong></p><p>- data in an invalid state, i.e. data that cannot be further read & used;<br>- leaked resources such as memory, files, ids, or anything else that needs to be allocated and released;<br>- corrupted memory;<br>- broken invariants, e.g. size function returns more elements than actually held in a container.</p></li><li><p><strong>Avoid using <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new>raw</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new>new</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new>&</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new>delete</a>. Use solutions from the standard library, e.g. <a href=/posts/understanding-unique-ptr-with-example-in-cpp11/>std::unique_pointer</a>, <code>std::make_unique</code>, <code>std::fstream</code>, <code>std::lock_guard</code>, etc.</strong></p></li><li><p><strong>Moreover, it is useful to split your code into modifying and non-modifying parts, where only the non-modifying part can throw exceptions.</strong></p></li><li><p><strong>Never throw exceptions while owing some resource.</strong></p></li></ul><p><strong>Some CPP Core Guidelines</strong></p><ul><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-design>E.1: Develop an error-handling strategy early in a design</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-errors>E.3: Use exceptions for error handling only</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-raii>E.6: Use RAII to prevent leaks</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-throw>E.13: Never throw while being the direct owner of an object</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-fail>E.16: Destructors, deallocation, and</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-fail>swap</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-fail>must never fail</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-not-always>E.17: Don’t try to catch every exception in every function</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch>E.18: Minimize the use of explicit</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch>try</a><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch>/</a><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch>catch</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-no-throw-crash>26: If you can’t throw exceptions, consider failing fast</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re_catch>E.31: Properly order your</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re_catch>catch</a><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re_catch>-clauses</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/best-practices-for-exception-handling-in-c/>Best-Practices-for-Exception-Handling-in-C</a></li><li><a href=http://localhost:1313/tags/best-practices-for-exception-handling-in-c-with-example/>Best-Practices-for-Exception-Handling-in-C-With-Example</a></li><li><a href=http://localhost:1313/tags/c-exception-example/>C-Exception-Example</a></li><li><a href=http://localhost:1313/tags/c-exception-handling-best-practices/>C-Exception-Handling-Best-Practices</a></li><li><a href=http://localhost:1313/tags/c-throw-exception-example/>C-Throw-Exception-Example</a></li><li><a href=http://localhost:1313/tags/c-try-catch-example/>C-Try-Catch-Example</a></li><li><a href=http://localhost:1313/tags/copy-move-constructor-while-throwing-user-defined-type-object/>Copy-Move-Constructor-While-Throwing-User-Defined-Type-Object</a></li><li><a href=http://localhost:1313/tags/cpp-exception-example/>Cpp-Exception-Example</a></li><li><a href=http://localhost:1313/tags/exception-handling-example-in-c/>Exception-Handling-Example-in-C</a></li><li><a href=http://localhost:1313/tags/exception-handling-in-c-example/>Exception-Handling-in-C-Example</a></li><li><a href=http://localhost:1313/tags/exception-handling-in-c-example-programs/>Exception-Handling-in-C-Example-Programs</a></li><li><a href=http://localhost:1313/tags/exception-handling-in-c-simple-program/>Exception-Handling-in-C-Simple-Program</a></li><li><a href=http://localhost:1313/tags/exception-handling-in-c-using-class/>Exception-Handling-in-C-Using-Class</a></li><li><a href=http://localhost:1313/tags/exception_ptr/>Exception_ptr</a></li><li><a href=http://localhost:1313/tags/keyword-ideas/>Keyword-Ideas</a></li><li><a href=http://localhost:1313/tags/move-semantics-exception-c/>Move-Semantics-Exception-C</a></li><li><a href=http://localhost:1313/tags/noexcept-operator-what-is-it-used-for/>Noexcept-Operator-What-Is-It-Used-For</a></li><li><a href=http://localhost:1313/tags/noexcept-specifier/>Noexcept-Specifier</a></li><li><a href=http://localhost:1313/tags/noexcept-specifier-vs-operator/>Noexcept-Specifier-vs-Operator</a></li><li><a href=http://localhost:1313/tags/performance-cost-of-exceptions-c/>Performance-Cost-of-Exceptions-C</a></li><li><a href=http://localhost:1313/tags/rethrowing-nested-exceptions/>Rethrowing-Nested-Exceptions</a></li><li><a href=http://localhost:1313/tags/rethrowing-nested-exceptions-with-stdexception_ptr/>Rethrowing-Nested-Exceptions-With-Stdexception_ptr</a></li><li><a href=http://localhost:1313/tags/simple-exception-handling-program-in-c/>Simple-Exception-Handling-Program-in-C</a></li><li><a href=http://localhost:1313/tags/simple-program-for-exception-handling-in-c/>Simple-Program-for-Exception-Handling-in-C</a></li><li><a href=http://localhost:1313/tags/stdmove_if_noexcept/>Stdmove_if_noexcept</a></li><li><a href=http://localhost:1313/tags/throw-c-example/>Throw-C-Example</a></li><li><a href=http://localhost:1313/tags/throw-exception-c-example/>Throw-Exception-C-Example</a></li><li><a href=http://localhost:1313/tags/throwing-exception-from-the-constructor/>Throwing-Exception-From-the-Constructor</a></li><li><a href=http://localhost:1313/tags/throwing-exception-from-the-constructor-c/>Throwing-Exception-From-the-Constructor-C</a></li><li><a href=http://localhost:1313/tags/throwing-exceptions-out-of-a-destructor/>Throwing-Exceptions-Out-of-a-Destructor</a></li><li><a href=http://localhost:1313/tags/throwing-exceptions-out-of-a-destructor-c/>Throwing-Exceptions-Out-of-a-Destructor-C</a></li><li><a href=http://localhost:1313/tags/try-catch-c-syntax/>Try-Catch-C-Syntax</a></li><li><a href=http://localhost:1313/tags/try-catch-in-c-example/>Try-Catch-in-C-Example</a></li><li><a href=http://localhost:1313/tags/try-catch-throw-c/>Try-Catch-Throw-C</a></li><li><a href=http://localhost:1313/tags/try-catch-throw-c-example/>Try-Catch-Throw-C-Example</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/><span class=title>« Prev</span><br><span>7 Advance C++ Concepts & Idiom Examples You Should Know</span>
</a><a class=next href=http://localhost:1313/posts/21-new-features-of-modern-cpp-to-use-in-your-project/><span class=title>Next »</span><br><span>21 New Features of Modern C++ to Use in Your Project</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Exception Handling Best Practices: 7 Things To Know on x" href="https://x.com/intent/tweet/?text=C%2b%2b%20Exception%20Handling%20Best%20Practices%3a%207%20Things%20To%20Know&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-best-practices-for-exception-handling-in-cpp-with-example%2f&amp;hashtags=best-practices-for-exception-handling-in-c%2cbest-practices-for-exception-handling-in-c-with-example%2cc-exception-example%2cc-exception-handling-best-practices%2cc-throw-exception-example%2cc-try-catch-example%2ccopy-move-constructor-while-throwing-user-defined-type-object%2ccpp-exception-example%2cexception-handling-example-in-c%2cexception-handling-in-c-example%2cexception-handling-in-c-example-programs%2cexception-handling-in-c-simple-program%2cexception-handling-in-c-using-class%2cexception_ptr%2ckeyword-ideas%2cmove-semantics-exception-c%2cnoexcept-operator-what-is-it-used-for%2cnoexcept-specifier%2cnoexcept-specifier-vs-operator%2cperformance-cost-of-exceptions-c%2crethrowing-nested-exceptions%2crethrowing-nested-exceptions-with-stdexception_ptr%2csimple-exception-handling-program-in-c%2csimple-program-for-exception-handling-in-c%2cstdmove_if_noexcept%2cthrow-c-example%2cthrow-exception-c-example%2cthrowing-exception-from-the-constructor%2cthrowing-exception-from-the-constructor-c%2cthrowing-exceptions-out-of-a-destructor%2cthrowing-exceptions-out-of-a-destructor-c%2ctry-catch-c-syntax%2ctry-catch-in-c-example%2ctry-catch-throw-c%2ctry-catch-throw-c-example"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Exception Handling Best Practices: 7 Things To Know on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-best-practices-for-exception-handling-in-cpp-with-example%2f&amp;title=C%2b%2b%20Exception%20Handling%20Best%20Practices%3a%207%20Things%20To%20Know&amp;summary=C%2b%2b%20Exception%20Handling%20Best%20Practices%3a%207%20Things%20To%20Know&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-best-practices-for-exception-handling-in-cpp-with-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Exception Handling Best Practices: 7 Things To Know on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-best-practices-for-exception-handling-in-cpp-with-example%2f&title=C%2b%2b%20Exception%20Handling%20Best%20Practices%3a%207%20Things%20To%20Know"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Exception Handling Best Practices: 7 Things To Know on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-best-practices-for-exception-handling-in-cpp-with-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Exception Handling Best Practices: 7 Things To Know on whatsapp" href="https://api.whatsapp.com/send?text=C%2b%2b%20Exception%20Handling%20Best%20Practices%3a%207%20Things%20To%20Know%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2f7-best-practices-for-exception-handling-in-cpp-with-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Exception Handling Best Practices: 7 Things To Know on telegram" href="https://telegram.me/share/url?text=C%2b%2b%20Exception%20Handling%20Best%20Practices%3a%207%20Things%20To%20Know&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-best-practices-for-exception-handling-in-cpp-with-example%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Exception Handling Best Practices: 7 Things To Know on ycombinator" href="https://news.ycombinator.com/submitlink?t=C%2b%2b%20Exception%20Handling%20Best%20Practices%3a%207%20Things%20To%20Know&u=http%3a%2f%2flocalhost%3a1313%2fposts%2f7-best-practices-for-exception-handling-in-cpp-with-example%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>