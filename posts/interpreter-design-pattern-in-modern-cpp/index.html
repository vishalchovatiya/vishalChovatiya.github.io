<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Interpreter Design Pattern in Modern C&#43;&#43; · Vishal Chovatiya
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Vishal Chovatiya">
<meta name="description" content="Interpreter Design Pattern is a Behavioural Design Pattern which is a component that processes structured text data by turning it into separate lexical tokens(lexing) and then interpreting sequences of tokens(parsing). In this article, we will see the Interpreter Design Pattern in Modern C&#43;&#43;.
By the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:
Chain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated.">
<meta name="keywords" content="blog,developer,personal">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Interpreter Design Pattern in Modern C&#43;&#43;">
  <meta name="twitter:description" content="Interpreter Design Pattern is a Behavioural Design Pattern which is a component that processes structured text data by turning it into separate lexical tokens(lexing) and then interpreting sequences of tokens(parsing). In this article, we will see the Interpreter Design Pattern in Modern C&#43;&#43;.
By the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:
Chain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated.">

<meta property="og:url" content="http://localhost:1313/posts/interpreter-design-pattern-in-modern-cpp/">
  <meta property="og:site_name" content="Vishal Chovatiya">
  <meta property="og:title" content="Interpreter Design Pattern in Modern C&#43;&#43;">
  <meta property="og:description" content="Interpreter Design Pattern is a Behavioural Design Pattern which is a component that processes structured text data by turning it into separate lexical tokens(lexing) and then interpreting sequences of tokens(parsing). In this article, we will see the Interpreter Design Pattern in Modern C&#43;&#43;.
By the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:
Chain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-04-03T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-04-03T00:00:00+00:00">




<link rel="canonical" href="http://localhost:1313/posts/interpreter-design-pattern-in-modern-cpp/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>




<body class="preload-transitions colorscheme-light">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      Vishal Chovatiya
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Latest</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/pages/start-here">Start Here</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/cpp/">C/C&#43;&#43;</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/linux-system-programming/">Linux System Programming</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/misc/">Misc</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/interpreter-design-pattern-in-modern-cpp/">
              Interpreter Design Pattern in Modern C&#43;&#43;
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2020-04-03T00:00:00Z">
                April 3, 2020
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              6-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/cpp/">Cpp</a>
      <span class="separator">•</span>
    <a href="/categories/design-patterns/">Design-Patterns</a>
      <span class="separator">•</span>
    <a href="/categories/software-engineering/">Software-Engineering</a></div>

          
        </div>
      </header>

      <div class="post-content">
        
          <img src="/images/Interpreter-Design-Pattern-in-Modern-C-vishal-chovatihya.png" alt="Featured image"/>
        
        <p>Interpreter Design Pattern is a Behavioural Design Pattern which is <strong><em>a component that processes structured text data by turning it into separate lexical tokens(<a href="https://stackoverflow.com/questions/2842809/lexers-vs-parsers"  class="external-link" target="_blank" rel="noopener">lexing</a>) and then interpreting sequences of tokens(<a href="https://stackoverflow.com/questions/2842809/lexers-vs-parsers"  class="external-link" target="_blank" rel="noopener">parsing</a>)</em></strong>. In this article, we will see the Interpreter Design Pattern in Modern C++.</p>
<p>By the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:</p>
<ol>
<li><a href="/posts//chain-of-responsibility-design-pattern-in-modern-cpp/" >Chain of responsibility</a></li>
<li><a href="/posts//command-design-pattern-in-modern-cpp/" >Command</a></li>
<li><a href="/posts//interpreter-design-pattern-in-modern-cpp/" >Interpreter</a></li>
<li><a href="/posts//iterator-design-pattern-in-modern-cpp/" >Iterator</a></li>
<li><a href="/posts//mediator-design-pattern-in-modern-cpp/" >Mediator</a></li>
<li><a href="/posts//memento-design-pattern-in-modern-cpp/" >Memento</a></li>
<li><a href="/posts//observer-design-pattern-in-modern-cpp/" >Observer</a></li>
<li><a href="/posts//state-design-pattern-in-modern-cpp/" >State</a></li>
<li><a href="/posts//strategy-design-pattern-in-modern-cpp/" >Strategy</a></li>
<li><a href="/posts//template-method-design-pattern-in-modern-cpp/" >Template Method</a></li>
<li><a href="/posts//double-dispatch-visitor-design-pattern-in-modern-cpp/" >Visitor</a></li>
</ol>
<p>The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like <code>override</code>, <code>final</code>, <code>public</code>(while inheritance) just to make code compact &amp; consumable(most of the time) in single standard screen size. I also prefer <code>struct</code> instead of <code>class</code> just to save line by not writing &ldquo;<code>public:</code>&rdquo; sometimes and also miss <a href="/posts//part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" >virtual destructor</a>, constructor, <a href="/posts//all-about-copy-constructor-in-cpp-with-example/" >copy constructor</a>, prefix <code>std::</code>, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.</p>
<p><strong><em>Note:</em></strong></p>
<ul>
<li>If you stumbled here directly, then I would suggest you go through <a href="/posts//what-is-design-pattern/" >What is design pattern?</a> first, even if it is trivial. I believe it will encourage you to explore more on this topic.</li>
<li>All of this code you encounter in this series of articles are compiled using C++20(though I have used <a href="/posts//21-new-features-of-modern-cpp-to-use-in-your-project/" >Modern C++</a> features up to C++17 in most cases). So if you don&rsquo;t have access to the latest compiler you can use <a href="https://wandbox.org/"  class="external-link" target="_blank" rel="noopener">https://wandbox.org/</a> which has preinstalled boost library as well.</li>
</ul>
<h2 id="intent">
  Intent
  <a class="heading-link" href="#intent">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<blockquote>
<p><strong><em>To process structured text data by tokenizing &amp; parsing.</em></strong></p>
</blockquote>
<ul>
<li>Interpreters are everywhere, and especially for us(i.e.programmers), we are dealing with it every day. The front end of almost every compiler is an interpreter. Which parse the textual input &amp; turn it into some sort of meaningful <a href="/posts/memory-layout-of-cpp-object/" >object-oriented representation</a>.</li>
<li>Even all mathematical expression is required to be interpreted first. For example, 3 - (4/5) is a candidate for interpretation before processing. In which minus &amp; division is operation whereas 3, 4 &amp; 5 are operand having priority context defined by brackets.</li>
</ul>
<h2 id="interpreter-design-pattern-example-in-c">
  Interpreter Design Pattern Example in C++
  <a class="heading-link" href="#interpreter-design-pattern-example-in-c">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>In the following example, we&rsquo;re going to take a look at the interpretation process by looking at how to tokenize, parse and indeed evaluate simple numeric expressions.</li>
<li>And to do so we have divided the example into two parts i.e. i). tokenizing &amp; ii). parsing though it really depends on the kind of data that you work with but considering the general case here.</li>
<li>So in the first part, we will process simple mathematical expression which is of type string &amp; convert it into some sort of object-oriented representation i.e. tokens, the sequence of tokens more specifically.</li>
</ul>
<h3 id="lexing">
  Lexing
  <a class="heading-link" href="#lexing">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Token</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Type</span> { integer, plus, minus, lparen, rparen };
</span></span><span style="display:flex;"><span>    Type        m_type;
</span></span><span style="display:flex;"><span>    string      m_text;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Token(Type typ, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> txt)<span style="color:#f92672">:</span> m_type(typ), m_text(txt) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream<span style="color:#f92672">&amp;</span> os, <span style="color:#66d9ef">const</span> Token<span style="color:#f92672">&amp;</span> o) { <span style="color:#66d9ef">return</span> os <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;`&#34;</span> <span style="color:#f92672">&lt;&lt;</span> o.m_text <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;`&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> lex(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> input) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>   result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> curr <span style="color:#f92672">=</span> begin(input); curr <span style="color:#f92672">!=</span> end(input); <span style="color:#f92672">++</span>curr) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (<span style="color:#f92672">*</span>curr) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;+&#39;</span><span style="color:#f92672">:</span> result.emplace_back(Token<span style="color:#f92672">::</span>plus, <span style="color:#e6db74">&#34;+&#34;</span>); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">:</span> result.emplace_back(Token<span style="color:#f92672">::</span>minus, <span style="color:#e6db74">&#34;-&#34;</span>); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;(&#39;</span><span style="color:#f92672">:</span> result.emplace_back(Token<span style="color:#f92672">::</span>lparen, <span style="color:#e6db74">&#34;(&#34;</span>); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;)&#39;</span><span style="color:#f92672">:</span> result.emplace_back(Token<span style="color:#f92672">::</span>rparen, <span style="color:#e6db74">&#34;)&#34;</span>); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> <span style="color:#75715e">// number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">auto</span> first_not_digit <span style="color:#f92672">=</span> find_if(curr, end(input), [](<span style="color:#66d9ef">auto</span> c) {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>isdigit(c);
</span></span><span style="display:flex;"><span>				});
</span></span><span style="display:flex;"><span>				string integer <span style="color:#f92672">=</span> string(curr, first_not_digit);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				result.emplace_back(Token<span style="color:#f92672">::</span>integer, integer);
</span></span><span style="display:flex;"><span>				curr <span style="color:#f92672">=</span> <span style="color:#f92672">--</span>first_not_digit;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> tokens <span style="color:#f92672">=</span> lex(<span style="color:#e6db74">&#34;(13-4)-(12+1)&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> t: tokens)
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> t <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;	<span style="color:#75715e">// Output: `(` `13` `-` `4` `) `-` `(` `12` `+` `1` `)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>As you can see in the above example, we are creating the collection of tokens i.e. <code>+</code>, <code>-</code>, <code>(</code>, <code>)</code> &amp; numbers as a part of the 1st step to evaluate the expression <code>(13-4)-(12+1)</code>.</li>
</ul>
<h3 id="parsing">
  Parsing
  <a class="heading-link" href="#parsing">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Element</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">eval</span>() <span style="color:#66d9ef">const</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Integer</span> <span style="color:#f92672">:</span> Element {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>   m_value;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">Integer</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> v) <span style="color:#f92672">:</span> m_value(v) {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">eval</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> m_value; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BinaryOperation</span> <span style="color:#f92672">:</span> Element {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Type</span> { addition, subtraction }   m_type;
</span></span><span style="display:flex;"><span>    shared_ptr<span style="color:#f92672">&lt;</span>Element<span style="color:#f92672">&gt;</span>                   m_lhs, m_rhs;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">eval</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (m_type <span style="color:#f92672">==</span> addition) <span style="color:#66d9ef">return</span> m_lhs<span style="color:#f92672">-&gt;</span>eval() <span style="color:#f92672">+</span> m_rhs<span style="color:#f92672">-&gt;</span>eval();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> m_lhs<span style="color:#f92672">-&gt;</span>eval() <span style="color:#f92672">-</span> m_rhs<span style="color:#f92672">-&gt;</span>eval();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>shared_ptr<span style="color:#f92672">&lt;</span>Element<span style="color:#f92672">&gt;</span> parse(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>tokens) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> result <span style="color:#f92672">=</span> make_unique<span style="color:#f92672">&lt;</span>BinaryOperation<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> curr_token <span style="color:#f92672">=</span> begin(tokens); curr_token <span style="color:#f92672">!=</span> end(tokens); <span style="color:#f92672">++</span>curr_token) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (curr_token<span style="color:#f92672">-&gt;</span>m_type) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* ----------------- Normal Expression ----------------- */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> Token<span style="color:#f92672">::</span>integer:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>result<span style="color:#f92672">-&gt;</span>m_lhs) result<span style="color:#f92672">-&gt;</span>m_lhs <span style="color:#f92672">=</span> make_shared<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>(stoi(curr_token<span style="color:#f92672">-&gt;</span>m_text));
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> result<span style="color:#f92672">-&gt;</span>m_rhs <span style="color:#f92672">=</span> make_shared<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>(stoi(curr_token<span style="color:#f92672">-&gt;</span>m_text));
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> Token<span style="color:#f92672">::</span>plus: result<span style="color:#f92672">-&gt;</span>m_type <span style="color:#f92672">=</span> BinaryOperation<span style="color:#f92672">::</span>addition; <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> Token<span style="color:#f92672">::</span>minus: result<span style="color:#f92672">-&gt;</span>m_type <span style="color:#f92672">=</span> BinaryOperation<span style="color:#f92672">::</span>subtraction; <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* ----------------------------------------------------- */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* ------------------- Sub Expression ------------------ */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> Token<span style="color:#f92672">::</span>lparen:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> rparen <span style="color:#f92672">=</span> find_if(curr_token, end(tokens), [](<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> token) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> token.m_type <span style="color:#f92672">==</span> Token<span style="color:#f92672">::</span>rparen;
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            vector<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>   subexpression(curr_token <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, rparen);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>result<span style="color:#f92672">-&gt;</span>m_lhs) result<span style="color:#f92672">-&gt;</span>m_lhs <span style="color:#f92672">=</span> parse(subexpression);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> result<span style="color:#f92672">-&gt;</span>m_rhs <span style="color:#f92672">=</span> parse(subexpression);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            curr_token <span style="color:#f92672">=</span> rparen;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* ----------------------------------------------------- */</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	string expression{<span style="color:#e6db74">&#34;(13-4)-(12+1)&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> tokens <span style="color:#f92672">=</span> lex(expression);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> parsed <span style="color:#f92672">=</span> parse(tokens);
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> expression <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> parsed<span style="color:#f92672">-&gt;</span>eval() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// Output: (13-4)-(12+1) = -4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>You may be thinking that the parsing algorithm is bit complex, but if you eliminate smart pointer, code would become easy to consume. You can divide the parsing algorithm in two-part:
<ol>
<li><strong>Normal Expression</strong>: i.e. 13-4 which is easily parsed by 1st three cases of the switch statement <code>Token::plus</code>, <code>Token::minus</code> &amp; <code>Token::integer</code>.</li>
<li><strong>Sub-expression</strong>: i.e. expression starting from parenthesis. For example, <code>(13-4)</code> where I am extracting the content within parenthesis &amp; again providing it to <code>parse()</code>as it is a recurring problem.</li>
</ol>
</li>
<li>At the end of parsing, you will form the following tree structure:</li>
</ul>
<pre tabindex="0"><code>// (13-4)-(12+1) 
                  BinaryOperation(subtraction)
                        /              \
                       /                \
BinaryOperation(subtraction)         BinaryOperation(addition)
       /      \                              /      \
      /        \                            /        \
Integer(13)    Integer(4)             Integer(12)   Integer(1)
</code></pre><ul>
<li>When we call <code>parsed-&gt;eval()</code> in the main function, polymorphic overloaded <code>eval()</code>for all the nodes <a href="/posts/cpp-type-casting-with-example-for-c-developers/" >type</a>(i.e. <code>Integer</code> or <code>BinaryOperation</code>) in the above tree will be called recursively. An evaluation of an expression happens in the bottom-up approach.</li>
</ul>
<h2 id="benefits-of-interpreter-design-pattern">
  Benefits of Interpreter Design Pattern
  <a class="heading-link" href="#benefits-of-interpreter-design-pattern">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ol>
<li>It&rsquo;s easy to change and extend the grammar. Because classes used to represent grammar rules i.e. <code>+</code>, <code>-</code>, etc., we can use inheritance to change or extend the grammar. For example, to extend the above example for multiplication operator, you need to add one more case in switch case &amp; a bit of modification in <code>BinaryOperation</code> class.</li>
<li>Implementing the grammar is easy, too. As each symbol represents a token that essentially a class. To add a new symbol you need to create a new class.</li>
</ol>
<h2 id="summary-by-faqs">
  Summary by FAQs
  <a class="heading-link" href="#summary-by-faqs">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>Use cases of Interpreter Design Pattern.</strong></p>
<p>Programming language compilers, interpreters, IDEs, Document readers like HTML, XML, PDF, etc.A regular expression is a very subtle example of Interpreter.</p>
<p><strong>What problems can the Interpreter Design Pattern solve?</strong></p>
<p>Interpreter Design Pattern is used to interpret domain languages which can be anything from a simple calculator to a C++ parser.</p>
<p><strong>What solution does the Interpreter Design Pattern describe?</strong></p>
<p>Tokenizing symbols &amp; parsing it as a tree.</p>

      </div>


      <footer>
        


        
        
        
        
        

        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2024
     Vishal Chovatiya 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  
  



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
