<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Regex C&#43;&#43; · Vishal Chovatiya
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Vishal Chovatiya">
<meta name="description" content="Regular expressions (or regex in short) is a much-hated &amp; underrated topic so far with Modern C&#43;&#43;. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy).">
<meta name="keywords" content="blog,developer,personal">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Regex C&#43;&#43;">
  <meta name="twitter:description" content="Regular expressions (or regex in short) is a much-hated &amp; underrated topic so far with Modern C&#43;&#43;. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy).">

<meta property="og:url" content="http://localhost:1313/posts/regex-c/">
  <meta property="og:site_name" content="Vishal Chovatiya">
  <meta property="og:title" content="Regex C&#43;&#43;">
  <meta property="og:description" content="Regular expressions (or regex in short) is a much-hated &amp; underrated topic so far with Modern C&#43;&#43;. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy).">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-07-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-07-16T00:00:00+00:00">




<link rel="canonical" href="http://localhost:1313/posts/regex-c/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>




<body class="preload-transitions colorscheme-light">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      Vishal Chovatiya
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Latest</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/pages/start-here">Start Here</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/cpp/">C/C&#43;&#43;</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/linux-system-programming/">Linux System Programming</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/misc/">Misc</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/regex-c/">
              Regex C&#43;&#43;
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2020-07-16T00:00:00Z">
                July 16, 2020
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              10-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/cpp/">Cpp</a></div>

          
        </div>
      </header>

      <div class="post-content">
        
          <img src="/images/Regex-C-Regular-Expression.webp" alt="Featured image"/>
        
        <p>Regular expressions (or regex in short) is a much-hated &amp; underrated topic so far with Modern C++. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to <strong><em>learn once, write anywhere</em></strong> philosophy).</p>
<p>Initially, In this article, I have decided to include regex-in-general also. But it doesn&rsquo;t make sense, as there is already people/tutorial out there who does better than me in teaching regex. But still, I left a small section to address <a href="/posts/regex-c/#Motivation" >Motivation</a> &amp; <a href="/posts/regex-c/#Learning_Regex" >Learning Regex</a>. For the rest of the article, I will be focusing on functionality provided by C++ to work with regex. And if you are already aware of regex, you can use the above mind-map as a refresher.</p>
<p><strong><em>Pointer:</em></strong> The C++ standard library offers several different &ldquo;flavours&rdquo; of regex syntax, but the default flavour (the one you should always use &amp; I am demonstrating here) was borrowed wholesale from the standard for <a href="https://www.wikiwand.com/en/ECMAScript"  class="external-link" target="_blank" rel="noopener">ECMAScript</a>.</p>
<h2 id="motivation">
  Motivation
  <a class="heading-link" href="#motivation">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>I know its pathetic and somewhat confusing tool-set. Consider the below regex pattern for an example that extract time in 24-hour format i.e. HH:MM.</li>
</ul>
<pre tabindex="0"><code class="language-regex" data-lang="regex">\b([01]?[0-9]|2[0-3]):([0-5]\d)\b
</code></pre><ul>
<li>I mean! <strong><em>Who wants to work with this cryptic text?</em></strong></li>
<li>And whatever running in your mind is 100% reasonable. In fact, <strong><em>I have procrastinated learning regex twice due to the same reason</em></strong>. But, believe me, all the ugly looking things are not that bad.</li>
<li>The way(<strong>↓</strong>) I am describing here won&rsquo;t take more than 2-3 hours to learn regex that too intuitively. And After learning it you will see the compounding effect with return on investment over-the-time.</li>
</ul>
<h2 id="learning-regex">
  Learning Regex
  <a class="heading-link" href="#learning-regex">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Do not google much &amp; try to analyse which tutorial is best. In fact, don&rsquo;t waste time in such analysis. Because there is no point in doing so. At this point in time(well! if you don&rsquo;t know the regex) what really matters is &ldquo;Getting Started&rdquo; rather than &ldquo;What Is Best!&rdquo;.</li>
<li><strong><em>Just go to <a href="https://regexone.com/"  class="external-link" target="_blank" rel="noopener">https://regexone.com</a> without much overthinking</em></strong>. And complete all the lessons. Trust me here, I have explored many articles, <a href="https://www.udemy.com/course/regex-academy-an-introduction-to-text-parsing-sorcery/"  class="external-link" target="_blank" rel="noopener">courses</a>(&lt;=this one is free, BTW) &amp; books. But this is best among all for getting started without losing motivation.</li>
<li>And after it, if you still have an appetite to solve more problem &amp; exercises. Consider the below links:
<ol>
<li><a href="http://regextutorials.com/"  class="external-link" target="_blank" rel="noopener">Exercises on regextutorials.com</a></li>
<li><a href="https://www.hackerrank.com/domains/regex"  class="external-link" target="_blank" rel="noopener">Practice problem on regex by hackerrank</a></li>
</ol>
</li>
</ul>
<h2 id="stdregexhttpsencppreferencecomwcppregexbasic_regex--stdregex_errorhttpsencppreferencecomwcppregexregex_error-example">
  <a href="https://en.cppreference.com/w/cpp/regex/basic_regex"  class="external-link" target="_blank" rel="noopener">std::regex</a> &amp; <a href="https://en.cppreference.com/w/cpp/regex/regex_error"  class="external-link" target="_blank" rel="noopener">std::regex_error</a> Example
  <a class="heading-link" href="#stdregexhttpsencppreferencecomwcppregexbasic_regex--stdregex_errorhttpsencppreferencecomwcppregexregex_error-example">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> r <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>regex(R<span style="color:#e6db74">&#34;(\)&#34;</span>); <span style="color:#75715e">// Escape sequence error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">catch</span> (<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>regex_error <span style="color:#f92672">&amp;</span>e) {
</span></span><span style="display:flex;"><span>		assert(strcmp(e.what(), <span style="color:#e6db74">&#34;Unexpected end of regex when escaping.&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>		assert(e.code() <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>regex_constants<span style="color:#f92672">::</span>error_escape);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>You see! I am using <a href="https://en.cppreference.com/w/cpp/language/string_literal"  class="external-link" target="_blank" rel="noopener">raw string literals</a>. You can also use the normal string. But, in that case, you have to use a double backslash for an escape sequence.</li>
<li>The current implementation of <code>std::regex</code> is slow(as it needs regex interpretation &amp; data structure creation at runtime), bloated and unavoidably require heap allocation(not allocator-aware). So, <strong><em>beware if you are using <code>std::regex</code> in a loop</em></strong>(see <a href="https://www.youtube.com/watch?v=7hfSyxNxFfo"  class="external-link" target="_blank" rel="noopener">C++ Weekly - Ep 74 - std::regex optimize by Jason Turner</a>). Also, there is only a single member function that I think could be of use is <a href="https://en.cppreference.com/w/cpp/regex/basic_regex/mark_count"  class="external-link" target="_blank" rel="noopener">std::regex::mark_count()</a> which returns a number of capture groups.</li>
<li>Moreover, if you are using multiple strings to create a regex pattern at run time. Then you may need <a href="/posts/7-best-practices-for-exception-handling-in-cpp-with-example/" >exception handling</a> i.e. <code>std::regex_error</code> to validate its correctness.</li>
</ul>
<h2 id="stdregex_searchhttpsencppreferencecomwcppregexregex_search-example">
  <a href="https://en.cppreference.com/w/cpp/regex/regex_search"  class="external-link" target="_blank" rel="noopener">std::regex_search</a> Example
  <a class="heading-link" href="#stdregex_searchhttpsencppreferencecomwcppregexregex_search-example">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> string input <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span>s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> regex r(R<span style="color:#e6db74">&#34;((\w+):(\w+);)&#34;</span>);
</span></span><span style="display:flex;"><span>    smatch m;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (regex_search(input, m, r)) {
</span></span><span style="display:flex;"><span>        assert(m.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>        assert(m[<span style="color:#ae81ff">0</span>].str() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;PQR:2;&#34;</span>);                <span style="color:#75715e">// Entire match
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        assert(m[<span style="color:#ae81ff">1</span>].str() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;PQR&#34;</span>);                   <span style="color:#75715e">// Substring that matches 1st group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        assert(m[<span style="color:#ae81ff">2</span>].str() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;2&#34;</span>);                     <span style="color:#75715e">// Substring that matches 2nd group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        assert(m.prefix().str() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;ABC:1-&gt;   &#34;</span>);      <span style="color:#75715e">// All before 1st character match
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        assert(m.suffix().str() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;;;   XYZ:3&lt;&lt;&lt;&#34;</span>);   <span style="color:#75715e">// All after last character match
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// for (string &amp;&amp;str : m) { // Alternatively. You can also do
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//     cout &lt;&lt; str &lt;&lt; endl;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>smatch</code> is the specializations of <a href="https://en.cppreference.com/w/cpp/regex/match_results"  class="external-link" target="_blank" rel="noopener">std::match_results</a> that stores the information about matches to be retrieved.</li>
</ul>
<h2 id="stdregex_matchhttpsencppreferencecomwcppregexregex_match-example">
  <a href="https://en.cppreference.com/w/cpp/regex/regex_match"  class="external-link" target="_blank" rel="noopener">std::regex_match</a> Example
  <a class="heading-link" href="#stdregex_matchhttpsencppreferencecomwcppregexregex_match-example">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Short &amp; sweet example that you may always find in every regex book is email validation. And that is where our <code>std::regex_match</code> function fits perfectly.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_valid_email_id</span>(string_view str) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> regex r(R<span style="color:#e6db74">&#34;(\w+@\w+\.(?:com|in))&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> regex_match(str.data(), r);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	assert(is_valid_email_id(<span style="color:#e6db74">&#34;vishalchovatiya@ymail.com&#34;</span>) <span style="color:#f92672">==</span> true);
</span></span><span style="display:flex;"><span>	assert(is_valid_email_id(<span style="color:#e6db74">&#34;@abc.com&#34;</span>) <span style="color:#f92672">==</span> false);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>I know this is not full proof email validator regex pattern. But my intention is also not that.</li>
<li>Rather you should wonder why I have used <code>std::regex_match</code>! not <code>std::regex_search</code>! The rationale is simple <strong><em><code>std::regex_match</code> matches the whole input sequence</em></strong>.</li>
<li>Also, Noticeable thing is <em><strong>static regex object to avoid constructing (&ldquo;compiling/interpreting&rdquo;) a new regex object every time</strong></em> the function entered.</li>
<li>The irony of <strong><em>above tiny code snippet is that it produces around 30k lines of assembly</em></strong> that too with <code>-O3</code> flag. And that is ridiculous. But don&rsquo;t worry this is already been brought to the ISO C++ community. And soon we may get some updates. Meanwhile, we do have other alternatives (mentioned at the end of this article).</li>
</ul>
<h2 id="difference-between-stdregex_matchhttpsencppreferencecomwcppregexregex_match--stdregex_searchhttpsencppreferencecomwcppregexregex_search">
  Difference Between <a href="https://en.cppreference.com/w/cpp/regex/regex_match"  class="external-link" target="_blank" rel="noopener">std::regex_match</a> &amp; <a href="https://en.cppreference.com/w/cpp/regex/regex_search"  class="external-link" target="_blank" rel="noopener">std::regex_search</a>?
  <a class="heading-link" href="#difference-between-stdregex_matchhttpsencppreferencecomwcppregexregex_match--stdregex_searchhttpsencppreferencecomwcppregexregex_search">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>You might be wondering why do we have two functions doing almost the same work? Even I had the doubt initially. But, after reading the description provided by cppreference over and over. I found the answer. And to explain that answer, I have created the example(obviously with the help of StackOverflow):</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> string input <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span>s;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> regex r(R<span style="color:#e6db74">&#34;((\w+):(\w+);)&#34;</span>);
</span></span><span style="display:flex;"><span>	smatch m;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	assert(regex_match(input, m, r) <span style="color:#f92672">==</span> false);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	assert(regex_search(input, m, r) <span style="color:#f92672">==</span> true <span style="color:#f92672">&amp;&amp;</span> m.ready() <span style="color:#f92672">==</span> true <span style="color:#f92672">&amp;&amp;</span> m[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;PQR&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong><em><code>std::regex_match</code> only returns <code>true</code> when the entire input sequence has been matched,</em></strong> while <strong><em><code>std::regex_search</code> will succeed even if only a sub-sequence matches the regex.</em></strong></li>
</ul>
<h2 id="stdregex_iteratorhttpsencppreferencecomwcppregexregex_iterator-example">
  <a href="https://en.cppreference.com/w/cpp/regex/regex_iterator"  class="external-link" target="_blank" rel="noopener">std::regex_iterator</a> Example
  <a class="heading-link" href="#stdregex_iteratorhttpsencppreferencecomwcppregexregex_iterator-example">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li><code>std::regex_iterator</code> is helpful when you need very detailed information about matches &amp; sub-matches.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define C_ALL(X) cbegin(X), cend(X)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> string input <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span>s;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> regex r(R<span style="color:#e6db74">&#34;((\w+):(\d))&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>smatch<span style="color:#f92672">&gt;</span> matches{
</span></span><span style="display:flex;"><span>		sregex_iterator{C_ALL(input), r},
</span></span><span style="display:flex;"><span>		sregex_iterator{}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	assert(matches[<span style="color:#ae81ff">0</span>].str(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;ABC:1&#34;</span> 
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">&amp;&amp;</span> matches[<span style="color:#ae81ff">0</span>].str(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;ABC&#34;</span> 
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">&amp;&amp;</span> matches[<span style="color:#ae81ff">0</span>].str(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	assert(matches[<span style="color:#ae81ff">1</span>].str(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;PQR:2&#34;</span> 
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">&amp;&amp;</span> matches[<span style="color:#ae81ff">1</span>].str(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;PQR&#34;</span> 
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">&amp;&amp;</span> matches[<span style="color:#ae81ff">1</span>].str(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;2&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	assert(matches[<span style="color:#ae81ff">2</span>].str(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;XYZ:3&#34;</span> 
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">&amp;&amp;</span> matches[<span style="color:#ae81ff">2</span>].str(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;XYZ&#34;</span> 
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">&amp;&amp;</span> matches[<span style="color:#ae81ff">2</span>].str(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;3&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Earlier(in C++11), there was a limitation that using <code>std::regex_interator</code> is not allowed to be called with a temporary regex object. Which has been rectified with overload from C++14.</li>
</ul>
<h2 id="stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator-example">
  <a href="https://en.cppreference.com/w/cpp/regex/regex_token_iterator"  class="external-link" target="_blank" rel="noopener">std::regex_token_iterator</a> Example
  <a class="heading-link" href="#stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator-example">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li><code>std::regex_token_iterator</code> is the utility you are going to use 80% of the time. It has a slight variation as compared to <code>std::regex_iterator</code>. The <strong><em>difference between <code>std::regex_iterator</code> &amp; <code>std::regex_token_iterator</code> is</em></strong>
<ul>
<li><strong><em><code>std::regex_iterator</code> points to match results.</em></strong></li>
<li><strong><em><code>std::regex_token_iterator</code> points to sub-matches.</em></strong></li>
</ul>
</li>
<li>In <code>std::regex_token_iterator</code>, each iterator contains only a single matched result.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define C_ALL(X) cbegin(X), cend(X)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> string input <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span>s;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> regex r(R<span style="color:#e6db74">&#34;((\w+):(\d))&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Note: vector&lt;string&gt; here, unlike vector&lt;smatch&gt; as in std::regex_iterator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> full_match{
</span></span><span style="display:flex;"><span>		sregex_token_iterator{C_ALL(input), r, <span style="color:#ae81ff">0</span>}, <span style="color:#75715e">// Mark `0` here i.e. whole regex match
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		sregex_token_iterator{}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	assert((full_match <span style="color:#f92672">==</span> <span style="color:#66d9ef">decltype</span>(full_match){<span style="color:#e6db74">&#34;ABC:1&#34;</span>, <span style="color:#e6db74">&#34;PQR:2&#34;</span>, <span style="color:#e6db74">&#34;XYZ:3&#34;</span>}));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> cptr_grp_1st{
</span></span><span style="display:flex;"><span>		sregex_token_iterator{C_ALL(input), r, <span style="color:#ae81ff">1</span>}, <span style="color:#75715e">// Mark `1` here i.e. 1st capture group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		sregex_token_iterator{}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	assert((cptr_grp_1st <span style="color:#f92672">==</span> <span style="color:#66d9ef">decltype</span>(cptr_grp_1st){<span style="color:#e6db74">&#34;ABC&#34;</span>, <span style="color:#e6db74">&#34;PQR&#34;</span>, <span style="color:#e6db74">&#34;XYZ&#34;</span>}));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> cptr_grp_2nd{
</span></span><span style="display:flex;"><span>		sregex_token_iterator{C_ALL(input), r, <span style="color:#ae81ff">2</span>}, <span style="color:#75715e">// Mark `2` here i.e. 2nd capture group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		sregex_token_iterator{}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	assert((cptr_grp_2nd <span style="color:#f92672">==</span> <span style="color:#66d9ef">decltype</span>(cptr_grp_2nd){<span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#e6db74">&#34;2&#34;</span>, <span style="color:#e6db74">&#34;3&#34;</span>}));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="inverted-match-with-stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator">
  Inverted Match With <a href="https://en.cppreference.com/w/cpp/regex/regex_token_iterator"  class="external-link" target="_blank" rel="noopener">std::regex_token_iterator</a>
  <a class="heading-link" href="#inverted-match-with-stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define C_ALL(X) cbegin(X), cend(X)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> string input <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span>s;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> regex r(R<span style="color:#e6db74">&#34;((\w+):(\d))&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> inverted{
</span></span><span style="display:flex;"><span>		sregex_token_iterator{C_ALL(input), r, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}, <span style="color:#75715e">// `-1` = parts that are not matched
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		sregex_token_iterator{}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	assert((inverted <span style="color:#f92672">==</span> <span style="color:#66d9ef">decltype</span>(inverted){
</span></span><span style="display:flex;"><span>							<span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>							<span style="color:#e6db74">&#34;-&gt;   &#34;</span>,
</span></span><span style="display:flex;"><span>							<span style="color:#e6db74">&#34;;;;   &#34;</span>,
</span></span><span style="display:flex;"><span>							<span style="color:#e6db74">&#34;&lt;&lt;&lt;&#34;</span>,
</span></span><span style="display:flex;"><span>						}));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="stdregex_replacehttpsencppreferencecomwcppregexregex_replace-example">
  <a href="https://en.cppreference.com/w/cpp/regex/regex_replace"  class="external-link" target="_blank" rel="noopener">std::regex_replace</a> Example
  <a class="heading-link" href="#stdregex_replacehttpsencppreferencecomwcppregexregex_replace-example">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string <span style="color:#a6e22e">transform_pair</span>(string_view text, regex_constants<span style="color:#f92672">::</span>match_flag_type f <span style="color:#f92672">=</span> {}) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> r <span style="color:#f92672">=</span> regex(R<span style="color:#e6db74">&#34;((\w+):(\d))&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> regex_replace(text.data(), r, <span style="color:#e6db74">&#34;$2&#34;</span>, f);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	assert(transform_pair(<span style="color:#e6db74">&#34;ABC:1, PQR:2&#34;</span>s) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1, 2&#34;</span>s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Things that aren&#39;t matched are not copied
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	assert(transform_pair(<span style="color:#e6db74">&#34;ABC:1, PQR:2&#34;</span>s, regex_constants<span style="color:#f92672">::</span>format_no_copy) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;12&#34;</span>s);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>You see in 2nd call of transform_pair, we passed flag <code>std::regex_constants::format_no_copy</code> which suggest do not copy thing that isn&rsquo;t matched. There are many such useful flags under <a href="https://en.cppreference.com/w/cpp/regex/match_flag_type"  class="external-link" target="_blank" rel="noopener">std::regex_constant</a>.</li>
<li>Also, we have constructed the fresh string holding the results. But what if we do not want a new string. Rather wants to append the results directly to somewhere(probably container or stream or already existing string). Guess what! the standard library has covered this also with overloaded <code>std::regex_replace</code> as follows:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> string input <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span>s;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> regex r(R<span style="color:#e6db74">&#34;(-|&gt;|&lt;|;| )&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Prints &#34;ABC:1     PQR:2      XYZ:3   &#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	regex_replace(ostreambuf_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(cout), C_ALL(input), r, <span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="use-cases">
  Use Cases
  <a class="heading-link" href="#use-cases">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="splitting-a-string-with-delimiter">
  Splitting a String With Delimiter
  <a class="heading-link" href="#splitting-a-string-with-delimiter">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Although <code>std::strtok</code> is best suitable &amp; optimal candidate for such a task. But just to demonstrate how you can do it with regex:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define C_ALL(X) cbegin(X), cend(X)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> split(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> str, string_view pattern) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> r <span style="color:#f92672">=</span> regex(pattern.data());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>{
</span></span><span style="display:flex;"><span>        sregex_token_iterator(C_ALL(str), r, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>        sregex_token_iterator()
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    assert((split(<span style="color:#e6db74">&#34;/root/home/vishal&#34;</span>, <span style="color:#e6db74">&#34;/&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">==</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>{<span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#e6db74">&#34;root&#34;</span>, <span style="color:#e6db74">&#34;home&#34;</span>, <span style="color:#e6db74">&#34;vishal&#34;</span>}));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="trim-whitespace-from-a-string">
  Trim Whitespace From a String
  <a class="heading-link" href="#trim-whitespace-from-a-string">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string <span style="color:#a6e22e">trim</span>(string_view text) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> r <span style="color:#f92672">=</span> regex(R<span style="color:#e6db74">&#34;(\s+)&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> regex_replace(text.data(), r, <span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	assert(trim(<span style="color:#e6db74">&#34;12   3 4      5&#34;</span>s) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;12345&#34;</span>s);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="finding-lines-containing-or-not-containing-certain-words-from-a-file">
  Finding Lines Containing or Not Containing Certain Words From a File
  <a class="heading-link" href="#finding-lines-containing-or-not-containing-certain-words-from-a-file">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string <span style="color:#a6e22e">join</span>(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> words, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> delimiter) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> accumulate(next(begin(words)), end(words), words[<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>            [<span style="color:#f92672">&amp;</span>delimiter](string<span style="color:#f92672">&amp;</span> p, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> word)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> p <span style="color:#f92672">+</span> delimiter <span style="color:#f92672">+</span> word;
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> lines_containing(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> file, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> words) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> prefix <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;^.*?</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">b(&#34;</span>s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> suffix <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;)</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">b.*$&#34;</span>s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//  ^.*?\b(one|two|three)\b.*$
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> pattern <span style="color:#f92672">=</span> move(prefix) <span style="color:#f92672">+</span> join(words, <span style="color:#e6db74">&#34;|&#34;</span>) <span style="color:#f92672">+</span> move(suffix);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ifstream        <span style="color:#a6e22e">infile</span>(file);
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>  result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (string line; getline(infile, line);) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(regex_match(line, regex(pattern))) {
</span></span><span style="display:flex;"><span>            result.emplace_back(move(line));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   assert((lines_containing(<span style="color:#e6db74">&#34;test.txt&#34;</span>, {<span style="color:#e6db74">&#34;one&#34;</span>,<span style="color:#e6db74">&#34;two&#34;</span>})
</span></span><span style="display:flex;"><span>                                        <span style="color:#f92672">==</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>{<span style="color:#e6db74">&#34;This is one&#34;</span>,
</span></span><span style="display:flex;"><span>                                                          <span style="color:#e6db74">&#34;This is two&#34;</span>}));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* test.txt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">This is one
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">This is two
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">This is three
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">This is four
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div><ul>
<li>Same goes for finding lines that are not containing words with the pattern <code>^((?!(one|two|three)).)*$</code>.</li>
</ul>
<h3 id="finding-files-in-a-directory">
  Finding Files in a Directory
  <a class="heading-link" href="#finding-files-in-a-directory">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> fs <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>filesystem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>fs<span style="color:#f92672">::</span>directory_entry<span style="color:#f92672">&gt;</span> find_files(<span style="color:#66d9ef">const</span> fs<span style="color:#f92672">::</span>path <span style="color:#f92672">&amp;</span>path, string_view rg) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>fs<span style="color:#f92672">::</span>directory_entry<span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>    regex <span style="color:#a6e22e">r</span>(rg.data());
</span></span><span style="display:flex;"><span>    copy_if(
</span></span><span style="display:flex;"><span>        fs<span style="color:#f92672">::</span>recursive_directory_iterator(path),
</span></span><span style="display:flex;"><span>        fs<span style="color:#f92672">::</span>recursive_directory_iterator(),
</span></span><span style="display:flex;"><span>        back_inserter(result),
</span></span><span style="display:flex;"><span>        [<span style="color:#f92672">&amp;</span>r](<span style="color:#66d9ef">const</span> fs<span style="color:#f92672">::</span>directory_entry <span style="color:#f92672">&amp;</span>entry) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> fs<span style="color:#f92672">::</span>is_regular_file(entry.path()) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                   regex_match(entry.path().filename().string(), r);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> dir        <span style="color:#f92672">=</span> fs<span style="color:#f92672">::</span>temp_directory_path();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> pattern    <span style="color:#f92672">=</span> R<span style="color:#e6db74">&#34;(\w+\.png)&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> result     <span style="color:#f92672">=</span> find_files(fs<span style="color:#f92672">::</span>current_path(), pattern);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>entry : result) {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> entry.path().string() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="tips-for-using-regex-in-general">
  Tips For Using Regex-In-General
  <a class="heading-link" href="#tips-for-using-regex-in-general">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Use raw string literal for describing the regex pattern in C++.</li>
<li>Use the regex validating tool like <a href="https://regex101.com"  class="external-link" target="_blank" rel="noopener">https://regex101.com</a>. What I like about <a href="https://regex101.com/"  class="external-link" target="_blank" rel="noopener">regex101</a> is code generation &amp; time-taken(will be helpful when optimizing regex) feature.</li>
<li>Also, try to add generated explanation from validation tool as a comment exactly above the regex pattern in your code.</li>
<li>Performance:
<ul>
<li>If you are using alternation, try to arrange options in high probability order like <code>com|net|org</code>.</li>
<li>Try to use lazy quantifiers if possible.</li>
<li>Use non-capture groups wherever possible.</li>
<li>Disable Backtracking.</li>
<li>Using the negated character class is more efficient than using a lazy dot.</li>
</ul>
</li>
</ul>
<h2 id="parting-words">
  Parting Words
  <a class="heading-link" href="#parting-words">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>It&rsquo;s not just that you will use regex with only C++ or any other language. I myself use it mostly on IDE(in vscode to analyse log files) &amp; on Linux terminal. But, bear in mind that overusing regex gives the feel of cleverness. And, it&rsquo;s a great way to make your co-workers (and anyone else who needs to work with your code) very angry with you. Also, regex is overkill for most parsing tasks that you&rsquo;ll face in your daily work.</p>
<p>The regexes really shine for complicated tasks where hand-written parsing code would be just as slow anyway; and for extremely simple tasks where the readability and robustness of regular expressions outweigh their performance costs.</p>
<p>One more notable thing is current regex implementation(till 19th June 2020) in standard libraries have performance &amp; code bloating issues. So choose wisely between Boost, CTRE and Standard library versions. Most probably you might go with the Hana Dusíková&rsquo;s work on <a href="https://github.com/hanickadot/compile-time-regular-expressions"  class="external-link" target="_blank" rel="noopener">Compile Time Regular Expression</a>. Also, her CppCon talk from <a href="https://www.youtube.com/watch?v=QM3W36COnE4&amp;list=WL&amp;index=9&amp;t=0s"  class="external-link" target="_blank" rel="noopener">2018</a> &amp; <a href="https://www.youtube.com/watch?v=8dKWdJzPwHw"  class="external-link" target="_blank" rel="noopener">2019</a>&rsquo;s would be helpful especially if you plan to use regex in embedded systems.</p>

      </div>


      <footer>
        


        
        
        
        
        

        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2024
     Vishal Chovatiya 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  
  



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
