<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Regex C++ | Vishal Chovatiya</title>
<meta name=keywords content="boost-regex-example,boost-regex-examples,boost-regex-tutorial,c-11-regex,c-programming-regex,c-regex-library,c-regex-posix,c-boost-regex,c-pattern-matching-example,c-regex-digit,c-regex-example,c-regex-find-all-matches,c-regex-groups,c-regex-online,c-regex-parser,c-regex-pattern,c-regex-search,c-regex-syntax,c-regex-tester,c-regex-tutorial,c-regular-expression,c-regular-expression-example,c-regular-expression-syntax,c-regular-expression-tutorial,c-std-regex-example,difference-between-stdregex_match-stdregex_search,finding-files-in-a-directory-c-regex,finding-lines-containing-or-not-containing-certain-words-from-a-file-c-regex,geeks-for-geeks-regex-c,inverted-match-with-stdregex_token_iterator,libboost-regex,regex-c-cheat-sheet,regex-c,regex-c-gfg,regex-c-tutorial,regex-cpp,regex-generator-c,regex-in-c-example-2,regex-in-c-programming,regex-in-c,regex-in-c-example,regex-library-c,regex-search-c,regex-split-c,regex_match-example-c,regular-expression-c-example,regular-expression-c-tutorial,regular-expression-cpp,regular-expression-in-c-example,regular-expression-in-c-example-2,regular-expression-in-cpp,splitting-a-string-with-delimiter-c-regex,sregex_token_iterator,stdregex-stdregex_error-example,stdregex_iterator-example,stdregex_match-example,stdregex_replace-example,stdregex_search-example,stdregex_token_iterator-example,string-to-regex-c,trim-whitespace-from-a-string-c-regex,use-regex-in-c,using-regex-c,validating-email-address-with-regex-hackerrank-c"><meta name=description content="Regular expressions (or regex in short) is a much-hated & underrated topic so far with Modern C++. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy)."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/regex-c/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/regex-c/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Regex C++"><meta property="og:description" content="Regular expressions (or regex in short) is a much-hated & underrated topic so far with Modern C++. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy)."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/regex-c/"><meta property="og:image" content="https://vishalchovatiya.github.io/images/Regex-C-Regular-Expression.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-16T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-16T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/images/Regex-C-Regular-Expression.webp"><meta name=twitter:title content="Regex C++"><meta name=twitter:description content="Regular expressions (or regex in short) is a much-hated & underrated topic so far with Modern C++. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Regex C++","item":"https://vishalchovatiya.github.io/posts/regex-c/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Regex C++","name":"Regex C\u002b\u002b","description":"Regular expressions (or regex in short) is a much-hated \u0026amp; underrated topic so far with Modern C++. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy).","keywords":["boost-regex-example","boost-regex-examples","boost-regex-tutorial","c-11-regex","c-programming-regex","c-regex-library","c-regex-posix","c-boost-regex","c-pattern-matching-example","c-regex-digit","c-regex-example","c-regex-find-all-matches","c-regex-groups","c-regex-online","c-regex-parser","c-regex-pattern","c-regex-search","c-regex-syntax","c-regex-tester","c-regex-tutorial","c-regular-expression","c-regular-expression-example","c-regular-expression-syntax","c-regular-expression-tutorial","c-std-regex-example","difference-between-stdregex_match-stdregex_search","finding-files-in-a-directory-c-regex","finding-lines-containing-or-not-containing-certain-words-from-a-file-c-regex","geeks-for-geeks-regex-c","inverted-match-with-stdregex_token_iterator","libboost-regex","regex-c-cheat-sheet","regex-c","regex-c-gfg","regex-c-tutorial","regex-cpp","regex-generator-c","regex-in-c-example-2","regex-in-c-programming","regex-in-c","regex-in-c-example","regex-library-c","regex-search-c","regex-split-c","regex_match-example-c","regular-expression-c-example","regular-expression-c-tutorial","regular-expression-cpp","regular-expression-in-c-example","regular-expression-in-c-example-2","regular-expression-in-cpp","splitting-a-string-with-delimiter-c-regex","sregex_token_iterator","stdregex-stdregex_error-example","stdregex_iterator-example","stdregex_match-example","stdregex_replace-example","stdregex_search-example","stdregex_token_iterator-example","string-to-regex-c","trim-whitespace-from-a-string-c-regex","use-regex-in-c","using-regex-c","validating-email-address-with-regex-hackerrank-c"],"articleBody":"Regular expressions (or regex in short) is a much-hated \u0026 underrated topic so far with Modern C++. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy).\nInitially, In this article, I have decided to include regex-in-general also. But it doesn’t make sense, as there is already people/tutorial out there who does better than me in teaching regex. But still, I left a small section to address Motivation \u0026 Learning Regex. For the rest of the article, I will be focusing on functionality provided by C++ to work with regex. And if you are already aware of regex, you can use the above mind-map as a refresher.\nPointer: The C++ standard library offers several different “flavours” of regex syntax, but the default flavour (the one you should always use \u0026 I am demonstrating here) was borrowed wholesale from the standard for ECMAScript.\nMotivation I know its pathetic and somewhat confusing tool-set. Consider the below regex pattern for an example that extract time in 24-hour format i.e. HH:MM. \\b([01]?[0-9]|2[0-3]):([0-5]\\d)\\b I mean! Who wants to work with this cryptic text? And whatever running in your mind is 100% reasonable. In fact, I have procrastinated learning regex twice due to the same reason. But, believe me, all the ugly looking things are not that bad. The way(↓) I am describing here won’t take more than 2-3 hours to learn regex that too intuitively. And After learning it you will see the compounding effect with return on investment over-the-time. Learning Regex Do not google much \u0026 try to analyse which tutorial is best. In fact, don’t waste time in such analysis. Because there is no point in doing so. At this point in time(well! if you don’t know the regex) what really matters is “Getting Started” rather than “What Is Best!”. Just go to https://regexone.com without much overthinking. And complete all the lessons. Trust me here, I have explored many articles, courses(\u003c=this one is free, BTW) \u0026 books. But this is best among all for getting started without losing motivation. And after it, if you still have an appetite to solve more problem \u0026 exercises. Consider the below links: Exercises on regextutorials.com Practice problem on regex by hackerrank std::regex \u0026 std::regex_error Example int main() { try { static const auto r = std::regex(R\"(\\)\"); // Escape sequence error } catch (const std::regex_error \u0026e) { assert(strcmp(e.what(), \"Unexpected end of regex when escaping.\") == 0); assert(e.code() == std::regex_constants::error_escape); } return EXIT_SUCCESS; } You see! I am using raw string literals. You can also use the normal string. But, in that case, you have to use a double backslash for an escape sequence. The current implementation of std::regex is slow(as it needs regex interpretation \u0026 data structure creation at runtime), bloated and unavoidably require heap allocation(not allocator-aware). So, beware if you are using std::regex in a loop(see C++ Weekly - Ep 74 - std::regex optimize by Jason Turner). Also, there is only a single member function that I think could be of use is std::regex::mark_count() which returns a number of capture groups. Moreover, if you are using multiple strings to create a regex pattern at run time. Then you may need exception handling i.e. std::regex_error to validate its correctness. std::regex_search Example int main() { const string input = \"ABC:1-\u003e PQR:2;;; XYZ:3\u003c\u003c\u003c\"s; const regex r(R\"((\\w+):(\\w+);)\"); smatch m; if (regex_search(input, m, r)) { assert(m.size() == 3); assert(m[0].str() == \"PQR:2;\"); // Entire match assert(m[1].str() == \"PQR\"); // Substring that matches 1st group assert(m[2].str() == \"2\"); // Substring that matches 2nd group assert(m.prefix().str() == \"ABC:1-\u003e \"); // All before 1st character match assert(m.suffix().str() == \";; XYZ:3\u003c\u003c\u003c\"); // All after last character match // for (string \u0026\u0026str : m) { // Alternatively. You can also do // cout \u003c\u003c str \u003c\u003c endl; // } } return EXIT_SUCCESS; } smatch is the specializations of std::match_results that stores the information about matches to be retrieved. std::regex_match Example Short \u0026 sweet example that you may always find in every regex book is email validation. And that is where our std::regex_match function fits perfectly. bool is_valid_email_id(string_view str) { static const regex r(R\"(\\w+@\\w+\\.(?:com|in))\"); return regex_match(str.data(), r); } int main() { assert(is_valid_email_id(\"vishalchovatiya@ymail.com\") == true); assert(is_valid_email_id(\"@abc.com\") == false); return EXIT_SUCCESS; } I know this is not full proof email validator regex pattern. But my intention is also not that. Rather you should wonder why I have used std::regex_match! not std::regex_search! The rationale is simple std::regex_match matches the whole input sequence. Also, Noticeable thing is static regex object to avoid constructing (“compiling/interpreting”) a new regex object every time the function entered. The irony of above tiny code snippet is that it produces around 30k lines of assembly that too with -O3 flag. And that is ridiculous. But don’t worry this is already been brought to the ISO C++ community. And soon we may get some updates. Meanwhile, we do have other alternatives (mentioned at the end of this article). Difference Between std::regex_match \u0026 std::regex_search? You might be wondering why do we have two functions doing almost the same work? Even I had the doubt initially. But, after reading the description provided by cppreference over and over. I found the answer. And to explain that answer, I have created the example(obviously with the help of StackOverflow): int main() { const string input = \"ABC:1-\u003e PQR:2;;; XYZ:3\u003c\u003c\u003c\"s; const regex r(R\"((\\w+):(\\w+);)\"); smatch m; assert(regex_match(input, m, r) == false); assert(regex_search(input, m, r) == true \u0026\u0026 m.ready() == true \u0026\u0026 m[1] == \"PQR\"); return EXIT_SUCCESS; } std::regex_match only returns true when the entire input sequence has been matched, while std::regex_search will succeed even if only a sub-sequence matches the regex. std::regex_iterator Example std::regex_iterator is helpful when you need very detailed information about matches \u0026 sub-matches. #define C_ALL(X) cbegin(X), cend(X) int main() { const string input = \"ABC:1-\u003e PQR:2;;; XYZ:3\u003c\u003c\u003c\"s; const regex r(R\"((\\w+):(\\d))\"); const vector\u003csmatch\u003e matches{ sregex_iterator{C_ALL(input), r}, sregex_iterator{} }; assert(matches[0].str(0) == \"ABC:1\" \u0026\u0026 matches[0].str(1) == \"ABC\" \u0026\u0026 matches[0].str(2) == \"1\"); assert(matches[1].str(0) == \"PQR:2\" \u0026\u0026 matches[1].str(1) == \"PQR\" \u0026\u0026 matches[1].str(2) == \"2\"); assert(matches[2].str(0) == \"XYZ:3\" \u0026\u0026 matches[2].str(1) == \"XYZ\" \u0026\u0026 matches[2].str(2) == \"3\"); return EXIT_SUCCESS; } Earlier(in C++11), there was a limitation that using std::regex_interator is not allowed to be called with a temporary regex object. Which has been rectified with overload from C++14. std::regex_token_iterator Example std::regex_token_iterator is the utility you are going to use 80% of the time. It has a slight variation as compared to std::regex_iterator. The difference between std::regex_iterator \u0026 std::regex_token_iterator is std::regex_iterator points to match results. std::regex_token_iterator points to sub-matches. In std::regex_token_iterator, each iterator contains only a single matched result. #define C_ALL(X) cbegin(X), cend(X) int main() { const string input = \"ABC:1-\u003e PQR:2;;; XYZ:3\u003c\u003c\u003c\"s; const regex r(R\"((\\w+):(\\d))\"); // Note: vector here, unlike vector as in std::regex_iterator const vector\u003cstring\u003e full_match{ sregex_token_iterator{C_ALL(input), r, 0}, // Mark `0` here i.e. whole regex match sregex_token_iterator{} }; assert((full_match == decltype(full_match){\"ABC:1\", \"PQR:2\", \"XYZ:3\"})); const vector\u003cstring\u003e cptr_grp_1st{ sregex_token_iterator{C_ALL(input), r, 1}, // Mark `1` here i.e. 1st capture group sregex_token_iterator{} }; assert((cptr_grp_1st == decltype(cptr_grp_1st){\"ABC\", \"PQR\", \"XYZ\"})); const vector\u003cstring\u003e cptr_grp_2nd{ sregex_token_iterator{C_ALL(input), r, 2}, // Mark `2` here i.e. 2nd capture group sregex_token_iterator{} }; assert((cptr_grp_2nd == decltype(cptr_grp_2nd){\"1\", \"2\", \"3\"})); return EXIT_SUCCESS; } Inverted Match With std::regex_token_iterator #define C_ALL(X) cbegin(X), cend(X) int main() { const string input = \"ABC:1-\u003e PQR:2;;; XYZ:3\u003c\u003c\u003c\"s; const regex r(R\"((\\w+):(\\d))\"); const vector\u003cstring\u003e inverted{ sregex_token_iterator{C_ALL(input), r, -1}, // `-1` = parts that are not matched sregex_token_iterator{} }; assert((inverted == decltype(inverted){ \"\", \"-\u003e \", \";;; \", \"\u003c\u003c\u003c\", })); return EXIT_SUCCESS; } std::regex_replace Example string transform_pair(string_view text, regex_constants::match_flag_type f = {}) { static const auto r = regex(R\"((\\w+):(\\d))\"); return regex_replace(text.data(), r, \"$2\", f); } int main() { assert(transform_pair(\"ABC:1, PQR:2\"s) == \"1, 2\"s); // Things that aren't matched are not copied assert(transform_pair(\"ABC:1, PQR:2\"s, regex_constants::format_no_copy) == \"12\"s); return EXIT_SUCCESS; } You see in 2nd call of transform_pair, we passed flag std::regex_constants::format_no_copy which suggest do not copy thing that isn’t matched. There are many such useful flags under std::regex_constant. Also, we have constructed the fresh string holding the results. But what if we do not want a new string. Rather wants to append the results directly to somewhere(probably container or stream or already existing string). Guess what! the standard library has covered this also with overloaded std::regex_replace as follows: int main() { const string input = \"ABC:1-\u003e PQR:2;;; XYZ:3\u003c\u003c\u003c\"s; const regex r(R\"(-|\u003e|\u003c|;| )\"); // Prints \"ABC:1 PQR:2 XYZ:3 \" regex_replace(ostreambuf_iterator\u003cchar\u003e(cout), C_ALL(input), r, \" \"); return EXIT_SUCCESS; } Use Cases Splitting a String With Delimiter Although std::strtok is best suitable \u0026 optimal candidate for such a task. But just to demonstrate how you can do it with regex: #define C_ALL(X) cbegin(X), cend(X) vector\u003cstring\u003e split(const string\u0026 str, string_view pattern) { const auto r = regex(pattern.data()); return vector\u003cstring\u003e{ sregex_token_iterator(C_ALL(str), r, -1), sregex_token_iterator() }; } int main() { assert((split(\"/root/home/vishal\", \"/\") == vector\u003cstring\u003e{\"\", \"root\", \"home\", \"vishal\"})); return EXIT_SUCCESS; } Trim Whitespace From a String string trim(string_view text) { static const auto r = regex(R\"(\\s+)\"); return regex_replace(text.data(), r, \"\"); } int main() { assert(trim(\"12 3 4 5\"s) == \"12345\"s); return EXIT_SUCCESS; } Finding Lines Containing or Not Containing Certain Words From a File string join(const vector\u003cstring\u003e\u0026 words, const string\u0026 delimiter) { return accumulate(next(begin(words)), end(words), words[0], [\u0026delimiter](string\u0026 p, const string\u0026 word) { return p + delimiter + word; }); } vector\u003cstring\u003e lines_containing(const string\u0026 file, const vector\u003cstring\u003e\u0026 words) { auto prefix = \"^.*?\\\\b(\"s; auto suffix = \")\\\\b.*$\"s; // ^.*?\\b(one|two|three)\\b.*$ const auto pattern = move(prefix) + join(words, \"|\") + move(suffix); ifstream infile(file); vector\u003cstring\u003e result; for (string line; getline(infile, line);) { if(regex_match(line, regex(pattern))) { result.emplace_back(move(line)); } } return result; } int main() { assert((lines_containing(\"test.txt\", {\"one\",\"two\"}) == vector\u003cstring\u003e{\"This is one\", \"This is two\"})); return EXIT_SUCCESS; } /* test.txt This is one This is two This is three This is four */ Same goes for finding lines that are not containing words with the pattern ^((?!(one|two|three)).)*$. Finding Files in a Directory namespace fs = std::filesystem; vector\u003cfs::directory_entry\u003e find_files(const fs::path \u0026path, string_view rg) { vector\u003cfs::directory_entry\u003e result; regex r(rg.data()); copy_if( fs::recursive_directory_iterator(path), fs::recursive_directory_iterator(), back_inserter(result), [\u0026r](const fs::directory_entry \u0026entry) { return fs::is_regular_file(entry.path()) \u0026\u0026 regex_match(entry.path().filename().string(), r); }); return result; } int main() { const auto dir = fs::temp_directory_path(); const auto pattern = R\"(\\w+\\.png)\"; const auto result = find_files(fs::current_path(), pattern); for (const auto \u0026entry : result) { cout \u003c\u003c entry.path().string() \u003c\u003c endl; } return EXIT_SUCCESS; } Tips For Using Regex-In-General Use raw string literal for describing the regex pattern in C++. Use the regex validating tool like https://regex101.com. What I like about regex101 is code generation \u0026 time-taken(will be helpful when optimizing regex) feature. Also, try to add generated explanation from validation tool as a comment exactly above the regex pattern in your code. Performance: If you are using alternation, try to arrange options in high probability order like com|net|org. Try to use lazy quantifiers if possible. Use non-capture groups wherever possible. Disable Backtracking. Using the negated character class is more efficient than using a lazy dot. Parting Words It’s not just that you will use regex with only C++ or any other language. I myself use it mostly on IDE(in vscode to analyse log files) \u0026 on Linux terminal. But, bear in mind that overusing regex gives the feel of cleverness. And, it’s a great way to make your co-workers (and anyone else who needs to work with your code) very angry with you. Also, regex is overkill for most parsing tasks that you’ll face in your daily work.\nThe regexes really shine for complicated tasks where hand-written parsing code would be just as slow anyway; and for extremely simple tasks where the readability and robustness of regular expressions outweigh their performance costs.\nOne more notable thing is current regex implementation(till 19th June 2020) in standard libraries have performance \u0026 code bloating issues. So choose wisely between Boost, CTRE and Standard library versions. Most probably you might go with the Hana Dusíková’s work on Compile Time Regular Expression. Also, her CppCon talk from 2018 \u0026 2019’s would be helpful especially if you plan to use regex in embedded systems.\n","wordCount":"2005","inLanguage":"en","image":"https://vishalchovatiya.github.io/images/Regex-C-Regular-Expression.webp","datePublished":"2020-07-16T00:00:00Z","dateModified":"2020-07-16T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/regex-c/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Regex C++</h1><div class=post-meta><span title='2020-07-16 00:00:00 +0000 UTC'>July 16, 2020</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2005 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/regex-c.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://vishalchovatiya.github.io/images/Regex-C-Regular-Expression.webp alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#learning-regex>Learning Regex</a></li><li><a href=#stdregexhttpsencppreferencecomwcppregexbasic_regex--stdregex_errorhttpsencppreferencecomwcppregexregex_error-example><a href=https://en.cppreference.com/w/cpp/regex/basic_regex>std::regex</a> & <a href=https://en.cppreference.com/w/cpp/regex/regex_error>std::regex_error</a> Example</a></li><li><a href=#stdregex_searchhttpsencppreferencecomwcppregexregex_search-example><a href=https://en.cppreference.com/w/cpp/regex/regex_search>std::regex_search</a> Example</a></li><li><a href=#stdregex_matchhttpsencppreferencecomwcppregexregex_match-example><a href=https://en.cppreference.com/w/cpp/regex/regex_match>std::regex_match</a> Example</a></li><li><a href=#difference-between-stdregex_matchhttpsencppreferencecomwcppregexregex_match--stdregex_searchhttpsencppreferencecomwcppregexregex_search>Difference Between <a href=https://en.cppreference.com/w/cpp/regex/regex_match>std::regex_match</a> & <a href=https://en.cppreference.com/w/cpp/regex/regex_search>std::regex_search</a>?</a></li><li><a href=#stdregex_iteratorhttpsencppreferencecomwcppregexregex_iterator-example><a href=https://en.cppreference.com/w/cpp/regex/regex_iterator>std::regex_iterator</a> Example</a></li><li><a href=#stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator-example><a href=https://en.cppreference.com/w/cpp/regex/regex_token_iterator>std::regex_token_iterator</a> Example</a><ul><li><a href=#inverted-match-with-stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator>Inverted Match With <a href=https://en.cppreference.com/w/cpp/regex/regex_token_iterator>std::regex_token_iterator</a></a></li></ul></li><li><a href=#stdregex_replacehttpsencppreferencecomwcppregexregex_replace-example><a href=https://en.cppreference.com/w/cpp/regex/regex_replace>std::regex_replace</a> Example</a></li><li><a href=#use-cases>Use Cases</a><ul><li><a href=#splitting-a-string-with-delimiter>Splitting a String With Delimiter</a></li><li><a href=#trim-whitespace-from-a-string>Trim Whitespace From a String</a></li><li><a href=#finding-lines-containing-or-not-containing-certain-words-from-a-file>Finding Lines Containing or Not Containing Certain Words From a File</a></li><li><a href=#finding-files-in-a-directory>Finding Files in a Directory</a></li></ul></li><li><a href=#tips-for-using-regex-in-general>Tips For Using Regex-In-General</a></li><li><a href=#parting-words>Parting Words</a></li></ul></nav></div></details></div><div class=post-content><p>Regular expressions (or regex in short) is a much-hated & underrated topic so far with Modern C++. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to <strong><em>learn once, write anywhere</em></strong> philosophy).</p><p>Initially, In this article, I have decided to include regex-in-general also. But it doesn&rsquo;t make sense, as there is already people/tutorial out there who does better than me in teaching regex. But still, I left a small section to address <a href=/posts/regex-c/#Motivation>Motivation</a> & <a href=/posts/regex-c/#Learning_Regex>Learning Regex</a>. For the rest of the article, I will be focusing on functionality provided by C++ to work with regex. And if you are already aware of regex, you can use the above mind-map as a refresher.</p><p><strong><em>Pointer:</em></strong> The C++ standard library offers several different &ldquo;flavours&rdquo; of regex syntax, but the default flavour (the one you should always use & I am demonstrating here) was borrowed wholesale from the standard for <a href=https://www.wikiwand.com/en/ECMAScript>ECMAScript</a>.</p><h2 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h2><ul><li>I know its pathetic and somewhat confusing tool-set. Consider the below regex pattern for an example that extract time in 24-hour format i.e. HH:MM.</li></ul><pre tabindex=0><code class=language-regex data-lang=regex>\b([01]?[0-9]|2[0-3]):([0-5]\d)\b
</code></pre><ul><li>I mean! <strong><em>Who wants to work with this cryptic text?</em></strong></li><li>And whatever running in your mind is 100% reasonable. In fact, <strong><em>I have procrastinated learning regex twice due to the same reason</em></strong>. But, believe me, all the ugly looking things are not that bad.</li><li>The way(<strong>↓</strong>) I am describing here won&rsquo;t take more than 2-3 hours to learn regex that too intuitively. And After learning it you will see the compounding effect with return on investment over-the-time.</li></ul><h2 id=learning-regex>Learning Regex<a hidden class=anchor aria-hidden=true href=#learning-regex>#</a></h2><ul><li>Do not google much & try to analyse which tutorial is best. In fact, don&rsquo;t waste time in such analysis. Because there is no point in doing so. At this point in time(well! if you don&rsquo;t know the regex) what really matters is &ldquo;Getting Started&rdquo; rather than &ldquo;What Is Best!&rdquo;.</li><li><strong><em>Just go to <a href=https://regexone.com/>https://regexone.com</a> without much overthinking</em></strong>. And complete all the lessons. Trust me here, I have explored many articles, <a href=https://www.udemy.com/course/regex-academy-an-introduction-to-text-parsing-sorcery/>courses</a>(&lt;=this one is free, BTW) & books. But this is best among all for getting started without losing motivation.</li><li>And after it, if you still have an appetite to solve more problem & exercises. Consider the below links:<ol><li><a href=http://regextutorials.com/>Exercises on regextutorials.com</a></li><li><a href=https://www.hackerrank.com/domains/regex>Practice problem on regex by hackerrank</a></li></ol></li></ul><h2 id=stdregexhttpsencppreferencecomwcppregexbasic_regex--stdregex_errorhttpsencppreferencecomwcppregexregex_error-example><a href=https://en.cppreference.com/w/cpp/regex/basic_regex>std::regex</a> & <a href=https://en.cppreference.com/w/cpp/regex/regex_error>std::regex_error</a> Example<a hidden class=anchor aria-hidden=true href=#stdregexhttpsencppreferencecomwcppregexbasic_regex--stdregex_errorhttpsencppreferencecomwcppregexregex_error-example>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>static</span> <span class=k>const</span> <span class=k>auto</span> <span class=n>r</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>regex</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;(\)&#34;</span><span class=p>);</span> <span class=c1>// Escape sequence error
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>regex_error</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>assert</span><span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>(),</span> <span class=s>&#34;Unexpected end of regex when escaping.&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>assert</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>code</span><span class=p>()</span> <span class=o>==</span> <span class=n>std</span><span class=o>::</span><span class=n>regex_constants</span><span class=o>::</span><span class=n>error_escape</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>You see! I am using <a href=https://en.cppreference.com/w/cpp/language/string_literal>raw string literals</a>. You can also use the normal string. But, in that case, you have to use a double backslash for an escape sequence.</li><li>The current implementation of <code>std::regex</code> is slow(as it needs regex interpretation & data structure creation at runtime), bloated and unavoidably require heap allocation(not allocator-aware). So, <strong><em>beware if you are using <code>std::regex</code> in a loop</em></strong>(see <a href="https://www.youtube.com/watch?v=7hfSyxNxFfo">C++ Weekly - Ep 74 - std::regex optimize by Jason Turner</a>). Also, there is only a single member function that I think could be of use is <a href=https://en.cppreference.com/w/cpp/regex/basic_regex/mark_count>std::regex::mark_count()</a> which returns a number of capture groups.</li><li>Moreover, if you are using multiple strings to create a regex pattern at run time. Then you may need <a href=/posts/7-best-practices-for-exception-handling-in-cpp-with-example/>exception handling</a> i.e. <code>std::regex_error</code> to validate its correctness.</li></ul><h2 id=stdregex_searchhttpsencppreferencecomwcppregexregex_search-example><a href=https://en.cppreference.com/w/cpp/regex/regex_search>std::regex_search</a> Example<a hidden class=anchor aria-hidden=true href=#stdregex_searchhttpsencppreferencecomwcppregexregex_search-example>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>string</span> <span class=n>input</span> <span class=o>=</span> <span class=s>&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>regex</span> <span class=n>r</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;((\w+):(\w+);)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>smatch</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>regex_search</span><span class=p>(</span><span class=n>input</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>r</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>str</span><span class=p>()</span> <span class=o>==</span> <span class=s>&#34;PQR:2;&#34;</span><span class=p>);</span>                <span class=c1>// Entire match
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>assert</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>str</span><span class=p>()</span> <span class=o>==</span> <span class=s>&#34;PQR&#34;</span><span class=p>);</span>                   <span class=c1>// Substring that matches 1st group
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>assert</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>].</span><span class=n>str</span><span class=p>()</span> <span class=o>==</span> <span class=s>&#34;2&#34;</span><span class=p>);</span>                     <span class=c1>// Substring that matches 2nd group
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>assert</span><span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=n>prefix</span><span class=p>().</span><span class=n>str</span><span class=p>()</span> <span class=o>==</span> <span class=s>&#34;ABC:1-&gt;   &#34;</span><span class=p>);</span>      <span class=c1>// All before 1st character match
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>assert</span><span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=n>suffix</span><span class=p>().</span><span class=n>str</span><span class=p>()</span> <span class=o>==</span> <span class=s>&#34;;;   XYZ:3&lt;&lt;&lt;&#34;</span><span class=p>);</span>   <span class=c1>// All after last character match
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=c1>// for (string &amp;&amp;str : m) { // Alternatively. You can also do
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//     cout &lt;&lt; str &lt;&lt; endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><code>smatch</code> is the specializations of <a href=https://en.cppreference.com/w/cpp/regex/match_results>std::match_results</a> that stores the information about matches to be retrieved.</li></ul><h2 id=stdregex_matchhttpsencppreferencecomwcppregexregex_match-example><a href=https://en.cppreference.com/w/cpp/regex/regex_match>std::regex_match</a> Example<a hidden class=anchor aria-hidden=true href=#stdregex_matchhttpsencppreferencecomwcppregexregex_match-example>#</a></h2><ul><li>Short & sweet example that you may always find in every regex book is email validation. And that is where our <code>std::regex_match</code> function fits perfectly.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>is_valid_email_id</span><span class=p>(</span><span class=n>string_view</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=k>const</span> <span class=n>regex</span> <span class=n>r</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;(\w+@\w+\.(?:com|in))&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>regex_match</span><span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>is_valid_email_id</span><span class=p>(</span><span class=s>&#34;vishalchovatiya@ymail.com&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>is_valid_email_id</span><span class=p>(</span><span class=s>&#34;@abc.com&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>I know this is not full proof email validator regex pattern. But my intention is also not that.</li><li>Rather you should wonder why I have used <code>std::regex_match</code>! not <code>std::regex_search</code>! The rationale is simple <strong><em><code>std::regex_match</code> matches the whole input sequence</em></strong>.</li><li>Also, Noticeable thing is <em><strong>static regex object to avoid constructing (&ldquo;compiling/interpreting&rdquo;) a new regex object every time</strong></em> the function entered.</li><li>The irony of <strong><em>above tiny code snippet is that it produces around 30k lines of assembly</em></strong> that too with <code>-O3</code> flag. And that is ridiculous. But don&rsquo;t worry this is already been brought to the ISO C++ community. And soon we may get some updates. Meanwhile, we do have other alternatives (mentioned at the end of this article).</li></ul><h2 id=difference-between-stdregex_matchhttpsencppreferencecomwcppregexregex_match--stdregex_searchhttpsencppreferencecomwcppregexregex_search>Difference Between <a href=https://en.cppreference.com/w/cpp/regex/regex_match>std::regex_match</a> & <a href=https://en.cppreference.com/w/cpp/regex/regex_search>std::regex_search</a>?<a hidden class=anchor aria-hidden=true href=#difference-between-stdregex_matchhttpsencppreferencecomwcppregexregex_match--stdregex_searchhttpsencppreferencecomwcppregexregex_search>#</a></h2><ul><li>You might be wondering why do we have two functions doing almost the same work? Even I had the doubt initially. But, after reading the description provided by cppreference over and over. I found the answer. And to explain that answer, I have created the example(obviously with the help of StackOverflow):</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>string</span> <span class=n>input</span> <span class=o>=</span> <span class=s>&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>regex</span> <span class=n>r</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;((\w+):(\w+);)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>smatch</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>regex_match</span><span class=p>(</span><span class=n>input</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>r</span><span class=p>)</span> <span class=o>==</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>regex_search</span><span class=p>(</span><span class=n>input</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>r</span><span class=p>)</span> <span class=o>==</span> <span class=nb>true</span> <span class=o>&amp;&amp;</span> <span class=n>m</span><span class=p>.</span><span class=n>ready</span><span class=p>()</span> <span class=o>==</span> <span class=nb>true</span> <span class=o>&amp;&amp;</span> <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=s>&#34;PQR&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><strong><em><code>std::regex_match</code> only returns <code>true</code> when the entire input sequence has been matched,</em></strong> while <strong><em><code>std::regex_search</code> will succeed even if only a sub-sequence matches the regex.</em></strong></li></ul><h2 id=stdregex_iteratorhttpsencppreferencecomwcppregexregex_iterator-example><a href=https://en.cppreference.com/w/cpp/regex/regex_iterator>std::regex_iterator</a> Example<a hidden class=anchor aria-hidden=true href=#stdregex_iteratorhttpsencppreferencecomwcppregexregex_iterator-example>#</a></h2><ul><li><code>std::regex_iterator</code> is helpful when you need very detailed information about matches & sub-matches.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define C_ALL(X) cbegin(X), cend(X)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>string</span> <span class=n>input</span> <span class=o>=</span> <span class=s>&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>regex</span> <span class=n>r</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;((\w+):(\d))&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>smatch</span><span class=o>&gt;</span> <span class=n>matches</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>sregex_iterator</span><span class=p>{</span><span class=n>C_ALL</span><span class=p>(</span><span class=n>input</span><span class=p>),</span> <span class=n>r</span><span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=n>sregex_iterator</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>matches</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>str</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;ABC:1&#34;</span> 
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=n>matches</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>str</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;ABC&#34;</span> 
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=n>matches</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>str</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>matches</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>str</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;PQR:2&#34;</span> 
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=n>matches</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>str</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;PQR&#34;</span> 
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=n>matches</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>str</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;2&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>matches</span><span class=p>[</span><span class=mi>2</span><span class=p>].</span><span class=n>str</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;XYZ:3&#34;</span> 
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=n>matches</span><span class=p>[</span><span class=mi>2</span><span class=p>].</span><span class=n>str</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;XYZ&#34;</span> 
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=n>matches</span><span class=p>[</span><span class=mi>2</span><span class=p>].</span><span class=n>str</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;3&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Earlier(in C++11), there was a limitation that using <code>std::regex_interator</code> is not allowed to be called with a temporary regex object. Which has been rectified with overload from C++14.</li></ul><h2 id=stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator-example><a href=https://en.cppreference.com/w/cpp/regex/regex_token_iterator>std::regex_token_iterator</a> Example<a hidden class=anchor aria-hidden=true href=#stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator-example>#</a></h2><ul><li><code>std::regex_token_iterator</code> is the utility you are going to use 80% of the time. It has a slight variation as compared to <code>std::regex_iterator</code>. The <strong><em>difference between <code>std::regex_iterator</code> & <code>std::regex_token_iterator</code> is</em></strong><ul><li><strong><em><code>std::regex_iterator</code> points to match results.</em></strong></li><li><strong><em><code>std::regex_token_iterator</code> points to sub-matches.</em></strong></li></ul></li><li>In <code>std::regex_token_iterator</code>, each iterator contains only a single matched result.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define C_ALL(X) cbegin(X), cend(X)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>string</span> <span class=n>input</span> <span class=o>=</span> <span class=s>&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>regex</span> <span class=n>r</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;((\w+):(\d))&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Note: vector&lt;string&gt; here, unlike vector&lt;smatch&gt; as in std::regex_iterator
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>full_match</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>sregex_token_iterator</span><span class=p>{</span><span class=n>C_ALL</span><span class=p>(</span><span class=n>input</span><span class=p>),</span> <span class=n>r</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span> <span class=c1>// Mark `0` here i.e. whole regex match
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>sregex_token_iterator</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>((</span><span class=n>full_match</span> <span class=o>==</span> <span class=k>decltype</span><span class=p>(</span><span class=n>full_match</span><span class=p>){</span><span class=s>&#34;ABC:1&#34;</span><span class=p>,</span> <span class=s>&#34;PQR:2&#34;</span><span class=p>,</span> <span class=s>&#34;XYZ:3&#34;</span><span class=p>}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>cptr_grp_1st</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>sregex_token_iterator</span><span class=p>{</span><span class=n>C_ALL</span><span class=p>(</span><span class=n>input</span><span class=p>),</span> <span class=n>r</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=c1>// Mark `1` here i.e. 1st capture group
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>sregex_token_iterator</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>((</span><span class=n>cptr_grp_1st</span> <span class=o>==</span> <span class=k>decltype</span><span class=p>(</span><span class=n>cptr_grp_1st</span><span class=p>){</span><span class=s>&#34;ABC&#34;</span><span class=p>,</span> <span class=s>&#34;PQR&#34;</span><span class=p>,</span> <span class=s>&#34;XYZ&#34;</span><span class=p>}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>cptr_grp_2nd</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>sregex_token_iterator</span><span class=p>{</span><span class=n>C_ALL</span><span class=p>(</span><span class=n>input</span><span class=p>),</span> <span class=n>r</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span> <span class=c1>// Mark `2` here i.e. 2nd capture group
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>sregex_token_iterator</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>((</span><span class=n>cptr_grp_2nd</span> <span class=o>==</span> <span class=k>decltype</span><span class=p>(</span><span class=n>cptr_grp_2nd</span><span class=p>){</span><span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=s>&#34;3&#34;</span><span class=p>}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=inverted-match-with-stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator>Inverted Match With <a href=https://en.cppreference.com/w/cpp/regex/regex_token_iterator>std::regex_token_iterator</a><a hidden class=anchor aria-hidden=true href=#inverted-match-with-stdregex_token_iteratorhttpsencppreferencecomwcppregexregex_token_iterator>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define C_ALL(X) cbegin(X), cend(X)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>string</span> <span class=n>input</span> <span class=o>=</span> <span class=s>&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>regex</span> <span class=n>r</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;((\w+):(\d))&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>inverted</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>sregex_token_iterator</span><span class=p>{</span><span class=n>C_ALL</span><span class=p>(</span><span class=n>input</span><span class=p>),</span> <span class=n>r</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>},</span> <span class=c1>// `-1` = parts that are not matched
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>sregex_token_iterator</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>((</span><span class=n>inverted</span> <span class=o>==</span> <span class=k>decltype</span><span class=p>(</span><span class=n>inverted</span><span class=p>){</span>
</span></span><span class=line><span class=cl>							<span class=s>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>							<span class=s>&#34;-&gt;   &#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>							<span class=s>&#34;;;;   &#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>							<span class=s>&#34;&lt;&lt;&lt;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>						<span class=p>}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=stdregex_replacehttpsencppreferencecomwcppregexregex_replace-example><a href=https://en.cppreference.com/w/cpp/regex/regex_replace>std::regex_replace</a> Example<a hidden class=anchor aria-hidden=true href=#stdregex_replacehttpsencppreferencecomwcppregexregex_replace-example>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=nf>transform_pair</span><span class=p>(</span><span class=n>string_view</span> <span class=n>text</span><span class=p>,</span> <span class=n>regex_constants</span><span class=o>::</span><span class=n>match_flag_type</span> <span class=n>f</span> <span class=o>=</span> <span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=k>const</span> <span class=k>auto</span> <span class=n>r</span> <span class=o>=</span> <span class=n>regex</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;((\w+):(\d))&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>regex_replace</span><span class=p>(</span><span class=n>text</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>r</span><span class=p>,</span> <span class=s>&#34;$2&#34;</span><span class=p>,</span> <span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>transform_pair</span><span class=p>(</span><span class=s>&#34;ABC:1, PQR:2&#34;</span><span class=n>s</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;1, 2&#34;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Things that aren&#39;t matched are not copied
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>assert</span><span class=p>(</span><span class=n>transform_pair</span><span class=p>(</span><span class=s>&#34;ABC:1, PQR:2&#34;</span><span class=n>s</span><span class=p>,</span> <span class=n>regex_constants</span><span class=o>::</span><span class=n>format_no_copy</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;12&#34;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>You see in 2nd call of transform_pair, we passed flag <code>std::regex_constants::format_no_copy</code> which suggest do not copy thing that isn&rsquo;t matched. There are many such useful flags under <a href=https://en.cppreference.com/w/cpp/regex/match_flag_type>std::regex_constant</a>.</li><li>Also, we have constructed the fresh string holding the results. But what if we do not want a new string. Rather wants to append the results directly to somewhere(probably container or stream or already existing string). Guess what! the standard library has covered this also with overloaded <code>std::regex_replace</code> as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>string</span> <span class=n>input</span> <span class=o>=</span> <span class=s>&#34;ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;&#34;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>regex</span> <span class=n>r</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;(-|&gt;|&lt;|;| )&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Prints &#34;ABC:1     PQR:2      XYZ:3   &#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>regex_replace</span><span class=p>(</span><span class=n>ostreambuf_iterator</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=n>cout</span><span class=p>),</span> <span class=n>C_ALL</span><span class=p>(</span><span class=n>input</span><span class=p>),</span> <span class=n>r</span><span class=p>,</span> <span class=s>&#34; &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=use-cases>Use Cases<a hidden class=anchor aria-hidden=true href=#use-cases>#</a></h2><h3 id=splitting-a-string-with-delimiter>Splitting a String With Delimiter<a hidden class=anchor aria-hidden=true href=#splitting-a-string-with-delimiter>#</a></h3><ul><li>Although <code>std::strtok</code> is best suitable & optimal candidate for such a task. But just to demonstrate how you can do it with regex:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define C_ALL(X) cbegin(X), cend(X)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>split</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>,</span> <span class=n>string_view</span> <span class=n>pattern</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>r</span> <span class=o>=</span> <span class=n>regex</span><span class=p>(</span><span class=n>pattern</span><span class=p>.</span><span class=n>data</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sregex_token_iterator</span><span class=p>(</span><span class=n>C_ALL</span><span class=p>(</span><span class=n>str</span><span class=p>),</span> <span class=n>r</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>sregex_token_iterator</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>((</span><span class=n>split</span><span class=p>(</span><span class=s>&#34;/root/home/vishal&#34;</span><span class=p>,</span> <span class=s>&#34;/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=o>==</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span><span class=p>{</span><span class=s>&#34;&#34;</span><span class=p>,</span> <span class=s>&#34;root&#34;</span><span class=p>,</span> <span class=s>&#34;home&#34;</span><span class=p>,</span> <span class=s>&#34;vishal&#34;</span><span class=p>}));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=trim-whitespace-from-a-string>Trim Whitespace From a String<a hidden class=anchor aria-hidden=true href=#trim-whitespace-from-a-string>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=nf>trim</span><span class=p>(</span><span class=n>string_view</span> <span class=n>text</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=k>const</span> <span class=k>auto</span> <span class=n>r</span> <span class=o>=</span> <span class=n>regex</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;(\s+)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>regex_replace</span><span class=p>(</span><span class=n>text</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>r</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>trim</span><span class=p>(</span><span class=s>&#34;12   3 4      5&#34;</span><span class=n>s</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;12345&#34;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=finding-lines-containing-or-not-containing-certain-words-from-a-file>Finding Lines Containing or Not Containing Certain Words From a File<a hidden class=anchor aria-hidden=true href=#finding-lines-containing-or-not-containing-certain-words-from-a-file>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=nf>join</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>words</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>delimiter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>accumulate</span><span class=p>(</span><span class=n>next</span><span class=p>(</span><span class=n>begin</span><span class=p>(</span><span class=n>words</span><span class=p>)),</span> <span class=n>end</span><span class=p>(</span><span class=n>words</span><span class=p>),</span> <span class=n>words</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=o>&amp;</span><span class=n>delimiter</span><span class=p>](</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>p</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>word</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>p</span> <span class=o>+</span> <span class=n>delimiter</span> <span class=o>+</span> <span class=n>word</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>lines_containing</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>file</span><span class=p>,</span> <span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>words</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>prefix</span> <span class=o>=</span> <span class=s>&#34;^.*?</span><span class=se>\\</span><span class=s>b(&#34;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>suffix</span> <span class=o>=</span> <span class=s>&#34;)</span><span class=se>\\</span><span class=s>b.*$&#34;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//  ^.*?\b(one|two|three)\b.*$
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>auto</span> <span class=n>pattern</span> <span class=o>=</span> <span class=n>move</span><span class=p>(</span><span class=n>prefix</span><span class=p>)</span> <span class=o>+</span> <span class=n>join</span><span class=p>(</span><span class=n>words</span><span class=p>,</span> <span class=s>&#34;|&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=n>move</span><span class=p>(</span><span class=n>suffix</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ifstream</span>        <span class=nf>infile</span><span class=p>(</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span>  <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>string</span> <span class=n>line</span><span class=p>;</span> <span class=n>getline</span><span class=p>(</span><span class=n>infile</span><span class=p>,</span> <span class=n>line</span><span class=p>);)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>regex_match</span><span class=p>(</span><span class=n>line</span><span class=p>,</span> <span class=n>regex</span><span class=p>(</span><span class=n>pattern</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>move</span><span class=p>(</span><span class=n>line</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>assert</span><span class=p>((</span><span class=n>lines_containing</span><span class=p>(</span><span class=s>&#34;test.txt&#34;</span><span class=p>,</span> <span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl>                                        <span class=o>==</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span><span class=p>{</span><span class=s>&#34;This is one&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=s>&#34;This is two&#34;</span><span class=p>}));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* test.txt
</span></span></span><span class=line><span class=cl><span class=cm>This is one
</span></span></span><span class=line><span class=cl><span class=cm>This is two
</span></span></span><span class=line><span class=cl><span class=cm>This is three
</span></span></span><span class=line><span class=cl><span class=cm>This is four
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><ul><li>Same goes for finding lines that are not containing words with the pattern <code>^((?!(one|two|three)).)*$</code>.</li></ul><h3 id=finding-files-in-a-directory>Finding Files in a Directory<a hidden class=anchor aria-hidden=true href=#finding-files-in-a-directory>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>fs</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>filesystem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>fs</span><span class=o>::</span><span class=n>directory_entry</span><span class=o>&gt;</span> <span class=n>find_files</span><span class=p>(</span><span class=k>const</span> <span class=n>fs</span><span class=o>::</span><span class=n>path</span> <span class=o>&amp;</span><span class=n>path</span><span class=p>,</span> <span class=n>string_view</span> <span class=n>rg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>fs</span><span class=o>::</span><span class=n>directory_entry</span><span class=o>&gt;</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>regex</span> <span class=nf>r</span><span class=p>(</span><span class=n>rg</span><span class=p>.</span><span class=n>data</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>copy_if</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>fs</span><span class=o>::</span><span class=n>recursive_directory_iterator</span><span class=p>(</span><span class=n>path</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>fs</span><span class=o>::</span><span class=n>recursive_directory_iterator</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=n>back_inserter</span><span class=p>(</span><span class=n>result</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=o>&amp;</span><span class=n>r</span><span class=p>](</span><span class=k>const</span> <span class=n>fs</span><span class=o>::</span><span class=n>directory_entry</span> <span class=o>&amp;</span><span class=n>entry</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>fs</span><span class=o>::</span><span class=n>is_regular_file</span><span class=p>(</span><span class=n>entry</span><span class=p>.</span><span class=n>path</span><span class=p>())</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                   <span class=n>regex_match</span><span class=p>(</span><span class=n>entry</span><span class=p>.</span><span class=n>path</span><span class=p>().</span><span class=n>filename</span><span class=p>().</span><span class=n>string</span><span class=p>(),</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>dir</span>        <span class=o>=</span> <span class=n>fs</span><span class=o>::</span><span class=n>temp_directory_path</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>pattern</span>    <span class=o>=</span> <span class=n>R</span><span class=s>&#34;(\w+\.png)&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>result</span>     <span class=o>=</span> <span class=n>find_files</span><span class=p>(</span><span class=n>fs</span><span class=o>::</span><span class=n>current_path</span><span class=p>(),</span> <span class=n>pattern</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>entry</span> <span class=p>:</span> <span class=n>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>entry</span><span class=p>.</span><span class=n>path</span><span class=p>().</span><span class=n>string</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=tips-for-using-regex-in-general>Tips For Using Regex-In-General<a hidden class=anchor aria-hidden=true href=#tips-for-using-regex-in-general>#</a></h2><ul><li>Use raw string literal for describing the regex pattern in C++.</li><li>Use the regex validating tool like <a href=https://regex101.com>https://regex101.com</a>. What I like about <a href=https://regex101.com/>regex101</a> is code generation & time-taken(will be helpful when optimizing regex) feature.</li><li>Also, try to add generated explanation from validation tool as a comment exactly above the regex pattern in your code.</li><li>Performance:<ul><li>If you are using alternation, try to arrange options in high probability order like <code>com|net|org</code>.</li><li>Try to use lazy quantifiers if possible.</li><li>Use non-capture groups wherever possible.</li><li>Disable Backtracking.</li><li>Using the negated character class is more efficient than using a lazy dot.</li></ul></li></ul><h2 id=parting-words>Parting Words<a hidden class=anchor aria-hidden=true href=#parting-words>#</a></h2><p>It&rsquo;s not just that you will use regex with only C++ or any other language. I myself use it mostly on IDE(in vscode to analyse log files) & on Linux terminal. But, bear in mind that overusing regex gives the feel of cleverness. And, it&rsquo;s a great way to make your co-workers (and anyone else who needs to work with your code) very angry with you. Also, regex is overkill for most parsing tasks that you&rsquo;ll face in your daily work.</p><p>The regexes really shine for complicated tasks where hand-written parsing code would be just as slow anyway; and for extremely simple tasks where the readability and robustness of regular expressions outweigh their performance costs.</p><p>One more notable thing is current regex implementation(till 19th June 2020) in standard libraries have performance & code bloating issues. So choose wisely between Boost, CTRE and Standard library versions. Most probably you might go with the Hana Dusíková&rsquo;s work on <a href=https://github.com/hanickadot/compile-time-regular-expressions>Compile Time Regular Expression</a>. Also, her CppCon talk from <a href="https://www.youtube.com/watch?v=QM3W36COnE4&amp;list=WL&amp;index=9&amp;t=0s">2018</a> & <a href="https://www.youtube.com/watch?v=8dKWdJzPwHw">2019</a>&rsquo;s would be helpful especially if you plan to use regex in embedded systems.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/boost-regex-example/>Boost-Regex-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/boost-regex-examples/>Boost-Regex-Examples</a></li><li><a href=https://vishalchovatiya.github.io/tags/boost-regex-tutorial/>Boost-Regex-Tutorial</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-11-regex/>C-11-Regex</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-programming-regex/>C-Programming-Regex</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-library/>C-Regex-Library</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-posix/>C-Regex-Posix</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-boost-regex/>C-Boost-Regex</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-pattern-matching-example/>C-Pattern-Matching-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-digit/>C-Regex-Digit</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-example/>C-Regex-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-find-all-matches/>C-Regex-Find-All-Matches</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-groups/>C-Regex-Groups</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-online/>C-Regex-Online</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-parser/>C-Regex-Parser</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-pattern/>C-Regex-Pattern</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-search/>C-Regex-Search</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-syntax/>C-Regex-Syntax</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-tester/>C-Regex-Tester</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regex-tutorial/>C-Regex-Tutorial</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regular-expression/>C-Regular-Expression</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regular-expression-example/>C-Regular-Expression-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regular-expression-syntax/>C-Regular-Expression-Syntax</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-regular-expression-tutorial/>C-Regular-Expression-Tutorial</a></li><li><a href=https://vishalchovatiya.github.io/tags/c-std-regex-example/>C-Std-Regex-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/difference-between-stdregex_match-stdregex_search/>Difference-Between-Stdregex_match-Stdregex_search</a></li><li><a href=https://vishalchovatiya.github.io/tags/finding-files-in-a-directory-c-regex/>Finding-Files-in-a-Directory-C-Regex</a></li><li><a href=https://vishalchovatiya.github.io/tags/finding-lines-containing-or-not-containing-certain-words-from-a-file-c-regex/>Finding-Lines-Containing-or-Not-Containing-Certain-Words-From-a-File-C-Regex</a></li><li><a href=https://vishalchovatiya.github.io/tags/geeks-for-geeks-regex-c/>Geeks-for-Geeks-Regex-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/inverted-match-with-stdregex_token_iterator/>Inverted-Match-With-Stdregex_token_iterator</a></li><li><a href=https://vishalchovatiya.github.io/tags/libboost-regex/>Libboost-Regex</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-c-cheat-sheet/>Regex-C-Cheat-Sheet</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-c/>Regex-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-c-gfg/>Regex-C-Gfg</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-c-tutorial/>Regex-C-Tutorial</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-cpp/>Regex-Cpp</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-generator-c/>Regex-Generator-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-in-c-example-2/>Regex-in-C-Example-2</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-in-c-programming/>Regex-in-C-Programming</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-in-c/>Regex-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-in-c-example/>Regex-in-C-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-library-c/>Regex-Library-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-search-c/>Regex-Search-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex-split-c/>Regex-Split-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/regex_match-example-c/>Regex_match-Example-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/regular-expression-c-example/>Regular-Expression-C-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/regular-expression-c-tutorial/>Regular-Expression-C-Tutorial</a></li><li><a href=https://vishalchovatiya.github.io/tags/regular-expression-cpp/>Regular-Expression-Cpp</a></li><li><a href=https://vishalchovatiya.github.io/tags/regular-expression-in-c-example/>Regular-Expression-in-C-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/regular-expression-in-c-example-2/>Regular-Expression-in-C-Example-2</a></li><li><a href=https://vishalchovatiya.github.io/tags/regular-expression-in-cpp/>Regular-Expression-in-Cpp</a></li><li><a href=https://vishalchovatiya.github.io/tags/splitting-a-string-with-delimiter-c-regex/>Splitting-a-String-With-Delimiter-C-Regex</a></li><li><a href=https://vishalchovatiya.github.io/tags/sregex_token_iterator/>Sregex_token_iterator</a></li><li><a href=https://vishalchovatiya.github.io/tags/stdregex-stdregex_error-example/>Stdregex-Stdregex_error-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/stdregex_iterator-example/>Stdregex_iterator-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/stdregex_match-example/>Stdregex_match-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/stdregex_replace-example/>Stdregex_replace-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/stdregex_search-example/>Stdregex_search-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/stdregex_token_iterator-example/>Stdregex_token_iterator-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/string-to-regex-c/>String-to-Regex-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/trim-whitespace-from-a-string-c-regex/>Trim-Whitespace-From-a-String-C-Regex</a></li><li><a href=https://vishalchovatiya.github.io/tags/use-regex-in-c/>Use-Regex-in-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/using-regex-c/>Using-Regex-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/validating-email-address-with-regex-hackerrank-c/>Validating-Email-Address-With-Regex-Hackerrank-C</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/mastering-c-books-courses-tools-tutorials-blogs-communities/><span class=title>« Prev</span><br><span>Mastering C++: Books | Courses | Tools | Tutorials | Blogs | Communities</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/using-std-map-wisely-with-modern-cpp/><span class=title>Next »</span><br><span>Using std::map Wisely With Modern C++</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Regex C++ on x" href="https://x.com/intent/tweet/?text=Regex%20C%2b%2b&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fregex-c%2f&amp;hashtags=boost-regex-example%2cboost-regex-examples%2cboost-regex-tutorial%2cc-11-regex%2cc-programming-regex%2cc-regex-library%2cc-regex-posix%2cc-boost-regex%2cc-pattern-matching-example%2cc-regex-digit%2cc-regex-example%2cc-regex-find-all-matches%2cc-regex-groups%2cc-regex-online%2cc-regex-parser%2cc-regex-pattern%2cc-regex-search%2cc-regex-syntax%2cc-regex-tester%2cc-regex-tutorial%2cc-regular-expression%2cc-regular-expression-example%2cc-regular-expression-syntax%2cc-regular-expression-tutorial%2cc-std-regex-example%2cdifference-between-stdregex_match-stdregex_search%2cfinding-files-in-a-directory-c-regex%2cfinding-lines-containing-or-not-containing-certain-words-from-a-file-c-regex%2cgeeks-for-geeks-regex-c%2cinverted-match-with-stdregex_token_iterator%2clibboost-regex%2cregex-c-cheat-sheet%2cregex-c%2cregex-c-gfg%2cregex-c-tutorial%2cregex-cpp%2cregex-generator-c%2cregex-in-c-example-2%2cregex-in-c-programming%2cregex-in-c%2cregex-in-c-example%2cregex-library-c%2cregex-search-c%2cregex-split-c%2cregex_match-example-c%2cregular-expression-c-example%2cregular-expression-c-tutorial%2cregular-expression-cpp%2cregular-expression-in-c-example%2cregular-expression-in-c-example-2%2cregular-expression-in-cpp%2csplitting-a-string-with-delimiter-c-regex%2csregex_token_iterator%2cstdregex-stdregex_error-example%2cstdregex_iterator-example%2cstdregex_match-example%2cstdregex_replace-example%2cstdregex_search-example%2cstdregex_token_iterator-example%2cstring-to-regex-c%2ctrim-whitespace-from-a-string-c-regex%2cuse-regex-in-c%2cusing-regex-c%2cvalidating-email-address-with-regex-hackerrank-c"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Regex C++ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fregex-c%2f&amp;title=Regex%20C%2b%2b&amp;summary=Regex%20C%2b%2b&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fregex-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Regex C++ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fregex-c%2f&title=Regex%20C%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Regex C++ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fregex-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Regex C++ on whatsapp" href="https://api.whatsapp.com/send?text=Regex%20C%2b%2b%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fregex-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Regex C++ on telegram" href="https://telegram.me/share/url?text=Regex%20C%2b%2b&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fregex-c%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Regex C++ on ycombinator" href="https://news.ycombinator.com/submitlink?t=Regex%20C%2b%2b&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fregex-c%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>