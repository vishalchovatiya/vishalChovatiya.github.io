<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ Type Casting With Example for C Developers | Vishal Chovatiya</title>
<meta name=keywords content="c-style-casts,const_cast,dynamic_cast,implicit-conversion-c,reinterpret_cast,static_cast,why-do-we-need-typecasting"><meta name=description content="The typecasting is the feature which makes C++ more type-safe, robust & may convince you to use it over C. But this is also a more underrated topic when you are a newbie or moving from C background. Hence, I come up with an article on it. Here, we will not only see the C++ type casting with example but we will also cover Why do we need typecasting? & C++ type casting cheat codes for C developers to remember & employ it easily."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/cpp-type-casting-with-example-for-c-developers/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/cpp-type-casting-with-example-for-c-developers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="C++ Type Casting With Example for C Developers"><meta property="og:description" content="The typecasting is the feature which makes C++ more type-safe, robust & may convince you to use it over C. But this is also a more underrated topic when you are a newbie or moving from C background. Hence, I come up with an article on it. Here, we will not only see the C++ type casting with example but we will also cover Why do we need typecasting? & C++ type casting cheat codes for C developers to remember & employ it easily."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/cpp-type-casting-with-example-for-c-developers/"><meta property="og:image" content="https://vishalchovatiya.github.io/images/C-type-casting-with-example-for-C-developers.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-12T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-12T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/images/C-type-casting-with-example-for-C-developers.png"><meta name=twitter:title content="C++ Type Casting With Example for C Developers"><meta name=twitter:description content="The typecasting is the feature which makes C++ more type-safe, robust & may convince you to use it over C. But this is also a more underrated topic when you are a newbie or moving from C background. Hence, I come up with an article on it. Here, we will not only see the C++ type casting with example but we will also cover Why do we need typecasting? & C++ type casting cheat codes for C developers to remember & employ it easily."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ Type Casting With Example for C Developers","item":"https://vishalchovatiya.github.io/posts/cpp-type-casting-with-example-for-c-developers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ Type Casting With Example for C Developers","name":"C\u002b\u002b Type Casting With Example for C Developers","description":"The typecasting is the feature which makes C++ more type-safe, robust \u0026amp; may convince you to use it over C. But this is also a more underrated topic when you are a newbie or moving from C background. Hence, I come up with an article on it. Here, we will not only see the C++ type casting with example but we will also cover Why do we need typecasting? \u0026amp; C++ type casting cheat codes for C developers to remember \u0026amp; employ it easily.","keywords":["c-style-casts","const_cast","dynamic_cast","implicit-conversion-c","reinterpret_cast","static_cast","why-do-we-need-typecasting"],"articleBody":"The typecasting is the feature which makes C++ more type-safe, robust \u0026 may convince you to use it over C. But this is also a more underrated topic when you are a newbie or moving from C background. Hence, I come up with an article on it. Here, we will not only see the C++ type casting with example but we will also cover Why do we need typecasting? \u0026 C++ type casting cheat codes for C developers to remember \u0026 employ it easily. Although I am not an expert but this is what I have learned so far from various sources \u0026 5+ yrs of industry experience.\nIn C++, there are 5 different types of casts: C-style casts, static_cast, const_cast, dynamic_cast, and reinterpret_cast.\nI usually start with “Why do we need it?”, but this time first we quickly go through some jargons \u0026 I will end this article with some of CPP core guidelines on typecasting.\nJargons You Need to Face Implicit conversion: where the compiler automatically typecast. Like float f = 3;, here compiler will not complain but directly transform 3 which is of type integer into float \u0026 assign to f. Explicit conversions: where the developer uses a casting operator to direct the conversion. All types of manual casting fall under the explicit type conversions category. Like int * p = (int*)std::malloc(10);, here we explicitly casting void* to int*. l-value: an identifier which represents memory location. For example, variable name, *ptr where ptr points to a memory location, etc. r-value: a value which is not l-value, r-value appear on the right-hand side of the assignment(=) operator. Like int a = 5; // 5 = r-value, q = p + 5; // p + 5 is r-value Note: Although there are some exceptions \u0026 more to learn on lvalue, rvalue and their references in C++.\nWhy Do We Need Typecasting? Data is a representation of the bits(0s \u0026 1s) in memory. Data-type is compiler directive which tells the compiler how to store \u0026 process particular data. uint32_t a = 5; by this statement you can presume that 4 bytes will be reserved in your memory \u0026 upon execution, it will store 0000 0000 0000 0000 0000 0000 0000 0101 data bits in that memory location. This was plain \u0026 simple. Let’s go a bit further, float f = 3.0; this statement will also reserve 4 bytes in memory \u0026 store data bits in the form of 1). the sign bit, 2). exponent \u0026 3). mantissa. Recall how floating-point numbers are stored in memory. But when you write like float f = 3;, the compiler will be confused that how to store an integer value in float type of memory. So it will automatically presume(Implicit conversion here) that you want to store 3.0 rather than 3 which is technically same from the human point of view but it’s different when you think from computer memory perspective cause they stored differently. There are many such scenarios where you provide data to store in memory which used to represent different data type. For example, in the following example, you are trying to assign an object of type B into an object of type A class A{}; class B{}; int main () { B b; A a = b; return 0; } In such scenario compiler can not presume anything \u0026 simply throws a compilation error: exit status 1 error: no viable conversion from 'B' to 'A' A a = b; ^ ~ note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'B' to 'const A \u0026' for 1st argument class A{}; ^ note: candidate constructor (the implicit move constructor) not viable: no known conversion from 'B' to 'A \u0026\u0026' for 1st argument class A{}; ^ 1 error generated. But when you define a conversion operator as follows: class B { public: operator A(){ cout\u003c\u003c\"CONVERSION OPERATOR\\n\"; return A(); } }; The compiler will simply call this member function \u0026 won’t throw any error because programmer explicitly mentioning that this is how he/she wants to convert. C++ Type Casting With Example for C Developers C-style casts int main() { float res = 10 / 4; cout\u003c\u003cres\u003c\u003cendl; return 0; } When you will try to run the above code, you will get 2 as output which we didn’t expect. To initialize res variable correctly we need to typecast using float as follows: float res = (float)10 / 4; Now your answer will be 2.5. This type of casting is very simple \u0026 straight forward as it appears. You can also write above casting in C++ as: float res = float(10) / 4; C-style casts can change a data type without changing the underlying memory representation which may lead to garbage results. static_cast If you are C developer like me, then this will be your best goto C++ cast which fits in most of the example like: int * p = std::malloc(10); When you try to compile above code using C compiler it works fine. But C++ compiler is not kind enough. It will throw an error as follows : exit status 1 error: cannot initialize a variable of type 'int *' with an rvalue of type 'void *' int * p = std::malloc(10); ^ ~~~~~~~~~~ 1 error generated. The first thing that comes to your mind is the C-style cast: int * p = (int*)std::malloc(10); This will work, but C-style cast is not recommended in C++. static_cast handles implicit conversions like this. We will primarily use it for converting in places where implicit conversions fail, such as std::malloc. int * p = static_cast\u003cint*\u003e(std::malloc(10)); The main advantage of static_cast is that it provides compile-time type checking, making it harder to make an inadvertent error. Let’s understand this with C++ example: class B {}; class D : public B {}; class X {}; int main() { D* d = new D; B* b = static_cast\u003cB*\u003e(d); // this works X* x = static_cast\u003cX*\u003e(d); // ERROR - Won't compile return 0; } As you can see, there is no easy way to distinguish between the two situations without knowing a lot about all the classes involved. Another problem with the C-style casts is that it is too hard to locate. In complex expressions, it can be very hard to see C-style casts e.g. T(something) syntax is equivalent to (T)something`. const_cast Now we will directly jump to example. No theory can explain this better than example. 1. Ignore constness\nint i = 0; const int\u0026 ref = i; const int* ptr = \u0026i; *ptr = 3; // Not OK const_cast\u003cint\u0026\u003e(ref) = 3; //OK *const_cast\u003cint*\u003e(ptr) = 3; //OK You are allowed to modify i, because of the object(i here) being assigned to, is not const. If you add const qualifier to i, code will compile, but its behaviour will be undefined (which can mean anything from “it works just fine” to “the program will crash”.) 2. Modifying data member using const this pointer\nconst_cast can be used to change non-const class members by a method in which this pointer declared as const. - This can also be useful when overloading member functions based on const, for instance: class X { public: int var; void changeAndPrint(int temp) const { this-\u003evar = temp; // Throw compilation error (const_cast\u003cX *\u003e(this))-\u003evar = temp; // Works fine } void changeAndPrint(int *temp) { // Do some stuff } }; int main() { int a = 4; X x; x.changeAndPrint(\u0026a); x.changeAndPrint(5); cout \u003c\u003c x.var \u003c\u003c endl; return 0; } 3. Pass const argument to a function which accepts only non-const argument\nconst_cast can also be used to pass const data to a function that doesn’t receive const argument. See the following code: int fun(int* ptr) { return (*ptr + 10); } int main(void) { const int val = 10; cout \u003c\u003c fun(const_cast \u003cint *\u003e(\u0026val)); return 0; } 4. Castaway volatile attribute\nconst_cast can also be used to cast away volatile attribute. Whatever we discussed above in const_cast is also valid for volatile keyword. dynamic_cast **dynamic_cast** uses the type checking at runtime in contrary to static_cast which does it at compile time. dynamic_cast is more useful when you don’t know the type of input which it represents. Let assume: Base* CreateRandom() { if( (rand()%2) == 0 ) return new Derived1; else return new Derived2; } Base* base = CreateRandom(); As you can see, we don’t know which object will be returned by CreateRandom() at run time but you want to execute Method1()of Derived1if it returnsDerived1. So in this scenario, you can use dynamic_cast` as follows Derived1 *pD1 = dynamic_cast\u003cDerived1 *\u003e(base); if (pD1){ pD1-\u003eMethod1(); } In case, if the input of dynamic_cast does not point to valid data, it will return nullptr for pointers or throw a std::bad_cast exception for references. In order to work with dynamic_cast, your classes must be polymorphic type i.e. must include at least one virtual methods. **dynamic_cast** take advantage of **RTTI**(Run Time Type Identification) mechanism. reinterpret_cast reinterpret_cast converts between types by reinterpreting the underlying bit pattern. You can use reinterpret_cast to cast any pointer or integral type to any other pointer or integral type. This can lead to dangerous situations: nothing will stop you from converting an int to an std::string*. You will use reinterpret_cast in your embedded systems. A common scenario where reinterpret_cast applies is converting between uintptr_t and an actual pointer or between: error: static_cast from 'int *' to 'uintptr_t' (aka 'unsigned long') is not allowed uintptr_t ptr = static_cast\u003cuintptr_t\u003e(p); ^~~~~~~~~~~~~~~~~~~~~~~~~ 1 error generated. Instead, use this: uintptr_t ptr = reinterpret_cast\u003cuintptr_t\u003e(p); I have tried to cover most of the intricacies to clear the main concept behind different typecasting, but still, there might be a chance that I may miss some. So, this is it for C++ type casting with example for C developers. Let’s quickly recap:\nCheat Code for C Developers Moving to C++ on Type Casting After reading all this you may confuse on what to use \u0026 when! That’s why I have created this cheat code\nAvoid C-style casts. Be sure about what you want while casting. Use static_cast wherever you were using C-style cast. Use dynamic_cast with polymorphic classes. Keep in mind that only use dynamic_cast on classes with at least one virtual member in the inheritance hierarchy. Use const_cast when you need to remove const or volatile qualifiers. Use reinterpret_cast when you have no options. Note: const_cast and reinterpret_cast should generally be avoided because they can be harmful if used incorrectly. Don’t use it unless you have a very good reason to use them.\nSome of the C++ Core Guidelines on Typecasting P.4: Ideally, a program should be statically (compile-time) type safe ES.48: Avoid casts ES.49: If you must use a cast, use a named cast ES.50: Don’t cast away const C.146: Use dynamic_cast where class hierarchy navigation is unavoidable C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative ","wordCount":"1833","inLanguage":"en","image":"https://vishalchovatiya.github.io/images/C-type-casting-with-example-for-C-developers.png","datePublished":"2019-09-12T00:00:00Z","dateModified":"2019-09-12T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/cpp-type-casting-with-example-for-c-developers/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ Type Casting With Example for C Developers</h1><div class=post-meta><span title='2019-09-12 00:00:00 +0000 UTC'>September 12, 2019</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1833 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/cpp-type-casting-with-example-for-c-developers.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://vishalchovatiya.github.io/images/C-type-casting-with-example-for-C-developers.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#jargons-you-need-to-face>Jargons You Need to Face</a></li><li><a href=#why-do-we-need-typecasting>Why Do We Need Typecasting?</a></li><li><a href=#c-type-casting-with-example-for-c-developers>C++ Type Casting With Example for C Developers</a></li><li><a href=#c-style-casts><code>C-style casts</code></a></li><li><a href=#static_cast><code>static_cast</code></a></li><li><a href=#const_cast><code>const_cast</code></a></li><li><a href=#dynamic_cast><code>dynamic_cast</code></a></li><li><a href=#reinterpret_cast><code>reinterpret_cast</code></a></li><li><a href=#cheat-code-for-c-developers-moving-to-c-on-type-casting>Cheat Code for C Developers Moving to C++ on Type Casting</a></li><li><a href=#some-of-the-c-core-guidelines-on-typecasting>Some of the C++ Core Guidelines on Typecasting</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>The typecasting is the feature which makes C++ more type-safe, robust & may convince you to use it over C. But this is also a more underrated topic when you are a newbie or moving from C background. Hence, I come up with an article on it. Here, we will not only see the C++ type casting with example but we will also cover <a href=#Why-do-we-need-typecasting>Why do we need typecasting?</a> & <a href=#Cheat-code-for-C-developers-moving-to-C++-on-type-casting>C++ type casting cheat codes for C developers</a> to remember & employ it easily. Although I am not an expert but this is what I have learned so far from various sources & 5+ yrs of industry experience.</p><p>In C++, there are 5 different types of casts: C-style casts, <code>static_cast</code>, <code>const_cast</code>, <code>dynamic_cast</code>, and <code>reinterpret_cast</code>.</p><p>I usually start with &ldquo;Why do we need it?&rdquo;, but this time first we quickly go through some jargons & I will end this article with <a href=#Some-of-the-C++-core-guidelines-on-typecasting>some of CPP core guidelines on typecasting</a>.</p><h3 id=jargons-you-need-to-face>Jargons You Need to Face<a hidden class=anchor aria-hidden=true href=#jargons-you-need-to-face>#</a></h3><ol><li><strong>Implicit conversion:</strong> where the compiler automatically typecast. Like <code>float f = 3;</code>, here compiler will not complain but directly transform <code>3</code> which is of type integer into <code>float</code> & assign to <code>f</code>.</li><li><strong>Explicit conversions</strong>: where the developer uses a casting operator to direct the conversion. All types of manual casting fall under the explicit type conversions category. Like <code>int * p = (int*)std::malloc(10);</code>, here we explicitly casting <code>void*</code> to <code>int*</code>.</li><li><strong><code>l-value</code></strong>: an identifier which represents memory location. For example, variable name, <code>*ptr</code> where <code>ptr</code> points to a memory location, etc.</li><li><strong><code>r-value</code></strong>: a value which is not <code>l-value</code>, <code>r-value</code> appear on the right-hand side of the assignment(<code>=</code>) operator. Like</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>// 5 = r-value, 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>q</span> <span class=o>=</span> <span class=n>p</span> <span class=o>+</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>// p + 5 is r-value
</span></span></span></code></pre></div><p>Note: Although there are some exceptions & more to learn on <a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>lvalue, rvalue and their references in C++</a>.</p><h3 id=why-do-we-need-typecasting>Why Do We Need Typecasting?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-typecasting>#</a></h3><ul><li>Data is a representation of the bits(<code>0</code>s & <code>1</code>s) in memory.</li><li>Data-type is compiler directive which tells the compiler how to store & process particular data.</li><li><code>uint32_t a = 5;</code> by this statement you can presume that 4 bytes will be reserved in your memory & upon execution, it will store <code>0000 0000 0000 0000 0000 0000 0000 0101</code> data bits in that memory location. This was plain & simple.</li><li>Let&rsquo;s go a bit further, <code>float f = 3.0;</code> this statement will also reserve 4 bytes in memory & store data bits in the form of 1). the sign bit, 2). exponent & 3). mantissa. Recall <a href=/posts/how-floating-point-no-is-stored-memory/>how floating-point numbers are stored in memory</a>.</li><li>But when you write like <code>float f = 3;</code>, the compiler will be confused that how to store an integer value in float type of memory.</li><li>So it will <strong>automatically presume(Implicit conversion</strong> here) that you want to store <code>3.0</code> rather than <code>3</code> which is technically same from the human point of view but it&rsquo;s different when you think from <a href=/posts/memory-layout-of-cpp-object/>computer memory perspective</a> cause they stored differently.</li><li>There are many such scenarios where you provide data to store in memory which used to represent different data type.</li><li>For example, in the following example, you are trying to assign an object of type <code>B</code> into an object of type <code>A</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>B</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span> <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>In such scenario compiler can not presume anything & simply throws a compilation error:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>exit</span> <span class=n>status</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=n>no</span> <span class=n>viable</span> <span class=n>conversion</span> <span class=n>from</span> <span class=sc>&#39;B&#39;</span> <span class=n>to</span> <span class=sc>&#39;A&#39;</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span> <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>^</span>   <span class=o>~</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>candidate</span> <span class=n>constructor</span> <span class=p>(</span><span class=n>the</span> <span class=n>implicit</span> <span class=n>copy</span> <span class=n>constructor</span><span class=p>)</span> <span class=n>not</span> <span class=nl>viable</span><span class=p>:</span> <span class=n>no</span> <span class=n>known</span> <span class=n>conversion</span> <span class=n>from</span> <span class=sc>&#39;B&#39;</span> <span class=n>to</span> <span class=err>&#39;</span><span class=k>const</span> <span class=n>A</span> <span class=o>&amp;</span><span class=err>&#39;</span> <span class=k>for</span> <span class=mi>1</span><span class=n>st</span> <span class=n>argument</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>      <span class=o>^</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>candidate</span> <span class=n>constructor</span> <span class=p>(</span><span class=n>the</span> <span class=n>implicit</span> <span class=n>move</span> <span class=n>constructor</span><span class=p>)</span> <span class=n>not</span> <span class=nl>viable</span><span class=p>:</span> <span class=n>no</span> <span class=n>known</span> <span class=n>conversion</span> <span class=n>from</span> <span class=sc>&#39;B&#39;</span> <span class=n>to</span> <span class=err>&#39;</span><span class=n>A</span> <span class=o>&amp;&amp;</span><span class=err>&#39;</span> <span class=k>for</span> <span class=mi>1</span><span class=n>st</span> <span class=n>argument</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>      <span class=o>^</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=n>error</span> <span class=n>generated</span><span class=p>.</span>
</span></span></code></pre></div><ul><li>But when you define a conversion operator as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>operator</span> <span class=n>A</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;CONVERSION OPERATOR</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>A</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>The compiler will simply call this member function & won&rsquo;t throw any error because programmer explicitly mentioning that this is how he/she wants to convert.</li></ul><h3 id=c-type-casting-with-example-for-c-developers>C++ Type Casting With Example for C Developers<a hidden class=anchor aria-hidden=true href=#c-type-casting-with-example-for-c-developers>#</a></h3><h3 id=c-style-casts><code>C-style casts</code><a hidden class=anchor aria-hidden=true href=#c-style-casts>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>10</span> <span class=o>/</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>res</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>When you will try to run the above code, you will get <code>2</code> as output which we didn&rsquo;t expect. To initialize <code>res</code> variable correctly we need to typecast using float as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>float</span> <span class=n>res</span> <span class=o>=</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=mi>10</span> <span class=o>/</span> <span class=mi>4</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Now your answer will be <code>2.5</code>. This type of casting is very simple & straight forward as it appears.</li><li>You can also write above casting in C++ as:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>float</span> <span class=n>res</span> <span class=o>=</span> <span class=kt>float</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> <span class=o>/</span> <span class=mi>4</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>C-style casts can change a data type without changing the underlying memory representation which may lead to garbage results.</li></ul><h3 id=static_cast><code>static_cast</code><a hidden class=anchor aria-hidden=true href=#static_cast>#</a></h3><ul><li>If you are C developer like me, then this will be your <strong>best goto C++ cast</strong> which fits in most of the example like:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>malloc</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>When you try to compile above code using C compiler it works fine. But C++ compiler is not kind enough. It will throw an error as follows :</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>exit</span> <span class=n>status</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=n>cannot</span> <span class=n>initialize</span> <span class=n>a</span> <span class=n>variable</span> <span class=n>of</span> <span class=n>type</span> <span class=err>&#39;</span><span class=kt>int</span> <span class=o>*</span><span class=err>&#39;</span> <span class=n>with</span> <span class=n>an</span> <span class=n>rvalue</span> <span class=n>of</span> <span class=n>type</span> <span class=err>&#39;</span><span class=kt>void</span> <span class=o>*</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>malloc</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>^</span>   <span class=o>~~~~~~~~~~</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=n>error</span> <span class=n>generated</span><span class=p>.</span>
</span></span></code></pre></div><ul><li>The first thing that comes to your mind is the C-style cast:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span><span class=n>std</span><span class=o>::</span><span class=n>malloc</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>This will work, but <strong>C-style cast is not recommended in C++.</strong> <code>static_cast</code> handles implicit conversions like this. We will primarily use it for converting in places where implicit conversions fail, such as std::malloc.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>malloc</span><span class=p>(</span><span class=mi>10</span><span class=p>));</span>
</span></span></code></pre></div><ul><li>The main advantage of <code>static_cast</code> is that it provides compile-time type checking, making it harder to make an inadvertent error. Let&rsquo;s understand this with C++ example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D</span> <span class=o>:</span> <span class=k>public</span> <span class=n>B</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>X</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>D</span><span class=o>*</span> <span class=n>d</span> <span class=o>=</span> <span class=k>new</span> <span class=n>D</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>B</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>B</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>d</span><span class=p>);</span> <span class=c1>// this works
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>X</span><span class=o>*</span> <span class=n>x</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>X</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>d</span><span class=p>);</span> <span class=c1>// ERROR - Won&#39;t compile
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>As you can see, there is no easy way to distinguish between the two situations without knowing a lot about all the classes involved.</li><li>Another problem with the C-style casts is that it is too hard to locate. In complex expressions, it can be very hard to see C-style casts e.g. <code>T(something) syntax is equivalent to </code>(T)something`.</li></ul><h3 id=const_cast><code>const_cast</code><a hidden class=anchor aria-hidden=true href=#const_cast>#</a></h3><ul><li>Now we will directly jump to example. No theory can explain this better than example.</li></ul><p><strong>1. Ignore constness</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>ref</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span><span class=o>*</span> <span class=n>ptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// Not OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>ref</span><span class=p>)</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>  <span class=c1>//OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>//OK
</span></span></span></code></pre></div><ul><li>You are allowed to modify <code>i</code>, because of the object(<code>i</code> here) being assigned to, is not <code>const</code>. If you add const qualifier to <code>i</code>, code will compile, but its behaviour will be undefined (which can mean anything from &ldquo;it works just fine&rdquo; to &ldquo;the program will crash&rdquo;.)</li></ul><p><strong>2. Modifying data member using <code>const</code> <code>this</code> pointer</strong></p><ul><li><code>const_cast</code> can be used to change non-const class members by a method in which this pointer declared as const. - This can also be useful when overloading member functions based on <code>const</code>, for instance:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>X</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>changeAndPrint</span><span class=p>(</span><span class=kt>int</span> <span class=n>temp</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>var</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>                    <span class=c1>// Throw compilation error
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>(</span><span class=k>const_cast</span><span class=o>&lt;</span><span class=n>X</span> <span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>))</span><span class=o>-&gt;</span><span class=n>var</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span> <span class=c1>// Works fine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>changeAndPrint</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>temp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Do some stuff
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>changeAndPrint</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>changeAndPrint</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span><span class=p>.</span><span class=n>var</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>3. Pass <code>const</code> argument to a function which accepts only non-const argument</strong></p><ul><li><code>const_cast</code> can also be used to pass const data to a function that doesn’t receive const argument. See the following code:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fun</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span> <span class=n>ptr</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=n>ptr</span> <span class=o>+</span> <span class=mi>10</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>fun</span><span class=p>(</span><span class=k>const_cast</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>val</span><span class=p>));</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></div><p><strong>4. Castaway <code>volatile</code> attribute</strong></p><ul><li><code>const_cast</code> can also be used to cast away <code>volatile</code> attribute. Whatever we discussed above in <code>const_cast</code> is also valid for <code>volatile</code> keyword.</li></ul><h3 id=dynamic_cast><code>dynamic_cast</code><a hidden class=anchor aria-hidden=true href=#dynamic_cast>#</a></h3><ul><li><code>**dynamic_cast**</code> <strong>uses the type checking at runtime</strong> in contrary to <code>static_cast</code> which does it at compile time. <code>dynamic_cast</code> is more useful when you don&rsquo;t know the type of input which it represents. Let assume:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Base</span><span class=o>*</span> <span class=nf>CreateRandom</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span> <span class=p>(</span><span class=n>rand</span><span class=p>()</span><span class=o>%</span><span class=mi>2</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>Derived1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>Derived2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=n>CreateRandom</span><span class=p>();</span>
</span></span></code></pre></div><ul><li>As you can see, we don&rsquo;t know which object will be returned by <code>CreateRandom() at run time but you want to execute </code>Method1()<code>of </code>Derived1<code>if it returns</code>Derived1<code>. So in this scenario, you can use </code>dynamic_cast` as follows</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Derived1</span> <span class=o>*</span><span class=n>pD1</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>Derived1</span> <span class=o>*&gt;</span><span class=p>(</span><span class=n>base</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>pD1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>pD1</span><span class=o>-&gt;</span><span class=n>Method1</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>In case, if the input of <code>dynamic_cast</code> does not point to valid data, it will return <code>nullptr</code> for pointers or throw a <code>std::bad_cast</code> exception for references. In order to work with <code>dynamic_cast</code>, your classes must be polymorphic type i.e. must include at least one virtual methods.</li><li><code>**dynamic_cast**</code> <strong>take advantage of</strong> <code>**RTTI**</code>(<a href=https://en.wikipedia.org/wiki/Run-time_type_information>Run Time Type Identification</a>) mechanism.</li></ul><h3 id=reinterpret_cast><code>reinterpret_cast</code><a hidden class=anchor aria-hidden=true href=#reinterpret_cast>#</a></h3><ul><li><code>reinterpret_cast</code> <strong>converts between types</strong> by reinterpreting the underlying bit pattern.</li><li>You can use <code>reinterpret_cast</code> to cast any pointer or integral type to any other pointer or integral type.</li><li>This can lead to dangerous situations: nothing will stop you from converting an <code>int</code> to an <code>std::string*</code>.</li><li>You will <strong>use</strong> <code>reinterpret_cast</code> <strong>in your embedded systems</strong>. A common scenario where <code>reinterpret_cast</code> applies is converting between <code>uintptr_t</code> and an actual pointer or between:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=k>static_cast</span> <span class=n>from</span> <span class=err>&#39;</span><span class=kt>int</span> <span class=o>*</span><span class=err>&#39;</span> <span class=n>to</span> <span class=err>&#39;</span><span class=n>uintptr_t</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>aka</span> <span class=err>&#39;</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=err>&#39;</span><span class=p>)</span> <span class=n>is</span> <span class=n>not</span> <span class=n>allowed</span>
</span></span><span class=line><span class=cl>        <span class=n>uintptr_t</span> <span class=n>ptr</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>uintptr_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=o>^~~~~~~~~~~~~~~~~~~~~~~~~</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=n>error</span> <span class=n>generated</span><span class=p>.</span>
</span></span></code></pre></div><ul><li>Instead, use this:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>uintptr_t</span> <span class=n>ptr</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uintptr_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span></code></pre></div><p>I have tried to cover most of the intricacies to clear the main concept behind different typecasting, but still, there might be a chance that I may miss some. So, this is it for C++ type casting with example for C developers. Let&rsquo;s quickly recap:</p><h3 id=cheat-code-for-c-developers-moving-to-c-on-type-casting>Cheat Code for C Developers Moving to C++ on Type Casting<a hidden class=anchor aria-hidden=true href=#cheat-code-for-c-developers-moving-to-c-on-type-casting>#</a></h3><p>After reading all this you may confuse on what to use & when! That&rsquo;s why I have created this cheat code</p><ul><li><strong>Avoid C-style casts</strong>. Be sure about what you want while casting.</li><li>Use <code>static_cast</code> <strong>wherever you were using C-style cast</strong>.</li><li>Use <code>dynamic_cast</code> <strong>with polymorphic classes</strong>. Keep in mind that only use <code>dynamic_cast</code> on classes with at least one virtual member in the inheritance hierarchy.</li><li>Use <code>const_cast</code> when you need to remove <code>const</code> or <code>volatile</code> qualifiers.</li><li>Use <code>reinterpret_cast</code> when you have no options.</li></ul><p>Note: <code>const_cast</code> <strong>and</strong> <code>reinterpret_cast</code> <strong>should generally be avoided</strong> because they can be harmful if used incorrectly. Don&rsquo;t use it unless you have a very good reason to use them.</p><h3 id=some-of-the-c-core-guidelines-on-typecasting>Some of the C++ Core Guidelines on Typecasting<a hidden class=anchor aria-hidden=true href=#some-of-the-c-core-guidelines-on-typecasting>#</a></h3><ul><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#p4-ideally-a-program-should-be-statically-type-safe>P.4: Ideally, a program should be statically (compile-time) type safe</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts>ES.48: Avoid casts</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-named>ES.49: If you must use a cast, use a named cast</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-const>ES.50: Don’t cast away</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-const><code>const</code></a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dynamic_cast>C.146: Use</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dynamic_cast><code>dynamic_cast</code></a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dynamic_cast>where class hierarchy navigation is unavoidable</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ref-cast>C.147: Use</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ref-cast><code>dynamic_cast</code></a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ref-cast>to a reference type when failure to find the required class is considered an error</a></li><li><a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ptr-cast>C.148: Use</a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ptr-cast><code>dynamic_cast</code></a> <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ptr-cast>to a pointer type when failure to find the required class is considered a valid alternative</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/c-style-casts/>C-Style-Casts</a></li><li><a href=https://vishalchovatiya.github.io/tags/const_cast/>Const_cast</a></li><li><a href=https://vishalchovatiya.github.io/tags/dynamic_cast/>Dynamic_cast</a></li><li><a href=https://vishalchovatiya.github.io/tags/implicit-conversion-c/>Implicit-Conversion-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/reinterpret_cast/>Reinterpret_cast</a></li><li><a href=https://vishalchovatiya.github.io/tags/static_cast/>Static_cast</a></li><li><a href=https://vishalchovatiya.github.io/tags/why-do-we-need-typecasting/>Why-Do-We-Need-Typecasting</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/unique_ptr-with-example-in-c/><span class=title>« Prev</span><br><span>Understanding unique_ptr with Example in C++11</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/complications-of-using-the-virtual-base-class/><span class=title>Next »</span><br><span>Complications of Using the Virtual Base Class</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Type Casting With Example for C Developers on x" href="https://x.com/intent/tweet/?text=C%2b%2b%20Type%20Casting%20With%20Example%20for%20C%20Developers&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcpp-type-casting-with-example-for-c-developers%2f&amp;hashtags=c-style-casts%2cconst_cast%2cdynamic_cast%2cimplicit-conversion-c%2creinterpret_cast%2cstatic_cast%2cwhy-do-we-need-typecasting"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Type Casting With Example for C Developers on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcpp-type-casting-with-example-for-c-developers%2f&amp;title=C%2b%2b%20Type%20Casting%20With%20Example%20for%20C%20Developers&amp;summary=C%2b%2b%20Type%20Casting%20With%20Example%20for%20C%20Developers&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcpp-type-casting-with-example-for-c-developers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Type Casting With Example for C Developers on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcpp-type-casting-with-example-for-c-developers%2f&title=C%2b%2b%20Type%20Casting%20With%20Example%20for%20C%20Developers"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Type Casting With Example for C Developers on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcpp-type-casting-with-example-for-c-developers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Type Casting With Example for C Developers on whatsapp" href="https://api.whatsapp.com/send?text=C%2b%2b%20Type%20Casting%20With%20Example%20for%20C%20Developers%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcpp-type-casting-with-example-for-c-developers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Type Casting With Example for C Developers on telegram" href="https://telegram.me/share/url?text=C%2b%2b%20Type%20Casting%20With%20Example%20for%20C%20Developers&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcpp-type-casting-with-example-for-c-developers%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Type Casting With Example for C Developers on ycombinator" href="https://news.ycombinator.com/submitlink?t=C%2b%2b%20Type%20Casting%20With%20Example%20for%20C%20Developers&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fcpp-type-casting-with-example-for-c-developers%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>