<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2 Wrong Way to Learn Copy Assignment Operator in C++ With Example | Vishal Chovatiya</title>
<meta name=keywords content="copy-assignment-operator-c-example,copy-assignment-operator-return-by-value,copy-operator-chain-assignment-c,return-by-pointer"><meta name=description content="While I was introducing myself to C++, I was confused about the syntax of the copy assignment operator in C++ & some of its use-cases. I have learned those lessons the hard way. And so I have decided to write this article, where we see 2 wrong way to learn copy assignment operator in C++ with example. And we also see why we need it & why its syntax like that only."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="2 Wrong Way to Learn Copy Assignment Operator in C++ With Example"><meta property="og:description" content="While I was introducing myself to C++, I was confused about the syntax of the copy assignment operator in C++ & some of its use-cases. I have learned those lessons the hard way. And so I have decided to write this article, where we see 2 wrong way to learn copy assignment operator in C++ with example. And we also see why we need it & why its syntax like that only."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/"><meta property="og:image" content="https://vishalchovatiya.github.io/images/2-wrong-way-to-learn-copy-assignment-operator-in-c.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-11T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-11T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/images/2-wrong-way-to-learn-copy-assignment-operator-in-c.png"><meta name=twitter:title content="2 Wrong Way to Learn Copy Assignment Operator in C++ With Example"><meta name=twitter:description content="While I was introducing myself to C++, I was confused about the syntax of the copy assignment operator in C++ & some of its use-cases. I have learned those lessons the hard way. And so I have decided to write this article, where we see 2 wrong way to learn copy assignment operator in C++ with example. And we also see why we need it & why its syntax like that only."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"2 Wrong Way to Learn Copy Assignment Operator in C++ With Example","item":"https://vishalchovatiya.github.io/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2 Wrong Way to Learn Copy Assignment Operator in C++ With Example","name":"2 Wrong Way to Learn Copy Assignment Operator in C\u002b\u002b With Example","description":"While I was introducing myself to C++, I was confused about the syntax of the copy assignment operator in C++ \u0026amp; some of its use-cases. I have learned those lessons the hard way. And so I have decided to write this article, where we see 2 wrong way to learn copy assignment operator in C++ with example. And we also see why we need it \u0026amp; why its syntax like that only.","keywords":["copy-assignment-operator-c-example","copy-assignment-operator-return-by-value","copy-operator-chain-assignment-c","return-by-pointer"],"articleBody":"While I was introducing myself to C++, I was confused about the syntax of the copy assignment operator in C++ \u0026 some of its use-cases. I have learned those lessons the hard way. And so I have decided to write this article, where we see 2 wrong way to learn copy assignment operator in C++ with example. And we also see why we need it \u0026 why its syntax like that only. Although I am not an expert or pro but this what I have learned so far from various sources.\nWhy Do We Need Copy Assignment Operator in C++? The simple answer is just to assign data. As we do an assignment in primitive data types like int a; a = 5. Sometimes we also need to do this in our user-defined data type i.e. class/struct. The answer would be the same as copy constructor which I have given here. A class could be a complex entity so that we need a special function which does this task. Although compiler provides a default one. But in some cases, you have to define your own copy assignment operation such as: Write your own assignment operator that does the deep copy if you are using dynamic memory. Do not allow the assignment of one object to another object or sub-object(object slicing). We can create our own dummy assignment operator and make it private or simply delete it. Why Do We Need to Return Something From the Copy Assignment Operator? While I was learning about the copy assignment operator, I always had a doubt that why do we need to return value from the copy assignment operator function. Let’s consider following example: Copy Assignment Operator in C++ With Example class X { public: int var; X(int x) { this-\u003evar = x; } X \u0026operator=(const X \u0026rhs) { this-\u003evar = rhs.var; return *this; } }; X x1(1), x2(2); x2 = x1; // Compiler augments into X::x2.operator=(x1); Actually, we don’t need to, if you look at the above code we are already assigning to a current object i.e. x2 using this pointer who called copy assignment operator function. I can understand the need for const in the argument of the copy assignment operator function. But the return value was not justifiable to me until I saw the following code: X x1(1), x2(2), x3(3); x3 = x2 = x1; If you make return type of copy assignment operator function as void, the compiler won’t throw error till you are using x2 = x1;. But when assignment chain will be created like x3 = x2 = x1; you have to return something so that it can be an argument on further call to copy assignment operator. So we have to return something from the copy assignment operator to support assignment chaining feature. But what should be the appropriate return type? This will lead us to our next point. What Should Be the Appropriate Return Type? I know, you will say we have to return a reference to the current object. Yeh! that’s correct also but why not return by value or pointer? Ok, then, let’s see 2 wrong way to learn copy assignment operator in C++\nNo. 1: Let’s try return by value class X { public: int var; X(int x) { this-\u003evar = x; } X operator=(X \u0026rhs) { this-\u003evar = rhs.var; return *this; } }; int main() { X x1(1), x2(2), x3(3); x2 = x1; // Statement 1: Works fine (x3 = x2) = x1; // Statement 2: Correct, but meaning less statement x3 = (x2 = x1); // Statement 3: Meaningful but compiler won't alllow us x3 = x2 = x1; // Statement 4: Meaningful but compiler won't alllow us cout \u003c\u003c x1.var \u003c\u003c endl; cout \u003c\u003c x2.var \u003c\u003c endl; cout \u003c\u003c x3.var \u003c\u003c endl; return 0; } Note that I have not taken an argument as const in copy assignment operator.\nWhen you will compile the above code, GCC will throw an error as follows: error: no viable overloaded '=' x3 = (x2 = x1); // Statement 3: Meaningful but compiler won't alllow us ~~ ^ ~~~~~~~~~ note: candidate function not viable: expects an l-value for 1st argument X operator = (X \u0026rhs){ ^ Let’s understand all these statements one-by-one x2 = x1; // Statement 1: Works fine Above statement is correct \u0026 works fine as we are not utilising return value provided by the copy assignment operator. (x3 = x2) = x1; // Statement 2: Correct, but meaningless statement This statements is perfectly fine \u0026 have no problem in a compilation. But Statement 2 is meaningless as we are first assigning x2 into x3 which returns a temporary(AKA anonymous) object which again calls a copy assignment operator with x1 as an argument. This works fine but at the end call of the copy assignment operator, we are assigning the value of x1 to a temporary object which is meaningless. Probable transformation of Statement 2 by the compiler would be (X::x3.operator=(x2)).operator=(x1); With more simplicity X temp = X::x3.operator=(x2); X::temp.operator=(x1); As you can see I have taken temp object which usually created by the compiler as we are returning an object by value. So this way output would be 1 2 2 which is not correct. Now we will observe Statement 3 x3 = (x2 = x1); // Statement 3: Meaningful but compiler won't allow us Probable transformation of Statement 3 by the compiler would be (X::x3.operator=((x2 = x1)); Code till operation x2 = x1 is fine we have seen it earlier but when the result of that operation becomes an argument to another copy assignment operator function, it will again create the problem of temporary object binding to a non-const reference. If you don’t know about “temporary object binding to non-const reference” then you should find out the reason behind why the following program is not working, you will understand everything you wanted to know for Statement 3. int main() { const string \u0026val1 = string(\"123\"); // Works fine string \u0026val2 = string(\"123\"); // Will throw error return 0; } Error: clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final) exit status 1 error: non-const lvalue reference to type 'basic_string\u003c...\u003e' cannot bind to a temporary of type 'basic_string\u003c...\u003e' string\u0026 val2 = string(\"123\"); ^ ~~~~~~~~~~~~~ 1 error generated. Note that the above code will work in some of the old compilers like VC2012, etc. Now we will move to Statement 4 x3 = x2 = x1; // Statement 4: Meaningful but compiler won't allow us This will also throw the same error as Statement 3 because conceptually both are same. Although Statement 3 \u0026 Statement 4 can also be valid if you modify argument of copy assignment operator from pass by reference to pass by value which we know adds the unnecessary overhead of calling copy constructor which also stands true for the return type. No. 2: Let’s try return by pointer class X { public: int var; X(int x) { this-\u003evar = x; } X *operator=(X \u0026rhs) { this-\u003evar = rhs.var; return this; } }; int main() { X x1(1), x2(2), x3(3); x2 = x1; // Statement 1: Works fine x3 = x2 = x1; // Statement 4: Meaningful but compiler won't alllow us cout \u003c\u003c x1.var \u003c\u003c endl; cout \u003c\u003c x2.var \u003c\u003c endl; cout \u003c\u003c x3.var \u003c\u003c endl; return 0; } This time we will not observe all four statements rather will go for 2 basic statement which is also valid for primitive data types. Statement 1 is not correct but still works fine. While Statement 4 throws an error clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final) exit status 1 error: no viable overloaded '=' x3 = x2 = x1; // Statement 4: Meaningful but compiler wont alllow us ~~ ^ ~~~~~~~ note: candidate function not viable: no known conversion from 'X *' to 'X \u0026' for 1st argument; dereference the argument with * X* operator = (X \u0026rhs){ ^ 1 error generated. Probable transformation of Statement 4 by the compiler would be (X::x3.operator=( ( x2 = x1 ) ); This will not work simply because of the result of an operation `( x2 = x1 ) is pointer \u0026 copy assignment operator function wants a reference as an argument. Now you will say that why we just not change argument with pointer rather than accepting it as a reference. Nice idea! I would say X *operator=(X *rhs) { cout \u003c\u003c \"THIS\\n\"; this-\u003evar = rhs-\u003evar; return this; } Now to call above copy assignment operator you need to use the following operation x2 = \u0026x1; Because we are expecting pointer as an argument in copy assignment operator. x1 = x2 or x3 = x2 = x1 won’t work anymore. If you are still getting the correct answer as 1 1 1 in your output window then just consider print from cout. You are getting the correct answer 1 1 1 because default copy constructor provided by the compiler is getting called every time. Technically, we have just overloaded copy constructor by changing its return type \u0026 argument as a pointer. Conclusion Above are the reason why it is not feasible to use pass by value or pointer an argument or return type of copy assignment operator. Compiler designer have designed standard in such a way that your class object operation should also work same as primitive type operations like // Primitive type \u0026 operations int a = 5, b, c; a = b = c; // User defined type \u0026 operations X x1(5), x2, x3; x3 = x2 = x1; assignment operator in C++ with example\n","wordCount":"1587","inLanguage":"en","image":"https://vishalchovatiya.github.io/images/2-wrong-way-to-learn-copy-assignment-operator-in-c.png","datePublished":"2019-09-11T00:00:00Z","dateModified":"2019-09-11T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">2 Wrong Way to Learn Copy Assignment Operator in C++ With Example</h1><div class=post-meta><span title='2019-09-11 00:00:00 +0000 UTC'>September 11, 2019</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1587 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://vishalchovatiya.github.io/images/2-wrong-way-to-learn-copy-assignment-operator-in-c.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#why-do-we-need-copy-assignment-operator-in-c>Why Do We Need Copy Assignment Operator in C++?</a></li><li><a href=#why-do-we-need-to-return-something-from-the-copy-assignment-operator>Why Do We Need to Return Something From the Copy Assignment Operator?</a><ul><li><a href=#copy-assignment-operator-in-c-with-example>Copy Assignment Operator in C++ With Example</a></li></ul></li><li><a href=#what-should-be-the-appropriate-return-type>What Should Be the Appropriate Return Type?</a><ul><li><a href=#no-1-lets-try-return-by-value>No. 1: <strong>Let&rsquo;s try <code>return by value</code></strong></a></li><li><a href=#no-2-lets-try-return-by-pointer>No. 2: <strong>Let&rsquo;s try <code>return by pointer</code></strong></a></li></ul></li><li><a href=#conclusion><strong>Conclusion</strong></a></li></ul></nav></div></details></div><div class=post-content><p>While I was introducing myself to C++, I was confused about the syntax of the copy assignment operator in C++ & some of its use-cases. I have learned those lessons the hard way. And so I have decided to write this article, where we see 2 wrong way to learn copy assignment operator in C++ with example. And we also see why we need it & why its syntax like that only. Although I am not an expert or pro but this what I have learned so far from various sources.</p><h2 id=why-do-we-need-copy-assignment-operator-in-c>Why Do We Need Copy Assignment Operator in C++?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-copy-assignment-operator-in-c>#</a></h2><ul><li>The simple answer is just to assign data. As we do an assignment in primitive data types like <code>int a; a = 5</code>. Sometimes we also need to do this in our user-defined data type i.e. class/struct. The answer would be the same as copy constructor which I have given <a href=/posts/all-about-copy-constructor-in-cpp/>here</a>.</li><li>A class could be a complex entity so that we need a special function which does this task. Although compiler provides a default one. But in some cases, you have to define your own copy assignment operation such as:<ol><li>Write your own assignment operator that does the deep copy if you are using dynamic memory.</li><li>Do not allow the assignment of one <a href=/posts/inside-the-c-object-model/>object</a> to another object or <a href=/posts/memory-layout-of-cpp-object/>sub-object</a>(object slicing). We can create our own dummy assignment operator and make it <code>private</code> or simply <code>delete</code> it.</li></ol></li></ul><h2 id=why-do-we-need-to-return-something-from-the-copy-assignment-operator>Why Do We Need to Return Something From the Copy Assignment Operator?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-to-return-something-from-the-copy-assignment-operator>#</a></h2><ul><li>While I was learning about the copy assignment operator, I always had a doubt that why do we need to return value from the copy assignment operator function. Let&rsquo;s consider following example:</li></ul><h3 id=copy-assignment-operator-in-c-with-example>Copy Assignment Operator in C++ With Example<a hidden class=anchor aria-hidden=true href=#copy-assignment-operator-in-c-with-example>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>X</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>X</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>var</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>X</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>var</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>X</span> <span class=nf>x1</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>x2</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span> <span class=c1>// Compiler augments into X::x2.operator=(x1);
</span></span></span></code></pre></div><ul><li>Actually, we don&rsquo;t need to, if you look at the above code we are already assigning to a current object i.e. <code>x2</code> using <code>this</code> pointer who called copy assignment operator function.</li><li>I can understand the need for <a href=/posts/when-to-use-const-vs-constexpr-in-cpp/><code>const</code></a> in the argument of the copy assignment operator function. But the return value was not justifiable to me until I saw the following code:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>X</span> <span class=nf>x1</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>x2</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=n>x3</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>x3</span> <span class=o>=</span> <span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>If you make return type of copy assignment operator function as <code>void</code>, the compiler won&rsquo;t throw error till you are using <code>x2 = x1;</code>.</li><li>But when assignment chain will be created like <code>x3 = x2 = x1;</code> you have to return something so that it can be an argument on further call to copy assignment operator.</li><li>So we have to return something from the copy assignment operator to support assignment chaining feature. But what should be the appropriate return type? This will lead us to our next point.</li></ul><h2 id=what-should-be-the-appropriate-return-type>What Should Be the Appropriate Return Type?<a hidden class=anchor aria-hidden=true href=#what-should-be-the-appropriate-return-type>#</a></h2><p>I know, you will say we have to return a reference to the current object. Yeh! that&rsquo;s correct also but why not <code>return by value</code> or <code>pointer</code>? Ok, then, let&rsquo;s see 2 wrong way to learn copy assignment operator in C++</p><h3 id=no-1-lets-try-return-by-value>No. 1: <strong>Let&rsquo;s try <code>return by value</code></strong><a hidden class=anchor aria-hidden=true href=#no-1-lets-try-return-by-value>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>X</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>X</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>var</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>X</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>var</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=n>x1</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>x2</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=n>x3</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span>        <span class=c1>// Statement 1: Works fine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>(</span><span class=n>x3</span> <span class=o>=</span> <span class=n>x2</span><span class=p>)</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span> <span class=c1>// Statement 2: Correct, but meaning less statement
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x3</span> <span class=o>=</span> <span class=p>(</span><span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>);</span> <span class=c1>// Statement 3: Meaningful but compiler won&#39;t alllow us
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x3</span> <span class=o>=</span> <span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span>   <span class=c1>// Statement 4: Meaningful but compiler won&#39;t alllow us
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x1</span><span class=p>.</span><span class=n>var</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x2</span><span class=p>.</span><span class=n>var</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x3</span><span class=p>.</span><span class=n>var</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note that I have not taken an argument as <a href=/posts/when-to-use-const-vs-constexpr-in-cpp/>const</a> in copy assignment operator.</p><ul><li>When you will compile the above code, GCC will throw an error as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=n>no</span> <span class=n>viable</span> <span class=n>overloaded</span> <span class=sc>&#39;=&#39;</span>
</span></span><span class=line><span class=cl>  <span class=n>x3</span> <span class=o>=</span> <span class=p>(</span><span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>);</span>   <span class=c1>// Statement 3: Meaningful but compiler won&#39;t alllow us
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>~~</span> <span class=o>^</span> <span class=o>~~~~~~~~~</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>candidate</span> <span class=n>function</span> <span class=n>not</span> <span class=nl>viable</span><span class=p>:</span> <span class=n>expects</span> <span class=n>an</span> <span class=n>l</span><span class=o>-</span><span class=n>value</span> <span class=k>for</span> <span class=mi>1</span><span class=n>st</span> <span class=n>argument</span>
</span></span><span class=line><span class=cl>  <span class=n>X</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>X</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=o>^</span>
</span></span></code></pre></div><ul><li>Let&rsquo;s understand all these statements one-by-one</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span>          <span class=c1>// Statement 1: Works fine
</span></span></span></code></pre></div><ul><li>Above statement is correct & works fine as we are not utilising return value provided by the copy assignment operator.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=n>x3</span> <span class=o>=</span> <span class=n>x2</span><span class=p>)</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span>   <span class=c1>// Statement 2: Correct, but meaningless statement
</span></span></span></code></pre></div><ul><li>This statements is perfectly fine & have no problem in a compilation. But <code>Statement 2</code> is meaningless as we are first assigning <code>x2</code> into <code>x3</code> which returns a temporary(AKA anonymous) object which again calls a copy assignment operator with <code>x1</code> as an argument. This works fine but at the end call of the copy assignment operator, we are assigning the value of <code>x1</code> to a temporary object which is meaningless.</li><li>Probable transformation of <code>Statement 2</code> by the compiler would be</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=n>X</span><span class=o>::</span><span class=n>x3</span><span class=p>.</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>x2</span><span class=p>)).</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>x1</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>With more simplicity</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>X</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>X</span><span class=o>::</span><span class=n>x3</span><span class=p>.</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>x2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>X</span><span class=o>::</span><span class=n>temp</span><span class=p>.</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>x1</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>As you can see I have taken <code>temp</code> object which usually created by the compiler as we are returning an object by value. So this way output would be <code>1 2 2</code> which is not correct.</li><li>Now we will observe <code>Statement 3</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x3</span> <span class=o>=</span> <span class=p>(</span><span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>);</span>   <span class=c1>// Statement 3: Meaningful but compiler won&#39;t allow us
</span></span></span></code></pre></div><ul><li>Probable transformation of <code>Statement 3</code> by the compiler would be</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=n>X</span><span class=o>::</span><span class=n>x3</span><span class=p>.</span><span class=k>operator</span><span class=o>=</span><span class=p>((</span><span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>));</span>
</span></span></code></pre></div><ul><li>Code till operation <code>x2 = x1</code> is fine we have seen it earlier but when the result of that operation becomes an argument to another copy assignment operator function, it will again create the problem of temporary object binding to a non-const reference.</li><li>If you don&rsquo;t know about &ldquo;<a href=/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/>temporary object binding to non-const reference</a>&rdquo; then you should find out the reason behind why the following program is not working, you will understand everything you wanted to know for <code>Statement 3</code>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>val1</span> <span class=o>=</span> <span class=n>string</span><span class=p>(</span><span class=s>&#34;123&#34;</span><span class=p>);</span> <span class=c1>// Works fine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>string</span> <span class=o>&amp;</span><span class=n>val2</span> <span class=o>=</span> <span class=n>string</span><span class=p>(</span><span class=s>&#34;123&#34;</span><span class=p>);</span>       <span class=c1>// Will throw error
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Error:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>clang</span> <span class=n>version</span> <span class=mf>6.0.0</span><span class=o>-</span><span class=mi>1u</span><span class=n>buntu2</span> <span class=p>(</span><span class=n>tags</span><span class=o>/</span><span class=n>RELEASE_600</span><span class=o>/</span><span class=k>final</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>exit</span> <span class=n>status</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=n>non</span><span class=o>-</span><span class=k>const</span> <span class=n>lvalue</span> <span class=n>reference</span> <span class=n>to</span> <span class=n>type</span> <span class=err>&#39;</span><span class=n>basic_string</span><span class=o>&lt;</span><span class=p>...</span><span class=o>&gt;</span><span class=err>&#39;</span> <span class=n>cannot</span> <span class=n>bind</span> <span class=n>to</span> <span class=n>a</span> <span class=n>temporary</span> <span class=n>of</span> <span class=n>type</span> <span class=err>&#39;</span><span class=n>basic_string</span><span class=o>&lt;</span><span class=p>...</span><span class=o>&gt;</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span><span class=o>&amp;</span> <span class=n>val2</span> <span class=o>=</span> <span class=n>string</span><span class=p>(</span><span class=s>&#34;123&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=o>^</span>      <span class=o>~~~~~~~~~~~~~</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=n>error</span> <span class=n>generated</span><span class=p>.</span>
</span></span></code></pre></div><ul><li>Note that the above code will work in some of the old compilers like VC2012, etc. Now we will move to <code>Statement 4</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x3</span> <span class=o>=</span> <span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span>     <span class=c1>// Statement 4: Meaningful but compiler won&#39;t allow us
</span></span></span></code></pre></div><ul><li>This will also throw the same error as <code>Statement 3</code> because conceptually both are same. Although <code>Statement 3</code> & <code>Statement 4</code> can also be valid if you modify argument of copy assignment operator from <code>pass by reference</code> to <code>pass by value</code> which we know adds the unnecessary overhead of calling copy constructor which also stands true for the return type.</li></ul><h3 id=no-2-lets-try-return-by-pointer>No. 2: <strong>Let&rsquo;s try <code>return by pointer</code></strong><a hidden class=anchor aria-hidden=true href=#no-2-lets-try-return-by-pointer>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>X</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>X</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>var</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=o>*</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>X</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>var</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=n>x1</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>x2</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=n>x3</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span>      <span class=c1>// Statement 1: Works fine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x3</span> <span class=o>=</span> <span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span> <span class=c1>// Statement 4: Meaningful but compiler won&#39;t alllow us
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x1</span><span class=p>.</span><span class=n>var</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x2</span><span class=p>.</span><span class=n>var</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x3</span><span class=p>.</span><span class=n>var</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>This time we will not observe all four statements rather will go for 2 basic statement which is also valid for primitive data types.</li><li><code>Statement 1</code> is not correct but still works fine. While <code>Statement 4</code> throws an error</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>clang</span> <span class=n>version</span> <span class=mf>6.0.0</span><span class=o>-</span><span class=mi>1u</span><span class=n>buntu2</span> <span class=p>(</span><span class=n>tags</span><span class=o>/</span><span class=n>RELEASE_600</span><span class=o>/</span><span class=k>final</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>exit</span> <span class=n>status</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=n>no</span> <span class=n>viable</span> <span class=n>overloaded</span> <span class=sc>&#39;=&#39;</span>
</span></span><span class=line><span class=cl>  <span class=n>x3</span> <span class=o>=</span> <span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span>     <span class=c1>// Statement 4: Meaningful but compiler wont alllow us
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>~~</span> <span class=o>^</span> <span class=o>~~~~~~~</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>candidate</span> <span class=n>function</span> <span class=n>not</span> <span class=nl>viable</span><span class=p>:</span> <span class=n>no</span> <span class=n>known</span> <span class=n>conversion</span> <span class=n>from</span> <span class=err>&#39;</span><span class=n>X</span> <span class=o>*</span><span class=err>&#39;</span> <span class=n>to</span> <span class=err>&#39;</span><span class=n>X</span> <span class=o>&amp;</span><span class=err>&#39;</span> <span class=k>for</span> <span class=mi>1</span><span class=n>st</span> <span class=n>argument</span><span class=p>;</span> <span class=n>dereference</span> <span class=n>the</span> <span class=n>argument</span> <span class=n>with</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>  <span class=n>X</span><span class=o>*</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>X</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>){</span>
</span></span><span class=line><span class=cl>     <span class=o>^</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=n>error</span> <span class=n>generated</span><span class=p>.</span>
</span></span></code></pre></div><ul><li>Probable transformation of <code>Statement 4</code> by the compiler would be</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=n>X</span><span class=o>::</span><span class=n>x3</span><span class=p>.</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span> <span class=p>(</span> <span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span> <span class=p>)</span> <span class=p>);</span>
</span></span></code></pre></div><ul><li>This will not work simply because of the result of an operation `( x2 = x1 ) is pointer & copy assignment operator function wants a reference as an argument.</li><li>Now you will say that why we just not change argument with pointer rather than accepting it as a reference. Nice idea! I would say</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>X</span> <span class=o>*</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>X</span> <span class=o>*</span><span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;THIS</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>-&gt;</span><span class=n>var</span> <span class=o>=</span> <span class=n>rhs</span><span class=o>-&gt;</span><span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Now to call above copy assignment operator you need to use the following operation</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x2</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x1</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Because we are expecting pointer as an argument in copy assignment operator. <code>x1 = x2</code> or <code>x3 = x2 = x1</code> won&rsquo;t work anymore.</li><li>If you are still getting the correct answer as <code>1 1 1</code> in your output window then just consider print from <code>cout</code>. You are getting the correct answer <code>1 1 1</code> because default copy constructor provided by the compiler is getting called every time. Technically, we have just overloaded copy constructor by changing its return type & argument as a pointer.</li></ul><h2 id=conclusion><strong>Conclusion</strong><a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><ul><li>Above are the reason why it is not feasible to use <code>pass by value</code> or <code>pointer</code> an argument or <a href=https://stackoverflow.com/questions/3105798/why-must-the-copy-assignment-operator-return-a-reference-const-reference>return type of copy assignment operator</a>.</li><li><strong><em>Compiler designer have designed standard in such a way that your class object operation should also work same as primitive type operations</em></strong> like</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Primitive type &amp; operations
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>b</span> <span class=o>=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// User defined type &amp; operations
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>X</span> <span class=nf>x1</span><span class=p>(</span><span class=mi>5</span><span class=p>),</span> <span class=n>x2</span><span class=p>,</span> <span class=n>x3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>x3</span> <span class=o>=</span> <span class=n>x2</span> <span class=o>=</span> <span class=n>x1</span><span class=p>;</span>
</span></span></code></pre></div><p>assignment operator in C++ with example</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/copy-assignment-operator-c-example/>Copy-Assignment-Operator-C-Example</a></li><li><a href=https://vishalchovatiya.github.io/tags/copy-assignment-operator-return-by-value/>Copy-Assignment-Operator-Return-by-Value</a></li><li><a href=https://vishalchovatiya.github.io/tags/copy-operator-chain-assignment-c/>Copy-Operator-Chain-Assignment-C</a></li><li><a href=https://vishalchovatiya.github.io/tags/return-by-pointer/>Return-by-Pointer</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/when-to-use-const-vs-constexpr-in-cpp/><span class=title>« Prev</span><br><span>When to Use const vs constexpr in C++</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/all-about-copy-constructor-in-cpp-with-example/><span class=title>Next »</span><br><span>All About Copy Constructor in C++ With Example</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 2 Wrong Way to Learn Copy Assignment Operator in C++ With Example on x" href="https://x.com/intent/tweet/?text=2%20Wrong%20Way%20to%20Learn%20Copy%20Assignment%20Operator%20in%20C%2b%2b%20With%20Example&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2f2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example%2f&amp;hashtags=copy-assignment-operator-c-example%2ccopy-assignment-operator-return-by-value%2ccopy-operator-chain-assignment-c%2creturn-by-pointer"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2 Wrong Way to Learn Copy Assignment Operator in C++ With Example on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2f2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example%2f&amp;title=2%20Wrong%20Way%20to%20Learn%20Copy%20Assignment%20Operator%20in%20C%2b%2b%20With%20Example&amp;summary=2%20Wrong%20Way%20to%20Learn%20Copy%20Assignment%20Operator%20in%20C%2b%2b%20With%20Example&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2f2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2 Wrong Way to Learn Copy Assignment Operator in C++ With Example on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2f2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example%2f&title=2%20Wrong%20Way%20to%20Learn%20Copy%20Assignment%20Operator%20in%20C%2b%2b%20With%20Example"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2 Wrong Way to Learn Copy Assignment Operator in C++ With Example on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2f2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2 Wrong Way to Learn Copy Assignment Operator in C++ With Example on whatsapp" href="https://api.whatsapp.com/send?text=2%20Wrong%20Way%20to%20Learn%20Copy%20Assignment%20Operator%20in%20C%2b%2b%20With%20Example%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2f2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2 Wrong Way to Learn Copy Assignment Operator in C++ With Example on telegram" href="https://telegram.me/share/url?text=2%20Wrong%20Way%20to%20Learn%20Copy%20Assignment%20Operator%20in%20C%2b%2b%20With%20Example&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2f2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2 Wrong Way to Learn Copy Assignment Operator in C++ With Example on ycombinator" href="https://news.ycombinator.com/submitlink?t=2%20Wrong%20Way%20to%20Learn%20Copy%20Assignment%20Operator%20in%20C%2b%2b%20With%20Example&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2f2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>