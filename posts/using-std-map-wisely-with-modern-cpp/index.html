<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Using std::map Wisely With Modern C&#43;&#43; · Vishal Chovatiya
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Vishal Chovatiya">
<meta name="description" content="std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C&#43;&#43;, we now have more reasons to use std::map. That&rsquo;s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let&rsquo;s dive-in directly.
std::map::contains(C&#43;&#43;20) Link to heading std::map::contains member function is a good step towards code expressiveness.">
<meta name="keywords" content="blog,developer,personal">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Using std::map Wisely With Modern C&#43;&#43;">
  <meta name="twitter:description" content="std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C&#43;&#43;, we now have more reasons to use std::map. That’s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let’s dive-in directly.
std::map::contains(C&#43;&#43;20) Link to heading std::map::contains member function is a good step towards code expressiveness.">

<meta property="og:url" content="http://localhost:1313/posts/using-std-map-wisely-with-modern-cpp/">
  <meta property="og:site_name" content="Vishal Chovatiya">
  <meta property="og:title" content="Using std::map Wisely With Modern C&#43;&#43;">
  <meta property="og:description" content="std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C&#43;&#43;, we now have more reasons to use std::map. That’s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let’s dive-in directly.
std::map::contains(C&#43;&#43;20) Link to heading std::map::contains member function is a good step towards code expressiveness.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-07-08T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-07-08T00:00:00+00:00">




<link rel="canonical" href="http://localhost:1313/posts/using-std-map-wisely-with-modern-cpp/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>




<body class="preload-transitions colorscheme-light">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      Vishal Chovatiya
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Latest</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/pages/start-here">Start Here</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/cpp/">C/C&#43;&#43;</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/linux-system-programming/">Linux System Programming</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/misc/">Misc</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/using-std-map-wisely-with-modern-cpp/">
              Using std::map Wisely With Modern C&#43;&#43;
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2020-07-08T00:00:00Z">
                July 8, 2020
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              10-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/cpp/">Cpp</a>
      <span class="separator">•</span>
    <a href="/categories/stl/">Stl</a></div>

          
        </div>
      </header>

      <div class="post-content">
        
          <img src="/images/std-map-C.webp" alt="Featured image"/>
        
        <p><a href="https://en.cppreference.com/w/cpp/container/map"  class="external-link" target="_blank" rel="noopener">std::map</a> and its siblings(<a href="https://en.cppreference.com/w/cpp/container/multimap"  class="external-link" target="_blank" rel="noopener">std::multimap</a>, <a href="https://en.cppreference.com/w/cpp/container/unordered_map"  class="external-link" target="_blank" rel="noopener">std::unordered_map</a>/<a href="https://en.cppreference.com/w/cpp/container/unordered_multimap"  class="external-link" target="_blank" rel="noopener">multimap</a>) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with <a href="/posts/21-new-features-of-modern-cpp-to-use-in-your-project/" >Modern C++</a>, we now have more reasons to use <code>std::map</code>. That&rsquo;s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let&rsquo;s dive-in directly.</p>
<h2 id="stdmapcontainshttpsencppreferencecomwcppcontainermapcontainsc20">
  <a href="https://en.cppreference.com/w/cpp/container/map/contains"  class="external-link" target="_blank" rel="noopener">std::map::contains</a>(C++20)
  <a class="heading-link" href="#stdmapcontainshttpsencppreferencecomwcppcontainermapcontainsc20">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li><code>std::map::contains</code> member function is a good step towards code expressiveness. And I am also tire of writing :</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">auto</span> search <span style="color:#f92672">=</span> freq_of.find(<span style="color:#ae81ff">2</span>); search <span style="color:#f92672">!=</span> freq_of.end()) {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Found&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Where assume, freq_of = map&lt;uint32_t, uint32_t&gt;{{3, 1}, {1, 1}, {2, 1}};
</span></span></span></code></pre></div><ul>
<li>Rather, from C++20, you can write:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (freq_of.contains(<span style="color:#ae81ff">2</span>)) {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Found&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><strong><em>The code we write is written first for human consumption &amp; only secondarily for the computer to understand.</em></strong>  <strong>- John Sonmez</strong></p>
</blockquote>
<h2 id="stdmaptry_emplacehttpsencppreferencecomwcppcontainermaptry_emplacec17">
  <a href="https://en.cppreference.com/w/cpp/container/map/try_emplace"  class="external-link" target="_blank" rel="noopener">std::map::try_emplace</a>(C++17)
  <a class="heading-link" href="#stdmaptry_emplacehttpsencppreferencecomwcppcontainermaptry_emplacec17">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>While inserting into the map, we have 2 different possibilities:
<ol>
<li>The key doesn&rsquo;t exist yet. Create a fresh key-value pair.</li>
<li>The key does exist already. Take the existing item and modify it.</li>
</ol>
</li>
<li>A typical approach to insert an element in <code>std::map</code> is by using <code>operator[ ]</code>, <code>std::map::insert</code> or <code>std::map::emplace</code> . But, in all of these cases, we have to bear the cost of default/specialized constructor or assignment call. And the worst part is if an item already exists, we have to drop the freshly created item.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    vector v{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>};
</span></span><span style="display:flex;"><span>    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, <span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;</span> freq_of;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>n : v) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>[it, inserted] <span style="color:#f92672">=</span> freq_of.emplace(n, <span style="color:#ae81ff">1</span>); <span style="color:#f92672">!</span>inserted) {
</span></span><span style="display:flex;"><span>            it<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">++</span>;  <span style="color:#75715e">// Exists already
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert(freq_of[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Instead:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>[it, inserted] <span style="color:#f92672">=</span> freq_of.try_emplace(n, <span style="color:#ae81ff">1</span>); <span style="color:#f92672">!</span>inserted) {
</span></span><span style="display:flex;"><span>    it<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>But, since C++17, there is this <strong><em><code>std::map::try_emplace</code> method that creates items only if the key doesn&rsquo;t exist yet</em></strong>. This boosts the performance in case objects of that type are expensive to create.</li>
<li>Although the above example hasn&rsquo;t showcased the expensive to create items. But, yes! whenever you encounter such a situation, must be known how to handle it with <code>std::map::try_emplace</code>.</li>
</ul>
<h2 id="stdmapinsert_or_assignhttpsencppreferencecomwcppcontainermapinsert_or_assignc17">
  <a href="https://en.cppreference.com/w/cpp/container/map/insert_or_assign"  class="external-link" target="_blank" rel="noopener">std::map::insert_or_assign</a>(C++17)
  <a class="heading-link" href="#stdmapinsert_or_assignhttpsencppreferencecomwcppcontainermapinsert_or_assignc17">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>When you have to insert element anyhow. For the sake of convenience, you use <a href="https://en.cppreference.com/w/cpp/container/map/operator_at"  class="external-link" target="_blank" rel="noopener">std::map::operator[ ]</a>. Which is OK( and <a href="https://devblogs.microsoft.com/oldnewthing/20190227-00/?p=101072"  class="external-link" target="_blank" rel="noopener">dangerous</a>)! Unless you have any constraint on insertion or assignment.</li>
<li>For example, while counting the frequency of elements with the added constraint that when an element is repeated(i.e. assigned) you have to remove all the element lesser than the current one.</li>
<li>In such a situation, <code>std::map::operator[ ]</code> isn&rsquo;t feasible. Rather, <code>std::map::insert_or_assign</code> is more appropriate and returns more information than [<code>std::map::operator[ ]</code>](<code>std::map::operator[ ]</code>). It also does not require default-constructibility of the mapped type. Consider the following example for the same.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	vector v{<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>};
</span></span><span style="display:flex;"><span>	map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, <span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;</span> freq_of;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;&amp;</span>n : v) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>[it, is_inserted] <span style="color:#f92672">=</span> freq_of.insert_or_assign(n, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>is_inserted) { <span style="color:#75715e">// remove all lesser element then current one if repeated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			freq_of.erase(begin(freq_of), it);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	assert((freq_of <span style="color:#f92672">==</span> <span style="color:#66d9ef">decltype</span>(freq_of){
</span></span><span style="display:flex;"><span>						   {<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>},
</span></span><span style="display:flex;"><span>						   {<span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">1</span>},
</span></span><span style="display:flex;"><span>					   }));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="stdmapinserthttpsencppreferencecomwcppcontainermapinsert-with-hintc1117">
  <a href="https://en.cppreference.com/w/cpp/container/map/insert"  class="external-link" target="_blank" rel="noopener">std::map::insert</a> With Hint(C++11/17)
  <a class="heading-link" href="#stdmapinserthttpsencppreferencecomwcppcontainermapinsert-with-hintc1117">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Looking up items in an <code>std::map</code> takes <code>O(log(n))</code> time. This is the same for inserting new items. Because the position where to insert them must looked up. Naive insertion of <code>M</code> new items would thus take <code>O(M * log(n))</code> time.</li>
<li>In order to make this more efficient, <code>std::map</code> insertion functions accept an optional insertion hint parameter. The insertion hint is basically an iterator, which points near the future position of the item that is to be inserted. If the hint is correct, then we get amortized <code>O(1)</code> insertion time.</li>
<li>This is quite useful from a performance point of view when the insertion sequence of items is somewhat predictable. For example:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, string<span style="color:#f92672">&gt;</span> m{{<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;&#34;</span>}, {<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;&#34;</span>}};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">auto</span> where(end(m));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>n : {<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>}) { <span style="color:#75715e">// Items in non-incremental order
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		where <span style="color:#f92672">=</span> m.insert(where, {n, <span style="color:#e6db74">&#34;&#34;</span>});
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// How it is not done!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// m.insert(end(m), {0, &#34;&#34;});
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>[key, value] <span style="color:#f92672">:</span> m) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> key <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; : &#34;</span> <span style="color:#f92672">&lt;&lt;</span> value <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>A <strong><em>correct hint will point to an existing element, which is greater than the element to be inserted</em></strong> so that the newly inserted key will be just before the hint. If this does not apply for the hint the user provided during insertion, the insert function will fall back to a nonoptimized insertion, yielding `O(log(n)) performance again.</li>
<li>For the above example, the first insertion, we got the end iterator of the map, because we had no better hint to start with. After installing an 8 in the tree, we knew that installing 7 will insert a new item just in front of the 8, which qualified it to be a correct hint. This applies to 6 as well, if put into the tree after inserting the 7, and so on. This is why it is possible to use the iterator, which was returned in the last insertion for the next insertion.</li>
<li>You can play around the above example to justify the performance gain with <a href="https://quick-bench.com/q/gF1CXbPkzjOzLxKfRG7X-Uv8lfw"  class="external-link" target="_blank" rel="noopener">quick-benchmark</a>.</li>
</ul>
<p><em><strong>Note:</strong> It is important to know that before C++11, insertion hints were considered correct when they pointed before the position of the newly inserted item.</em></p>
<h2 id="stdmapmergehttpsencppreferencecomwcppcontainermapmergec17">
  <a href="https://en.cppreference.com/w/cpp/container/map/merge"  class="external-link" target="_blank" rel="noopener">std::map::merge</a>(C++17)
  <a class="heading-link" href="#stdmapmergehttpsencppreferencecomwcppcontainermapmergec17">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Same as <a href="https://en.cppreference.com/w/cpp/container/list/splice"  class="external-link" target="_blank" rel="noopener">std::list:splice</a>, which transfers the elements from one list to another. we have <code>std::map::merge</code> which can merge the two same type of <code>std::map</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, string<span style="color:#f92672">&gt;</span> fruits{{<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;grapes&#34;</span>}, {<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;tomoto&#34;</span>}};
</span></span><span style="display:flex;"><span>	map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, string<span style="color:#f92672">&gt;</span> person{{<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;mickel&#34;</span>}, {<span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;shree&#34;</span>}};
</span></span><span style="display:flex;"><span>	map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span>, string<span style="color:#f92672">&gt;</span> fruits_and_persons;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fruits_and_persons.merge(fruits);
</span></span><span style="display:flex;"><span>	assert(fruits.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fruits_and_persons.merge(person);
</span></span><span style="display:flex;"><span>	assert(person.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	assert(person.at(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;mickel&#34;</span>); <span style="color:#75715e">// Won&#39;t overwrite value at 2 i.e.`mickel`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	assert((fruits_and_persons <span style="color:#f92672">==</span> <span style="color:#66d9ef">decltype</span>(fruits){
</span></span><span style="display:flex;"><span>									  {<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;tomoto&#34;</span>},
</span></span><span style="display:flex;"><span>									  {<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;grapes&#34;</span>},
</span></span><span style="display:flex;"><span>									  {<span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;shree&#34;</span>},
</span></span><span style="display:flex;"><span>								  }));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>The thing here to note is what happens when there are duplicates! <strong><em>The duplicated elements are not transferred. They&rsquo;re left behind in the right-hand-side map</em></strong>.</li>
</ul>
<h2 id="stdmapextracthttpsencppreferencecomwcppcontainermapextractc17">
  <a href="https://en.cppreference.com/w/cpp/container/map/extract"  class="external-link" target="_blank" rel="noopener">std::map::extract</a>(C++17)
  <a class="heading-link" href="#stdmapextracthttpsencppreferencecomwcppcontainermapextractc17">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>Unlike <code>std::map::merge</code> that transfers the elements in bulk, <strong><em><code>std::map::extract</code> along with <code>std::map::insert</code> transfers element piecewise</em></strong>. But what is the more compelling application of <code>std::map::extract</code> is modifying keys.</li>
<li>As we know, for <code>std::map</code> keys are always unique and sorted. Hence, It is crucial that users cannot modify the keys of map nodes that are already inserted. In order to prevent the user from modifying the key items of perfectly sorted map nodes, the <a href="/posts/when-to-use-const-vs-constexpr-in-cpp/" >const</a> qualifier is added to the key type.</li>
<li>This kind of restriction is perfectly valid because it makes harder for the user to use <code>std::map</code> the wrong way. But what if we really need to change the keys of some map items?</li>
<li>Prior to C++17, we had to remove &amp; reinsert the items in order to change the key. The downside of this approach is memory allocation &amp; deallocation, which sounds bad in terms of performance. But, from C++17, we can remove &amp; reinsert std::map nodes without any reallocation of memory.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, string<span style="color:#f92672">&gt;</span> race_scoreboard{{<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Mickel&#34;</span>}, {<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;Shree&#34;</span>}, {<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;Jenti&#34;</span>}};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">using</span> Pair <span style="color:#f92672">=</span> map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, string<span style="color:#f92672">&gt;::</span>value_type;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">auto</span> Jenti(race_scoreboard.extract(<span style="color:#ae81ff">3</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">auto</span> Mickel(race_scoreboard.extract(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		swap(Jenti.key(), Mickel.key());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">auto</span> [it, is_inserted, nh] <span style="color:#f92672">=</span> race_scoreboard.insert(move(Jenti)); <span style="color:#75715e">// nh = node handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		assert(<span style="color:#f92672">*</span>it <span style="color:#f92672">==</span> Pair(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Jenti&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> is_inserted <span style="color:#f92672">==</span> true <span style="color:#f92672">&amp;&amp;</span> nh.empty());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		race_scoreboard.insert(move(Mickel));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	assert((race_scoreboard <span style="color:#f92672">==</span> <span style="color:#66d9ef">decltype</span>(race_scoreboard){
</span></span><span style="display:flex;"><span>								   {<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Jenti&#34;</span>},
</span></span><span style="display:flex;"><span>								   {<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;Shree&#34;</span>},
</span></span><span style="display:flex;"><span>								   {<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;Mickel&#34;</span>},
</span></span><span style="display:flex;"><span>							   }));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Consider the above example of the racing scoreboard where you have employed <code>std::map</code> to imitate the racing position. And after a while, Jenti took the lead &amp; Mickel left behind. In this case, how we have switched the keys(position on a race track) of those players.</li>
<li><code>std::map::extract</code> comes in two flavours:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>node_type <span style="color:#a6e22e">extract</span>(const_iterator position);
</span></span><span style="display:flex;"><span>node_type <span style="color:#a6e22e">extract</span>(<span style="color:#66d9ef">const</span> key_type<span style="color:#f92672">&amp;</span> x);
</span></span></code></pre></div><ul>
<li>In the above example, we used the second one, which accepts a key and then finds &amp; extracts the map node that matches the key parameter. The first one accepts an iterator, which implies that it is faster because it doesn&rsquo;t need to search for the item.</li>
</ul>
<h3 id="what-if-the-node-with-a-particular-key-does-not-exist">
  What If the Node With a Particular Key Does Not Exist?
  <a class="heading-link" href="#what-if-the-node-with-a-particular-key-does-not-exist">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>If we try to extract an item that doesn&rsquo;t exist with the second method (the one that searches using a key), it <strong><em>returns an empty <code>node_type</code> instance i.e. node handle</em></strong>. The <code>empty()</code>member method or overloaded bool operator tells us that whether a <code>node_type</code> instance is empty or not.</li>
</ul>
<h3 id="ok-then-how-do-i-modify-stdmap-keys">
  OK! Then How Do I Modify std::map Keys?
  <a class="heading-link" href="#ok-then-how-do-i-modify-stdmap-keys">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>After extracting nodes, we were able to modify their keys <strong><em>using the <code>key()</code>method</em></strong>, which gives us non-const access to the key, although keys are usually <a href="/posts/when-to-use-const-vs-constexpr-in-cpp/" >const</a>.</li>
<li>Note that in order to reinsert the nodes into the map again, we had to move them into the insert function. This makes sense because the extract is all about avoiding unnecessary copies and allocations. Moreover, while we move a <code>node_type</code> instance, this does not result in actual moves of any of the container values.</li>
</ul>
<h3 id="can-i-modify-associated-values-in-stdmap-also">
  Can I Modify Associated Values in std::map Also?
  <a class="heading-link" href="#can-i-modify-associated-values-in-stdmap-also">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Yes! You can <strong>_use the accessor methods <code>nh.mapped()</code></strong>(instead of <code>nh.key()</code> to manipulate the pieces of the entry in a <code>std::map</code> (or <code>nh.value()</code>for the single piece of data in an element of a <code>std::set</code>). Thus you can extract, manipulate, and reinsert a key without ever copying or moving its actual data.</li>
</ul>
<h3 id="but-what-about-safety">
  But What About Safety?
  <a class="heading-link" href="#but-what-about-safety">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>If you extract a node from a map and then throw an <a href="/posts/7-best-practices-for-exception-handling-in-cpp-with-example/" >exception</a> before you&rsquo;ve managed to re-insert it into the destination map.</li>
<li>A node handle&rsquo;s destructor is called and will correctly clean up the memory associated with the node. So, technically <strong><em><code>std::map::extract</code> by-default(without insert) will act as <a href="https://en.cppreference.com/w/cpp/container/map/erase"  class="external-link" target="_blank" rel="noopener">std::map::erase</a></em></strong>!</li>
</ul>
<h3 id="there-is-more-interoperability">
  There Is More! Interoperability
  <a class="heading-link" href="#there-is-more-interoperability">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>Map nodes that have been extracted using the <code>std::map::extract</code> are actually very versatile. <strong><em>We can extract nodes from a map instance and insert it into any other map or even multimap instance</em></strong>.</li>
<li>It does also work between <a href="https://en.cppreference.com/w/cpp/container/unordered_map"  class="external-link" target="_blank" rel="noopener">unordered_map</a> and <a href="https://en.cppreference.com/w/cpp/container/unordered_multimap"  class="external-link" target="_blank" rel="noopener">unordered_multimap</a> instances, as well as with <a href="https://en.cppreference.com/w/cpp/container/set"  class="external-link" target="_blank" rel="noopener">set</a>/<a href="https://en.cppreference.com/w/cpp/container/multiset"  class="external-link" target="_blank" rel="noopener">multiset</a> and respective <a href="https://en.cppreference.com/w/cpp/container/unordered_set"  class="external-link" target="_blank" rel="noopener">unordered_set</a>/<a href="https://en.cppreference.com/w/cpp/container/unordered_multiset"  class="external-link" target="_blank" rel="noopener">unordered_multiset</a>.</li>
<li>In order to move items between different map/set structures, the types of key, value and allocator need to be identical.</li>
</ul>
<h2 id="difference-between-operator--vs-insert-vs-at">
  Difference Between operator[ ] vs insert() vs at()
  <a class="heading-link" href="#difference-between-operator--vs-insert-vs-at">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>This is trivial for experienced devs but, still I want to go over it quickly.</p>
<h3 id="stdmapoperator-httpsencppreferencecomwcppcontainermapoperator_at">
  <a href="https://en.cppreference.com/w/cpp/container/map/operator_at"  class="external-link" target="_blank" rel="noopener">std::map::operator[ ]</a>
  <a class="heading-link" href="#stdmapoperator-httpsencppreferencecomwcppcontainermapoperator_at">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>Operation</strong>: find-or-add; try to find an element with the given key inside the map, and if it exists it will return a reference to the stored value. If it does not, it will create a new element inserted in place with default initialization and return a reference to it.</li>
<li><strong>Applicability</strong>:
<ul>
<li>Not usable for <code>const std::map</code>, as it will create the element if it doesn&rsquo;t exist.</li>
<li>Not suitable for value type that does not default constructible and assignable(in layman term, doesn&rsquo;t have default constructor &amp; copy/move constructor).</li>
</ul>
</li>
<li><strong>When key exists</strong>: Overwrites it.</li>
</ul>
<h3 id="stdmapinserthttpsencppreferencecomwcppcontainermapinsert">
  <a href="https://en.cppreference.com/w/cpp/container/map/insert"  class="external-link" target="_blank" rel="noopener">std::map::insert</a>
  <a class="heading-link" href="#stdmapinserthttpsencppreferencecomwcppcontainermapinsert">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>Operation</strong>: insert-or-nop; accepts a value_type (<code>std::pair</code>) and uses the key(first member) and to insert it. As<code>std::map</code> does not allow for duplicates, if there is an existing element it will not insert anything.</li>
<li><strong>Applicability</strong>:
<ul>
<li>Liberty in calling insert different ways that require the creation of the value_type externally and the copy of that object into the container.</li>
<li>Highly applicable when item insertion sequence is somewhat predictable to gain the performance.</li>
</ul>
</li>
<li><strong>When key exists</strong>: Not modify the state of the map, but instead return an iterator to the element that prevented the insertion.</li>
</ul>
<h3 id="stdmapathttpsencppreferencecomwcppcontainermapat">
  <a href="https://en.cppreference.com/w/cpp/container/map/at"  class="external-link" target="_blank" rel="noopener">std::map::at</a>
  <a class="heading-link" href="#stdmapathttpsencppreferencecomwcppcontainermapat">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>Operation</strong>: find-or-throw; returns a reference to the mapped value of the element with key equivalent to input key. If no such element exists, an <a href="/posts/7-best-practices-for-exception-handling-in-cpp-with-example/" >exception</a> of type <a href="https://en.cppreference.com/w/cpp/error/out_of_range"  class="external-link" target="_blank" rel="noopener">std::out_of_range</a> is thrown.</li>
<li><strong>Applicability</strong>:
<ul>
<li>Not recommended using <code>at()</code>when accessing const maps and when element absence is a logic error.</li>
<li>Yes, it&rsquo;s better to use <code>std::map::find()</code>when you&rsquo;re not sure element is there. Because, throwing and catching <a href="https://en.cppreference.com/w/cpp/error/logic_error"  class="external-link" target="_blank" rel="noopener">std::logic_error</a> exception will not be a very elegant way of programming, even if we don&rsquo;t think about performance.</li>
</ul>
</li>
<li><strong>When key exists</strong>: returns a reference to mapped value.</li>
</ul>
<h2 id="parting-words">
  Parting Words
  <a class="heading-link" href="#parting-words">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>If you see the table of content for this article above, more than half of the member functions are around inserting the elements into the map. To the newbie, this is the reason for anxiety(or standard committee would say modernness). But if you account for the new features &amp; complexity of language those are pretty much justified. BTW, this modernness doesn&rsquo;t stop here, we do have other specialization also available for map like <a href="https://en.cppreference.com/w/cpp/container/map/swap2"  class="external-link" target="_blank" rel="noopener">std::swap</a>(C++17), <a href="https://en.cppreference.com/w/cpp/container/map/erase_if"  class="external-link" target="_blank" rel="noopener">std::erase_if</a>(C++20) &amp; bunch of comparison operators.</p>

      </div>


      <footer>
        


        
        
        
        
        

        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2024
     Vishal Chovatiya 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  
  



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
