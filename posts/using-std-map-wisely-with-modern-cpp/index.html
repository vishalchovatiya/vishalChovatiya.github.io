<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using std::map Wisely With Modern C++ | Vishal Chovatiya</title>
<meta name=keywords content="c-map-check-if-key-exists,c-map-class,c-map-comparator,c-map-data-structure,c-map-empty,c-map-end,c-map-examples,c-map-find-example,c-map-function,c-map-get-value-by-key,c-map-greater,c-map-in-map,c-map-initialization,c-map-iterator,c-map-iterator-first,c-map-loop,c-map-methods,c-map-of-classes,c-map-of-lists,c-map-of-maps,c-map-of-objects,c-map-of-vectors,c-map-performance,c-map-reduce,c-map-reserve,c-map-struct-as-key,c-map-struct-key,c-map-template,c-map-template-example,c-map-to-vector,c-map-usage,c-map-vector,c-map-with-custom-comparator,c-remove_if-map,c-std-hash-map,c-stl-map,c-stl-map-example,c-vector-to-map,can-i-modify-associated-values-in-stdmap-also,const-map-c,cpp-std-map,cpp-std-map-example,cppreference-map,difference-between-operator-vs-insert-vs-at,map-c-stl,map-std-c,multimap-stl,ok-then-how-do-i-modify-stdmap-keys,ordered-map-c,static-map-c,std-hash-map,std-map-c,std-map-vector,std-unsorted-map,stdmap-example,stdmap-find,stdmap-insert,stdmapat,stdmapcontainsc20,stdmapextractc17,stdmapinsert,stdmapinsert-with-hintc11-17,stdmapinsert_or_assignc17,stdmapmergec17,stdmapoperator,stdmaptry_emplacec17,stl-c-map,unordered_map-c,what-if-the-node-with-a-particular-key-does-not-exist"><meta name=description content="std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C++, we now have more reasons to use std::map. That&rsquo;s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let&rsquo;s dive-in directly.
std::map::contains(C++20) std::map::contains member function is a good step towards code expressiveness."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=http://localhost:1313/posts/using-std-map-wisely-with-modern-cpp/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/trident_favicon.webp><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/images/trident_favicon.webp><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/images/trident_favicon.webp><link rel=apple-touch-icon href=http://localhost:1313/images/trident_favicon.webp><link rel=mask-icon href=http://localhost:1313/images/trident_favicon.webp><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/using-std-map-wisely-with-modern-cpp/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Using std::map Wisely With Modern C++"><meta property="og:description" content="std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C++, we now have more reasons to use std::map. That&rsquo;s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let&rsquo;s dive-in directly.
std::map::contains(C++20) std::map::contains member function is a good step towards code expressiveness."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/using-std-map-wisely-with-modern-cpp/"><meta property="og:image" content="http://localhost:1313/images/std-map-C.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-08T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-08T00:00:00+00:00"><meta property="og:site_name" content="Vishal Chovatiya"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/std-map-C.webp"><meta name=twitter:title content="Using std::map Wisely With Modern C++"><meta name=twitter:description content="std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C++, we now have more reasons to use std::map. That&rsquo;s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let&rsquo;s dive-in directly.
std::map::contains(C++20) std::map::contains member function is a good step towards code expressiveness."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Using std::map Wisely With Modern C++","item":"http://localhost:1313/posts/using-std-map-wisely-with-modern-cpp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using std::map Wisely With Modern C++","name":"Using std::map Wisely With Modern C\u002b\u002b","description":"std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C++, we now have more reasons to use std::map. That\u0026rsquo;s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let\u0026rsquo;s dive-in directly.\nstd::map::contains(C++20) std::map::contains member function is a good step towards code expressiveness.","keywords":["c-map-check-if-key-exists","c-map-class","c-map-comparator","c-map-data-structure","c-map-empty","c-map-end","c-map-examples","c-map-find-example","c-map-function","c-map-get-value-by-key","c-map-greater","c-map-in-map","c-map-initialization","c-map-iterator","c-map-iterator-first","c-map-loop","c-map-methods","c-map-of-classes","c-map-of-lists","c-map-of-maps","c-map-of-objects","c-map-of-vectors","c-map-performance","c-map-reduce","c-map-reserve","c-map-struct-as-key","c-map-struct-key","c-map-template","c-map-template-example","c-map-to-vector","c-map-usage","c-map-vector","c-map-with-custom-comparator","c-remove_if-map","c-std-hash-map","c-stl-map","c-stl-map-example","c-vector-to-map","can-i-modify-associated-values-in-stdmap-also","const-map-c","cpp-std-map","cpp-std-map-example","cppreference-map","difference-between-operator-vs-insert-vs-at","map-c-stl","map-std-c","multimap-stl","ok-then-how-do-i-modify-stdmap-keys","ordered-map-c","static-map-c","std-hash-map","std-map-c","std-map-vector","std-unsorted-map","stdmap-example","stdmap-find","stdmap-insert","stdmapat","stdmapcontainsc20","stdmapextractc17","stdmapinsert","stdmapinsert-with-hintc11-17","stdmapinsert_or_assignc17","stdmapmergec17","stdmapoperator","stdmaptry_emplacec17","stl-c-map","unordered_map-c","what-if-the-node-with-a-particular-key-does-not-exist"],"articleBody":"std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C++, we now have more reasons to use std::map. That’s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let’s dive-in directly.\nstd::map::contains(C++20) std::map::contains member function is a good step towards code expressiveness. And I am also tire of writing : 1 2 3 4 if (auto search = freq_of.find(2); search != freq_of.end()) { cout \u003c\u003c \"Found\" \u003c\u003c endl; } // Where assume, freq_of = map{{3, 1}, {1, 1}, {2, 1}}; Rather, from C++20, you can write: 1 2 3 if (freq_of.contains(2)) { cout \u003c\u003c \"Found\" \u003c\u003c endl; } The code we write is written first for human consumption \u0026 only secondarily for the computer to understand. - John Sonmez\nstd::map::try_emplace(C++17) While inserting into the map, we have 2 different possibilities: The key doesn’t exist yet. Create a fresh key-value pair. The key does exist already. Take the existing item and modify it. A typical approach to insert an element in std::map is by using operator[ ], std::map::insert or std::map::emplace . But, in all of these cases, we have to bear the cost of default/specialized constructor or assignment call. And the worst part is if an item already exists, we have to drop the freshly created item. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { vector v{3, 4, 5, 8, 7, 3, 5, 2, 4}; map\u003cuint32_t, uint32_t\u003e freq_of; for (const auto \u0026n : v) { if (const auto \u0026[it, inserted] = freq_of.emplace(n, 1); !inserted) { it-\u003esecond++; // Exists already } } assert(freq_of[3] == 2); return EXIT_SUCCESS; } Instead: 1 2 3 if (const auto \u0026[it, inserted] = freq_of.try_emplace(n, 1); !inserted) { it-\u003esecond++; } But, since C++17, there is this std::map::try_emplace method that creates items only if the key doesn’t exist yet. This boosts the performance in case objects of that type are expensive to create. Although the above example hasn’t showcased the expensive to create items. But, yes! whenever you encounter such a situation, must be known how to handle it with std::map::try_emplace. std::map::insert_or_assign(C++17) When you have to insert element anyhow. For the sake of convenience, you use std::map::operator[ ]. Which is OK( and dangerous)! Unless you have any constraint on insertion or assignment. For example, while counting the frequency of elements with the added constraint that when an element is repeated(i.e. assigned) you have to remove all the element lesser than the current one. In such a situation, std::map::operator[ ] isn’t feasible. Rather, std::map::insert_or_assign is more appropriate and returns more information than [std::map::operator[ ]](std::map::operator[ ]). It also does not require default-constructibility of the mapped type. Consider the following example for the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { vector v{8, 3, 9, 5, 8}; map\u003cuint32_t, uint32_t\u003e freq_of; for (auto \u0026\u0026n : v) { const auto \u0026[it, is_inserted] = freq_of.insert_or_assign(n, 1); if (!is_inserted) { // remove all lesser element then current one if repeated freq_of.erase(begin(freq_of), it); } } assert((freq_of == decltype(freq_of){ {8, 1}, {9, 1}, })); return EXIT_SUCCESS; } std::map::insert With Hint(C++11/17) Looking up items in an std::map takes O(log(n)) time. This is the same for inserting new items. Because the position where to insert them must looked up. Naive insertion of M new items would thus take O(M * log(n)) time. In order to make this more efficient, std::map insertion functions accept an optional insertion hint parameter. The insertion hint is basically an iterator, which points near the future position of the item that is to be inserted. If the hint is correct, then we get amortized O(1) insertion time. This is quite useful from a performance point of view when the insertion sequence of items is somewhat predictable. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { map\u003cuint32_t, string\u003e m{{2, \"\"}, {3, \"\"}}; auto where(end(m)); for (const auto \u0026n : {8, 7, 6, 5, 4, 3, 2, 1}) { // Items in non-incremental order where = m.insert(where, {n, \"\"}); } // How it is not done! // m.insert(end(m), {0, \"\"}); for (const auto \u0026[key, value] : m) { cout \u003c\u003c key \u003c\u003c \" : \" \u003c\u003c value \u003c\u003c endl; } return EXIT_SUCCESS; } A correct hint will point to an existing element, which is greater than the element to be inserted so that the newly inserted key will be just before the hint. If this does not apply for the hint the user provided during insertion, the insert function will fall back to a nonoptimized insertion, yielding `O(log(n)) performance again. For the above example, the first insertion, we got the end iterator of the map, because we had no better hint to start with. After installing an 8 in the tree, we knew that installing 7 will insert a new item just in front of the 8, which qualified it to be a correct hint. This applies to 6 as well, if put into the tree after inserting the 7, and so on. This is why it is possible to use the iterator, which was returned in the last insertion for the next insertion. You can play around the above example to justify the performance gain with quick-benchmark. Note: It is important to know that before C++11, insertion hints were considered correct when they pointed before the position of the newly inserted item.\nstd::map::merge(C++17) Same as std::list:splice, which transfers the elements from one list to another. we have std::map::merge which can merge the two same type of std::map. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { map\u003cuint32_t, string\u003e fruits{{5, \"grapes\"}, {2, \"tomoto\"}}; map\u003cuint32_t, string\u003e person{{2, \"mickel\"}, {10, \"shree\"}}; map\u003cuint32_t, string\u003e fruits_and_persons; fruits_and_persons.merge(fruits); assert(fruits.size() == 0); fruits_and_persons.merge(person); assert(person.size() == 1); assert(person.at(2) == \"mickel\"); // Won't overwrite value at 2 i.e.`mickel` assert((fruits_and_persons == decltype(fruits){ {2, \"tomoto\"}, {5, \"grapes\"}, {10, \"shree\"}, })); return EXIT_SUCCESS; } The thing here to note is what happens when there are duplicates! The duplicated elements are not transferred. They’re left behind in the right-hand-side map. std::map::extract(C++17) Unlike std::map::merge that transfers the elements in bulk, std::map::extract along with std::map::insert transfers element piecewise. But what is the more compelling application of std::map::extract is modifying keys. As we know, for std::map keys are always unique and sorted. Hence, It is crucial that users cannot modify the keys of map nodes that are already inserted. In order to prevent the user from modifying the key items of perfectly sorted map nodes, the const qualifier is added to the key type. This kind of restriction is perfectly valid because it makes harder for the user to use std::map the wrong way. But what if we really need to change the keys of some map items? Prior to C++17, we had to remove \u0026 reinsert the items in order to change the key. The downside of this approach is memory allocation \u0026 deallocation, which sounds bad in terms of performance. But, from C++17, we can remove \u0026 reinsert std::map nodes without any reallocation of memory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int main() { map\u003cint, string\u003e race_scoreboard{{1, \"Mickel\"}, {2, \"Shree\"}, {3, \"Jenti\"}}; using Pair = map\u003cint, string\u003e::value_type; { auto Jenti(race_scoreboard.extract(3)); auto Mickel(race_scoreboard.extract(1)); swap(Jenti.key(), Mickel.key()); auto [it, is_inserted, nh] = race_scoreboard.insert(move(Jenti)); // nh = node handle assert(*it == Pair(1, \"Jenti\") \u0026\u0026 is_inserted == true \u0026\u0026 nh.empty()); race_scoreboard.insert(move(Mickel)); } assert((race_scoreboard == decltype(race_scoreboard){ {1, \"Jenti\"}, {2, \"Shree\"}, {3, \"Mickel\"}, })); return EXIT_SUCCESS; } Consider the above example of the racing scoreboard where you have employed std::map to imitate the racing position. And after a while, Jenti took the lead \u0026 Mickel left behind. In this case, how we have switched the keys(position on a race track) of those players. std::map::extract comes in two flavours: 1 2 node_type extract(const_iterator position); node_type extract(const key_type\u0026 x); In the above example, we used the second one, which accepts a key and then finds \u0026 extracts the map node that matches the key parameter. The first one accepts an iterator, which implies that it is faster because it doesn’t need to search for the item. What If the Node With a Particular Key Does Not Exist? If we try to extract an item that doesn’t exist with the second method (the one that searches using a key), it returns an empty node_type instance i.e. node handle. The empty()member method or overloaded bool operator tells us that whether a node_type instance is empty or not. OK! Then How Do I Modify std::map Keys? After extracting nodes, we were able to modify their keys using the key()method, which gives us non-const access to the key, although keys are usually const. Note that in order to reinsert the nodes into the map again, we had to move them into the insert function. This makes sense because the extract is all about avoiding unnecessary copies and allocations. Moreover, while we move a node_type instance, this does not result in actual moves of any of the container values. Can I Modify Associated Values in std::map Also? Yes! You can _use the accessor methods nh.mapped()(instead of nh.key() to manipulate the pieces of the entry in a std::map (or nh.value()for the single piece of data in an element of a std::set). Thus you can extract, manipulate, and reinsert a key without ever copying or moving its actual data. But What About Safety? If you extract a node from a map and then throw an exception before you’ve managed to re-insert it into the destination map. A node handle’s destructor is called and will correctly clean up the memory associated with the node. So, technically std::map::extract by-default(without insert) will act as std::map::erase! There Is More! Interoperability Map nodes that have been extracted using the std::map::extract are actually very versatile. We can extract nodes from a map instance and insert it into any other map or even multimap instance. It does also work between unordered_map and unordered_multimap instances, as well as with set/multiset and respective unordered_set/unordered_multiset. In order to move items between different map/set structures, the types of key, value and allocator need to be identical. Difference Between operator[ ] vs insert() vs at() This is trivial for experienced devs but, still I want to go over it quickly.\nstd::map::operator[ ] Operation: find-or-add; try to find an element with the given key inside the map, and if it exists it will return a reference to the stored value. If it does not, it will create a new element inserted in place with default initialization and return a reference to it. Applicability: Not usable for const std::map, as it will create the element if it doesn’t exist. Not suitable for value type that does not default constructible and assignable(in layman term, doesn’t have default constructor \u0026 copy/move constructor). When key exists: Overwrites it. std::map::insert Operation: insert-or-nop; accepts a value_type (std::pair) and uses the key(first member) and to insert it. Asstd::map does not allow for duplicates, if there is an existing element it will not insert anything. Applicability: Liberty in calling insert different ways that require the creation of the value_type externally and the copy of that object into the container. Highly applicable when item insertion sequence is somewhat predictable to gain the performance. When key exists: Not modify the state of the map, but instead return an iterator to the element that prevented the insertion. std::map::at Operation: find-or-throw; returns a reference to the mapped value of the element with key equivalent to input key. If no such element exists, an exception of type std::out_of_range is thrown. Applicability: Not recommended using at()when accessing const maps and when element absence is a logic error. Yes, it’s better to use std::map::find()when you’re not sure element is there. Because, throwing and catching std::logic_error exception will not be a very elegant way of programming, even if we don’t think about performance. When key exists: returns a reference to mapped value. Parting Words If you see the table of content for this article above, more than half of the member functions are around inserting the elements into the map. To the newbie, this is the reason for anxiety(or standard committee would say modernness). But if you account for the new features \u0026 complexity of language those are pretty much justified. BTW, this modernness doesn’t stop here, we do have other specialization also available for map like std::swap(C++17), std::erase_if(C++20) \u0026 bunch of comparison operators.\n","wordCount":"2120","inLanguage":"en","image":"http://localhost:1313/images/std-map-C.webp","datePublished":"2020-07-08T00:00:00Z","dateModified":"2020-07-08T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/using-std-map-wisely-with-modern-cpp/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/trident_favicon.webp"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=http://localhost:1313/posts/ title=Latest><span>Latest</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Using std::map Wisely With Modern C++</h1><div class=post-meta><span title='2020-07-08 00:00:00 +0000 UTC'>July 8, 2020</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2120 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/blob/main/vishalchovatiya/content/posts/using-std-map-wisely-with-modern-cpp.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/images/std-map-C.webp alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#stdmapcontainshttpsencppreferencecomwcppcontainermapcontainsc20><a href=https://en.cppreference.com/w/cpp/container/map/contains>std::map::contains</a>(C++20)</a></li><li><a href=#stdmaptry_emplacehttpsencppreferencecomwcppcontainermaptry_emplacec17><a href=https://en.cppreference.com/w/cpp/container/map/try_emplace>std::map::try_emplace</a>(C++17)</a></li><li><a href=#stdmapinsert_or_assignhttpsencppreferencecomwcppcontainermapinsert_or_assignc17><a href=https://en.cppreference.com/w/cpp/container/map/insert_or_assign>std::map::insert_or_assign</a>(C++17)</a></li><li><a href=#stdmapinserthttpsencppreferencecomwcppcontainermapinsert-with-hintc1117><a href=https://en.cppreference.com/w/cpp/container/map/insert>std::map::insert</a> With Hint(C++11/17)</a></li><li><a href=#stdmapmergehttpsencppreferencecomwcppcontainermapmergec17><a href=https://en.cppreference.com/w/cpp/container/map/merge>std::map::merge</a>(C++17)</a></li><li><a href=#stdmapextracthttpsencppreferencecomwcppcontainermapextractc17><a href=https://en.cppreference.com/w/cpp/container/map/extract>std::map::extract</a>(C++17)</a><ul><li><a href=#what-if-the-node-with-a-particular-key-does-not-exist>What If the Node With a Particular Key Does Not Exist?</a></li><li><a href=#ok-then-how-do-i-modify-stdmap-keys>OK! Then How Do I Modify std::map Keys?</a></li><li><a href=#can-i-modify-associated-values-in-stdmap-also>Can I Modify Associated Values in std::map Also?</a></li><li><a href=#but-what-about-safety>But What About Safety?</a></li><li><a href=#there-is-more-interoperability>There Is More! Interoperability</a></li></ul></li><li><a href=#difference-between-operator--vs-insert-vs-at>Difference Between operator[ ] vs insert() vs at()</a><ul><li><a href=#stdmapoperator-httpsencppreferencecomwcppcontainermapoperator_at><a href=https://en.cppreference.com/w/cpp/container/map/operator_at>std::map::operator[ ]</a></a></li><li><a href=#stdmapinserthttpsencppreferencecomwcppcontainermapinsert><a href=https://en.cppreference.com/w/cpp/container/map/insert>std::map::insert</a></a></li><li><a href=#stdmapathttpsencppreferencecomwcppcontainermapat><a href=https://en.cppreference.com/w/cpp/container/map/at>std::map::at</a></a></li></ul></li><li><a href=#parting-words>Parting Words</a></li></ul></nav></div></details></div><div class=post-content><p><a href=https://en.cppreference.com/w/cpp/container/map>std::map</a> and its siblings(<a href=https://en.cppreference.com/w/cpp/container/multimap>std::multimap</a>, <a href=https://en.cppreference.com/w/cpp/container/unordered_map>std::unordered_map</a>/<a href=https://en.cppreference.com/w/cpp/container/unordered_multimap>multimap</a>) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with <a href=/posts/21-new-features-of-modern-cpp-to-use-in-your-project/>Modern C++</a>, we now have more reasons to use <code>std::map</code>. That&rsquo;s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let&rsquo;s dive-in directly.</p><h2 id=stdmapcontainshttpsencppreferencecomwcppcontainermapcontainsc20><a href=https://en.cppreference.com/w/cpp/container/map/contains>std::map::contains</a>(C++20)<a hidden class=anchor aria-hidden=true href=#stdmapcontainshttpsencppreferencecomwcppcontainermapcontainsc20>#</a></h2><ul><li><code>std::map::contains</code> member function is a good step towards code expressiveness. And I am also tire of writing :</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=n>search</span> <span class=o>=</span> <span class=n>freq_of</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=n>search</span> <span class=o>!=</span> <span class=n>freq_of</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Found&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Where assume, freq_of = map&lt;uint32_t, uint32_t&gt;{{3, 1}, {1, 1}, {2, 1}};
</span></span></span></code></pre></td></tr></table></div></div><ul><li>Rather, from C++20, you can write:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>freq_of</span><span class=p>.</span><span class=n>contains</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Found&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p><strong><em>The code we write is written first for human consumption & only secondarily for the computer to understand.</em></strong> <strong>- John Sonmez</strong></p></blockquote><h2 id=stdmaptry_emplacehttpsencppreferencecomwcppcontainermaptry_emplacec17><a href=https://en.cppreference.com/w/cpp/container/map/try_emplace>std::map::try_emplace</a>(C++17)<a hidden class=anchor aria-hidden=true href=#stdmaptry_emplacehttpsencppreferencecomwcppcontainermaptry_emplacec17>#</a></h2><ul><li>While inserting into the map, we have 2 different possibilities:<ol><li>The key doesn&rsquo;t exist yet. Create a fresh key-value pair.</li><li>The key does exist already. Take the existing item and modify it.</li></ol></li><li>A typical approach to insert an element in <code>std::map</code> is by using <code>operator[ ]</code>, <code>std::map::insert</code> or <code>std::map::emplace</code> . But, in all of these cases, we have to bear the cost of default/specialized constructor or assignment call. And the worst part is if an item already exists, we have to drop the freshly created item.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span> <span class=n>v</span><span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>freq_of</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>n</span> <span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=p>[</span><span class=n>it</span><span class=p>,</span> <span class=n>inserted</span><span class=p>]</span> <span class=o>=</span> <span class=n>freq_of</span><span class=p>.</span><span class=n>emplace</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=o>!</span><span class=n>inserted</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span><span class=o>++</span><span class=p>;</span>  <span class=c1>// Exists already
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>freq_of</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>==</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Instead:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=p>[</span><span class=n>it</span><span class=p>,</span> <span class=n>inserted</span><span class=p>]</span> <span class=o>=</span> <span class=n>freq_of</span><span class=p>.</span><span class=n>try_emplace</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=o>!</span><span class=n>inserted</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>But, since C++17, there is this <strong><em><code>std::map::try_emplace</code> method that creates items only if the key doesn&rsquo;t exist yet</em></strong>. This boosts the performance in case objects of that type are expensive to create.</li><li>Although the above example hasn&rsquo;t showcased the expensive to create items. But, yes! whenever you encounter such a situation, must be known how to handle it with <code>std::map::try_emplace</code>.</li></ul><h2 id=stdmapinsert_or_assignhttpsencppreferencecomwcppcontainermapinsert_or_assignc17><a href=https://en.cppreference.com/w/cpp/container/map/insert_or_assign>std::map::insert_or_assign</a>(C++17)<a hidden class=anchor aria-hidden=true href=#stdmapinsert_or_assignhttpsencppreferencecomwcppcontainermapinsert_or_assignc17>#</a></h2><ul><li>When you have to insert element anyhow. For the sake of convenience, you use <a href=https://en.cppreference.com/w/cpp/container/map/operator_at>std::map::operator[ ]</a>. Which is OK( and <a href="https://devblogs.microsoft.com/oldnewthing/20190227-00/?p=101072">dangerous</a>)! Unless you have any constraint on insertion or assignment.</li><li>For example, while counting the frequency of elements with the added constraint that when an element is repeated(i.e. assigned) you have to remove all the element lesser than the current one.</li><li>In such a situation, <code>std::map::operator[ ]</code> isn&rsquo;t feasible. Rather, <code>std::map::insert_or_assign</code> is more appropriate and returns more information than [<code>std::map::operator[ ]</code>](<code>std::map::operator[ ]</code>). It also does not require default-constructibility of the mapped type. Consider the following example for the same.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>vector</span> <span class=n>v</span><span class=p>{</span><span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>8</span><span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>freq_of</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;&amp;</span><span class=nl>n</span> <span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=p>[</span><span class=n>it</span><span class=p>,</span> <span class=n>is_inserted</span><span class=p>]</span> <span class=o>=</span> <span class=n>freq_of</span><span class=p>.</span><span class=n>insert_or_assign</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>is_inserted</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// remove all lesser element then current one if repeated
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>freq_of</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>begin</span><span class=p>(</span><span class=n>freq_of</span><span class=p>),</span> <span class=n>it</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>((</span><span class=n>freq_of</span> <span class=o>==</span> <span class=k>decltype</span><span class=p>(</span><span class=n>freq_of</span><span class=p>){</span>
</span></span><span class=line><span class=cl>						   <span class=p>{</span><span class=mi>8</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>						   <span class=p>{</span><span class=mi>9</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>					   <span class=p>}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=stdmapinserthttpsencppreferencecomwcppcontainermapinsert-with-hintc1117><a href=https://en.cppreference.com/w/cpp/container/map/insert>std::map::insert</a> With Hint(C++11/17)<a hidden class=anchor aria-hidden=true href=#stdmapinserthttpsencppreferencecomwcppcontainermapinsert-with-hintc1117>#</a></h2><ul><li>Looking up items in an <code>std::map</code> takes <code>O(log(n))</code> time. This is the same for inserting new items. Because the position where to insert them must looked up. Naive insertion of <code>M</code> new items would thus take <code>O(M * log(n))</code> time.</li><li>In order to make this more efficient, <code>std::map</code> insertion functions accept an optional insertion hint parameter. The insertion hint is basically an iterator, which points near the future position of the item that is to be inserted. If the hint is correct, then we get amortized <code>O(1)</code> insertion time.</li><li>This is quite useful from a performance point of view when the insertion sequence of items is somewhat predictable. For example:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>{{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>}};</span>
</span></span><span class=line><span class=cl>	<span class=k>auto</span> <span class=n>where</span><span class=p>(</span><span class=n>end</span><span class=p>(</span><span class=n>m</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>n</span> <span class=p>:</span> <span class=p>{</span><span class=mi>8</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>})</span> <span class=p>{</span> <span class=c1>// Items in non-incremental order
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>where</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>where</span><span class=p>,</span> <span class=p>{</span><span class=n>n</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>});</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// How it is not done!
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// m.insert(end(m), {0, &#34;&#34;});
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=p>[</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>]</span> <span class=o>:</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>key</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; : &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>A <strong><em>correct hint will point to an existing element, which is greater than the element to be inserted</em></strong> so that the newly inserted key will be just before the hint. If this does not apply for the hint the user provided during insertion, the insert function will fall back to a nonoptimized insertion, yielding `O(log(n)) performance again.</li><li>For the above example, the first insertion, we got the end iterator of the map, because we had no better hint to start with. After installing an 8 in the tree, we knew that installing 7 will insert a new item just in front of the 8, which qualified it to be a correct hint. This applies to 6 as well, if put into the tree after inserting the 7, and so on. This is why it is possible to use the iterator, which was returned in the last insertion for the next insertion.</li><li>You can play around the above example to justify the performance gain with <a href=https://quick-bench.com/q/gF1CXbPkzjOzLxKfRG7X-Uv8lfw>quick-benchmark</a>.</li></ul><p><em><strong>Note:</strong> It is important to know that before C++11, insertion hints were considered correct when they pointed before the position of the newly inserted item.</em></p><h2 id=stdmapmergehttpsencppreferencecomwcppcontainermapmergec17><a href=https://en.cppreference.com/w/cpp/container/map/merge>std::map::merge</a>(C++17)<a hidden class=anchor aria-hidden=true href=#stdmapmergehttpsencppreferencecomwcppcontainermapmergec17>#</a></h2><ul><li>Same as <a href=https://en.cppreference.com/w/cpp/container/list/splice>std::list:splice</a>, which transfers the elements from one list to another. we have <code>std::map::merge</code> which can merge the two same type of <code>std::map</code>.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span> <span class=n>fruits</span><span class=p>{{</span><span class=mi>5</span><span class=p>,</span> <span class=s>&#34;grapes&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;tomoto&#34;</span><span class=p>}};</span>
</span></span><span class=line><span class=cl>	<span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span> <span class=n>person</span><span class=p>{{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;mickel&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>10</span><span class=p>,</span> <span class=s>&#34;shree&#34;</span><span class=p>}};</span>
</span></span><span class=line><span class=cl>	<span class=n>map</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span> <span class=n>fruits_and_persons</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fruits_and_persons</span><span class=p>.</span><span class=n>merge</span><span class=p>(</span><span class=n>fruits</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>fruits</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fruits_and_persons</span><span class=p>.</span><span class=n>merge</span><span class=p>(</span><span class=n>person</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>person</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>(</span><span class=n>person</span><span class=p>.</span><span class=n>at</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>==</span> <span class=s>&#34;mickel&#34;</span><span class=p>);</span> <span class=c1>// Won&#39;t overwrite value at 2 i.e.`mickel`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>((</span><span class=n>fruits_and_persons</span> <span class=o>==</span> <span class=k>decltype</span><span class=p>(</span><span class=n>fruits</span><span class=p>){</span>
</span></span><span class=line><span class=cl>									  <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;tomoto&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>									  <span class=p>{</span><span class=mi>5</span><span class=p>,</span> <span class=s>&#34;grapes&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>									  <span class=p>{</span><span class=mi>10</span><span class=p>,</span> <span class=s>&#34;shree&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>								  <span class=p>}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The thing here to note is what happens when there are duplicates! <strong><em>The duplicated elements are not transferred. They&rsquo;re left behind in the right-hand-side map</em></strong>.</li></ul><h2 id=stdmapextracthttpsencppreferencecomwcppcontainermapextractc17><a href=https://en.cppreference.com/w/cpp/container/map/extract>std::map::extract</a>(C++17)<a hidden class=anchor aria-hidden=true href=#stdmapextracthttpsencppreferencecomwcppcontainermapextractc17>#</a></h2><ul><li>Unlike <code>std::map::merge</code> that transfers the elements in bulk, <strong><em><code>std::map::extract</code> along with <code>std::map::insert</code> transfers element piecewise</em></strong>. But what is the more compelling application of <code>std::map::extract</code> is modifying keys.</li><li>As we know, for <code>std::map</code> keys are always unique and sorted. Hence, It is crucial that users cannot modify the keys of map nodes that are already inserted. In order to prevent the user from modifying the key items of perfectly sorted map nodes, the <a href=/posts/when-to-use-const-vs-constexpr-in-cpp/>const</a> qualifier is added to the key type.</li><li>This kind of restriction is perfectly valid because it makes harder for the user to use <code>std::map</code> the wrong way. But what if we really need to change the keys of some map items?</li><li>Prior to C++17, we had to remove & reinsert the items in order to change the key. The downside of this approach is memory allocation & deallocation, which sounds bad in terms of performance. But, from C++17, we can remove & reinsert std::map nodes without any reallocation of memory.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span> <span class=n>race_scoreboard</span><span class=p>{{</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;Mickel&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;Shree&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;Jenti&#34;</span><span class=p>}};</span>
</span></span><span class=line><span class=cl>	<span class=k>using</span> <span class=n>Pair</span> <span class=o>=</span> <span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;::</span><span class=n>value_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>auto</span> <span class=n>Jenti</span><span class=p>(</span><span class=n>race_scoreboard</span><span class=p>.</span><span class=n>extract</span><span class=p>(</span><span class=mi>3</span><span class=p>));</span>
</span></span><span class=line><span class=cl>		<span class=k>auto</span> <span class=n>Mickel</span><span class=p>(</span><span class=n>race_scoreboard</span><span class=p>.</span><span class=n>extract</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>swap</span><span class=p>(</span><span class=n>Jenti</span><span class=p>.</span><span class=n>key</span><span class=p>(),</span> <span class=n>Mickel</span><span class=p>.</span><span class=n>key</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>auto</span> <span class=p>[</span><span class=n>it</span><span class=p>,</span> <span class=n>is_inserted</span><span class=p>,</span> <span class=n>nh</span><span class=p>]</span> <span class=o>=</span> <span class=n>race_scoreboard</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>move</span><span class=p>(</span><span class=n>Jenti</span><span class=p>));</span> <span class=c1>// nh = node handle
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>assert</span><span class=p>(</span><span class=o>*</span><span class=n>it</span> <span class=o>==</span> <span class=n>Pair</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;Jenti&#34;</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>is_inserted</span> <span class=o>==</span> <span class=nb>true</span> <span class=o>&amp;&amp;</span> <span class=n>nh</span><span class=p>.</span><span class=n>empty</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>race_scoreboard</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>move</span><span class=p>(</span><span class=n>Mickel</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>assert</span><span class=p>((</span><span class=n>race_scoreboard</span> <span class=o>==</span> <span class=k>decltype</span><span class=p>(</span><span class=n>race_scoreboard</span><span class=p>){</span>
</span></span><span class=line><span class=cl>								   <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;Jenti&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>								   <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;Shree&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>								   <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;Mickel&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>							   <span class=p>}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Consider the above example of the racing scoreboard where you have employed <code>std::map</code> to imitate the racing position. And after a while, Jenti took the lead & Mickel left behind. In this case, how we have switched the keys(position on a race track) of those players.</li><li><code>std::map::extract</code> comes in two flavours:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>node_type</span> <span class=nf>extract</span><span class=p>(</span><span class=n>const_iterator</span> <span class=n>position</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>node_type</span> <span class=nf>extract</span><span class=p>(</span><span class=k>const</span> <span class=n>key_type</span><span class=o>&amp;</span> <span class=n>x</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>In the above example, we used the second one, which accepts a key and then finds & extracts the map node that matches the key parameter. The first one accepts an iterator, which implies that it is faster because it doesn&rsquo;t need to search for the item.</li></ul><h3 id=what-if-the-node-with-a-particular-key-does-not-exist>What If the Node With a Particular Key Does Not Exist?<a hidden class=anchor aria-hidden=true href=#what-if-the-node-with-a-particular-key-does-not-exist>#</a></h3><ul><li>If we try to extract an item that doesn&rsquo;t exist with the second method (the one that searches using a key), it <strong><em>returns an empty <code>node_type</code> instance i.e. node handle</em></strong>. The <code>empty()</code>member method or overloaded bool operator tells us that whether a <code>node_type</code> instance is empty or not.</li></ul><h3 id=ok-then-how-do-i-modify-stdmap-keys>OK! Then How Do I Modify std::map Keys?<a hidden class=anchor aria-hidden=true href=#ok-then-how-do-i-modify-stdmap-keys>#</a></h3><ul><li>After extracting nodes, we were able to modify their keys <strong><em>using the <code>key()</code>method</em></strong>, which gives us non-const access to the key, although keys are usually <a href=/posts/when-to-use-const-vs-constexpr-in-cpp/>const</a>.</li><li>Note that in order to reinsert the nodes into the map again, we had to move them into the insert function. This makes sense because the extract is all about avoiding unnecessary copies and allocations. Moreover, while we move a <code>node_type</code> instance, this does not result in actual moves of any of the container values.</li></ul><h3 id=can-i-modify-associated-values-in-stdmap-also>Can I Modify Associated Values in std::map Also?<a hidden class=anchor aria-hidden=true href=#can-i-modify-associated-values-in-stdmap-also>#</a></h3><ul><li>Yes! You can <strong>_use the accessor methods <code>nh.mapped()</code></strong>(instead of <code>nh.key()</code> to manipulate the pieces of the entry in a <code>std::map</code> (or <code>nh.value()</code>for the single piece of data in an element of a <code>std::set</code>). Thus you can extract, manipulate, and reinsert a key without ever copying or moving its actual data.</li></ul><h3 id=but-what-about-safety>But What About Safety?<a hidden class=anchor aria-hidden=true href=#but-what-about-safety>#</a></h3><ul><li>If you extract a node from a map and then throw an <a href=/posts/7-best-practices-for-exception-handling-in-cpp-with-example/>exception</a> before you&rsquo;ve managed to re-insert it into the destination map.</li><li>A node handle&rsquo;s destructor is called and will correctly clean up the memory associated with the node. So, technically <strong><em><code>std::map::extract</code> by-default(without insert) will act as <a href=https://en.cppreference.com/w/cpp/container/map/erase>std::map::erase</a></em></strong>!</li></ul><h3 id=there-is-more-interoperability>There Is More! Interoperability<a hidden class=anchor aria-hidden=true href=#there-is-more-interoperability>#</a></h3><ul><li>Map nodes that have been extracted using the <code>std::map::extract</code> are actually very versatile. <strong><em>We can extract nodes from a map instance and insert it into any other map or even multimap instance</em></strong>.</li><li>It does also work between <a href=https://en.cppreference.com/w/cpp/container/unordered_map>unordered_map</a> and <a href=https://en.cppreference.com/w/cpp/container/unordered_multimap>unordered_multimap</a> instances, as well as with <a href=https://en.cppreference.com/w/cpp/container/set>set</a>/<a href=https://en.cppreference.com/w/cpp/container/multiset>multiset</a> and respective <a href=https://en.cppreference.com/w/cpp/container/unordered_set>unordered_set</a>/<a href=https://en.cppreference.com/w/cpp/container/unordered_multiset>unordered_multiset</a>.</li><li>In order to move items between different map/set structures, the types of key, value and allocator need to be identical.</li></ul><h2 id=difference-between-operator--vs-insert-vs-at>Difference Between operator[ ] vs insert() vs at()<a hidden class=anchor aria-hidden=true href=#difference-between-operator--vs-insert-vs-at>#</a></h2><p>This is trivial for experienced devs but, still I want to go over it quickly.</p><h3 id=stdmapoperator-httpsencppreferencecomwcppcontainermapoperator_at><a href=https://en.cppreference.com/w/cpp/container/map/operator_at>std::map::operator[ ]</a><a hidden class=anchor aria-hidden=true href=#stdmapoperator-httpsencppreferencecomwcppcontainermapoperator_at>#</a></h3><ul><li><strong>Operation</strong>: find-or-add; try to find an element with the given key inside the map, and if it exists it will return a reference to the stored value. If it does not, it will create a new element inserted in place with default initialization and return a reference to it.</li><li><strong>Applicability</strong>:<ul><li>Not usable for <code>const std::map</code>, as it will create the element if it doesn&rsquo;t exist.</li><li>Not suitable for value type that does not default constructible and assignable(in layman term, doesn&rsquo;t have default constructor & copy/move constructor).</li></ul></li><li><strong>When key exists</strong>: Overwrites it.</li></ul><h3 id=stdmapinserthttpsencppreferencecomwcppcontainermapinsert><a href=https://en.cppreference.com/w/cpp/container/map/insert>std::map::insert</a><a hidden class=anchor aria-hidden=true href=#stdmapinserthttpsencppreferencecomwcppcontainermapinsert>#</a></h3><ul><li><strong>Operation</strong>: insert-or-nop; accepts a value_type (<code>std::pair</code>) and uses the key(first member) and to insert it. As<code>std::map</code> does not allow for duplicates, if there is an existing element it will not insert anything.</li><li><strong>Applicability</strong>:<ul><li>Liberty in calling insert different ways that require the creation of the value_type externally and the copy of that object into the container.</li><li>Highly applicable when item insertion sequence is somewhat predictable to gain the performance.</li></ul></li><li><strong>When key exists</strong>: Not modify the state of the map, but instead return an iterator to the element that prevented the insertion.</li></ul><h3 id=stdmapathttpsencppreferencecomwcppcontainermapat><a href=https://en.cppreference.com/w/cpp/container/map/at>std::map::at</a><a hidden class=anchor aria-hidden=true href=#stdmapathttpsencppreferencecomwcppcontainermapat>#</a></h3><ul><li><strong>Operation</strong>: find-or-throw; returns a reference to the mapped value of the element with key equivalent to input key. If no such element exists, an <a href=/posts/7-best-practices-for-exception-handling-in-cpp-with-example/>exception</a> of type <a href=https://en.cppreference.com/w/cpp/error/out_of_range>std::out_of_range</a> is thrown.</li><li><strong>Applicability</strong>:<ul><li>Not recommended using <code>at()</code>when accessing const maps and when element absence is a logic error.</li><li>Yes, it&rsquo;s better to use <code>std::map::find()</code>when you&rsquo;re not sure element is there. Because, throwing and catching <a href=https://en.cppreference.com/w/cpp/error/logic_error>std::logic_error</a> exception will not be a very elegant way of programming, even if we don&rsquo;t think about performance.</li></ul></li><li><strong>When key exists</strong>: returns a reference to mapped value.</li></ul><h2 id=parting-words>Parting Words<a hidden class=anchor aria-hidden=true href=#parting-words>#</a></h2><p>If you see the table of content for this article above, more than half of the member functions are around inserting the elements into the map. To the newbie, this is the reason for anxiety(or standard committee would say modernness). But if you account for the new features & complexity of language those are pretty much justified. BTW, this modernness doesn&rsquo;t stop here, we do have other specialization also available for map like <a href=https://en.cppreference.com/w/cpp/container/map/swap2>std::swap</a>(C++17), <a href=https://en.cppreference.com/w/cpp/container/map/erase_if>std::erase_if</a>(C++20) & bunch of comparison operators.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/c-map-check-if-key-exists/>C-Map-Check-if-Key-Exists</a></li><li><a href=http://localhost:1313/tags/c-map-class/>C-Map-Class</a></li><li><a href=http://localhost:1313/tags/c-map-comparator/>C-Map-Comparator</a></li><li><a href=http://localhost:1313/tags/c-map-data-structure/>C-Map-Data-Structure</a></li><li><a href=http://localhost:1313/tags/c-map-empty/>C-Map-Empty</a></li><li><a href=http://localhost:1313/tags/c-map-end/>C-Map-End</a></li><li><a href=http://localhost:1313/tags/c-map-examples/>C-Map-Examples</a></li><li><a href=http://localhost:1313/tags/c-map-find-example/>C-Map-Find-Example</a></li><li><a href=http://localhost:1313/tags/c-map-function/>C-Map-Function</a></li><li><a href=http://localhost:1313/tags/c-map-get-value-by-key/>C-Map-Get-Value-by-Key</a></li><li><a href=http://localhost:1313/tags/c-map-greater/>C-Map-Greater</a></li><li><a href=http://localhost:1313/tags/c-map-in-map/>C-Map-in-Map</a></li><li><a href=http://localhost:1313/tags/c-map-initialization/>C-Map-Initialization</a></li><li><a href=http://localhost:1313/tags/c-map-iterator/>C-Map-Iterator</a></li><li><a href=http://localhost:1313/tags/c-map-iterator-first/>C-Map-Iterator-First</a></li><li><a href=http://localhost:1313/tags/c-map-loop/>C-Map-Loop</a></li><li><a href=http://localhost:1313/tags/c-map-methods/>C-Map-Methods</a></li><li><a href=http://localhost:1313/tags/c-map-of-classes/>C-Map-of-Classes</a></li><li><a href=http://localhost:1313/tags/c-map-of-lists/>C-Map-of-Lists</a></li><li><a href=http://localhost:1313/tags/c-map-of-maps/>C-Map-of-Maps</a></li><li><a href=http://localhost:1313/tags/c-map-of-objects/>C-Map-of-Objects</a></li><li><a href=http://localhost:1313/tags/c-map-of-vectors/>C-Map-of-Vectors</a></li><li><a href=http://localhost:1313/tags/c-map-performance/>C-Map-Performance</a></li><li><a href=http://localhost:1313/tags/c-map-reduce/>C-Map-Reduce</a></li><li><a href=http://localhost:1313/tags/c-map-reserve/>C-Map-Reserve</a></li><li><a href=http://localhost:1313/tags/c-map-struct-as-key/>C-Map-Struct-as-Key</a></li><li><a href=http://localhost:1313/tags/c-map-struct-key/>C-Map-Struct-Key</a></li><li><a href=http://localhost:1313/tags/c-map-template/>C-Map-Template</a></li><li><a href=http://localhost:1313/tags/c-map-template-example/>C-Map-Template-Example</a></li><li><a href=http://localhost:1313/tags/c-map-to-vector/>C-Map-to-Vector</a></li><li><a href=http://localhost:1313/tags/c-map-usage/>C-Map-Usage</a></li><li><a href=http://localhost:1313/tags/c-map-vector/>C-Map-Vector</a></li><li><a href=http://localhost:1313/tags/c-map-with-custom-comparator/>C-Map-With-Custom-Comparator</a></li><li><a href=http://localhost:1313/tags/c-remove_if-map/>C-Remove_if-Map</a></li><li><a href=http://localhost:1313/tags/c-std-hash-map/>C-Std-Hash-Map</a></li><li><a href=http://localhost:1313/tags/c-stl-map/>C-Stl-Map</a></li><li><a href=http://localhost:1313/tags/c-stl-map-example/>C-Stl-Map-Example</a></li><li><a href=http://localhost:1313/tags/c-vector-to-map/>C-Vector-to-Map</a></li><li><a href=http://localhost:1313/tags/can-i-modify-associated-values-in-stdmap-also/>Can-I-Modify-Associated-Values-in-Stdmap-Also</a></li><li><a href=http://localhost:1313/tags/const-map-c/>Const-Map-C</a></li><li><a href=http://localhost:1313/tags/cpp-std-map/>Cpp-Std-Map</a></li><li><a href=http://localhost:1313/tags/cpp-std-map-example/>Cpp-Std-Map-Example</a></li><li><a href=http://localhost:1313/tags/cppreference-map/>Cppreference-Map</a></li><li><a href=http://localhost:1313/tags/difference-between-operator-vs-insert-vs-at/>Difference-Between-Operator-vs-Insert-vs-At</a></li><li><a href=http://localhost:1313/tags/map-c-stl/>Map-C-Stl</a></li><li><a href=http://localhost:1313/tags/map-std-c/>Map-Std-C</a></li><li><a href=http://localhost:1313/tags/multimap-stl/>Multimap-Stl</a></li><li><a href=http://localhost:1313/tags/ok-then-how-do-i-modify-stdmap-keys/>Ok-Then-How-Do-I-Modify-Stdmap-Keys</a></li><li><a href=http://localhost:1313/tags/ordered-map-c/>Ordered-Map-C</a></li><li><a href=http://localhost:1313/tags/static-map-c/>Static-Map-C</a></li><li><a href=http://localhost:1313/tags/std-hash-map/>Std-Hash-Map</a></li><li><a href=http://localhost:1313/tags/std-map-c/>Std-Map-C</a></li><li><a href=http://localhost:1313/tags/std-map-vector/>Std-Map-Vector</a></li><li><a href=http://localhost:1313/tags/std-unsorted-map/>Std-Unsorted-Map</a></li><li><a href=http://localhost:1313/tags/stdmap-example/>Stdmap-Example</a></li><li><a href=http://localhost:1313/tags/stdmap-find/>Stdmap-Find</a></li><li><a href=http://localhost:1313/tags/stdmap-insert/>Stdmap-Insert</a></li><li><a href=http://localhost:1313/tags/stdmapat/>Stdmapat</a></li><li><a href=http://localhost:1313/tags/stdmapcontainsc20/>Stdmapcontainsc20</a></li><li><a href=http://localhost:1313/tags/stdmapextractc17/>Stdmapextractc17</a></li><li><a href=http://localhost:1313/tags/stdmapinsert/>Stdmapinsert</a></li><li><a href=http://localhost:1313/tags/stdmapinsert-with-hintc11-17/>Stdmapinsert-With-Hintc11-17</a></li><li><a href=http://localhost:1313/tags/stdmapinsert_or_assignc17/>Stdmapinsert_or_assignc17</a></li><li><a href=http://localhost:1313/tags/stdmapmergec17/>Stdmapmergec17</a></li><li><a href=http://localhost:1313/tags/stdmapoperator/>Stdmapoperator</a></li><li><a href=http://localhost:1313/tags/stdmaptry_emplacec17/>Stdmaptry_emplacec17</a></li><li><a href=http://localhost:1313/tags/stl-c-map/>Stl-C-Map</a></li><li><a href=http://localhost:1313/tags/unordered_map-c/>Unordered_map-C</a></li><li><a href=http://localhost:1313/tags/what-if-the-node-with-a-particular-key-does-not-exist/>What-if-the-Node-With-a-Particular-Key-Does-Not-Exist</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/regex-c/><span class=title>« Prev</span><br><span>Regex C++</span>
</a><a class=next href=http://localhost:1313/posts/crtp-c-examples/><span class=title>Next »</span><br><span>CRTP C++ Examples</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Using std::map Wisely With Modern C++ on x" href="https://x.com/intent/tweet/?text=Using%20std%3a%3amap%20Wisely%20With%20Modern%20C%2b%2b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fusing-std-map-wisely-with-modern-cpp%2f&amp;hashtags=c-map-check-if-key-exists%2cc-map-class%2cc-map-comparator%2cc-map-data-structure%2cc-map-empty%2cc-map-end%2cc-map-examples%2cc-map-find-example%2cc-map-function%2cc-map-get-value-by-key%2cc-map-greater%2cc-map-in-map%2cc-map-initialization%2cc-map-iterator%2cc-map-iterator-first%2cc-map-loop%2cc-map-methods%2cc-map-of-classes%2cc-map-of-lists%2cc-map-of-maps%2cc-map-of-objects%2cc-map-of-vectors%2cc-map-performance%2cc-map-reduce%2cc-map-reserve%2cc-map-struct-as-key%2cc-map-struct-key%2cc-map-template%2cc-map-template-example%2cc-map-to-vector%2cc-map-usage%2cc-map-vector%2cc-map-with-custom-comparator%2cc-remove_if-map%2cc-std-hash-map%2cc-stl-map%2cc-stl-map-example%2cc-vector-to-map%2ccan-i-modify-associated-values-in-stdmap-also%2cconst-map-c%2ccpp-std-map%2ccpp-std-map-example%2ccppreference-map%2cdifference-between-operator-vs-insert-vs-at%2cmap-c-stl%2cmap-std-c%2cmultimap-stl%2cok-then-how-do-i-modify-stdmap-keys%2cordered-map-c%2cstatic-map-c%2cstd-hash-map%2cstd-map-c%2cstd-map-vector%2cstd-unsorted-map%2cstdmap-example%2cstdmap-find%2cstdmap-insert%2cstdmapat%2cstdmapcontainsc20%2cstdmapextractc17%2cstdmapinsert%2cstdmapinsert-with-hintc11-17%2cstdmapinsert_or_assignc17%2cstdmapmergec17%2cstdmapoperator%2cstdmaptry_emplacec17%2cstl-c-map%2cunordered_map-c%2cwhat-if-the-node-with-a-particular-key-does-not-exist"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using std::map Wisely With Modern C++ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fusing-std-map-wisely-with-modern-cpp%2f&amp;title=Using%20std%3a%3amap%20Wisely%20With%20Modern%20C%2b%2b&amp;summary=Using%20std%3a%3amap%20Wisely%20With%20Modern%20C%2b%2b&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fusing-std-map-wisely-with-modern-cpp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using std::map Wisely With Modern C++ on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fusing-std-map-wisely-with-modern-cpp%2f&title=Using%20std%3a%3amap%20Wisely%20With%20Modern%20C%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using std::map Wisely With Modern C++ on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fusing-std-map-wisely-with-modern-cpp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using std::map Wisely With Modern C++ on whatsapp" href="https://api.whatsapp.com/send?text=Using%20std%3a%3amap%20Wisely%20With%20Modern%20C%2b%2b%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fusing-std-map-wisely-with-modern-cpp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using std::map Wisely With Modern C++ on telegram" href="https://telegram.me/share/url?text=Using%20std%3a%3amap%20Wisely%20With%20Modern%20C%2b%2b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fusing-std-map-wisely-with-modern-cpp%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using std::map Wisely With Modern C++ on ycombinator" href="https://news.ycombinator.com/submitlink?t=Using%20std%3a%3amap%20Wisely%20With%20Modern%20C%2b%2b&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fusing-std-map-wisely-with-modern-cpp%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>