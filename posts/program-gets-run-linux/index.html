<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How Program Gets Run: Linux | Vishal Chovatiya</title>
<meta name=keywords content="bash-shell,elf-format,how-program-gets-run"><meta name=description content="I know it’s long, but please bear with me & have patience.
How do we launch our programs? Do you know how programs get runs behind the screen when you double-click on it or you type ./a.out on shell As you know, the standard way to launch an application from a shell is to start terminal emulator application & just write the name of the program & pass or not arguments to our program, for example: 1 2 3 4 5 6 7 8 [vishal@machine Desktop]$ ls --version ls (GNU coreutils) 8."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/program-gets-run-linux/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/images/trident_favicon.webp><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/images/trident_favicon.webp><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/images/trident_favicon.webp><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/images/trident_favicon.webp><link rel=mask-icon href=https://vishalchovatiya.github.io/images/trident_favicon.webp><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/program-gets-run-linux/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How Program Gets Run: Linux"><meta property="og:description" content="I know it’s long, but please bear with me & have patience.
How do we launch our programs? Do you know how programs get runs behind the screen when you double-click on it or you type ./a.out on shell As you know, the standard way to launch an application from a shell is to start terminal emulator application & just write the name of the program & pass or not arguments to our program, for example: 1 2 3 4 5 6 7 8 [vishal@machine Desktop]$ ls --version ls (GNU coreutils) 8."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/program-gets-run-linux/"><meta property="og:image" content="https://vishalchovatiya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-09-25T00:00:00+00:00"><meta property="article:modified_time" content="2016-09-25T00:00:00+00:00"><meta property="og:site_name" content="Vishal Chovatiya"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="How Program Gets Run: Linux"><meta name=twitter:description content="I know it’s long, but please bear with me & have patience.
How do we launch our programs? Do you know how programs get runs behind the screen when you double-click on it or you type ./a.out on shell As you know, the standard way to launch an application from a shell is to start terminal emulator application & just write the name of the program & pass or not arguments to our program, for example: 1 2 3 4 5 6 7 8 [vishal@machine Desktop]$ ls --version ls (GNU coreutils) 8."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"How Program Gets Run: Linux","item":"https://vishalchovatiya.github.io/posts/program-gets-run-linux/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How Program Gets Run: Linux","name":"How Program Gets Run: Linux","description":"I know it’s long, but please bear with me \u0026amp; have patience.\nHow do we launch our programs? Do you know how programs get runs behind the screen when you double-click on it or you type ./a.out on shell As you know, the standard way to launch an application from a shell is to start terminal emulator application \u0026amp; just write the name of the program \u0026amp; pass or not arguments to our program, for example: 1 2 3 4 5 6 7 8 [vishal@machine Desktop]$ ls --version ls (GNU coreutils) 8.","keywords":["bash-shell","elf-format","how-program-gets-run"],"articleBody":"I know it’s long, but please bear with me \u0026 have patience.\nHow do we launch our programs? Do you know how programs get runs behind the screen when you double-click on it or you type ./a.out on shell As you know, the standard way to launch an application from a shell is to start terminal emulator application \u0026 just write the name of the program \u0026 pass or not arguments to our program, for example: 1 2 3 4 5 6 7 8 [vishal@machine Desktop]$ ls --version ls (GNU coreutils) 8.22 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later . This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Written by Richard M. Stallman and David MacKenzie. Get In To Bash : /dev/tty Sanity Checks So let’s start with the main function of bash shell. If you will look on the source code of the bash shell, you will find the main function in the shell.c source code file which makes many different things before the main thread loop of the bash started to work. For example this function: checks and tries to open /dev/tty check that shell running in debug mode parse command-line arguments reads shell environment loads .bashrc, .profile and other configuration files and many more. Creating Environment After all of these operations, you can see the call of the reader_loop function defined in the eval.c which reads the given program name \u0026 arguments, then it calls the execute_command function from the execute_cmd.c which in turn calls following function chain which makes different checks like do we need to start subshell, was it built-in bash function or not etc. 1 2 3 4 5 execute_command --\u003e execute_command_internal ----\u003e execute_simple_command ------\u003e execute_disk_command --------\u003e shell_execve In the end of this process, the shell_execve function calls the execve system call which has the following signature 1 int execve(const char *filename, char *const argv [], char *const envp[]); Executes a program by the given filename, with the given arguments and environment variables. So, a user application (bash in our case) calls the system call \u0026 as we already know the next step is the Linux kernel. Get Into Kernel: execve System Call execve System Call Implementation This system call defined in the fs/exec.c source code file \u0026 has following signature : 1 2 3 4 5 6 7 SYSCALL_DEFINE3(execve, const char __user *, filename, const char __user *const __user *, argv, const char __user *const __user *, envp) { return do_execve(getname(filename), argv, envp); } Implementation of the execve is pretty simple here, as we can see it just returns the result of the do_execve function which initialize two pointers on a userspace data with the given arguments and environment variables \u0026 return the result of the do_execveat_common. We can see its implementation:\n1 2 3 4 5 6 7 8 int do_execve(struct filename *filename, const char __user *const __user *__argv, const char __user *const __user *__envp) { struct user_arg_ptr argv = { .ptr.native = __argv }; struct user_arg_ptr envp = { .ptr.native = __envp }; return do_execveat_common(AT_FDCWD, filename, argv, envp, 0); } The do_execveat_common function takes a similar set of arguments, but having 2 extra arguments. Sanity Checks The first argument AT_FDCWD is the file descriptor of current directory \u0026 fifth argument is flags. which we will see later. do_execveat_common function checks the filename pointer \u0026 returns if it is NULL. After this it check flags of the current process that limit of running processes is not exceeded: 1 2 3 4 5 6 7 8 9 10 if (IS_ERR(filename)) return PTR_ERR(filename); if ((current-\u003eflags \u0026 PF_NPROC_EXCEEDED) \u0026\u0026 atomic_read(¤t_user()-\u003eprocesses) \u003e rlimit(RLIMIT_NPROC)) { retval = -EAGAIN; goto out_ret; } current-\u003eflags \u0026= ~PF_NPROC_EXCEEDED; If these two checks were successful we unset PF_NPROC_EXCEEDED flag in the flags of the current process to prevent failure of the execve. In the next step we call the unshare_files function that defined in the kernel/fork.c and unshares the files of the current task and check the result of this function: 1 2 3 retval = unshare_files(\u0026displaced); if (retval) goto out_ret; We need to call this function to eliminate potential leak of the execve'd binary’s file descriptor. In the next step, we start preparation of the bprm that represented by the struct linux_binprm structure (defined in the include/linux/binfmts.h header file). Preparing Binary Parameter Struct struct linux_binprm The linux_binprm structure is used to hold the arguments that are used when loading binaries. For example it contains vm_area_struct which represents a single memory area over a contiguous interval in a given address space where our application will be loaded mm field which is memory descriptor of the binary, pointer to the top of memory and many other different fields. Allocating Memory 1 2 3 bprm = kzalloc(sizeof(*bprm), GFP_KERNEL); if (!bprm) goto out_files; Preparing Credentials 1 2 3 4 5 6 retval = prepare_bprm_creds(bprm); if (retval) goto out_free; check_unsafe_exec(bprm); current-\u003ein_execve = 1; Initialization of the cred structure that stored inside of the linux_binprm structure contains the security context of a task, for example real uid of the task, real guid of the task, uid and guid for the virtual file system operations etc. In the next step, the call of the check_unsafe_exec function set the current process to the in_execve state. Set-up \u0026 Schedule Binary After all of these operations, we call the do_open_execat function which\n- Searches \u0026 opens executable file on disk \u0026 checks that,\n- load a binary file from noexec mount points bypassed flag 0 (we need to avoid execute a binary from filesystems that do not contain executable binaries like proc or sysfs),\n- initialize file structure \u0026 returns pointer on this structure. Next, we can see the call the sched_exec after this. The sched_exec function is used to determine the least loaded processor that can execute the new program \u0026 to migrate the current process to it. 1 2 3 4 5 6 file = do_open_execat(fd, filename, flags); retval = PTR_ERR(file); if (IS_ERR(file)) goto out_unmark; sched_exec(); After this, we need to check file descriptor of the give executable binary. We try to check does the name of the our binary file starts from the / symbol or does the path of the given executable binary is interpreted relative to the current working directory of the calling process or in other words file descriptor is AT_FDCWD. If one of these checks is successful we set the binary parameter filename: 1 2 3 4 5 bprm-\u003efile = file; if (fd == AT_FDCWD || filename-\u003ename[0] == '/') { bprm-\u003efilename = filename-\u003ename; } Otherwise, if the filename is empty we set the binary parameter filename to the /dev/fd/%d or /dev/fd/%d/%s depends on the filename of the given executable binary which means that we will execute the file to which the file descriptor refers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 } else { if (filename-\u003ename[0] == '\\0') pathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd); else pathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\tfd, filename-\u003ename); if (!pathbuf) { retval = -ENOMEM; goto out_unmark; } bprm-\u003efilename = pathbuf; } bprm-\u003einterp = bprm-\u003efilename; Note that we set not only the bprm-\u003efilename but also bprm-\u003einterp that will contain the name of the program interpreter. For now we just write the same name there, but later it will be updated with the real name of the program interpreter depends on the binary format of a program. Preparing Memory Related Info 1 2 3 retval = bprm_mm_init(bprm); if (retval) goto out_unmark; The bprm_mm_init defined in the same source code file initializes mm_struct structure \u0026 populate it with a temporary stack vm_area_struct which is defined in the include/linux/mm_types.h header file \u0026 represents address space of a process. Counting Command Line Args \u0026 Environment Variables 1 2 3 4 5 6 7 bprm-\u003eargc = count(argv, MAX_ARG_STRINGS); if ((retval = bprm-\u003eargc) \u003c 0) goto out; bprm-\u003eenvc = count(envp, MAX_ARG_STRINGS); if ((retval = bprm-\u003eenvc) \u003c 0) goto out; As you can see, MAX_ARG_STRINGS is the upper limit macro defined in the header file represents maximum number of strings that were passed to the execve system call. The value of the MAX_ARG_STRINGS: 1 #define MAX_ARG_STRINGS 0x7FFFFFFF Reading Binary(ELF) File Now, the call of prepare_binprm function fills the linux_binprm structure with the uid from inode and read 128 bytes from the binary executable file. We read only first 128 from the executable file because we need to check a type of our executable. We will read the rest of the executable file in the later step. 1 2 3 retval = prepare_binprm(bprm); if (retval \u003c 0) goto out; After the preparation of the linux_bprm structure we copy the filename of the executable binary file, command-line arguments and environment variables to the linux_bprm from the kernel with the call of the copy_strings_kernel function: 1 2 3 4 5 6 7 8 9 10 11 retval = copy_strings_kernel(1, \u0026bprm-\u003efilename, bprm); if (retval \u003c 0) goto out; retval = copy_strings(bprm-\u003eenvc, envp, bprm); if (retval \u003c 0) goto out; retval = copy_strings(bprm-\u003eargc, argv, bprm); if (retval \u003c 0) goto out; And set the pointer to the top of the new program’s stack that we set in the bprm_mm_init function bprm-\u003eexec = bprm-\u003ep; The top of the stack will contain the program filename and we store this filename to the exec field of the linux_bprm structure. Processing Binary Parameter Struct Call to exec_binprm function stores the pid from the namespace of the current task before it changes 1 2 3 retval = exec_binprm(bprm); if (retval \u003c 0) goto out; and call the: search_binary_handler(bprm);\nWhich goes through the list of handlers that contains different binary formats. Currently the Linux kernel supports following binary formats:\nbinfmt_script support for interpreted scripts that start from the #! line;\nbinfmt_misc - support different binary formats, according to runtime configuration of the Linux kernel;\nbinfmt_elf - support elf format;\nbinfmt_aout - support a.out format;\nbinfmt_flat - support for flat format;\nbinfmt_elf_fdpic - Support for elf FDPIC binaries;\nbinfmt_em86 - support for Intel elf binaries running on Alpha machines.\nSo, the search_binary_handler tries to call the load_binary function and pass linux_binprm to it. If the binary handler supports the given executable file format, it starts to prepare the executable binary for execution:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int search_binary_handler(struct linux_binprm *bprm) { ... ... ... list_for_each_entry(fmt, \u0026formats, lh) { retval = fmt-\u003eload_binary(bprm); if (retval \u003c 0 \u0026\u0026 !bprm-\u003emm) { force_sigsegv(SIGSEGV, current); return retval; } } return retval; Where the load_binary for example checks the magic number (each elf binary file contains magic number in the header) in the linux_bprm buffer (remember that we read first 128 bytes from the executable binary file) \u0026 exit if it is not elf binary: Executing Binary Sanity Checks If the given executable file is in elf format, the load_elf_binary continues \u0026 checks the architecture and type of the executable file and exit if there is wrong architecture and executable file non-executable non shared: 1 2 3 4 if (loc-\u003eelf_ex.e_type != ET_EXEC \u0026\u0026 loc-\u003eelf_ex.e_type != ET_DYN) goto out; if (!elf_check_arch(\u0026loc-\u003eelf_ex)) goto out; Setup Process Address Space \u0026 Dependencies Tries to load the program header table that describes segments. Read the program interpreter and libraries that linked with the our executable binary file from disk and load it to memory. 1 2 3 elf_phdata = load_elf_phdrs(\u0026loc-\u003eelf_ex, bprm-\u003efile); if (!elf_phdata) goto out; The program interpreter specified in the .interp section of the executable file (in most cases, linker is - /lib64/ld-linux-x86-64.so.2 for the x86_64). It setups the stack and map elf binary into the correct location in memory. It maps the bss and the brk sections and does many other different things to prepare executable file to execute. In the end of the execution of the load_elf_binary we call the start_thread function and pass three arguments to it: 1 2 3 4 5 6 start_thread(regs, elf_entry, bprm-\u003ep); retval = 0; out: kfree(loc); out_ret: return retval; These Arguments are: Set of registers for the new task Address of the entry point of the new task Address of the top of the stack for the new task As we can understand from the function’s name, it starts a new thread, but it is not so. The start_thread function just prepares new task’s registers to be ready to run. Let’s look at the implementation of this function: 1 2 3 4 5 6 void start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp) { start_thread_common(regs, new_ip, new_sp, __USER_CS, __USER_DS, 0); } As we can see the start_thread function just makes a call of the start_thread_common function that will do all for us. Put The Process On-Core 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static void start_thread_common(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp, unsigned int _cs, unsigned int _ss, unsigned int _ds) { loadsegment(fs, 0); loadsegment(es, _ds); loadsegment(ds, _ds); load_gs_index(0); regs-\u003eip = new_ip; regs-\u003esp = new_sp; regs-\u003ecs = _cs; regs-\u003ess = _ss; regs-\u003eflags = X86_EFLAGS_IF; force_iret(); } The start_thread_common function fills fs segment register with zero and es \u0026 ds with the value of the data segment register. After this we set new values to the instruction pointer, cs segments etc. At the end of the start_thread_common function we can see the force_iret macro that force a system call return via iret instruction. Ok, we prepared new thread to run in userspace and now we can return from the exec_binprm and now we are in the do_execveat_common again. After the exec_binprm will finish its execution we release memory for structures that were allocated before and return. After we returned from the execve system call handler, execution of our program will be started. We can do it, because all context-related information already configured for this purpose. As we saw the execve system call does not return control to a process, but code, data and other segments of the caller process are just overwritten of the program segments. The exit from our application will be implemented through the exit system call. And we are done with execution\n","wordCount":"2354","inLanguage":"en","image":"https://vishalchovatiya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2016-09-25T00:00:00Z","dateModified":"2016-09-25T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/program-gets-run-linux/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/images/trident_favicon.webp"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How Program Gets Run: Linux</h1><div class=post-meta><span title='2016-09-25 00:00:00 +0000 UTC'>September 25, 2016</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2354 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/blob/main/vishalchovatiya/content/posts/program-gets-run-linux.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#how-do-we-launch-our-programs>How do we launch our programs?</a></li><li><a href=#get-in-to-bash-devtty>Get In To Bash : <code>/dev/tty</code></a></li><li><a href=#get-into-kernelexecve-system-call>Get Into Kernel: <code>execve</code> System Call</a></li><li><a href=#preparing-binary-parameter-struct>Preparing Binary Parameter Struct</a></li><li><a href=#processing-binary-parameter-struct>Processing Binary Parameter Struct</a></li><li><a href=#executing-binary>Executing Binary</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>I know it’s long, but please bear with me & have patience.</p><h3 id=how-do-we-launch-our-programs>How do we launch our programs?<a hidden class=anchor aria-hidden=true href=#how-do-we-launch-our-programs>#</a></h3><ul><li>Do you know how programs get runs behind the screen when you double-click on it or you type <code>./a.out</code> on shell</li><li>As you know, the standard way to launch an application from a shell is to start terminal emulator application & just write the name of the program & pass or not arguments to our program, for example:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>vishal@machine Desktop<span class=o>]</span>$ ls --version
</span></span><span class=line><span class=cl>ls <span class=o>(</span>GNU coreutils<span class=o>)</span> 8.22
</span></span><span class=line><span class=cl>Copyright <span class=o>(</span>C<span class=o>)</span> <span class=m>2013</span> Free Software Foundation, Inc.
</span></span><span class=line><span class=cl>License GPLv3+: GNU GPL version <span class=m>3</span> or later .
</span></span><span class=line><span class=cl>This is free software: you are free to change and redistribute it.
</span></span><span class=line><span class=cl>There is NO WARRANTY, to the extent permitted by law.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Written by Richard M. Stallman and David MacKenzie.
</span></span></code></pre></td></tr></table></div></div><h3 id=get-in-to-bash-devtty>Get In To Bash : <code>/dev/tty</code><a hidden class=anchor aria-hidden=true href=#get-in-to-bash-devtty>#</a></h3><h4 id=sanity-checks>Sanity Checks<a hidden class=anchor aria-hidden=true href=#sanity-checks>#</a></h4><ul><li>So let&rsquo;s start with the main function of <code>bash</code> shell. If you will look on the source code of the <code>bash</code> shell, you will find the main function in the <code>shell.c</code> source code file which makes many different things before the main thread loop of the bash started to work. For example this function:</li></ul><ol><li>checks and tries to open <code>/dev/tty</code></li><li>check that shell running in debug mode</li><li>parse command-line arguments</li><li>reads shell environment</li><li>loads <code>.bashrc</code>, <code>.profile</code> and other configuration files and many more.</li></ol><h4 id=creating-environment>Creating Environment<a hidden class=anchor aria-hidden=true href=#creating-environment>#</a></h4><ul><li>After all of these operations, you can see the call of the <code>reader_loop</code> function defined in the <code>eval.c</code> which reads the given program name & arguments, then it calls the <code>execute_command</code> function from the <code>execute_cmd.c</code> which in turn calls following function chain which makes different checks like do we need to start <code>subshell</code>, was it built-in <code>bash</code> function or not etc.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>execute_command
</span></span><span class=line><span class=cl>--&gt; execute_command_internal
</span></span><span class=line><span class=cl>----&gt; execute_simple_command
</span></span><span class=line><span class=cl>------&gt; execute_disk_command
</span></span><span class=line><span class=cl>--------&gt; shell_execve
</span></span></code></pre></td></tr></table></div></div><ul><li>In the end of this process, the <code>shell_execve</code> function calls the <code>execve</code> system call which has the following signature</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execve</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>filename</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span> <span class=p>[],</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Executes a program by the given filename, with the given arguments and environment variables. So, a user application (bash in our case) calls the system call & as we already know the next step is the Linux kernel.</li></ul><h3 id=get-into-kernelexecve-system-call>Get Into Kernel: <code>execve</code> System Call<a hidden class=anchor aria-hidden=true href=#get-into-kernelexecve-system-call>#</a></h3><h4 id=execve-system-call-implementation><code>execve</code> System Call Implementation<a hidden class=anchor aria-hidden=true href=#execve-system-call-implementation>#</a></h4><ul><li>This system call defined in the <code>fs/exec.c</code> source code file & has following signature :</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>SYSCALL_DEFINE3</span><span class=p>(</span><span class=n>execve</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=n>filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=k>const</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=k>const</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=n>envp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nf>do_execve</span><span class=p>(</span><span class=nf>getname</span><span class=p>(</span><span class=n>filename</span><span class=p>),</span> <span class=n>argv</span><span class=p>,</span> <span class=n>envp</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Implementation of the <code>execve</code> is pretty simple here, as we can see it just returns the result of the <code>do_execve</code> function which initialize two pointers on a userspace data with the given arguments and environment variables & return the result of the <code>do_execveat_common</code>.</li></ul><p>We can see its implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>do_execve</span><span class=p>(</span><span class=k>struct</span> <span class=n>filename</span> <span class=o>*</span><span class=n>filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=k>const</span> <span class=n>__user</span> <span class=o>*</span><span class=n>__argv</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=k>const</span> <span class=n>__user</span> <span class=o>*</span><span class=n>__envp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>user_arg_ptr</span> <span class=n>argv</span> <span class=o>=</span> <span class=p>{</span> <span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>native</span> <span class=o>=</span> <span class=n>__argv</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>user_arg_ptr</span> <span class=n>envp</span> <span class=o>=</span> <span class=p>{</span> <span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>native</span> <span class=o>=</span> <span class=n>__envp</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>do_execveat_common</span><span class=p>(</span><span class=n>AT_FDCWD</span><span class=p>,</span> <span class=n>filename</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=n>envp</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The <code>do_execveat_common</code> function takes a similar set of arguments, but having 2 extra arguments.</li></ul><h4 id=sanity-checks-1>Sanity Checks<a hidden class=anchor aria-hidden=true href=#sanity-checks-1>#</a></h4><ul><li>The first argument <code>AT_FDCWD</code> is the file descriptor of current directory & fifth argument is flags. which we will see later.</li><li><code>do_execveat_common</code> function checks the filename pointer & returns if it is <code>NULL</code>.</li><li>After this it check flags of the current process that limit of running processes is not exceeded:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>IS_ERR</span><span class=p>(</span><span class=n>filename</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>PTR_ERR</span><span class=p>(</span><span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>current</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>PF_NPROC_EXCEEDED</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl><span class=nf>atomic_read</span><span class=p>(</span><span class=err>¤</span><span class=nf>t_user</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>processes</span><span class=p>)</span> <span class=o>&gt;</span> <span class=nf>rlimit</span><span class=p>(</span><span class=n>RLIMIT_NPROC</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>retval</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>goto</span> <span class=n>out_ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>current</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>PF_NPROC_EXCEEDED</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>If these two checks were successful we unset <code>PF_NPROC_EXCEEDED</code> flag in the flags of the current process to prevent failure of the execve.</li><li>In the next step we call the <code>unshare_files</code> function that defined in the <code>kernel/fork.c</code> and unshares the files of the current task and check the result of this function:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>retval</span> <span class=o>=</span> <span class=nf>unshare_files</span><span class=p>(</span><span class=o>&amp;</span><span class=n>displaced</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>retval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out_ret</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>We need to call this function to eliminate potential leak of the <code>execve'd</code> binary&rsquo;s file descriptor. In the next step, we start preparation of the <code>bprm</code> that represented by the struct <code>linux_binprm</code> structure (defined in the <code>include/linux/binfmts.h</code> header file).</li></ul><h3 id=preparing-binary-parameter-struct>Preparing Binary Parameter Struct<a hidden class=anchor aria-hidden=true href=#preparing-binary-parameter-struct>#</a></h3><h4 id=structlinux_binprm><code>struct linux_binprm</code><a hidden class=anchor aria-hidden=true href=#structlinux_binprm>#</a></h4><ul><li>The <code>linux_binprm</code> structure is used to hold the arguments that are used when loading binaries.</li><li>For example it contains <code>vm_area_struct</code> which represents a single memory area over a contiguous interval in a given address space where our application will be loaded</li><li><code>mm</code> field which is memory descriptor of the binary, pointer to the top of memory and many other different fields.</li></ul><h4 id=allocating-memory>Allocating Memory<a hidden class=anchor aria-hidden=true href=#allocating-memory>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>bprm</span> <span class=o>=</span> <span class=nf>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>bprm</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bprm</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out_files</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=preparing-credentials>Preparing Credentials<a hidden class=anchor aria-hidden=true href=#preparing-credentials>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>retval</span> <span class=o>=</span> <span class=nf>prepare_bprm_creds</span><span class=p>(</span><span class=n>bprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>retval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out_free</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>check_unsafe_exec</span><span class=p>(</span><span class=n>bprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>current</span><span class=o>-&gt;</span><span class=n>in_execve</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Initialization of the cred structure that stored inside of the <code>linux_binprm</code> structure contains the security context of a task, for example real <code>uid</code> of the task, real <code>guid</code> of the task, <code>uid</code> and <code>guid</code> for the virtual file system operations etc.</li><li>In the next step, the call of the <code>check_unsafe_exec</code> function set the current process to the <code>in_execve</code> state.</li></ul><h4 id=set-up--schedule-binary>Set-up & Schedule Binary<a hidden class=anchor aria-hidden=true href=#set-up--schedule-binary>#</a></h4><ul><li>After all of these operations, we call the <code>do_open_execat</code> function which<br>- Searches & opens executable file on disk & checks that,<br>- load a binary file from <code>noexec</code> mount points bypassed flag <code>0</code> (we need to avoid execute a binary from filesystems that do not contain executable binaries like proc or sysfs),<br>- initialize <code>file</code> structure & returns pointer on this structure.</li><li>Next, we can see the call the <code>sched_exec</code> after this. The <code>sched_exec</code> function is used to determine the least loaded processor that can execute the new program & to migrate the current process to it.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>file</span> <span class=o>=</span> <span class=nf>do_open_execat</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>filename</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>retval</span> <span class=o>=</span> <span class=nf>PTR_ERR</span><span class=p>(</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>IS_ERR</span><span class=p>(</span><span class=n>file</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out_unmark</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>sched_exec</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>After this, we need to check file descriptor of the give executable binary. We try to check does the name of the our binary file starts from the <code>/</code> symbol or does the path of the given executable binary is interpreted relative to the current working directory of the calling process or in other words file descriptor is <code>AT_FDCWD</code>.</li><li>If one of these checks is successful we set the binary parameter filename:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>file</span> <span class=o>=</span> <span class=n>file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=n>AT_FDCWD</span> <span class=o>||</span> <span class=n>filename</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;/&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>bprm</span><span class=o>-&gt;</span><span class=n>filename</span> <span class=o>=</span> <span class=n>filename</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Otherwise, if the filename is empty we set the binary parameter filename to the <code>/dev/fd/%d</code> or <code>/dev/fd/%d/%s</code> depends on the filename of the given executable binary which means that we will execute the file to which the file descriptor refers:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>filename</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>pathbuf</span> <span class=o>=</span> <span class=nf>kasprintf</span><span class=p>(</span><span class=n>GFP_TEMPORARY</span><span class=p>,</span> <span class=s>&#34;/dev/fd/%d&#34;</span><span class=p>,</span> <span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>
</span></span><span class=line><span class=cl>		<span class=n>pathbuf</span> <span class=o>=</span> <span class=nf>kasprintf</span><span class=p>(</span><span class=n>GFP_TEMPORARY</span><span class=p>,</span> <span class=s>&#34;/dev/fd/%d/%s&#34;</span><span class=p>,</span>	<span class=n>fd</span><span class=p>,</span> <span class=n>filename</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>pathbuf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>retval</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=n>out_unmark</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>bprm</span><span class=o>-&gt;</span><span class=n>filename</span> <span class=o>=</span> <span class=n>pathbuf</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>interp</span> <span class=o>=</span> <span class=n>bprm</span><span class=o>-&gt;</span><span class=n>filename</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Note that we set not only the <code>bprm->filename</code> but also <code>bprm->interp</code> that will contain the name of the program interpreter.</li><li>For now we just write the same name there, but later it will be updated with the real name of the program interpreter depends on the binary format of a program.</li></ul><h4 id=preparing-memory-related-info>Preparing Memory Related Info<a hidden class=anchor aria-hidden=true href=#preparing-memory-related-info>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>retval</span> <span class=o>=</span> <span class=nf>bprm_mm_init</span><span class=p>(</span><span class=n>bprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>retval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=k>goto</span> <span class=n>out_unmark</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The <code>bprm_mm_init</code> defined in the same source code file initializes <code>mm_struct</code> structure & populate it with a temporary stack <code>vm_area_struct</code> which is defined in the <code>include/linux/mm_types.h</code> header file & represents address space of a process.</li></ul><h4 id=countingcommand-line-args--environment-variables>Counting Command Line Args & Environment Variables<a hidden class=anchor aria-hidden=true href=#countingcommand-line-args--environment-variables>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4>4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5>5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6>6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>argc</span> <span class=o>=</span> <span class=nf>count</span><span class=p>(</span><span class=n>argv</span><span class=p>,</span> <span class=n>MAX_ARG_STRINGS</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>retval</span> <span class=o>=</span> <span class=n>bprm</span><span class=o>-&gt;</span><span class=n>argc</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>envc</span> <span class=o>=</span> <span class=nf>count</span><span class=p>(</span><span class=n>envp</span><span class=p>,</span> <span class=n>MAX_ARG_STRINGS</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>retval</span> <span class=o>=</span> <span class=n>bprm</span><span class=o>-&gt;</span><span class=n>envc</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>As you can see, <code>MAX_ARG_STRINGS</code> is the upper limit macro defined in the header file represents maximum number of strings that were passed to the <code>execve</code> system call. The value of the <code>MAX_ARG_STRINGS</code>:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define MAX_ARG_STRINGS 0x7FFFFFFF
</span></span></span></code></pre></td></tr></table></div></div><h4 id=reading-binaryelf-file>Reading Binary(ELF) File<a hidden class=anchor aria-hidden=true href=#reading-binaryelf-file>#</a></h4><ul><li>Now, the call of <code>prepare_binprm</code> function fills the <code>linux_binprm</code> structure with the <code>uid</code> from <code>inode</code> and read <code>128</code> bytes from the binary executable file. We read only first <code>128</code> from the executable file because we need to check a type of our executable. We will read the rest of the executable file in the later step.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>retval</span> <span class=o>=</span> <span class=nf>prepare_binprm</span><span class=p>(</span><span class=n>bprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>After the preparation of the <code>linux_bprm</code> structure we copy the filename of the executable binary file, command-line arguments and environment variables to the <code>linux_bprm</code> from the kernel with the call of the <code>copy_strings_kernel</code> function:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>retval</span> <span class=o>=</span> <span class=nf>copy_strings_kernel</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>filename</span><span class=p>,</span> <span class=n>bprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>retval</span> <span class=o>=</span> <span class=nf>copy_strings</span><span class=p>(</span><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>envc</span><span class=p>,</span> <span class=n>envp</span><span class=p>,</span> <span class=n>bprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>retval</span> <span class=o>=</span> <span class=nf>copy_strings</span><span class=p>(</span><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=n>bprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>And set the pointer to the top of the new program&rsquo;s stack that we set in the <code>bprm_mm_init</code> function <code>bprm->exec = bprm->p;</code></li><li>The top of the stack will contain the program filename and we store this filename to the <code>exec</code> field of the <code>linux_bprm</code> structure.</li></ul><h3 id=processing-binary-parameter-struct>Processing Binary Parameter Struct<a hidden class=anchor aria-hidden=true href=#processing-binary-parameter-struct>#</a></h3><ul><li>Call to <code>exec_binprm</code> function stores the pid from the namespace of the current task before it changes</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>retval</span> <span class=o>=</span> <span class=nf>exec_binprm</span><span class=p>(</span><span class=n>bprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>and call the:</li></ul><p><code>search_binary_handler(bprm);</code></p><ul><li><p>Which goes through the list of handlers that contains different binary formats. Currently the Linux kernel supports following binary formats:</p></li><li><p><code>binfmt_script</code> support for interpreted scripts that start from the #! line;</p></li><li><p><code>binfmt_misc</code> - support different binary formats, according to runtime configuration of the Linux kernel;</p></li><li><p><code>binfmt_elf</code> - support elf format;</p></li><li><p><code>binfmt_aout</code> - support a.out format;</p></li><li><p><code>binfmt_flat</code> - support for flat format;</p></li><li><p><code>binfmt_elf_fdpic</code> - Support for elf FDPIC binaries;</p></li><li><p><code>binfmt_em86</code> - support for Intel elf binaries running on Alpha machines.</p></li><li><p>So, the <code>search_binary_handler</code> tries to call the <code>load_binary</code> function and pass <code>linux_binprm</code> to it. If the binary handler supports the given executable file format, it starts to prepare the executable binary for execution:</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>search_binary_handler</span><span class=p>(</span><span class=k>struct</span> <span class=n>linux_binprm</span> <span class=o>*</span><span class=n>bprm</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>	<span class=nf>list_for_each_entry</span><span class=p>(</span><span class=n>fmt</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>formats</span><span class=p>,</span> <span class=n>lh</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>retval</span> <span class=o>=</span> <span class=n>fmt</span><span class=o>-&gt;</span><span class=nf>load_binary</span><span class=p>(</span><span class=n>bprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>mm</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>force_sigsegv</span><span class=p>(</span><span class=n>SIGSEGV</span><span class=p>,</span> <span class=n>current</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>retval</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>retval</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Where the <code>load_binary</code> for example checks the magic number (each elf binary file contains magic number in the header) in the <code>linux_bprm</code> buffer (remember that we read first <code>128</code> bytes from the executable binary file) & exit if it is not elf binary:</li></ul><h3 id=executing-binary>Executing Binary<a hidden class=anchor aria-hidden=true href=#executing-binary>#</a></h3><h4 id=sanity-checks-2>Sanity Checks<a hidden class=anchor aria-hidden=true href=#sanity-checks-2>#</a></h4><ul><li>If the given executable file is in elf format, the <code>load_elf_binary</code> continues & checks the architecture and type of the executable file and exit if there is wrong architecture and executable file non-executable non shared:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3>3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>.</span><span class=n>e_type</span> <span class=o>!=</span> <span class=n>ET_EXEC</span> <span class=o>&amp;&amp;</span> <span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>.</span><span class=n>e_type</span> <span class=o>!=</span> <span class=n>ET_DYN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>elf_check_arch</span><span class=p>(</span><span class=o>&amp;</span><span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=setup-process-address-space--dependencies>Setup Process Address Space & Dependencies<a hidden class=anchor aria-hidden=true href=#setup-process-address-space--dependencies>#</a></h4><ul><li>Tries to load the <code>program header</code> table that describes <code>segments</code>. Read the program interpreter and libraries that linked with the our executable binary file from disk and load it to memory.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2>2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>elf_phdata</span> <span class=o>=</span> <span class=nf>load_elf_phdrs</span><span class=p>(</span><span class=o>&amp;</span><span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>,</span> <span class=n>bprm</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>elf_phdata</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The program interpreter specified in the <code>.interp</code> section of the executable file (in most cases, linker is - <code>/lib64/ld-linux-x86-64.so.2</code> for the <code>x86_64</code>).</li><li>It setups the stack and map elf binary into the correct location in memory. It maps the bss and the brk sections and does many other different things to prepare executable file to execute.</li><li>In the end of the execution of the <code>load_elf_binary</code> we call the <code>start_thread</code> function and pass three arguments to it:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2>2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3>3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4>4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5>5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=nf>start_thread</span><span class=p>(</span><span class=n>regs</span><span class=p>,</span> <span class=n>elf_entry</span><span class=p>,</span> <span class=n>bprm</span><span class=o>-&gt;</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>retval</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>out</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>kfree</span><span class=p>(</span><span class=n>loc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>out_ret</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>retval</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>These Arguments are:<ul><li>Set of registers for the new task</li><li>Address of the entry point of the new task</li><li>Address of the top of the stack for the new task</li></ul></li><li>As we can understand from the function&rsquo;s name, it starts a new thread, but it is not so. The <code>start_thread</code> function just prepares new task&rsquo;s registers to be ready to run. Let&rsquo;s look at the implementation of this function:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1>1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2>2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3>3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4>4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5>5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>start_thread</span><span class=p>(</span><span class=k>struct</span> <span class=n>pt_regs</span> <span class=o>*</span><span class=n>regs</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>new_ip</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>new_sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>start_thread_common</span><span class=p>(</span><span class=n>regs</span><span class=p>,</span> <span class=n>new_ip</span><span class=p>,</span> <span class=n>new_sp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>__USER_CS</span><span class=p>,</span> <span class=n>__USER_DS</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>As we can see the <code>start_thread</code> function just makes a call of the <code>start_thread_common</code> function that will do all for us.</li></ul><h4 id=put-the-process-on-core>Put The Process On-Core<a hidden class=anchor aria-hidden=true href=#put-the-process-on-core>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1> 1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2> 2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3> 3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4> 4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5> 5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6> 6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7> 7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8> 8</a>
</span><span class=lnt id=hl-23-9><a class=lnlinks href=#hl-23-9> 9</a>
</span><span class=lnt id=hl-23-10><a class=lnlinks href=#hl-23-10>10</a>
</span><span class=lnt id=hl-23-11><a class=lnlinks href=#hl-23-11>11</a>
</span><span class=lnt id=hl-23-12><a class=lnlinks href=#hl-23-12>12</a>
</span><span class=lnt id=hl-23-13><a class=lnlinks href=#hl-23-13>13</a>
</span><span class=lnt id=hl-23-14><a class=lnlinks href=#hl-23-14>14</a>
</span><span class=lnt id=hl-23-15><a class=lnlinks href=#hl-23-15>15</a>
</span><span class=lnt id=hl-23-16><a class=lnlinks href=#hl-23-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>start_thread_common</span><span class=p>(</span><span class=k>struct</span> <span class=n>pt_regs</span> <span class=o>*</span><span class=n>regs</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>new_ip</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>new_sp</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>_cs</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>_ss</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>_ds</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>loadsegment</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>loadsegment</span><span class=p>(</span><span class=n>es</span><span class=p>,</span> <span class=n>_ds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>loadsegment</span><span class=p>(</span><span class=n>ds</span><span class=p>,</span> <span class=n>_ds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>load_gs_index</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>regs</span><span class=o>-&gt;</span><span class=n>ip</span> <span class=o>=</span> <span class=n>new_ip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>regs</span><span class=o>-&gt;</span><span class=n>sp</span> <span class=o>=</span> <span class=n>new_sp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>regs</span><span class=o>-&gt;</span><span class=n>cs</span> <span class=o>=</span> <span class=n>_cs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>regs</span><span class=o>-&gt;</span><span class=n>ss</span> <span class=o>=</span> <span class=n>_ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>regs</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>X86_EFLAGS_IF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>force_iret</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The <code>start_thread_common</code> function fills <code>fs</code> segment register with zero and <code>es</code> & <code>ds</code> with the value of the data segment register. After this we set new values to the instruction pointer, <code>cs</code> segments etc. At the end of the <code>start_thread_common</code> function we can see the <code>force_iret</code> macro that force a system call return via iret instruction.</li><li>Ok, we prepared new thread to run in userspace and now we can return from the <code>exec_binprm</code> and now we are in the <code>do_execveat_common</code> again. After the <code>exec_binprm</code> will finish its execution we release memory for structures that were allocated before and return.</li><li>After we returned from the <code>execve</code> system call handler, execution of our program will be started. We can do it, because all context-related information already configured for this purpose.</li><li>As we saw the <code>execve</code> system call does not return control to a process, but code, data and other segments of the caller process are just overwritten of the program segments.</li><li>The exit from our application will be implemented through the exit system call.</li></ul><p>And we are done with execution</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/bash-shell/>Bash-Shell</a></li><li><a href=https://vishalchovatiya.github.io/tags/elf-format/>Elf-Format</a></li><li><a href=https://vishalchovatiya.github.io/tags/how-program-gets-run/>How-Program-Gets-Run</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/gnu-build-system-automake-autoconf-libtool/><span class=title>« Prev</span><br><span>GNU Build System: Automake, Autoconf, Libtool</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/hack-c-cpp-application-using-rtld-next-with-an-easy-example/><span class=title>Next »</span><br><span>How to hack C/C++ application using RTLD_NEXT with an easy example</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How Program Gets Run: Linux on x" href="https://x.com/intent/tweet/?text=How%20Program%20Gets%20Run%3a%20Linux&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fprogram-gets-run-linux%2f&amp;hashtags=bash-shell%2celf-format%2chow-program-gets-run"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Program Gets Run: Linux on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fprogram-gets-run-linux%2f&amp;title=How%20Program%20Gets%20Run%3a%20Linux&amp;summary=How%20Program%20Gets%20Run%3a%20Linux&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fprogram-gets-run-linux%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Program Gets Run: Linux on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fprogram-gets-run-linux%2f&title=How%20Program%20Gets%20Run%3a%20Linux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Program Gets Run: Linux on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fprogram-gets-run-linux%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Program Gets Run: Linux on whatsapp" href="https://api.whatsapp.com/send?text=How%20Program%20Gets%20Run%3a%20Linux%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fprogram-gets-run-linux%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Program Gets Run: Linux on telegram" href="https://telegram.me/share/url?text=How%20Program%20Gets%20Run%3a%20Linux&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fprogram-gets-run-linux%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How Program Gets Run: Linux on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20Program%20Gets%20Run%3a%20Linux&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fprogram-gets-run-linux%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>