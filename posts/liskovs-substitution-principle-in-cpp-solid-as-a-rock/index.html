<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Liskov's Substitution Principle in C++ | SOLID as a Rock | Vishal Chovatiya</title>
<meta name=keywords content="benefits,compatibility,intent,liskov-sub,liskov-substition-principle,liskov-substitution-principle-covariance-liskov-substitution-principle-code-example,liskov-substitution-principle-definition,liskov-substitution-principle-example,liskov-substitution-principle-real-world-example,liskov-substitution-principle-uncle-bob,liskovs-substitution-principle-2,liskovs-substitution-principle-in-c-2,lsp-principle,maintainability,motivation-violating-the-liskovs-substitution-principle-2,principle-of-substitutability,solid-liskov-substitution-principle,solid-principles-liskov,solution-example-of-liskovs-substitution-principle-in-c-2,substitution-principle,substitution-principle-definition,type-safety,with-factory-pattern,yardstick-to-craft-liskovs-substitution-principle-friendly-software-in-c"><meta name=description content="So you know how to code in general, understand the object-oriented programming, learned C++, and completed at least one Software Development Course (if you’re not there yet, these articles aren&rsquo;t for you). You can write software easily if you know at least one programming language, but is your code any good? Could it be done any better? Is it clean (and what on earth does that mean)? Is your architecture any good?"><meta name=author content="Vishal Chovatiya"><link rel=canonical href=http://localhost:1313/posts/liskovs-substitution-principle-in-cpp-solid-as-a-rock/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/liskovs-substitution-principle-in-cpp-solid-as-a-rock/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Liskov's Substitution Principle in C++ | SOLID as a Rock"><meta property="og:description" content="So you know how to code in general, understand the object-oriented programming, learned C++, and completed at least one Software Development Course (if you’re not there yet, these articles aren&rsquo;t for you). You can write software easily if you know at least one programming language, but is your code any good? Could it be done any better? Is it clean (and what on earth does that mean)? Is your architecture any good?"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/liskovs-substitution-principle-in-cpp-solid-as-a-rock/"><meta property="og:image" content="http://localhost:1313/images/Liskovs-Substitution-Principle-in-C-SOLID-as-a-Rock-vishal-chovatiya.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-07T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-07T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/Liskovs-Substitution-Principle-in-C-SOLID-as-a-Rock-vishal-chovatiya.webp"><meta name=twitter:title content="Liskov's Substitution Principle in C++ | SOLID as a Rock"><meta name=twitter:description content="So you know how to code in general, understand the object-oriented programming, learned C++, and completed at least one Software Development Course (if you’re not there yet, these articles aren&rsquo;t for you). You can write software easily if you know at least one programming language, but is your code any good? Could it be done any better? Is it clean (and what on earth does that mean)? Is your architecture any good?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Liskov's Substitution Principle in C++ | SOLID as a Rock","item":"http://localhost:1313/posts/liskovs-substitution-principle-in-cpp-solid-as-a-rock/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Liskov's Substitution Principle in C++ | SOLID as a Rock","name":"Liskov\u0027s Substitution Principle in C\u002b\u002b | SOLID as a Rock","description":"So you know how to code in general, understand the object-oriented programming, learned C++, and completed at least one Software Development Course (if you’re not there yet, these articles aren\u0026rsquo;t for you). You can write software easily if you know at least one programming language, but is your code any good? Could it be done any better? Is it clean (and what on earth does that mean)? Is your architecture any good?","keywords":["benefits","compatibility","intent","liskov-sub","liskov-substition-principle","liskov-substitution-principle-covariance-liskov-substitution-principle-code-example","liskov-substitution-principle-definition","liskov-substitution-principle-example","liskov-substitution-principle-real-world-example","liskov-substitution-principle-uncle-bob","liskovs-substitution-principle-2","liskovs-substitution-principle-in-c-2","lsp-principle","maintainability","motivation-violating-the-liskovs-substitution-principle-2","principle-of-substitutability","solid-liskov-substitution-principle","solid-principles-liskov","solution-example-of-liskovs-substitution-principle-in-c-2","substitution-principle","substitution-principle-definition","type-safety","with-factory-pattern","yardstick-to-craft-liskovs-substitution-principle-friendly-software-in-c"],"articleBody":"So you know how to code in general, understand the object-oriented programming, learned C++, and completed at least one Software Development Course (if you’re not there yet, these articles aren’t for you). You can write software easily if you know at least one programming language, but is your code any good? Could it be done any better? Is it clean (and what on earth does that mean)? Is your architecture any good? Should you use a different one? What about Design Patterns? These were some of the questions I’ve had when I started, and answering them helped me to step up to a professional level. Which is why I have written these series SOLID as a Rock design principle. Liskov’s Substitution Principle in C++ is the second principle in this series which I will discuss here.\nBy the way, If you haven’t gone through my previous articles on design principles, then below is the quick links:\nSRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026 consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing “public:” sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don’t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent Subtypes must be substitutable for their base types without altering the correctness of the program\nIf I address this in the context of C++, this literally means that functions that use pointers/references to base classes must be able to substitute by its derived classes. The Liskov Substitution Principle revolves around ensuring that inheritance is used correctly. Motivation: Violating the Liskov’s Substitution Principle A great \u0026 traditional example illustrating LSP was how sometimes something that sounds right in natural language doesn’t quite work in code. In mathematics, a Square is a Rectangle. Indeed it is a specialization of a rectangle. The “IS A” makes you want to model this with inheritance. However if in code you made Square derive from Rectangle, then a Square should be usable anywhere you expect a Rectangle. This makes for some strange behaviour as follows: struct Rectangle { Rectangle(const uint32_t width, const uint32_t height) : m_width{width}, m_height{height} {} uint32_t get_width() const { return m_width; } uint32_t get_height() const { return m_height; } virtual void set_width(const uint32_t width) { this-\u003em_width = width; } virtual void set_height(const uint32_t height) { this-\u003em_height = height; } uint32_t area() const { return m_width * m_height; } protected: uint32_t m_width, m_height; }; struct Square : Rectangle { Square(uint32_t size) : Rectangle(size, size) {} void set_width(const uint32_t width) override { this-\u003em_width = m_height = width; } void set_height(const uint32_t height) override { this-\u003em_height = m_width = height; } }; void process(Rectangle \u0026r) { uint32_t w = r.get_width(); r.set_height(10); assert((w * 10) == r.area()); // Fails for Square \u003c-------------------- } int main() { Rectangle r{5, 5}; process(r); Square s{5}; process(s); return EXIT_SUCCESS; } As you can see above, we have violated Liskovs’s Substitution Principle in the void process(Rectangle \u0026r) function. Therefore Square is not a valid substitute of Rectangle. If you see from the design perspective, the very idea of inheriting Square from Rectangle is not a good idea. Because Square does not have height \u0026 width, rather it has the size/length of sides. Solution: Example of Liskov’s Substitution Principle in C++ Not so good void process(Rectangle \u0026r) { uint32_t w = r.get_width(); r.set_height(10); if (dynamic_cast\u003cSquare *\u003e(\u0026r) != nullptr) assert((r.get_width() * r.get_width()) == r.area()); else assert((w * 10) == r.area()); } A common code smell that frequently indicates an LSP violation is the presence of type checking code within a code block that is polymorphic. For instance, if you have a std::for_each loop over a collection of objects of type Foo, and within this loop, there is a check to see if Foo is in fact Bar(a subtype of Foo), then this is almost certainly an LSP violation. Rather you should ensure Bar is in all ways substitutable for Foo, there should be no need to include such a check. An OK way to do it void process(Rectangle \u0026r) { uint32_t w = r.get_width(); r.set_height(10); if (r.is_square()) assert((r.get_width() * r.get_width()) == r.area()); else assert((w * 10) == r.area()); } No need to create a separate class for Square. Instead, you can simply check for bool flag within the Rectangle class to validate Square property. Though not a recommended way. Use proper inheritance hierarchy struct Shape { virtual uint32_t area() const = 0; }; struct Rectangle : Shape { Rectangle(const uint32_t width, const uint32_t height) : m_width{width}, m_height{height} {} uint32_t get_width() const { return m_width; } uint32_t get_height() const { return m_height; } virtual void set_width(const uint32_t width) { this-\u003em_width = width; } virtual void set_height(const uint32_t height) { this-\u003em_height = height; } uint32_t area() const override { return m_width * m_height; } private: uint32_t m_width, m_height; }; struct Square : Shape { Square(uint32_t size) : m_size(size) {} void set_size(const uint32_t size) { this-\u003em_size = size; } uint32_t area() const override { return m_size * m_size; } private: uint32_t m_size; }; void process(Shape \u0026s) { // Use polymorphic behaviour only i.e. area() } With Factory Pattern Still, creation or change is needed to process Shape, then you should try to use Virtual Constructor \u0026 Virtual Copy Constructor i.e. Factory Pattern. struct ShapeFactory { static Shape CreateRectangle(uint32_t width, uint32_t height); static Shape CreateSquare(uint32_t size); }; Benefits of Liskov’s Substitution Principle =\u003e Compatibility It enables the binary compatibility between multiple releases \u0026 patches. In other words, It keeps the client code away from being impacted. =\u003e Type Safety It’s the easiest approach to handle type safety with inheritance, as types are not allowed to vary when inheriting. =\u003e Maintainability Code that adheres to LSP is loosely dependent on each other \u0026 encourages code reusability. Code that adheres to the LSP is code that makes the right abstractions. Yardstick to Craft Liskov’s Substitution Principle Friendly Software in C++ In most introductions to object-oriented programming, inheritance discussed as an “IS-A” relationship with the inherited object. However, this is necessary, but not sufficient. It is more appropriate to say that one object can be designed to inherit from another if it always has an “IS-SUBSTITUTABLE-FOR” relationship with the inherited object. The whole point of using an abstract base class is so that, in the future, you can write a new subclass \u0026 insert it into existing, working, tested code. A noble goal, but how to achieve it? First, start with decomposing your problem space — domain. Second, express your contract/interfaces/virtual-methods in plain English. Closing Notes Don’t get me wrong, I like SOLID and the approaches it promotes. But it’s just a shape of deeper principles lying in its foundation. The examples above made it clear what this principle is striving for i.e. loose coupling \u0026 ensuring correct inheritance.\nNow, go out there and make your subclasses swappable, and thank Dr. Barbara Liskov for such a useful principle.\n","wordCount":"1299","inLanguage":"en","image":"http://localhost:1313/images/Liskovs-Substitution-Principle-in-C-SOLID-as-a-Rock-vishal-chovatiya.webp","datePublished":"2020-04-07T00:00:00Z","dateModified":"2020-04-07T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/liskovs-substitution-principle-in-cpp-solid-as-a-rock/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=http://localhost:1313/posts/ title=Latest><span>Latest</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Liskov's Substitution Principle in C++ | SOLID as a Rock</h1><div class=post-meta><span title='2020-04-07 00:00:00 +0000 UTC'>April 7, 2020</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1299 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/liskovs-substitution-principle-in-cpp-solid-as-a-rock.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/images/Liskovs-Substitution-Principle-in-C-SOLID-as-a-Rock-vishal-chovatiya.webp alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intent>Intent</a></li><li><a href=#motivation-violating-the-liskovs-substitution-principle>Motivation: Violating the Liskov&rsquo;s Substitution Principle</a></li><li><a href=#solution-example-of-liskovs-substitution-principle-in-c>Solution: Example of Liskov&rsquo;s Substitution Principle in C++</a><ul><li><a href=#not-so-good>Not so good</a></li><li><a href=#an-ok-way-to-do-it>An OK way to do it</a></li><li><a href=#use-proper-inheritance-hierarchy>Use proper inheritance hierarchy</a></li><li><a href=#with-factory-pattern>With Factory Pattern</a></li></ul></li><li><a href=#benefits-of-liskovs-substitution-principle>Benefits of Liskov&rsquo;s Substitution Principle</a><ul><li><a href=#-compatibility>=> Compatibility</a></li><li><a href=#-type-safety>=> Type Safety</a></li><li><a href=#-maintainability>=> Maintainability</a></li></ul></li><li><a href=#yardstick-to-craft-liskovs-substitution-principle-friendly-software-in-c>Yardstick to Craft Liskov&rsquo;s Substitution Principle Friendly Software in C++</a></li><li><a href=#closing-notes>Closing Notes</a></li></ul></nav></div></details></div><div class=post-content><p>So you know how to code in general, understand the object-oriented programming, learned C++, and completed at least one Software Development Course (if you’re not there yet, these articles aren&rsquo;t for you). You can write software easily if you know at least one programming language, but is your code any good? Could it be done any better? Is it clean (and what on earth does that mean)? Is your architecture any good? Should you use a different one? <a href=/posts/what-is-design-pattern/>What about Design Patterns?</a> These were some of the questions I&rsquo;ve had when I started, and answering them helped me to step up to a professional level. Which is why I have written these series SOLID as a Rock design principle. <strong>L</strong>iskov&rsquo;s <strong>S</strong>ubstitution <strong>P</strong>rinciple in C++ is the second principle in this series which I will discuss here.</p><p>By the way, If you haven&rsquo;t gone through my previous articles on design principles, then below is the quick links:</p><ol><li><a href=/posts//single-responsibility-principle-in-cpp-solid-as-a-rock/><strong>S</strong>RP – Single Responsibility Principle</a></li><li><a href=/posts//open-closed-principle-in-cpp-solid-as-a-rock/><strong>O</strong>CP – Open/Closed Principle</a></li><li><a href=/posts//liskovs-substitution-principle-in-cpp-solid-as-a-rock/><strong>L</strong>SP – Liskov Substitution Principle</a></li><li><a href=/posts//interface-segregation-principle-in-cpp-solid-as-a-rock/><strong>I</strong>SP – Interface Segregation Principle</a></li><li><a href=/posts//dependency-inversion-principle-in-cpp-solid-as-a-rock/><strong>D</strong>IP – Dependency Inversion Principle</a></li></ol><p>The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like <code>override</code>, <code>final</code>, <code>public</code>(while inheritance) just to make code compact & consumable(most of the time) in single standard screen size. I also prefer <code>struct</code> instead of <code>class</code> just to save line by not writing &ldquo;<code>public:</code>&rdquo; sometimes and also miss <a href=/posts//part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/>virtual destructor</a>, constructor, <a href=/posts//all-about-copy-constructor-in-cpp-with-example/>copy constructor</a>, prefix <code>std::</code>, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.</p><p><strong><em>Note:</em></strong></p><ul><li>If you stumbled here directly, then I would suggest you go through <a href=/posts//what-is-design-pattern/>What is design pattern?</a> first, even if it is trivial. I believe it will encourage you to explore more on this topic.</li><li>All of this code you encounter in this series of articles are compiled using C++20(though I have used <a href=/posts//21-new-features-of-modern-cpp-to-use-in-your-project/>Modern C++</a> features up to C++17 in most cases). So if you don&rsquo;t have access to the latest compiler you can use <a href=https://wandbox.org/>https://wandbox.org/</a> which has preinstalled boost library as well.</li></ul><h2 id=intent>Intent<a hidden class=anchor aria-hidden=true href=#intent>#</a></h2><blockquote><p><strong><em>Subtypes must be substitutable for their base types without altering the correctness of the program</em></strong></p></blockquote><ul><li>If I address this in the context of C++, this literally means that functions that use pointers/references to base classes must be able to substitute by its derived classes.</li><li>The Liskov Substitution Principle revolves around ensuring that inheritance is used correctly.</li></ul><h2 id=motivation-violating-the-liskovs-substitution-principle>Motivation: Violating the Liskov&rsquo;s Substitution Principle<a hidden class=anchor aria-hidden=true href=#motivation-violating-the-liskovs-substitution-principle>#</a></h2><ul><li>A great & traditional example illustrating LSP was how sometimes something that sounds right in natural language doesn&rsquo;t quite work in code.</li><li>In mathematics, a <code>Square</code> is a <code>Rectangle</code>. Indeed it is a specialization of a rectangle. The &ldquo;IS A&rdquo; makes you want to model this with inheritance. However if in code you made <code>Square</code> derive from <code>Rectangle</code>, then a <code>Square</code> should be usable anywhere you expect a <code>Rectangle</code>. This makes for some strange behaviour as follows:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Rectangle</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Rectangle</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>width</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>height</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_width</span><span class=p>{</span><span class=n>width</span><span class=p>},</span> <span class=n>m_height</span><span class=p>{</span><span class=n>height</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>get_width</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_width</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>get_height</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_height</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>set_width</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>width</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>m_width</span> <span class=o>=</span> <span class=n>width</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>set_height</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>height</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>m_height</span> <span class=o>=</span> <span class=n>height</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>area</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_width</span> <span class=o>*</span> <span class=n>m_height</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>m_width</span><span class=p>,</span> <span class=n>m_height</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Square</span> <span class=o>:</span> <span class=n>Rectangle</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Square</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>size</span><span class=p>)</span> <span class=o>:</span> <span class=n>Rectangle</span><span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>set_width</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>width</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>m_width</span> <span class=o>=</span> <span class=n>m_height</span> <span class=o>=</span> <span class=n>width</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>set_height</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>height</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>m_height</span> <span class=o>=</span> <span class=n>m_width</span> <span class=o>=</span> <span class=n>height</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>process</span><span class=p>(</span><span class=n>Rectangle</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>w</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>get_width</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=p>.</span><span class=n>set_height</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>((</span><span class=n>w</span> <span class=o>*</span> <span class=mi>10</span><span class=p>)</span> <span class=o>==</span> <span class=n>r</span><span class=p>.</span><span class=n>area</span><span class=p>());</span> <span class=c1>// Fails for Square &lt;--------------------
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Rectangle</span> <span class=n>r</span><span class=p>{</span><span class=mi>5</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>process</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Square</span> <span class=n>s</span><span class=p>{</span><span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>process</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>As you can see above, we have violated Liskovs&rsquo;s Substitution Principle in the <code>void process(Rectangle &amp;r)</code> function. Therefore <code>Square</code> is not a valid substitute of <code>Rectangle</code>.</li><li>If you see from the design perspective, the very idea of inheriting <code>Square</code> from <code>Rectangle</code> is not a good idea. Because <code>Square</code> does not have height & width, rather it has the size/length of sides.</li></ul><h2 id=solution-example-of-liskovs-substitution-principle-in-c>Solution: Example of Liskov&rsquo;s Substitution Principle in C++<a hidden class=anchor aria-hidden=true href=#solution-example-of-liskovs-substitution-principle-in-c>#</a></h2><h3 id=not-so-good>Not so good<a hidden class=anchor aria-hidden=true href=#not-so-good>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>process</span><span class=p>(</span><span class=n>Rectangle</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>w</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>get_width</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=p>.</span><span class=n>set_height</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>Square</span> <span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>)</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>((</span><span class=n>r</span><span class=p>.</span><span class=n>get_width</span><span class=p>()</span> <span class=o>*</span> <span class=n>r</span><span class=p>.</span><span class=n>get_width</span><span class=p>())</span> <span class=o>==</span> <span class=n>r</span><span class=p>.</span><span class=n>area</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>((</span><span class=n>w</span> <span class=o>*</span> <span class=mi>10</span><span class=p>)</span> <span class=o>==</span> <span class=n>r</span><span class=p>.</span><span class=n>area</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>A common code smell that frequently indicates an LSP violation is the presence of <a href=/posts/cpp-type-casting-with-example-for-c-developers/>type checking</a> code within a code block that is polymorphic.</li><li>For instance, if you have a <code>std::for_each</code> loop over a collection of objects of type <code>Foo</code>, and within this loop, there is a check to see if <code>Foo</code> is in fact <code>Bar</code>(a subtype of <code>Foo</code>), then this is almost certainly an LSP violation. Rather you should ensure <code>Bar</code> is in all ways substitutable for <code>Foo</code>, there should be no need to include such a check.</li></ul><h3 id=an-ok-way-to-do-it>An OK way to do it<a hidden class=anchor aria-hidden=true href=#an-ok-way-to-do-it>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>process</span><span class=p>(</span><span class=n>Rectangle</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>w</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>get_width</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=p>.</span><span class=n>set_height</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>is_square</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>((</span><span class=n>r</span><span class=p>.</span><span class=n>get_width</span><span class=p>()</span> <span class=o>*</span> <span class=n>r</span><span class=p>.</span><span class=n>get_width</span><span class=p>())</span> <span class=o>==</span> <span class=n>r</span><span class=p>.</span><span class=n>area</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>((</span><span class=n>w</span> <span class=o>*</span> <span class=mi>10</span><span class=p>)</span> <span class=o>==</span> <span class=n>r</span><span class=p>.</span><span class=n>area</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>No need to create a separate class for <code>Square</code>. Instead, you can simply check for <code>bool</code> flag within the <code>Rectangle</code> class to validate <code>Square</code> property. Though not a recommended way.</li></ul><h3 id=use-proper-inheritance-hierarchy>Use proper inheritance hierarchy<a hidden class=anchor aria-hidden=true href=#use-proper-inheritance-hierarchy>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>uint32_t</span> <span class=nf>area</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Rectangle</span> <span class=o>:</span> <span class=n>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Rectangle</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>width</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>height</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_width</span><span class=p>{</span><span class=n>width</span><span class=p>},</span> <span class=n>m_height</span><span class=p>{</span><span class=n>height</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>get_width</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_width</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>get_height</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_height</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>set_width</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>width</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>m_width</span> <span class=o>=</span> <span class=n>width</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>set_height</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>height</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>m_height</span> <span class=o>=</span> <span class=n>height</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>area</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_width</span> <span class=o>*</span> <span class=n>m_height</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>m_width</span><span class=p>,</span> <span class=n>m_height</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Square</span> <span class=o>:</span> <span class=n>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Square</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>size</span><span class=p>)</span> <span class=o>:</span> <span class=n>m_size</span><span class=p>(</span><span class=n>size</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>set_size</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>m_size</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>area</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_size</span> <span class=o>*</span> <span class=n>m_size</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>m_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>process</span><span class=p>(</span><span class=n>Shape</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Use polymorphic behaviour only i.e. area()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=with-factory-pattern>With Factory Pattern<a hidden class=anchor aria-hidden=true href=#with-factory-pattern>#</a></h3><ul><li>Still, creation or change is needed to process <code>Shape</code>, then you should try to use <a href=/posts/7-advanced-cpp-concepts-idiom-examples-you-should-know/#Virtual-Constructor>Virtual Constructor</a> & <a href=/posts/prototype-design-pattern-in-modern-cpp/>Virtual Copy Constructor</a> i.e. <a href=/posts/factory-design-pattern-in-modern-cpp/>Factory Pattern</a>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ShapeFactory</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Shape</span> <span class=nf>CreateRectangle</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>width</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Shape</span> <span class=nf>CreateSquare</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=benefits-of-liskovs-substitution-principle>Benefits of Liskov&rsquo;s Substitution Principle<a hidden class=anchor aria-hidden=true href=#benefits-of-liskovs-substitution-principle>#</a></h2><h3 id=-compatibility>=> Compatibility<a hidden class=anchor aria-hidden=true href=#-compatibility>#</a></h3><ul><li>It enables the binary compatibility between multiple releases & patches. In other words, It keeps the client code away from being impacted.</li></ul><h3 id=-type-safety>=> Type Safety<a hidden class=anchor aria-hidden=true href=#-type-safety>#</a></h3><ul><li>It&rsquo;s the easiest approach to handle type safety with inheritance, as types are not allowed to <em>vary</em> when inheriting.</li></ul><h3 id=-maintainability>=> Maintainability<a hidden class=anchor aria-hidden=true href=#-maintainability>#</a></h3><ul><li>Code that adheres to LSP is loosely dependent on each other & encourages code reusability.</li><li>Code that adheres to the LSP is code that makes the right abstractions.</li></ul><h2 id=yardstick-to-craft-liskovs-substitution-principle-friendly-software-in-c>Yardstick to Craft Liskov&rsquo;s Substitution Principle Friendly Software in C++<a hidden class=anchor aria-hidden=true href=#yardstick-to-craft-liskovs-substitution-principle-friendly-software-in-c>#</a></h2><ul><li>In most introductions to <a href=/posts/memory-layout-of-cpp-object/>object-oriented programming</a>, inheritance discussed as an &ldquo;IS-A&rdquo; relationship with the inherited object. However, this is necessary, but not sufficient. It is more appropriate to say that one object can be designed to inherit from another if it always has an &ldquo;IS-SUBSTITUTABLE-FOR&rdquo; relationship with the inherited object.</li><li>The whole point of using an abstract base class is so that, in the future, you can write a new <a href=/posts/inside-the-cpp-object-model/>subclass</a> & insert it into existing, working, tested code. A noble goal, but how to achieve it? First, start with decomposing your problem space &mdash; domain. Second, express your contract/interfaces/<a href=/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/>virtual-methods</a> in plain English.</li></ul><h2 id=closing-notes>Closing Notes<a hidden class=anchor aria-hidden=true href=#closing-notes>#</a></h2><p>Don’t get me wrong, I like SOLID and the approaches it promotes. But it’s just a shape of deeper principles lying in its foundation. The examples above made it clear what this principle is striving for i.e. <strong><em>loose coupling & ensuring correct inheritance</em></strong>.</p><p>Now, go out there and make your subclasses swappable, and thank <a href=https://en.wikipedia.org/wiki/Barbara_Liskov><strong>Dr. Barbara Liskov</strong></a> for such a useful principle.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/benefits/>Benefits</a></li><li><a href=http://localhost:1313/tags/compatibility/>Compatibility</a></li><li><a href=http://localhost:1313/tags/intent/>Intent</a></li><li><a href=http://localhost:1313/tags/liskov-sub/>Liskov-Sub</a></li><li><a href=http://localhost:1313/tags/liskov-substition-principle/>Liskov-Substition-Principle</a></li><li><a href=http://localhost:1313/tags/liskov-substitution-principle-covariance-liskov-substitution-principle-code-example/>Liskov-Substitution-Principle-Covariance-Liskov-Substitution-Principle-Code-Example</a></li><li><a href=http://localhost:1313/tags/liskov-substitution-principle-definition/>Liskov-Substitution-Principle-Definition</a></li><li><a href=http://localhost:1313/tags/liskov-substitution-principle-example/>Liskov-Substitution-Principle-Example</a></li><li><a href=http://localhost:1313/tags/liskov-substitution-principle-real-world-example/>Liskov-Substitution-Principle-Real-World-Example</a></li><li><a href=http://localhost:1313/tags/liskov-substitution-principle-uncle-bob/>Liskov-Substitution-Principle-Uncle-Bob</a></li><li><a href=http://localhost:1313/tags/liskovs-substitution-principle-2/>Liskovs-Substitution-Principle-2</a></li><li><a href=http://localhost:1313/tags/liskovs-substitution-principle-in-c-2/>Liskovs-Substitution-Principle-in-C-2</a></li><li><a href=http://localhost:1313/tags/lsp-principle/>Lsp-Principle</a></li><li><a href=http://localhost:1313/tags/maintainability/>Maintainability</a></li><li><a href=http://localhost:1313/tags/motivation-violating-the-liskovs-substitution-principle-2/>Motivation-Violating-the-Liskovs-Substitution-Principle-2</a></li><li><a href=http://localhost:1313/tags/principle-of-substitutability/>Principle-of-Substitutability</a></li><li><a href=http://localhost:1313/tags/solid-liskov-substitution-principle/>Solid-Liskov-Substitution-Principle</a></li><li><a href=http://localhost:1313/tags/solid-principles-liskov/>Solid-Principles-Liskov</a></li><li><a href=http://localhost:1313/tags/solution-example-of-liskovs-substitution-principle-in-c-2/>Solution-Example-of-Liskovs-Substitution-Principle-in-C-2</a></li><li><a href=http://localhost:1313/tags/substitution-principle/>Substitution-Principle</a></li><li><a href=http://localhost:1313/tags/substitution-principle-definition/>Substitution-Principle-Definition</a></li><li><a href=http://localhost:1313/tags/type-safety/>Type-Safety</a></li><li><a href=http://localhost:1313/tags/with-factory-pattern/>With-Factory-Pattern</a></li><li><a href=http://localhost:1313/tags/yardstick-to-craft-liskovs-substitution-principle-friendly-software-in-c/>Yardstick-to-Craft-Liskovs-Substitution-Principle-Friendly-Software-in-C</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/double-dispatch-in-cpp/><span class=title>« Prev</span><br><span>Double Dispatch in C++: Recover Original Type of the Object Pointed by Base Class Pointer</span>
</a><a class=next href=http://localhost:1313/posts/open-closed-principle-in-cpp-solid-as-a-rock/><span class=title>Next »</span><br><span>Open Closed Principle in C++ | SOLID as a Rock</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Liskov's Substitution Principle in C++ | SOLID as a Rock on x" href="https://x.com/intent/tweet/?text=Liskov%27s%20Substitution%20Principle%20in%20C%2b%2b%20%7c%20SOLID%20as%20a%20Rock&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fliskovs-substitution-principle-in-cpp-solid-as-a-rock%2f&amp;hashtags=benefits%2ccompatibility%2cintent%2cliskov-sub%2cliskov-substition-principle%2cliskov-substitution-principle-covariance-liskov-substitution-principle-code-example%2cliskov-substitution-principle-definition%2cliskov-substitution-principle-example%2cliskov-substitution-principle-real-world-example%2cliskov-substitution-principle-uncle-bob%2cliskovs-substitution-principle-2%2cliskovs-substitution-principle-in-c-2%2clsp-principle%2cmaintainability%2cmotivation-violating-the-liskovs-substitution-principle-2%2cprinciple-of-substitutability%2csolid-liskov-substitution-principle%2csolid-principles-liskov%2csolution-example-of-liskovs-substitution-principle-in-c-2%2csubstitution-principle%2csubstitution-principle-definition%2ctype-safety%2cwith-factory-pattern%2cyardstick-to-craft-liskovs-substitution-principle-friendly-software-in-c"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Liskov's Substitution Principle in C++ | SOLID as a Rock on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fliskovs-substitution-principle-in-cpp-solid-as-a-rock%2f&amp;title=Liskov%27s%20Substitution%20Principle%20in%20C%2b%2b%20%7c%20SOLID%20as%20a%20Rock&amp;summary=Liskov%27s%20Substitution%20Principle%20in%20C%2b%2b%20%7c%20SOLID%20as%20a%20Rock&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fliskovs-substitution-principle-in-cpp-solid-as-a-rock%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Liskov's Substitution Principle in C++ | SOLID as a Rock on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fliskovs-substitution-principle-in-cpp-solid-as-a-rock%2f&title=Liskov%27s%20Substitution%20Principle%20in%20C%2b%2b%20%7c%20SOLID%20as%20a%20Rock"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Liskov's Substitution Principle in C++ | SOLID as a Rock on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fliskovs-substitution-principle-in-cpp-solid-as-a-rock%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Liskov's Substitution Principle in C++ | SOLID as a Rock on whatsapp" href="https://api.whatsapp.com/send?text=Liskov%27s%20Substitution%20Principle%20in%20C%2b%2b%20%7c%20SOLID%20as%20a%20Rock%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fliskovs-substitution-principle-in-cpp-solid-as-a-rock%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Liskov's Substitution Principle in C++ | SOLID as a Rock on telegram" href="https://telegram.me/share/url?text=Liskov%27s%20Substitution%20Principle%20in%20C%2b%2b%20%7c%20SOLID%20as%20a%20Rock&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fliskovs-substitution-principle-in-cpp-solid-as-a-rock%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Liskov's Substitution Principle in C++ | SOLID as a Rock on ycombinator" href="https://news.ycombinator.com/submitlink?t=Liskov%27s%20Substitution%20Principle%20in%20C%2b%2b%20%7c%20SOLID%20as%20a%20Rock&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fliskovs-substitution-principle-in-cpp-solid-as-a-rock%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>