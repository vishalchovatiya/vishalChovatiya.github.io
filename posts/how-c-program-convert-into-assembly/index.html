<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How C Program Converts Into Assembly! | Vishal Chovatiya</title>
<meta name=keywords content="accessing-global-local-static-variables-in-c,function-prologue-epilogue,function-stack-frame,how-c-program-converts-into-assembly,how-do-you-corrupt-stack-deliberately,how-do-you-determine-the-stack-growth-direction,how-you-can-increase-stack-frame-size,return-value-from-function-in-c,x86-special-function-registers"><meta name=description content="In an earlier article, we have seen C runtime: before starting main & How C program stored in RAM memory. Here we will see &ldquo;How C program converts into assembly?&rdquo; and different aspect of its working at the machine level.
A Bit About Functions Stack Frames During function code execution, a new stack frame is created in stack memory to allow access to function parameters and local variables. The direction of stack frame growth totally depends on compiler ABI which is out of our scope for this article."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=http://localhost:1313/posts/how-c-program-convert-into-assembly/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/trident_favicon.webp><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/images/trident_favicon.webp><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/images/trident_favicon.webp><link rel=apple-touch-icon href=http://localhost:1313/images/trident_favicon.webp><link rel=mask-icon href=http://localhost:1313/images/trident_favicon.webp><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/how-c-program-convert-into-assembly/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How C Program Converts Into Assembly!"><meta property="og:description" content="In an earlier article, we have seen C runtime: before starting main & How C program stored in RAM memory. Here we will see &ldquo;How C program converts into assembly?&rdquo; and different aspect of its working at the machine level.
A Bit About Functions Stack Frames During function code execution, a new stack frame is created in stack memory to allow access to function parameters and local variables. The direction of stack frame growth totally depends on compiler ABI which is out of our scope for this article."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/how-c-program-convert-into-assembly/"><meta property="og:image" content="http://localhost:1313/images/How-C-program-converted-into-assembly.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-16T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-16T00:00:00+00:00"><meta property="og:site_name" content="Vishal Chovatiya"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/How-C-program-converted-into-assembly.png"><meta name=twitter:title content="How C Program Converts Into Assembly!"><meta name=twitter:description content="In an earlier article, we have seen C runtime: before starting main & How C program stored in RAM memory. Here we will see &ldquo;How C program converts into assembly?&rdquo; and different aspect of its working at the machine level.
A Bit About Functions Stack Frames During function code execution, a new stack frame is created in stack memory to allow access to function parameters and local variables. The direction of stack frame growth totally depends on compiler ABI which is out of our scope for this article."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"How C Program Converts Into Assembly!","item":"http://localhost:1313/posts/how-c-program-convert-into-assembly/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How C Program Converts Into Assembly!","name":"How C Program Converts Into Assembly!","description":"In an earlier article, we have seen C runtime: before starting main \u0026amp; How C program stored in RAM memory. Here we will see \u0026ldquo;How C program converts into assembly?\u0026rdquo; and different aspect of its working at the machine level.\nA Bit About Functions Stack Frames During function code execution, a new stack frame is created in stack memory to allow access to function parameters and local variables. The direction of stack frame growth totally depends on compiler ABI which is out of our scope for this article.","keywords":["accessing-global-local-static-variables-in-c","function-prologue-epilogue","function-stack-frame","how-c-program-converts-into-assembly","how-do-you-corrupt-stack-deliberately","how-do-you-determine-the-stack-growth-direction","how-you-can-increase-stack-frame-size","return-value-from-function-in-c","x86-special-function-registers"],"articleBody":"In an earlier article, we have seen C runtime: before starting main \u0026 How C program stored in RAM memory. Here we will see “How C program converts into assembly?” and different aspect of its working at the machine level.\nA Bit About Functions Stack Frames During function code execution, a new stack frame is created in stack memory to allow access to function parameters and local variables. The direction of stack frame growth totally depends on compiler ABI which is out of our scope for this article. The complete information on stack frame size, memory allocation, returning from stack frame is decided at compile time. Before diving into assembly code you should be aware of two things : CPU registers of x86 machine. x86 assembly instructions: As this is a very vast topic \u0026 updating quite frequently, we will only see the instructions needed for our examples. x86 CPU Registers General Purpose Registers: 32-bit SFR 64-bit SFR Name eax rax Accumulator uses for arithmetic ebx rbx Base uses for memory address calculations ecx rcx Counter uses to hold loop count edx rdx Double-word Accumulator or data register use for I/O port access Pointer Register: 32-bit SFR 64-bit SFR Name esp rsp Stack pointer ebp rbp Frame/base pointer points current stack frame eip rip Instruction pointer points to the next instruction to execute Segment Register: SFR Name cs Code segment ds Data segment ss Stack segment es Extra segment Index Registers: 32-bit SFR 64-bit SFR Name esi rsi Source Index uses to point index in sequential memory operations edi rdi Destination Index uses to point index in sequential memory operations Apart from all these, there are many other registers as well which even I don’t know about. But above-mentioned registers are sufficient to understand the subsequent topics.\nHow C Program Converts Into Assembly? We will consider the following example with its disassembly inlined to understand its different aspect of working at machine level :\nWe will focus on a stack frame of the function func() But before analysing stack frame of it, we will see how the calling of function happens:\nFunction calling Function calling is done by call instruction(see Line 15) which is subroutine instruction equivalent to :\n1 2 push rip + 1 ; return address is address of next instructions jmp func Here, call store the rip+1(not that +1 is just for simplicity, technically this will be substituted by the size of instruction) in the stack which is return address once call to func()ends.\nFunction Stack Frame A function stack frame is divided into three parts\nPrologue/Entry User code Epilogue/Exit 1. Prologue/Entry: As you can see instructions(line 2 to 4) generated against start bracket { is prologue which is setting up the stack frame for `func(), Line 2 is pushing the previous frame pointer into the stack \u0026 Line 3 is updating the current frame pointer with stack end which is going to be a new frame start.\npush is basically equivalent to :\n1 2 sub esp, 4 ; decrements ESP by 4 which is kind of space allocation mov [esp], X ; put new stack item value X in Parameter Passing Argument of func() is stored in edi register on Line 14 before calling call instruction. If there is more argument then it will be stored in a subsequent register or stack \u0026 address will be used. Line 4 in func()is reserving space by pulling frame pointer(pointed by rbp register) down by 4 bytes for the parameter arg as it is of type int. Then mov instruction will initialize it with value store inedi. This is how parameters are passed \u0026 stored in the current stack frame.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ---|-------------------------|--- main() | | | | | | |-------------------------| | main frame pointer | rbp \u0026 rsp ---|-------------------------|--- func() in func() | arg | |-------------------------| | a | |-------------------------| stack | + | | | + | | | + | | ---|-------------------------|--- \\|/ | | | | Allocating Space for Local Variables 2. User code: Line 5 is reserving space for a local variable a, again by pulling frame pointer further down by 4 bytes. mov instruction will initialize that memory with a value 5.\nAccessing Global \u0026 Local Static Variables As you can see above, g is addressed directly with its absolute addressing because its address is fixed which lies in the data segment. This is not the case all the time. Here we have compiled our code for x86 mode, that’s why it is accessing it with an absolute address. In the case of x64 mode, the address is resolved using rip register which meant that the assembler and linker should cooperate to compute the offset of g from the ultimate location of the current instruction which is pointed by rip register. The same statement stands true for the local static variables also. 3. Epilogue/Exit: After the user code execution, the previous frame pointer is retrieved from the stack by pop instruction which we have stored in Line 2. pop is equivalent to:\n1 2 mov X, [esp] ; put top stack item value into X add esp, 4 ; increments ESP by 4 which is kind of deallocation Return From Function ret instruction jumps back to the next instruction from where func()called by retrieving the jump address from stack stored by call instruction. ret is subroutine instruction which is equivalent to:\n1 2 pop rip ; jmp rip ; If any return value specified then it will be stored in eax register which you can see in Line 16.\nSo, this is it for “How C program converts into assembly?”. Although this kind of information is strictly coupled with compiler \u0026 ABI. But most of the compilers, ABI \u0026 instruction set architecture follows the same more or less. In case, you have not gone through my previous articles, here are simple FAQs helps you to understand better:\nFAQs Q. How do you determine the stack growth direction\nA. Simple…! by comparing the address of two different function’s local variables.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int *main_ptr = NULL; int *func_ptr = NULL; void func() { int a; func_ptr = \u0026a; } int main() { int a; main_ptr = \u0026a; func(); (main_ptr \u003e func_ptr) ? printf(\"DOWN\\n\") : printf(\"UP\\n\"); return 0; } Q. How do you corrupt stack deliberately\nA. Corrupt the SFR values stored in the stack frame.\n1 2 3 4 5 6 7 8 9 10 11 void func() { int a; memset(\u0026a, 0, 100); // Corrupt SFR values stored in stack frame } int main() { func(); return 0; } Q. How you can increase stack frame size\nA. alloca()is the answer. Google about it or see this. Although this is not recommended.\n","wordCount":"1149","inLanguage":"en","image":"http://localhost:1313/images/How-C-program-converted-into-assembly.png","datePublished":"2019-09-16T00:00:00Z","dateModified":"2019-09-16T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/how-c-program-convert-into-assembly/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/trident_favicon.webp"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=http://localhost:1313/posts/ title=Latest><span>Latest</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How C Program Converts Into Assembly!</h1><div class=post-meta><span title='2019-09-16 00:00:00 +0000 UTC'>September 16, 2019</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1149 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/blob/main/vishalchovatiya/content/posts/how-c-program-convert-into-assembly.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/images/How-C-program-converted-into-assembly.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#a-bit-about-functions-stack-frames>A Bit About Functions Stack Frames</a></li><li><a href=#x86-cpu-registers>x86 CPU Registers</a><ul><li><a href=#general-purpose-registers>General Purpose Registers:</a></li><li><a href=#pointer-register>Pointer Register:</a></li><li><a href=#segment-register>Segment Register:</a></li><li><a href=#index-registers>Index Registers:</a></li></ul></li><li><a href=#how-c-program-converts-into-assembly>How C Program Converts Into Assembly?</a><ul><li><a href=#function-calling>Function calling</a></li><li><a href=#function-stack-frame>Function Stack Frame</a></li><li><a href=#parameter-passing>Parameter Passing</a></li><li><a href=#allocating-space-for-local-variables>Allocating Space for Local Variables</a></li><li><a href=#accessing-global--local-static-variables>Accessing Global & Local Static Variables</a></li><li><a href=#return-from-function><strong>Return From Function</strong></a></li></ul></li><li><a href=#faqs>FAQs</a></li></ul></nav></div></details></div><div class=post-content><p>In an earlier article, we have seen <a href=/posts/before-starting-main-c-runtime/>C runtime: before starting main</a> & <a href=/posts/how-c-program-stored-in-ram-memory/>How C program stored in RAM memory</a>. Here we will see &ldquo;How C program converts into assembly?&rdquo; and different aspect of its working at the machine level.</p><h2 id=a-bit-about-functions-stack-frames>A Bit About Functions Stack Frames<a hidden class=anchor aria-hidden=true href=#a-bit-about-functions-stack-frames>#</a></h2><ul><li>During function code execution, a new stack frame is created in stack memory to allow access to function parameters and local variables.</li><li>The direction of stack frame growth totally depends on compiler ABI which is out of our scope for this article.</li><li>The complete information on stack frame size, memory allocation, returning from stack frame is decided at compile time.</li><li>Before diving into assembly code you should be aware of two things :<ol><li>CPU registers of x86 machine.</li><li>x86 assembly instructions: As this is a very vast topic & updating quite frequently, we will only see the instructions needed for our examples.</li></ol></li></ul><h2 id=x86-cpu-registers>x86 CPU Registers<a hidden class=anchor aria-hidden=true href=#x86-cpu-registers>#</a></h2><h3 id=general-purpose-registers>General Purpose Registers:<a hidden class=anchor aria-hidden=true href=#general-purpose-registers>#</a></h3><table><thead><tr><th>32-bit SFR</th><th>64-bit SFR</th><th>Name</th></tr></thead><tbody><tr><td>eax</td><td>rax</td><td>Accumulator uses for arithmetic</td></tr><tr><td>ebx</td><td>rbx</td><td>Base uses for memory address calculations</td></tr><tr><td>ecx</td><td>rcx</td><td>Counter uses to hold loop count</td></tr><tr><td>edx</td><td>rdx</td><td>Double-word Accumulator or data register use for I/O port access</td></tr></tbody></table><h3 id=pointer-register>Pointer Register:<a hidden class=anchor aria-hidden=true href=#pointer-register>#</a></h3><table><thead><tr><th>32-bit SFR</th><th>64-bit SFR</th><th>Name</th></tr></thead><tbody><tr><td>esp</td><td>rsp</td><td>Stack pointer</td></tr><tr><td>ebp</td><td>rbp</td><td>Frame/base pointer points current stack frame</td></tr><tr><td>eip</td><td>rip</td><td>Instruction pointer points to the next instruction to execute</td></tr></tbody></table><h3 id=segment-register>Segment Register:<a hidden class=anchor aria-hidden=true href=#segment-register>#</a></h3><table><thead><tr><th>SFR</th><th>Name</th></tr></thead><tbody><tr><td>cs</td><td>Code segment</td></tr><tr><td>ds</td><td>Data segment</td></tr><tr><td>ss</td><td>Stack segment</td></tr><tr><td>es</td><td>Extra segment</td></tr></tbody></table><h3 id=index-registers>Index Registers:<a hidden class=anchor aria-hidden=true href=#index-registers>#</a></h3><table><thead><tr><th>32-bit SFR</th><th>64-bit SFR</th><th>Name</th></tr></thead><tbody><tr><td>esi</td><td>rsi</td><td>Source Index uses to point index in sequential memory operations</td></tr><tr><td>edi</td><td>rdi</td><td>Destination Index uses to point index in sequential memory operations</td></tr></tbody></table><p>Apart from all these, there are many other registers as well which even I don&rsquo;t know about. But above-mentioned registers are sufficient to understand the subsequent topics.</p><h2 id=how-c-program-converts-into-assembly>How C Program Converts Into Assembly?<a hidden class=anchor aria-hidden=true href=#how-c-program-converts-into-assembly>#</a></h2><p>We will consider the following example with its disassembly inlined to understand its different aspect of working at machine level :</p><p><img loading=lazy src=/images/How-C-program-converted-into-assembly-1024x441.png#center alt="How C program converted into assembly?"></p><p>We will focus on a stack frame of the function <code>func()</code> But before analysing stack frame of it, we will see how the calling of function happens:</p><h3 id=function-calling>Function calling<a hidden class=anchor aria-hidden=true href=#function-calling>#</a></h3><p>Function calling is done by <code>call</code> instruction(see Line 15) which is subroutine instruction equivalent to :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>push</span> <span class=no>rip</span> <span class=err>+</span> <span class=mi>1</span> <span class=c1>; return address is address of next instructions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>jmp</span> <span class=no>func</span>
</span></span></code></pre></td></tr></table></div></div><p>Here, <code>call</code> store the <code>rip+1</code>(not that +1 is just for simplicity, technically this will be substituted by the size of instruction) in the stack which is return address once call to <code>func()</code>ends.</p><h3 id=function-stack-frame>Function Stack Frame<a hidden class=anchor aria-hidden=true href=#function-stack-frame>#</a></h3><p>A function stack frame is divided into three parts</p><ol><li><a href=https://en.wikipedia.org/wiki/Function_prologue>Prologue</a>/Entry</li><li>User code</li><li><a href=https://en.wikipedia.org/wiki/Function_prologue#Epilogue>Epilogue</a>/Exit</li></ol><p><strong>1. Prologue/Entry:</strong> As you can see instructions(line 2 to 4) generated against start bracket <code>{</code> is prologue which is setting up the stack frame for `func(), Line 2 is pushing the previous frame pointer into the stack & Line 3 is updating the current frame pointer with stack end which is going to be a new frame start.</p><p><code>push</code> is basically equivalent to :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>sub</span> <span class=no>esp</span><span class=p>,</span> <span class=mi>4</span>   <span class=c1>; decrements ESP by 4 which is kind of space allocation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>mov</span> <span class=p>[</span><span class=no>esp</span><span class=p>],</span> <span class=no>X</span> <span class=c1>; put new stack item value X in
</span></span></span></code></pre></td></tr></table></div></div><h3 id=parameter-passing>Parameter Passing<a hidden class=anchor aria-hidden=true href=#parameter-passing>#</a></h3><p>Argument of <code>func()</code> is stored in <code>edi</code> register on Line 14 before calling <code>call</code> instruction. If there is more argument then it will be stored in a subsequent register or stack & address will be used. Line 4 in <code>func()</code>is reserving space by pulling frame pointer(pointed by <code>rbp</code> register) down by 4 bytes for the parameter <code>arg</code> as it is of type <code>int</code>. Then <code>mov</code> instruction will initialize it with value store in<code>edi</code>. This is how parameters are passed & stored in the current stack frame.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>          ---|-------------------------|--- main()
</span></span><span class=line><span class=cl>             |                         |          
</span></span><span class=line><span class=cl>             |                         |          
</span></span><span class=line><span class=cl>             |                         |          
</span></span><span class=line><span class=cl>             |-------------------------|          
</span></span><span class=line><span class=cl>             |    main frame pointer   |          
</span></span><span class=line><span class=cl>rbp &amp; rsp ---|-------------------------|--- func()
</span></span><span class=line><span class=cl>in func()    |           arg           |          
</span></span><span class=line><span class=cl>             |-------------------------|          
</span></span><span class=line><span class=cl>             |            a            |          
</span></span><span class=line><span class=cl>             |-------------------------|    stack 
</span></span><span class=line><span class=cl>             |            +            |      |   
</span></span><span class=line><span class=cl>             |            +            |      |   
</span></span><span class=line><span class=cl>             |            +            |      |   
</span></span><span class=line><span class=cl>          ---|-------------------------|--- \|/  
</span></span><span class=line><span class=cl>             |                         |          
</span></span><span class=line><span class=cl>             |                         |          
</span></span><span class=line><span class=cl>                                                   
</span></span></code></pre></td></tr></table></div></div><h3 id=allocating-space-for-local-variables>Allocating Space for Local Variables<a hidden class=anchor aria-hidden=true href=#allocating-space-for-local-variables>#</a></h3><p><strong>2.</strong> <strong>User</strong> <strong>code:</strong> Line 5 is reserving space for a local variable <code>a</code>, again by pulling frame pointer further down by 4 bytes. <code>mov</code> instruction will initialize that memory with a value <code>5</code>.</p><h3 id=accessing-global--local-static-variables>Accessing Global & Local Static Variables<a hidden class=anchor aria-hidden=true href=#accessing-global--local-static-variables>#</a></h3><ul><li>As you can see above, <code>g</code> is addressed directly with its absolute addressing because its address is fixed which lies in the data segment.</li><li>This is not the case all the time. Here we have compiled our code for  x86 mode, that&rsquo;s why it is accessing it with an absolute address.</li><li>In the case of x64 mode, the address is resolved using <code>rip</code> register which meant that the assembler and linker should cooperate to compute the offset of <code>g</code> from the ultimate location of the current instruction which is pointed by <code>rip</code> register.</li><li>The same statement stands true for the local static variables also.</li></ul><p><strong>3. Epilogue/Exit:</strong> After the user code execution, the previous frame pointer is retrieved from the stack by <code>pop</code> instruction which we have stored in Line 2. <code>pop</code> is equivalent to:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>mov</span> <span class=no>X</span><span class=p>,</span> <span class=p>[</span><span class=no>esp</span><span class=p>]</span> <span class=c1>; put top stack item value into X 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>add</span> <span class=no>esp</span><span class=p>,</span> <span class=mi>4</span>   <span class=c1>; increments ESP by 4 which is kind of deallocation
</span></span></span></code></pre></td></tr></table></div></div><h3 id=return-from-function><strong>Return From Function</strong><a hidden class=anchor aria-hidden=true href=#return-from-function>#</a></h3><p><code>ret</code> instruction jumps back to the next instruction from where <code>func()</code>called by retrieving the jump address from stack stored by <code>call</code> instruction. <code>ret</code> is subroutine instruction which is equivalent to:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>pop</span> <span class=no>rip</span> <span class=c1>; 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>jmp</span> <span class=no>rip</span> <span class=c1>;
</span></span></span></code></pre></td></tr></table></div></div><p>If any return value specified then it will be stored in <code>eax</code> register which you can see in Line 16.</p><p>So, this is it for &ldquo;How C program converts into assembly?&rdquo;. Although this kind of information is strictly coupled with compiler & ABI. But most of the compilers, ABI & instruction set architecture follows the same more or less. In case, you have not gone through <a href=/posts/category/c-language/>my previous articles</a>, here are simple FAQs helps you to understand better:</p><h2 id=faqs>FAQs<a hidden class=anchor aria-hidden=true href=#faqs>#</a></h2><p><strong>Q. How do you determine the stack growth direction</strong></p><p><strong>A.</strong> Simple&mldr;! by comparing the address of two different function&rsquo;s local variables.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>main_ptr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>func_ptr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>a</span><span class=p>;</span> <span class=n>func_ptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=p>;</span> <span class=n>main_ptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>main_ptr</span> <span class=o>&gt;</span> <span class=n>func_ptr</span><span class=p>)</span> <span class=o>?</span> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;DOWN</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span> <span class=o>:</span> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;UP</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Q. How do you corrupt stack deliberately</strong></p><p><strong>A.</strong> Corrupt the SFR values stored in the stack frame.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>100</span><span class=p>);</span> <span class=c1>// Corrupt SFR values stored in stack frame
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Q. How you can increase stack frame size</strong></p><p><strong>A.</strong> <code>alloca()</code>is the answer. Google about it or see <a href=http://man7.org/linux/man-pages/man3/alloca.3.html>this</a>. Although this is not recommended.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/accessing-global-local-static-variables-in-c/>Accessing-Global-Local-Static-Variables-in-C</a></li><li><a href=http://localhost:1313/tags/function-prologue-epilogue/>Function-Prologue-Epilogue</a></li><li><a href=http://localhost:1313/tags/function-stack-frame/>Function-Stack-Frame</a></li><li><a href=http://localhost:1313/tags/how-c-program-converts-into-assembly/>How-C-Program-Converts-Into-Assembly</a></li><li><a href=http://localhost:1313/tags/how-do-you-corrupt-stack-deliberately/>How-Do-You-Corrupt-Stack-Deliberately</a></li><li><a href=http://localhost:1313/tags/how-do-you-determine-the-stack-growth-direction/>How-Do-You-Determine-the-Stack-Growth-Direction</a></li><li><a href=http://localhost:1313/tags/how-you-can-increase-stack-frame-size/>How-You-Can-Increase-Stack-Frame-Size</a></li><li><a href=http://localhost:1313/tags/return-value-from-function-in-c/>Return-Value-From-Function-in-C</a></li><li><a href=http://localhost:1313/tags/x86-special-function-registers/>X86-Special-Function-Registers</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/learn-lambda-function-in-cpp-with-example/><span class=title>« Prev</span><br><span>All About Lambda Function in C++(From C++11 to C++20)</span>
</a><a class=next href=http://localhost:1313/posts/how-c-program-stored-in-ram-memory/><span class=title>Next »</span><br><span>How C Program Stored in Ram Memory!</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How C Program Converts Into Assembly! on x" href="https://x.com/intent/tweet/?text=How%20C%20Program%20Converts%20Into%20Assembly%21&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-c-program-convert-into-assembly%2f&amp;hashtags=accessing-global-local-static-variables-in-c%2cfunction-prologue-epilogue%2cfunction-stack-frame%2chow-c-program-converts-into-assembly%2chow-do-you-corrupt-stack-deliberately%2chow-do-you-determine-the-stack-growth-direction%2chow-you-can-increase-stack-frame-size%2creturn-value-from-function-in-c%2cx86-special-function-registers"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How C Program Converts Into Assembly! on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-c-program-convert-into-assembly%2f&amp;title=How%20C%20Program%20Converts%20Into%20Assembly%21&amp;summary=How%20C%20Program%20Converts%20Into%20Assembly%21&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-c-program-convert-into-assembly%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How C Program Converts Into Assembly! on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-c-program-convert-into-assembly%2f&title=How%20C%20Program%20Converts%20Into%20Assembly%21"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How C Program Converts Into Assembly! on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-c-program-convert-into-assembly%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How C Program Converts Into Assembly! on whatsapp" href="https://api.whatsapp.com/send?text=How%20C%20Program%20Converts%20Into%20Assembly%21%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-c-program-convert-into-assembly%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How C Program Converts Into Assembly! on telegram" href="https://telegram.me/share/url?text=How%20C%20Program%20Converts%20Into%20Assembly%21&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-c-program-convert-into-assembly%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How C Program Converts Into Assembly! on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20C%20Program%20Converts%20Into%20Assembly%21&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fhow-c-program-convert-into-assembly%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>