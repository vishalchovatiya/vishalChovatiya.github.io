<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to hack C/C++ application using RTLD_NEXT with an easy example | Vishal Chovatiya</title>
<meta name=keywords content="dlerror,dlsym,hack-c-c-application-using-rtld_next,ld_preload,rtld_next,shared-library-loading-sequence,strip,stripped-binaries"><meta name=description content="While I was working as a core C library developer with my previous employer. I came across this RTLD_NEXT flag in dynamic linking which has the amazing capability and can be easily exploited or used for unethical purpose(Here I intend to educate the developer to don&rsquo;t be victims). In this article, I will show you a simple way to hack C/C++ application using RTLD_NEXT with an easy example.
Brief Let say you have a C/C++ application/tool which is highly proprietary and driving most of the business to your company."><meta name=author content="Vishal Chovatiya"><link rel=canonical href=https://vishalchovatiya.github.io/posts/hack-c-cpp-application-using-rtld-next-with-an-easy-example/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vishalchovatiya.github.io/posts/hack-c-cpp-application-using-rtld-next-with-an-easy-example/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How to hack C/C++ application using RTLD_NEXT with an easy example"><meta property="og:description" content="While I was working as a core C library developer with my previous employer. I came across this RTLD_NEXT flag in dynamic linking which has the amazing capability and can be easily exploited or used for unethical purpose(Here I intend to educate the developer to don&rsquo;t be victims). In this article, I will show you a simple way to hack C/C++ application using RTLD_NEXT with an easy example.
Brief Let say you have a C/C++ application/tool which is highly proprietary and driving most of the business to your company."><meta property="og:type" content="article"><meta property="og:url" content="https://vishalchovatiya.github.io/posts/hack-c-cpp-application-using-rtld-next-with-an-easy-example/"><meta property="og:image" content="https://vishalchovatiya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-09-25T00:00:00+00:00"><meta property="article:modified_time" content="2016-09-25T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vishalchovatiya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="How to hack C/C++ application using RTLD_NEXT with an easy example"><meta name=twitter:description content="While I was working as a core C library developer with my previous employer. I came across this RTLD_NEXT flag in dynamic linking which has the amazing capability and can be easily exploited or used for unethical purpose(Here I intend to educate the developer to don&rsquo;t be victims). In this article, I will show you a simple way to hack C/C++ application using RTLD_NEXT with an easy example.
Brief Let say you have a C/C++ application/tool which is highly proprietary and driving most of the business to your company."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vishalchovatiya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"How to hack C/C++ application using RTLD_NEXT with an easy example","item":"https://vishalchovatiya.github.io/posts/hack-c-cpp-application-using-rtld-next-with-an-easy-example/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to hack C/C++ application using RTLD_NEXT with an easy example","name":"How to hack C\/C\u002b\u002b application using RTLD_NEXT with an easy example","description":"While I was working as a core C library developer with my previous employer. I came across this RTLD_NEXT flag in dynamic linking which has the amazing capability and can be easily exploited or used for unethical purpose(Here I intend to educate the developer to don\u0026rsquo;t be victims). In this article, I will show you a simple way to hack C/C++ application using RTLD_NEXT with an easy example.\nBrief Let say you have a C/C++ application/tool which is highly proprietary and driving most of the business to your company.","keywords":["dlerror","dlsym","hack-c-c-application-using-rtld_next","ld_preload","rtld_next","shared-library-loading-sequence","strip","stripped-binaries"],"articleBody":"While I was working as a core C library developer with my previous employer. I came across this RTLD_NEXT flag in dynamic linking which has the amazing capability and can be easily exploited or used for unethical purpose(Here I intend to educate the developer to don’t be victims). In this article, I will show you a simple way to hack C/C++ application using RTLD_NEXT with an easy example.\nBrief Let say you have a C/C++ application/tool which is highly proprietary and driving most of the business to your company. You have done some licensing or encryption which prevents a hacker(or maybe rivals) from cracking your binary or to use it without your license keys or something. This binary can easily be cracked by the use of RTLD_NEXT flag if you have not taken enough precautions which we will discuss later in this article. Library linking \u0026 symbol resolution Library linking \u0026 symbol resolution i.e. extracting address(precisely offset here in dynamic linking case) of function is specified at compile time. For example, there are four shared libraries linked \u0026 loaded dynamically in order as A.so, B.so, C.so \u0026 D.so with the main application. And funcXYZ()is called from the main application which is defined in both the library C.so \u0026 D.so with the same prototype. Then funcXYZ()from C.so will be called first as it’s ahead of D.so in linking order. Intro to RTLD_NEXT But what if you want to call funcXYZ() from D.so? You can achieve this byRTLD_NEXTflag defined in. What you have to do is define your funcXYZ()as below in C.so`:\nvoid funcXYZ() { void (*fptr)(void) = NULL; if ((fptr = (void (*)(void))dlsym(RTLD_NEXT, \"funcXYZ\")) == NULL) { (void)printf(\"dlsym: %s\\n\", dlerror()); exit(1); } return ((*fptr)()); } Now, whenever funcXYZ()called from main application it will come to C.so which simply search for the same symbol from next loaded libraries i.e. D.so . dlsym() search for symbol provided in argument from the memory and a returns function pointer to the same. Let’s hack C/C++ application using RTLD_NEXT malloc.c #include #include void *malloc(size_t size) { static void *(*fptr)(size_t) = NULL; /* look up of malloc, only the first time we are here */ if (fptr == NULL) { fptr = (void *(*)(size_t))dlsym(RTLD_NEXT, \"malloc\"); if (fptr == NULL) { printf(\"dlsym: %s\\n\", dlerror()); return NULL; } } printf(\"Our Malloc\\n\"); return (*fptr)(size); // Calling original malloc } main.c #include #include int main() { malloc(1); return 0; } Creating a shared library $ gcc -o malloc.so -shared -fPIC malloc.c -D_GNU_SOURCE Linking \u0026 executing the main application $ gcc -o main main.c ./malloc.so -ldl $ ./main Our Malloc Note: You can also use LD_PRELOAD as below, which loads the specified library first. No need to mention ./malloc.so explicitly in the compilation.\n$ LD_PRELOAD=`pwd`/malloc.so ./main How it works When you compile main.c with gcc -o main main.c ./malloc.so -ldl, you specify malloc.so explicitly on first order. We can verify this by ldd command $ ldd main linux-vdso.so.1 =\u003e (0x00007fff37bf4000) malloc.so (0x00007fc5df598000) libdl.so.2 =\u003e /lib64/libdl.so.2 (0x00007fc5df37d000) libc.so.6 =\u003e /lib64/libc.so.6 (0x00007fc5defbb000) /lib64/ld-linux-x86-64.so.2 (0x00007fc5df79b000) So when you call malloc it will refer the first occurrence of the symbol from the loaded library sequence which is in our malloc.so library. We now extract original malloc from next loaded shared library which is /lib64/libc.so.6. What RTLD_NEXT used for? An obvious question would be “Why the hell library designer/developer keep this kind of vulnerability?”\nRTLD_NEXT allows one to provide a wrapper around a function defined in another shared library. At least that is what man page of dlsym describes. I am still confused! Is this feature or vulnerability?\nVulnerability If you not experienced enough then perhaps your question would be “What’s vulnerability in this ?\"?‍♀️ then let me tell you, my friend, you might have stored license string, encryption key or any other proprietary data to validate against user access which usually programmer stores using struct or array kind of data structures. Now, we generally use memcmp() or strcmp()library functions to compare user access or validate key/data. You can easily generate wrapper around these functions using RTLD_NEXT` and manipulate it. Some companies use real-time authentication by an HTTP request which can also be cracked as there might be a particular function returning true or false as access check. You can simply create a wrapper of that function to manipulate it. This may take more time to find out function by hit \u0026 trial method. But it’s not impossible. To figure out function name you can use nm or readelf like utilities which list out symbol names \u0026 it’s corresponding addresses/offset as follows $ nm main .... 0000000000600e00 d _DYNAMIC 00000000004005b7 T main U malloc 0000000000400540 t register_tm_clones .... If you want to learn more about binary file format ELF, then I have written a separate article for it here. Precautions you should consider Use stripped binaries for release Compiled binary usually contain symbol information as we show using nm utility above. But when you strip binary it just strip symbol table from it which is not necessary for execution as it is only being used in debugging \u0026 link resolution at compile time. Stripped binary can produced with the help of the compiler itself, e.g. GNU GCC compilers’ -s flag, or with a dedicated tool like strip on Unix.\n$ strip --strip-all main $ nm main nm: main: no symbols $ Static linking Rather than releasing a dynamic linking binary, compile static version \u0026 strip it. Although it has some cons which are out of topic for this article.\nDo not use library functions for handling proprietary data While processing proprietary data in your application do not rely on library functions rather design your own with weird names. If you are storing read-only proprietary data in ASCII format within binary then encrypt it or simply add a particular number in every char so that memory dump won’t show any human-readable sentences or words.\n","wordCount":"980","inLanguage":"en","image":"https://vishalchovatiya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2016-09-25T00:00:00Z","dateModified":"2016-09-25T00:00:00Z","author":{"@type":"Person","name":"Vishal Chovatiya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vishalchovatiya.github.io/posts/hack-c-cpp-application-using-rtld-next-with-an-easy-example/"},"publisher":{"@type":"Organization","name":"Vishal Chovatiya","logo":{"@type":"ImageObject","url":"https://vishalchovatiya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vishalchovatiya.github.io/ accesskey=h title="Vishal Chovatiya (Alt + H)"><img src=https://vishalchovatiya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Vishal Chovatiya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vishalchovatiya.github.io/pages/vishal-chovatiya title="About Me"><span>About Me</span></a></li><li><a href=https://vishalchovatiya.github.io/pages/start-here title="Start Here"><span>Start Here</span></a></li><li><a href=https://vishalchovatiya.github.io/posts/ title=Latest><span>Latest</span></a></li><li><a href=https://vishalchovatiya.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vishalchovatiya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vishalchovatiya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How to hack C/C++ application using RTLD_NEXT with an easy example</h1><div class=post-meta><span title='2016-09-25 00:00:00 +0000 UTC'>September 25, 2016</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;980 words&nbsp;·&nbsp;Vishal Chovatiya&nbsp;|&nbsp;<a href=https://github.com/vishalchovatiya/blog/vishalchovatiya/content/posts/hack-c-cpp-application-using-rtld-next-with-an-easy-example.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#brief>Brief</a></li><li><a href=#library-linking--symbol-resolution>Library linking & symbol resolution</a></li><li><a href=#intro-to-rtld_next>Intro to RTLD_NEXT</a></li><li><a href=#lets-hack-cc-application-using-rtld_next>Let&rsquo;s hack C/C++ application using RTLD_NEXT</a><ul><li></li></ul></li><li><a href=#how-it-works>How it works</a></li><li><a href=#what-rtld_next-used-for>What RTLD_NEXT used for?</a></li><li><a href=#vulnerability>Vulnerability</a></li><li><a href=#precautions-you-should-consider>Precautions you should consider</a><ul><li></li></ul></li></ul></nav></div></details></div><div class=post-content><p>While I was working as a core C library developer with my previous employer. I came across this RTLD_NEXT flag in dynamic linking which has the amazing capability and can be easily exploited or used for unethical purpose(Here I intend to educate the developer to don&rsquo;t be victims). In this article, I will show you a simple way to hack C/C++ application using RTLD_NEXT with an easy example.</p><h2 id=brief>Brief<a hidden class=anchor aria-hidden=true href=#brief>#</a></h2><ul><li>Let say you have a C/C++ application/tool which is highly proprietary and driving most of the business to your company. You have done some licensing or encryption which prevents a hacker(or maybe rivals) from cracking your binary or to use it without your license keys or something.</li><li>This binary can easily be cracked by the use of <code>RTLD_NEXT</code> flag if you have not taken enough precautions which we will discuss later in this article.</li></ul><h2 id=library-linking--symbol-resolution>Library linking & symbol resolution<a hidden class=anchor aria-hidden=true href=#library-linking--symbol-resolution>#</a></h2><ul><li>Library linking & symbol resolution i.e. extracting address(precisely offset here in dynamic linking case) of function is specified at compile time.</li><li>For example, there are four shared libraries linked & loaded dynamically in order as <code>A.so</code>, <code>B.so</code>, <code>C.so</code> & <code>D.so</code> with the main application. And <code>funcXYZ()</code>is called from the main application which is defined in both the library <code>C.so</code> & <code>D.so</code> with the same prototype.</li><li>Then <code>funcXYZ()</code>from <code>C.so</code> will be called first as it&rsquo;s ahead of <code>D.so</code> in linking order.</li></ul><h2 id=intro-to-rtld_next>Intro to RTLD_NEXT<a hidden class=anchor aria-hidden=true href=#intro-to-rtld_next>#</a></h2><p>But what if you want to call <code>funcXYZ() from </code>D.so<code>? You can achieve this by</code>RTLD_NEXT<code>flag defined in</code>&lt;dlfcn.h><code>. What you have to do is define your </code>funcXYZ()<code>as below in </code>C.so`:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>funcXYZ</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>fptr</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>fptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>void</span><span class=p>))</span><span class=nf>dlsym</span><span class=p>(</span><span class=n>RTLD_NEXT</span><span class=p>,</span> <span class=s>&#34;funcXYZ&#34;</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;dlsym: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>dlerror</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>((</span><span class=o>*</span><span class=n>fptr</span><span class=p>)());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>Now, whenever <code>funcXYZ()</code>called from main application it will come to <code>C.so</code> which simply search for the same symbol from next loaded libraries i.e. <code>D.so</code> .</li><li><a href=https://linux.die.net/man/3/dlsym>dlsym()</a> search for symbol provided in argument from the <a href=/posts/how-does-virtual-memory-work/>memory</a> and a returns function pointer to the same.</li></ul><h2 id=lets-hack-cc-application-using-rtld_next>Let&rsquo;s hack C/C++ application using RTLD_NEXT<a hidden class=anchor aria-hidden=true href=#lets-hack-cc-application-using-rtld_next>#</a></h2><h4 id=mallocc>malloc.c<a hidden class=anchor aria-hidden=true href=#mallocc>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dlfcn.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>malloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>void</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>fptr</span><span class=p>)(</span><span class=kt>size_t</span><span class=p>)</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* look up of malloc, only the first time we are here */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fptr</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>size_t</span><span class=p>))</span><span class=nf>dlsym</span><span class=p>(</span><span class=n>RTLD_NEXT</span><span class=p>,</span> <span class=s>&#34;malloc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>fptr</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;dlsym: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>dlerror</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Our Malloc</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=n>fptr</span><span class=p>)(</span><span class=n>size</span><span class=p>);</span> <span class=c1>// Calling original malloc
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=mainc>main.c<a hidden class=anchor aria-hidden=true href=#mainc>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=creating-a-shared-library>Creating a shared library<a hidden class=anchor aria-hidden=true href=#creating-a-shared-library>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ gcc -o malloc.so -shared -fPIC malloc.c -D_GNU_SOURCE
</span></span></code></pre></div><h4 id=linking--executing-the-main-application>Linking & executing the main application<a hidden class=anchor aria-hidden=true href=#linking--executing-the-main-application>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ gcc -o main main.c ./malloc.so -ldl
</span></span><span class=line><span class=cl>$ ./main
</span></span><span class=line><span class=cl>Our Malloc
</span></span></code></pre></div><p><strong>Note:</strong> You can also use <code>LD_PRELOAD</code> as below, which loads the specified library first. No need to mention <code>./malloc.so</code> explicitly in the compilation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nv>LD_PRELOAD</span><span class=o>=</span><span class=sb>`</span><span class=nb>pwd</span><span class=sb>`</span>/malloc.so ./main
</span></span></code></pre></div><h2 id=how-it-works>How it works<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h2><ul><li>When you compile <code>main.c</code> with <code>gcc -o main main.c ./malloc.so -ldl</code>, you specify <code>malloc.so</code> explicitly on first order. We can verify this by <code>ldd</code> command</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ldd main
</span></span><span class=line><span class=cl>linux-vdso.so.1 <span class=o>=</span>&gt; <span class=o>(</span>0x00007fff37bf4000<span class=o>)</span>
</span></span><span class=line><span class=cl>malloc.so <span class=o>(</span>0x00007fc5df598000<span class=o>)</span>
</span></span><span class=line><span class=cl>libdl.so.2 <span class=o>=</span>&gt; /lib64/libdl.so.2 <span class=o>(</span>0x00007fc5df37d000<span class=o>)</span>
</span></span><span class=line><span class=cl>libc.so.6 <span class=o>=</span>&gt; /lib64/libc.so.6 <span class=o>(</span>0x00007fc5defbb000<span class=o>)</span>
</span></span><span class=line><span class=cl>/lib64/ld-linux-x86-64.so.2 <span class=o>(</span>0x00007fc5df79b000<span class=o>)</span>
</span></span></code></pre></div><ul><li>So when you call <a href=/posts/how-do-malloc-free-work-in-c/>malloc</a> it will refer the first occurrence of the symbol from the loaded library sequence which is in our <code>malloc.so</code> library.</li><li>We now extract original malloc from next loaded shared library which is <code>/lib64/libc.so.6</code>.</li></ul><h2 id=what-rtld_next-used-for>What RTLD_NEXT used for?<a hidden class=anchor aria-hidden=true href=#what-rtld_next-used-for>#</a></h2><p>An obvious question would be &ldquo;Why the hell library designer/developer keep this kind of vulnerability?&rdquo;</p><ul><li><code>RTLD_NEXT</code> allows one to provide a wrapper around a function defined in another shared library. At least that is what <a href=https://linux.die.net/man/3/dlsym>man page of dlsym</a> describes.</li></ul><p>I am still confused! Is this feature or vulnerability?</p><h2 id=vulnerability>Vulnerability<a hidden class=anchor aria-hidden=true href=#vulnerability>#</a></h2><ul><li>If you not experienced enough then perhaps your question would be &ldquo;What&rsquo;s vulnerability in this ?"?‍♀️ then let me tell you, my friend, you might have stored license string, encryption key or any other proprietary data to validate against user access which usually programmer stores using struct or array kind of data structures.</li><li>Now, we generally use <code>memcmp() or </code>strcmp()<code>library functions to compare user access or validate key/data. You can easily generate wrapper around these functions using </code>RTLD_NEXT` and manipulate it.</li><li>Some companies use real-time authentication by an HTTP request which can also be cracked as there might be a particular function returning <code>true</code> or <code>false</code> as access check. You can simply create a wrapper of that function to manipulate it.</li><li>This may take more time to find out function by hit & trial method. But it&rsquo;s not impossible. To figure out function name you can use <code>nm</code> or <code>readelf</code> like utilities which list out symbol names & it&rsquo;s corresponding addresses/offset as follows</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ nm main 
</span></span><span class=line><span class=cl>....                                                                                                                                                             
</span></span><span class=line><span class=cl>0000000000600e00 d _DYNAMIC                                                                                                                                           
</span></span><span class=line><span class=cl>00000000004005b7 T main                                                                                                                                                      
</span></span><span class=line><span class=cl>                 U malloc                                                                                                                                                    
</span></span><span class=line><span class=cl><span class=m>0000000000400540</span> t register_tm_clones    
</span></span><span class=line><span class=cl>....
</span></span></code></pre></div><ul><li>If you want to learn more about binary file format ELF, then I have written a separate article for it <a href=/posts/understand-elf-file-format/>here</a>.</li></ul><h2 id=precautions-you-should-consider>Precautions you should consider<a hidden class=anchor aria-hidden=true href=#precautions-you-should-consider>#</a></h2><h4 id=use-stripped-binaries-for-release>Use stripped binaries for release<a hidden class=anchor aria-hidden=true href=#use-stripped-binaries-for-release>#</a></h4><p>Compiled binary usually contain symbol information as we show using <code>nm</code> utility above. But when you strip binary it just strip <a href=/posts/understand-elf-file-format/>symbol table</a> from it which is not necessary for execution as it is only being used in debugging & link resolution at compile time. Stripped binary can produced with the help of the compiler itself, e.g. GNU GCC compilers&rsquo; <code>-s</code> flag, or with a dedicated tool like strip on Unix.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ strip --strip-all main
</span></span><span class=line><span class=cl>$ nm main                                                                                                                                                              
</span></span><span class=line><span class=cl>nm: main: no symbols
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><h4 id=static-linking>Static linking<a hidden class=anchor aria-hidden=true href=#static-linking>#</a></h4><p>Rather than releasing a dynamic linking binary, compile static version & strip it. Although it has some cons which are out of topic for this article.</p><h4 id=do-not-use-library-functions-for-handling-proprietary-data>Do not use library functions for handling proprietary data<a hidden class=anchor aria-hidden=true href=#do-not-use-library-functions-for-handling-proprietary-data>#</a></h4><p>While processing proprietary data in your application do not rely on library functions rather design your own with weird names. If you are storing read-only proprietary data in ASCII format within binary then encrypt it or simply add a particular number in every char so that memory dump won&rsquo;t show any human-readable sentences or words.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://vishalchovatiya.github.io/tags/dlerror/>Dlerror</a></li><li><a href=https://vishalchovatiya.github.io/tags/dlsym/>Dlsym</a></li><li><a href=https://vishalchovatiya.github.io/tags/hack-c-c-application-using-rtld_next/>Hack-C-C-Application-Using-Rtld_next</a></li><li><a href=https://vishalchovatiya.github.io/tags/ld_preload/>Ld_preload</a></li><li><a href=https://vishalchovatiya.github.io/tags/rtld_next/>Rtld_next</a></li><li><a href=https://vishalchovatiya.github.io/tags/shared-library-loading-sequence/>Shared-Library-Loading-Sequence</a></li><li><a href=https://vishalchovatiya.github.io/tags/strip/>Strip</a></li><li><a href=https://vishalchovatiya.github.io/tags/stripped-binaries/>Stripped-Binaries</a></li></ul><nav class=paginav><a class=prev href=https://vishalchovatiya.github.io/posts/program-gets-run-linux/><span class=title>« Prev</span><br><span>How Program Gets Run: Linux</span>
</a><a class=next href=https://vishalchovatiya.github.io/posts/mmap/><span class=title>Next »</span><br><span>A Bit About mmap</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How to hack C/C++ application using RTLD_NEXT with an easy example on x" href="https://x.com/intent/tweet/?text=How%20to%20hack%20C%2fC%2b%2b%20application%20using%20RTLD_NEXT%20with%20an%20easy%20example&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fhack-c-cpp-application-using-rtld-next-with-an-easy-example%2f&amp;hashtags=dlerror%2cdlsym%2chack-c-c-application-using-rtld_next%2cld_preload%2crtld_next%2cshared-library-loading-sequence%2cstrip%2cstripped-binaries"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to hack C/C++ application using RTLD_NEXT with an easy example on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fhack-c-cpp-application-using-rtld-next-with-an-easy-example%2f&amp;title=How%20to%20hack%20C%2fC%2b%2b%20application%20using%20RTLD_NEXT%20with%20an%20easy%20example&amp;summary=How%20to%20hack%20C%2fC%2b%2b%20application%20using%20RTLD_NEXT%20with%20an%20easy%20example&amp;source=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fhack-c-cpp-application-using-rtld-next-with-an-easy-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to hack C/C++ application using RTLD_NEXT with an easy example on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fhack-c-cpp-application-using-rtld-next-with-an-easy-example%2f&title=How%20to%20hack%20C%2fC%2b%2b%20application%20using%20RTLD_NEXT%20with%20an%20easy%20example"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to hack C/C++ application using RTLD_NEXT with an easy example on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fhack-c-cpp-application-using-rtld-next-with-an-easy-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to hack C/C++ application using RTLD_NEXT with an easy example on whatsapp" href="https://api.whatsapp.com/send?text=How%20to%20hack%20C%2fC%2b%2b%20application%20using%20RTLD_NEXT%20with%20an%20easy%20example%20-%20https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fhack-c-cpp-application-using-rtld-next-with-an-easy-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to hack C/C++ application using RTLD_NEXT with an easy example on telegram" href="https://telegram.me/share/url?text=How%20to%20hack%20C%2fC%2b%2b%20application%20using%20RTLD_NEXT%20with%20an%20easy%20example&amp;url=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fhack-c-cpp-application-using-rtld-next-with-an-easy-example%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to hack C/C++ application using RTLD_NEXT with an easy example on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20to%20hack%20C%2fC%2b%2b%20application%20using%20RTLD_NEXT%20with%20an%20easy%20example&u=https%3a%2f%2fvishalchovatiya.github.io%2fposts%2fhack-c-cpp-application-using-rtld-next-with-an-easy-example%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vishalchovatiya.github.io/>Vishal Chovatiya</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>