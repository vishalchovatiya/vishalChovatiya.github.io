[{"content":"A coroutine is one of the major feature introduced with the C++20 standard apart from Module, Ranges \u0026amp; Concept. And you see how happy I am to unfold it. I already set the baseline on this topic with my previous article that Coroutine in C Language, where we saw, how suspension-resumption of execution works! With this article \u0026ldquo;C++20 Coroutine: Under The Hood\u0026rdquo;, we will see how compiler creates magic \u0026amp; standard library helps it with basic infrastructure making C++20 coroutine more sophisticated(yet complex) \u0026amp; scalable/customizable.\nAt any point, you feel there is some jargons/terminology that is not known to you. Please keep reading forward. I have added a special section for it.\nWhat Is Coroutine In General? Please refer my previous article Coroutine in C Language for more. What Is C++20 Coroutine? A function that Contains keywords co_await, co_yield and/or co_return. Use a return type specifying a promise. From the higher abstraction, the C++20 coroutine consists of: Promise Defines overall coroutine behaviour. Act as a communicator between caller \u0026amp; called coroutine. Awaiter Controls suspension \u0026amp; resumption behaviour. Coroutine handle Controls execution behaviour. Why Do You Even Need Coroutine? I have already covered this in my earlier post Coroutine in C Language.\nHowever, if you still want to understand the need for coroutine with use case then please refer to Iterator Design Pattern With Modern C++.\nOr you can directly see the section of this article Generating Integer Sequence Using Coroutine.\nUnderstanding C++20 Coroutine With Examples Enough theory. Let\u0026rsquo;s talk code. Suspending a Coroutine Following is a lame \u0026amp; minimal example of a C++20 Coroutine. However, this is a very good starting point for beginner with slow pace \u0026amp; less cluttered code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;coroutine\u0026gt; #include \u0026lt;iostream\u0026gt; struct HelloWorldCoro { struct promise_type { // compiler looks for `promise_type` HelloWorldCoro get_return_object() { return this; } std::suspend_always initial_suspend() { return {}; } std::suspend_always final_suspend() { return {}; } }; HelloWorldCoro(promise_type* p) : m_handle(std::coroutine_handle\u0026lt;promise_type\u0026gt;::from_promise(*p)) {} ~HelloWorldCoro() { m_handle.destroy(); } std::coroutine_handle\u0026lt;promise_type\u0026gt; m_handle; }; HelloWorldCoro print_hello_world() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; co_await std::suspend_always{}; std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { HelloWorldCoro mycoro = print_hello_world(); mycoro.m_handle.resume(); mycoro.m_handle(); // Equal to mycoro.m_handle.resume(); return EXIT_SUCCESS; } // g++-10 -std=c++20 -fcoroutines -fno-exceptions -o myapp Main.cpp A coroutine can be resumed by a resume member function of the std::coroutine_handle or by invoking the function call operator of the std::coroutine_handle object.\nAs I have mentioned earlier, the C++20 coroutine consists of:\nPromise i.e. promise_type\nType containing special methods like get_return_object(), initial_suspend(), final_suspend(), etc. that compiler use in coroutine transformation. Hence, it controls overall coroutine behaviour. Awaiter i.e. std::suspend_always\nEmpty class to suspend coroutine always. You can see the GCC implementation for this type here. Coroutine handle i.e. std::coroutine_handle\nHandler for coroutine that used to resume, destroy or check on a lifetime of coroutine. The compiler transforms the above print_hello_world coroutine as :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 HelloWorldCoro print_hello_world() { __HelloWorldCoro_ctx* __context = new __HelloWorldCoro_ctx{}; auto __return = __context-\u0026gt;_promise.get_return_object(); co_await __context-\u0026gt;_promise.initial_suspend(); std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; co_await std::suspend_always{ }; std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; __final_suspend_label: co_await __context-\u0026gt;_promise.final_suspend(); delete __context; return __return; } As you can see, the compiler first creates the context(i.e. coroutine state) object. Which presumably look like: 1 2 3 4 5 6 7 8 struct __HelloWorldCoro_ctx { HelloWorldCoro::promise_type _promise; // storage for argument passed to coroutine // storage for local variables // storage for representation of the current suspension point }; // Standard doesn\u0026#39;t define such type, rather compilers choose the type that suits its implementation. As seen, with the help of this context object, it creates the HelloWorldCoro object named as __return with the help of promise\u0026rsquo;s method get_return_object()\nFinally, one more level of transformation of co_await statements, coroutine would look like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 HelloWorldCoro print_hello_world() { __HelloWorldCoro_ctx* __context = new __HelloWorldCoro_ctx{}; auto __return = __context-\u0026gt;_promise.get_return_object(); { auto\u0026amp;\u0026amp; awaiter = std::suspend_always{}; if (!awaiter.await_ready()) { awaiter.await_suspend(std::coroutine_handle\u0026lt;\u0026gt; p); // compiler added suspend/resume hook } awaiter.await_resume(); } std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; { auto\u0026amp;\u0026amp; awaiter = std::suspend_always{}; if (!awaiter.await_ready()) { awaiter.await_suspend(std::coroutine_handle\u0026lt;\u0026gt; p); // compiler added suspend/resume hook } awaiter.await_resume(); } std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; __final_suspend_label: { auto\u0026amp;\u0026amp; awaiter = std::suspend_always{}; if (!awaiter.await_ready()) { awaiter.await_suspend(std::coroutine_handle\u0026lt;\u0026gt; p); // compiler added suspend/resume hook } awaiter.await_resume(); } return __return; } As you can see our HelloWorldCoro::promise_type::initial_suspend()\n\u0026amp; HelloWorldCoro::promise_type::final_suspend()returns std::suspend_always. Whose, method std::suspend_always::await_ready()in turn returns false always. So our coroutine will be suspended every time it encounters co_await.\nReturning a Value From Coroutine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;coroutine\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cassert\u0026gt; struct HelloWorldCoro { struct promise_type { int m_value; HelloWorldCoro get_return_object() { return this; } std::suspend_always initial_suspend() { return {}; } std::suspend_always final_suspend() { return {}; } void return_value(int val) { m_value = val; } }; HelloWorldCoro(promise_type* p) : m_handle(std::coroutine_handle\u0026lt;promise_type\u0026gt;::from_promise(*p)) {} ~HelloWorldCoro() { m_handle.destroy(); } std::coroutine_handle\u0026lt;promise_type\u0026gt; m_handle; }; HelloWorldCoro print_hello_world() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; co_await std::suspend_always{ }; std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; co_return -1; } int main() { HelloWorldCoro mycoro = print_hello_world(); mycoro.m_handle.resume(); mycoro.m_handle.resume(); assert(mycoro.m_handle.promise().m_value == -1); return EXIT_SUCCESS; } To return a value from a coroutine, you need to supply return_value()method to promise type. In other words, the compiler expects the method named return_value with appropriate argument.\nAnd, if you don\u0026rsquo;t supply it to promise type, you will be prompted with the below error:\n1 2 3 Main.cpp:27:5: error: no member named ‘return_value’ in ‘std::__n4861::__coroutine_traits_impl\u0026lt;HelloWorldCoro, void\u0026gt;::promise_type’ {aka ‘HelloWorldCoro::promise_type’} 27 | co_return -1; | ^~~~~~~~~ This return_value()method is then used by compiler to transform the co_return statement as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 HelloWorldCoro print_hello_world() { __HelloWorldCoro_ctx* __context = new __HelloWorldCoro_ctx{}; auto __return = __context-\u0026gt;_promise.get_return_object(); co_await __context-\u0026gt;_promise.initial_suspend(); std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; co_await std::suspend_always{ }; std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; __context-\u0026gt;_promise.return_value(-1); goto __final_suspend_label; __final_suspend_label: co_await __context-\u0026gt;_promise.final_suspend(); delete __context; return __return; } As you might have noticed, co_return transformation is plain vanilla, where the compiler just passes the return value to the promise object \u0026amp; jump to the final suspend label.\nI will not expand the co_await statements again. Otherwise, the code will become messy. However, by now, you can guess what could be there.\nYielding a Value From Coroutine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;coroutine\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cassert\u0026gt; struct HelloWorldCoro { struct promise_type { int m_val; HelloWorldCoro get_return_object() { return this; } std::suspend_always initial_suspend() { return {}; } std::suspend_always final_suspend() { return {}; } std::suspend_always yield_value(int val) { m_val = val; return {}; } }; HelloWorldCoro(promise_type* p) : m_handle(std::coroutine_handle\u0026lt;promise_type\u0026gt;::from_promise(*p)) {} ~HelloWorldCoro() { m_handle.destroy(); } std::coroutine_handle\u0026lt;promise_type\u0026gt; m_handle; }; HelloWorldCoro print_hello_world() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; co_yield 1; std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { HelloWorldCoro mycoro = print_hello_world(); mycoro.m_handle.resume(); assert(mycoro.m_handle.promise().m_val == 1); mycoro.m_handle.resume(); return EXIT_SUCCESS; } As we have done in returning a value from a coroutine, to yield anything from coroutine you need to supply the yield_value()method to promise_type that returns awaitable type.\nOnce again, the compiler transforms the coroutine that yields as:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 HelloWorldCoro print_hello_world() { __HelloWorldCoro_ctx* __context = new __HelloWorldCoro_ctx{}; auto __return = __context-\u0026gt;_promise.get_return_object(); co_await __context-\u0026gt;_promise.initial_suspend(); std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; co_await __context-\u0026gt;_promise.yield_value(1); std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; __final_suspend_label: co_await __context-\u0026gt;_promise.final_suspend(); delete __context; return __return; } As you can see co_yield statement transformed into co_await considering the promise\u0026rsquo;s method(i.e. yield_value() call as expression. That returns std::suspend_always so our coroutine will be suspended thereafter yielding a value. Generating Integer Sequence Using C++20 Coroutine So, that we understood the compiler transformations of coroutine, let\u0026rsquo;s do something meaningful with coroutine. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;coroutine\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cassert\u0026gt; struct Generator { struct promise_type { int m_val; Generator get_return_object() { return this; } std::suspend_never initial_suspend() { return {}; } std::suspend_always final_suspend() { return {}; } std::suspend_always yield_value(int val) { m_val = val; return {}; } }; /* ---------------------------- Iterator Implementation ----------------------------- */ struct iterator { bool operator!=(const iterator\u0026amp; rhs) { return not m_h_ptr-\u0026gt;done(); } iterator\u0026amp; operator++() { m_h_ptr-\u0026gt;resume(); return *this; } int operator*() { return m_h_ptr-\u0026gt;promise().m_val; } std::coroutine_handle\u0026lt;promise_type\u0026gt; *m_h_ptr; }; iterator begin() { return iterator{\u0026amp;m_handle}; } iterator end() { return iterator{nullptr}; } /* ---------------------------------------------------------------------------------- */ Generator(promise_type* p) : m_handle(std::coroutine_handle\u0026lt;promise_type\u0026gt;::from_promise(*p)) {} ~Generator() { m_handle.destroy(); } std::coroutine_handle\u0026lt;promise_type\u0026gt; m_handle; }; Generator range(uint32_t start, uint32_t end) { while(start != end) co_yield start++; } int main() { for (auto \u0026amp;\u0026amp;no : range(0, 10)) { // Isn\u0026#39;t this look like Python ! std::cout\u0026lt;\u0026lt; no \u0026lt;\u0026lt;std::endl; } return EXIT_SUCCESS; } A range()function of the above code will generate the integers on every iteration on a need basis. Instead of generating \u0026amp; returning precomputed sequence.\nFor the rest of the code, I suggest you spend some time with patience. And play around it.\nAnd, If you are thinking that why do we need iterator implementation inside Generator, then please learn How Range Based `for` Loop Works In C++!.\nC++20 Coroutine Terminology This section should have been at beginning of the article. However, I believe that until you understand how coroutine works under the hood, you won\u0026rsquo;t be able to connect the dots on C++20 coroutine jargons( or won\u0026rsquo;t understand data type naming convention).\nBy this time you are able to write a C++ coroutine \u0026amp; you can ignore this section. Nonetheless, it is just that you will have a hard time communicating with fellow C++ developers \u0026amp; reading cppreference. If you do so.\nAwaitable A type that supports the co_await operator is called an Awaitable type.\nC++20 introduced a new unary operator co_await that can be applied to an expression. For example:\n1 2 3 4 5 6 7 8 9 struct dummy { // Awaitable std::suspend_always operator co_await(){ return {}; } }; HelloWorldCoro print_hello_world() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; co_await dummy{}; std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; } Awaiter 1 2 3 4 5 6 7 8 9 10 11 struct my_awaiter { bool await_ready() { return false; } void await_suspend(std::coroutine_handle\u0026lt;\u0026gt;) {} void await_resume() {} }; HelloWorldCoro print_hello_world() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; co_await my_awaiter{}; std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; } An Awaiter type is a type that implements the three special methods that are called as part of a co_await expression: await_ready(), await_suspend() and await_resume() For example, standard library defined trivial awaiters i.e. std::suspend_always \u0026amp; std::suspend_never.\nNote that a type can be both an Awaitable type and an Awaiter type.\nco_await co_await is a unary operator that suspends a coroutine and returns control to the caller. Its operand is an expression whose type must either define operator co_await, or Awaitable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct dummy { }; // Awaitable struct HelloWorldCoro { struct promise_type { // . . . auto await_transform(const dummy\u0026amp;) { return std::suspend_always{}; } }; // . . . }; HelloWorldCoro print_hello_world() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34;; co_await dummy{}; std::cout \u0026lt;\u0026lt; \u0026#34;World!\u0026#34; \u0026lt;\u0026lt; std::endl; } Promise A type strictly named as promise_type.\nThe promise object is used inside the coroutine. The coroutine submits its result or exception through this object.\nThe promise type is determined by the compiler from the return type of the coroutine using std::coroutine_traits.\nCoroutine Handle The coroutine handle used to resume the execution of the coroutine or to destroy the coroutine frame. It does also indicates the status of coroutine using std::coroutine_handle::done()method. Coroutine State The coroutine state(referred to as a context object) is a compiler-generated, heap-allocated (unless the allocation is optimized out) object that contains Promise object. Parameters (all copied by value). Local variables. Representation of the current suspension point, so that resume knows where to continue and destroy knows what local variables were in scope. How Does Coroutine Gets Executed! Ahh\u0026hellip;! it\u0026rsquo;s time for the real magic!\nNow, that we saw how the compiler does the magic with coroutine keywords co_await, co_yield \u0026amp; co_return. Let\u0026rsquo;s understand how it gets executed.\nBut, Before, we move forward, let me clarify some points:\nC++ Standard doesn\u0026rsquo;t bother about implementation rather it only states behaviour. Hence implementation of the coroutine is completely dependent on the compiler \u0026amp; library writers. To see that, you can check the library implementation of std::coroutine_handle::resume()that uses __builtin_coro_resume which is provided by the GCC compiler. Proving that the library \u0026amp; compiler is tightly coupled.\nWith that being said, I have not written any C++ library or compiler in my career. Though I have written/ported the core C library for proprietary architecture. So, whatever you see in this section is just to build your intuition on how coroutine can be implemented. Based on my research \u0026amp; intuition.\nThere are two ways I can see this can be done:\nHypothesis 1 For example, If you have defined your coroutine as: 1 2 3 4 5 6 7 8 HelloWorldCoro print_hello_world(int a) { int b = 10; co_await std::suspend_always{}; a = 10; int c = 10; co_await std::suspend_always{}; co_return a + b + c; } Then, operations can be divided into 3 different sections separated by 2 suspension-point(i.e. co_await \u0026lt;expr\u0026gt;) as\nint b = 10;\na = 10; int c = 10;\nco_return a + b + c;\nConsidering these suspension points, then the compiler basically\nRewrite your coroutine into a bit like functions.\nAnd create a copy of all local variables as a data member of the coroutine state object.\nYou can assume coroutine state object layout as:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct print_hello_world { print_hello_world(int a_) : a{a}{} // Coroutine state object with coroutine arguments void _s1(){ // Before suspension point 1 operations int b = 10; sp = 1; // switching call back based on suspension point } void _s2(){ // Operations b/w suspension point 1 \u0026amp; 2 a = 10; int c = 10; sp = 2; } void _s3(){ // Operations after suspension point 2 promise.return_value(a + b + c); // After execution, coro_done = true; coro_done = true; } int a, b, c; // Local variables promise_type\u0026amp; promise; void (*s_cb)[] = {_s1, _s2, _s3}; // suspension point callbacks int sp{0}; // current suspension point(sp) bool coro_done{false}; }; Now, when you call coroutine, you are basically creating a coroutine state object with a similar argument to that of coroutine. 1 2 3 4 5 auto mycoro = print_hello_world(5); // transform into print_hello_world mycoro(5); As you might have guessed, due to rewriting coroutine into tiny functions, we don\u0026rsquo;t need a suspension mechanism anymore. And resumption can be implemented as: 1 2 3 4 void std::coroutine_handle::resume() { if(not print_hello_world::coro_done) print_hello_world::s_cb[sp](); } So, when you call resume you are basically calling the suspension-point specific tiny function(technically its method) from a coroutine state object. That implies the creation of two stack frame i.e. std::coroutine_handle::resume()\u0026amp; print_hello_world::_sX(), where X stands for a suspension point number. Consequently not needing a separate stack \u0026amp; using the same stack as the caller. And this is why C++20 coroutines are stackless coroutine \u0026amp; faster.\nI agree that the above example is not compilable, don\u0026rsquo;t cover edge cases \u0026amp; doesn\u0026rsquo;t consider customized(i.e. awaiter object) coroutine behaviour. But, with the intuition we just built, you can easily create a mental model of coroutine \u0026amp; see the compiler perspective.\nAnd to test your intuition capability, just imagine How you can transform the tiny functions for the coroutine that contains co_await expression in a for loop?\nHypothesis 2 Another usual way you can implement suspension-resumption is with the help of context switching APIs. For example, in the expansion of co_wait \u0026lt;expr\u0026gt; statement, I have mentioned the comment \u0026ldquo;compiler added suspend/resume hook\u0026rdquo; as below. 1 2 3 4 5 6 7 8 { auto\u0026amp;\u0026amp; awaiter = std::suspend_always{}; if (!awaiter.await_ready()) { awaiter.await_suspend(std::coroutine_handle\u0026lt;\u0026gt; p); // compiler added suspend/resume hook } awaiter.await_resume(); } This is the place where your compiler adds its secret sauce to your code with context switching APIs. And rest is I think easy to imagine if you have read my earlier post Coroutine in C Language thoroughly. Summary Subroutine vs Coroutine Subroutines Coroutines call calling convention i.e. foo() calling convention i.e. foo() suspend Can\u0026rsquo;t suspend co_await/co_yield expression resume Can\u0026rsquo;t suspend coroutine_handle\u0026lt;\u0026gt;::resume() return return statement co_return statement Compiler Transformation Of Coroutine Related Keywords 1 2 3 4 5 6 co_return x; // transforms into __promise.return_value(x); goto __final_suspend_label; 1 2 3 4 5 6 7 8 9 10 co_await y; // transforms into auto\u0026amp;\u0026amp; __awaitable = y; if (__awaitable.await_ready()) { __awaitable.await_suspend(); // compiler added suspend/resume hook } __awaitable.await_resume(); 1 2 3 4 5 co_yield z; // transforms into co_await __promise.yield_value(z); Parting Words With FAQs This is not just it, there are still many things that we haven\u0026rsquo;t explored like exception handling, coroutine calling coroutine, etc.\nOne unusual thing I observed about C++20 Coroutine is, You have to specify the return type even if you don\u0026rsquo;t return anything from the coroutine. IMO, this is unusual \u0026amp; counter-intuitive.\nWhat does it mean by stackfull \u0026amp; stackless coroutine?\nstackfull coroutines need a separate stack to be executed. stackless coroutine uses the same stack as of caller. Difference between threads \u0026amp; coroutines?\nCoroutines are about your programming model and threads are about your execution model. co-routine can still do concurrency without scheduler overhead - it simply manages the context-switching itself. Another benefit is the much lower memory usage. With the threaded model, each thread needs to allocate its own stack, and so your memory usage grows linearly with the number of threads you have. What does it mean by \u0026ldquo;coroutines are like lightweight threads\u0026rdquo;?\nFirst of all, coroutines \u0026amp; threads are a different entity. Because coroutine can be stackless \u0026amp; doesn\u0026rsquo;t need OS intervention on schedule, it is lower on memory footprint \u0026amp; faster on execution as compared to thread. With C++, it\u0026rsquo;s, even more, faster if you use Hypothesis 1. How come C++ coroutine are stackless?\nThis is already answered in Hypothesis 1. Still one more time. The compiler \u0026ldquo;returns\u0026rdquo; a handle to this dynamically allocated coroutine frame to the caller of the coroutine. When a caller calls std::coroutine_handle::resume() method, stackframe for std::coroutine_handle::resume() will be created which resumes the coroutine while processing all coroutine data on a dynamically allocated coroutine frame. And this is how coroutine is stackless in C++. Because it executes in the current stack only. Instead of a separate coroutine stack. ","permalink":"https://vishalchovatiya.github.io/posts/cpp20-coroutine-under-the-hood/","summary":"A coroutine is one of the major feature introduced with the C++20 standard apart from Module, Ranges \u0026amp; Concept. And you see how happy I am to unfold it. I already set the baseline on this topic with my previous article that Coroutine in C Language, where we saw, how suspension-resumption of execution works! With this article \u0026ldquo;C++20 Coroutine: Under The Hood\u0026rdquo;, we will see how compiler creates magic \u0026amp; standard library helps it with basic infrastructure making C++20 coroutine more sophisticated(yet complex) \u0026amp; scalable/customizable.","title":"C++20 Coroutine: Under The Hood"},{"content":"It\u0026rsquo;s been quite a while that I haven\u0026rsquo;t published anything on my blog. But that\u0026rsquo;s due to the job change. I hope you understand that it has never been easy to re-settle in a new environment with new people while maintaining a steep technical learning curve. It takes time to tune yourself accordingly. Anyways, I wrote on \u0026ldquo;Coroutine in C Language\u0026rdquo; as a pre-pend to my upcoming post on C++20 Coroutine. Today we will see \u0026ldquo;How Coroutine Works Internally?\u0026rdquo;.\nPrologue If you are an absolute beginner, then go through the below pre-requisites. And if you are not a beginner, you better know what to skip!\nHow C Program Gets Converted To Assembly! Memory Layout Of C Program Note: Context switching APIs getcontext, setcontext, makecontext and swapcontext were obsoleted in POSIX.1-2004 and removed in POSIX.1-2008 citing portability issues. So, please do not use it. Here I have used it for demonstration purpose.\nCoroutine Basics What Is Coroutine? A coroutine is a function/sub-routine(co-operative sub-routine to be precise) that can be suspended and resumed. In other words, You can think of coroutine as an in-between solution of normal function \u0026amp; thread. Because, once function/sub-routine called, it executes till the end. On other hand, a thread can be blocked by synchronization primitives(like mutex, semaphores, etc) or suspended by an OS scheduler. But again you can not decide on suspension \u0026amp; resumption on it. As it is done by the OS scheduler. While coroutine on other hand, can be suspended on a pre-defined point \u0026amp; resumed later on a need basis by the programmer. So here programmer will be having complete control of execution flow. That too with minimal overhead as compared to thread. A coroutine is also known as native threads, fibres(in windows), lightweight threads, green threads(in java), etc. Why Do We Need Coroutine? As I usually do, before learning anything new, you should be asking this question to yourself. But, let me answer it: Coroutines can provide a very high level of concurrency with very little overhead. As it doesn\u0026rsquo;t need OS intervention in scheduling. While in a threaded environment, you have to bear the OS scheduling overhead. A coroutine can suspend on a pre-determined point, so you can also avoid locking on shared data structures. Because you would never tell your code to switch to another coroutine in the middle of a critical section. With the threads, each thread needs its own stack with thread local storage \u0026amp; other things. So your memory usage grows linearly with the number of threads you have. While with co-routines, the number of routines you have doesn\u0026rsquo;t have a direct relationship with your memory usage. For most use cases coroutine is a more optimal choice as it is faster as compared to thread. And if you are still not convinced then wait for my C++20 Coroutine post. To-the-point Context Switching API Theory Before we dive into a implementation of Coroutine in C, we need to understand the below foundation functions/APIs for context switching. Off-course, as we do, with less to-the-point theory \u0026amp; with more code examples. setcontext getcontext makecontext swapcontext If you are already familiar with setjmp/longjmp, then you might have ease in understanding these functions. You can consider these functions as an advanced version of setjmp/longjmp. The only difference is setjmp/longjmp allows only a single non-local jump up the stack. Whereas, these APIs allows the creation of multiple cooperative threads of control, each with its own stack or entry point. Data Strucutre To Store Execution Context ucontext_t type structure that defined as below is used to store the execution context. All four(setcontext, getcontext, makecontext \u0026amp; swapcontext) control flow functions operates on this structure. 1 2 3 4 5 6 7 typedef struct { ucontext_t *uc_link; stack_t uc_stack; mcontext_t uc_mcontext; sigset_t uc_sigmask; ... } ucontext_t; uc_link points to the context which will be resumed when the current context exits, if the context was created with makecontext (a secondary context). uc_stack is the stack used by the context. uc_mcontext stores execution state, including all registers and CPU flags, frame/base pointer(i.e. indicates current execution frame), instruction pointer(i.e. program counter), link register(i.e. stores return address) and the stack pointer(i.e. indicates current stack limit or end of current frame). mcontext_t is an opaque type. uc_sigmask is used to store the set of signals blocked in the context. Which isn\u0026rsquo;t the focus for today. int setcontext(const ucontext_t *ucp) This function transfers control to the context in ucp. Execution continues from the point at which the context was stored in ucp. setcontext does not return. int getcontext(ucontext_t *ucp) Saves current context into ucp. This function returns in two possible cases: after the initial call, or when a thread switches to the context in ucp via setcontext or swapcontext. The getcontext function does not provide a return value to distinguish the cases (its return value is used solely to signal error), so the programmer must use an explicit flag variable, which must not be a register variable and must be declared volatile to avoid constant propagation or other compiler optimisations. void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...) The makecontext function sets up an alternate thread of control in ucp , which has previously been initialised using getcontext. The ucp.uc_stack member should be pointed to an appropriately sized stack; the constant SIGSTKSZ or MINSIGSTKSZ is commonly used. When ucp is jumped to using setcontext or swapcontext, execution will begin at the entry point to the function pointed to by func, with argc arguments as specified. When func terminates, control is returned to the context specified in ucp.uc_link. int swapcontext(ucontext_t *oucp, ucontext_t *ucp) Saves the current execution state into oucp and then transfers the execution control to ucp. [Example 1]: Understanding Context Switching With setcontext \u0026amp; getcontext Functions Now, that we have read lot of theory. Let\u0026rsquo;s create meaningful out of it. Consider below program that implements plain infinite loop printing \u0026ldquo;Hello world\u0026rdquo; every second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ucontext.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main( ) { ucontext_t ctx = {0}; getcontext(\u0026amp;ctx); // Loop start puts(\u0026#34;Hello world\u0026#34;); sleep(1); setcontext(\u0026amp;ctx); // Loop end return EXIT_SUCCESS; } Here, getcontext is returning with both possible cases as we have mentioned earlier i.e.: after the initial call, when a thread switches to the context via setcontext. Rest is I think self-explanatory. [Example 2]: Understanding Control Flow With makecontext \u0026amp; swapcontext Functions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;ucontext.h\u0026gt; void assign(uint32_t *var, uint32_t val) { *var = val; } int main( ) { uint32_t var = 0; ucontext_t ctx = {0}, back = {0}; getcontext(\u0026amp;ctx); ctx.uc_stack.ss_sp = calloc(1, MINSIGSTKSZ); ctx.uc_stack.ss_size = MINSIGSTKSZ; ctx.uc_stack.ss_flags = 0; ctx.uc_link = \u0026amp;back; // Will get back to main as `swapcontext` call will populate `back` with current context // ctx.uc_link = 0; // Will exit directly after `swapcontext` call makecontext(\u0026amp;ctx, (void (*)())assign, 2, \u0026amp;var, 100); swapcontext(\u0026amp;back, \u0026amp;ctx); // Calling `assign` by switching context printf(\u0026#34;var = %d\\n\u0026#34;, var); return EXIT_SUCCESS; } Here, the makecontext function sets up an alternate thread of control in ctx. And when jump made with ctx by using swapcontext, execution will begin at assign, with respective arguments as specified. When assign terminates, control will be switch to ctx.uc_link. Which points to back \u0026amp; will be populated by swapcontext before jump/context-switch. If the ctx.uc_link is made to 0, then current execution context is considered as the main context, and the thread will exit when assign context gets over. Before a call is made to makecontext, the application/developer needs to ensure that the context being modified has a pre-allocated stack. And argc matches the number of arguments of type int passed to func. Otherwise, the behavior is undefined. Coroutine in C Language Initially, I have created single file to demonstrate the example. But then I realised It will be too much to stuff into the single file. Hence, I splited implementation \u0026amp; usage example into different file which will make the example more comprehensible \u0026amp; easy to understand. Implementation of Coroutine in C So, here is the simplest coroutine in c language: coroutine.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #pragma once #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ucontext.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef struct coro_t_ coro_t; typedef int (*coro_function_t)(coro_t *coro); /* Coroutine handler */ struct coro_t_ { coro_function_t function; // Actual co-routine function ucontext_t suspend_context; // Stores context previous to coroutine jump ucontext_t resume_context; // Stores coroutine context int yield_value; // Coroutine return/yield value bool is_coro_finished; // To indicate the current coroutine status }; /* Coroutine APIs for users */ coro_t *coro_new(coro_function_t function); int coro_resume(coro_t *coro); void coro_yield(coro_t *coro, int value); void coro_free(coro_t *coro); Just ignore the coroutine APIs as of now. The main thing to focus here is coroutine handler that has following field function : That holds the address of actual coroutine function supplied by user. suspend_context : That used to suspend the coroutine function. resume_context : That holds the context of actual coroutine function. yield_value: To store the return value between intermediate suspension point \u0026amp; also final return value. is_coro_finished : An indicator to check status on coroutine lifetime. coroutine.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;signal.h\u0026gt; #include \u0026#34;coroutine.h\u0026#34; static void _coro_entry_point(coro_t *coro) { int return_value = coro-\u0026gt;function(coro); coro-\u0026gt;is_coro_finished = true; coro_yield(coro, return_value); } coro_t *coro_new(coro_function_t function) { coro_t *coro = calloc(1, sizeof(*coro)); coro-\u0026gt;is_coro_finished = false; coro-\u0026gt;function = function; coro-\u0026gt;resume_context.uc_stack.ss_sp = calloc(1, MINSIGSTKSZ); coro-\u0026gt;resume_context.uc_stack.ss_size = MINSIGSTKSZ; coro-\u0026gt;resume_context.uc_link = 0; getcontext(\u0026amp;coro-\u0026gt;resume_context); makecontext(\u0026amp;coro-\u0026gt;resume_context, (void (*)())_coro_entry_point, 1, coro); return coro; } int coro_resume(coro_t *coro) { if (coro-\u0026gt;is_coro_finished) return -1; swapcontext(\u0026amp;coro-\u0026gt;suspend_context, \u0026amp;coro-\u0026gt;resume_context); return coro-\u0026gt;yield_value; } void coro_yield(coro_t *coro, int value) { coro-\u0026gt;yield_value = value; swapcontext(\u0026amp;coro-\u0026gt;resume_context, \u0026amp;coro-\u0026gt;suspend_context); } void coro_free(coro_t *coro) { free(coro-\u0026gt;resume_context.uc_stack.ss_sp); free(coro); } The most used APIs for coroutine is coro_resume \u0026amp; coro_yield that drags the actual work of suspension \u0026amp; resumption. If you already have consciously gone through the above Context Switching API Examples, then I don\u0026rsquo;t think there is much to explain for coro_resume \u0026amp; coro_yield. It\u0026rsquo;s just coro_yield jumps to coro_resume \u0026amp; vice-versa. Except for the first call to coro_resume which jumps to _coro_entry_point. coro_new function allocates memory for the handler as well as stack \u0026amp; then populates the handler members. Again getcontext \u0026amp; makecontext should be clear by this point. If not then please re-read the above section on Context Switching API Examples. If you genuinely understand the above coroutine API implementation, then the obvious question would be why do we even need _coro_entry_point? Why can\u0026rsquo;t we directly jump to the actual coroutine function?. But then my argument will be \u0026ldquo;How do you ensure the lifetime of coroutine?\u0026rdquo;. Which technically means, number of call to coro_resume should be similar/valid to number of call to coro_yield plus one(for actual return). Otherwise, you can not keep track of yields. And behaviour will become undefined. Nonetheless, _coro_entry_point function is needed otherwise there is no way by which you can deduce the coroutine execution finished completely. And next/subsequent call to coro_resume is not valid anymore. Coroutine Lifetime By the above implementation, using the coroutine handler, you should only be able to execute coroutine function completely once throughout program/application life. If you want to call the coroutine function again, then you need to create a new coroutine handler. And rest of the process will remain the same. Coroutine Usage Example coroutine_example.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026#34;coroutine.h\u0026#34; int hello_world(coro_t *coro) { puts(\u0026#34;Hello\u0026#34;); coro_yield(coro, 1); // Suspension point that returns the value `1` puts(\u0026#34;World\u0026#34;); return 2; } int main() { coro_t *coro = coro_new(hello_world); assert(coro_resume(coro) == 1); // Verifying return value assert(coro_resume(coro) == 2); // Verifying return value assert(coro_resume(coro) == -1); // Invalid call coro_free(coro); return EXIT_SUCCESS; } Usecase is pretty straight forward: First, you create a coroutine handler. Then, you start/resume the actual coroutine function with the help of the same coroutine handler. And, whenever your actual coroutine function encounters a call the coro_yield, it will suspend the execution \u0026amp; return the value passed in the 2nd argument of coro_yield. And when actual coroutine function execution finishes completely. The call to coro_resume will return -1 to indicate that the coroutine handler object is no more valid \u0026amp; the lifetime is expired. So, you see coro_resume is a wrapper to our coroutine hello_world which executes hello_world in parts(obviously by context switching). Compiling I have tested this example in WSL with gcc 9.3.0 \u0026amp; glibc 2.31. 1 2 3 $ gcc -I./ coroutine_example.c coroutine.c -o myapp \u0026amp;\u0026amp; ./myapp Hello World Parting Words You see there is no magic if you understand \u0026ldquo;How CPU Executes The Code..!\u0026rdquo; well-given Glibc provided a rich set of context switching API. And, from the perspective of low-level developers, it\u0026rsquo;s merely a well-arranged \u0026amp; difficult to organize/maintain(if used raw) context switching function calls. My intention here was to put the foundation for C++20 Coroutine. Because I believe, if you see the code from CPU \u0026amp; compiler\u0026rsquo;s point of view, then everything becomes easy to reason about in C++. See you next time with my C++20 Coroutine post.\n","permalink":"https://vishalchovatiya.github.io/posts/coroutine-in-c-language/","summary":"It\u0026rsquo;s been quite a while that I haven\u0026rsquo;t published anything on my blog. But that\u0026rsquo;s due to the job change. I hope you understand that it has never been easy to re-settle in a new environment with new people while maintaining a steep technical learning curve. It takes time to tune yourself accordingly. Anyways, I wrote on \u0026ldquo;Coroutine in C Language\u0026rdquo; as a pre-pend to my upcoming post on C++20 Coroutine.","title":"Coroutine in C Language"},{"content":"This page gives you a quick start index for entire blog, segregated topic-wise:\nC++ Fundamentals Memory Layout of C++ Object in Different Scenarios Inside the C++ Object Model Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? Part 3: All About Virtual Keyword in C++: How Does Virtual Destructor Works? Complications of Using the Virtual Base Class 2 Wrong Way to Learn Copy Assignment Operator in C++ With Example When to Use const vs constexpr in C++ All About Copy Constructor in C++ With Example How to hack C/C++ application using RTLD_NEXT with an easy example Lvalue Rvalue and Their References With Example in C++ Move Constructor \u0026amp; Assignment Operator With std::shared_ptr Understanding unique_ptr with Example in C++11 Advanced All About Lambda Function in C++(From C++11 to C++20) C++ Template: A Quick UpToDate Look(C++11/14/17/20) 7 Advance C++ Concepts \u0026amp; Idiom Examples You Should Know C++ Type Casting With Example for C Developers Mastering C++: Books | Courses | Tools | Tutorials | Blogs | Communities Variadic Template C++: Implementing Unsophisticated Tuple Regex C++ 21 New Features of Modern C++ to Use in Your Project CRTP C++ Examples C++ Exception Handling Best Practices: 7 Things To Know Using std::map Wisely With Modern C++ What Exactly nullptr Is in C++? Double Dispatch in C++: Recover Original Type of the Object Pointed by Base Class Pointer C++20 Coroutine: Under The Hood Design Patterns With Modern C++ SOLID Design Principles in C++ SRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle Creational Design Patterns in C++ Factory Builder Prototype Singleton Structural Design Patterns in C++ Adapter Bridge Composite Decorator Facade Flyweight Proxy Behavioural Design Patterns in C++ Chain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor C Language How C Program Converts Into Assembly! How C Program Stored in Ram Memory! How Do malloc \u0026amp; free Work in C! Default Handlers in C: weak_alias How Floating-Point No Is Stored in Memory! CRT: C Run Time Before Starting main() Coroutine in C Language Linux System Programming Understand ELF file format How Program Gets Run: Linux Execute Threads Parallelly at Given Time: pthread_barrier_t Dynamic Linking Example Binary semaphore example between threads in C Semaphore between processes example in C Create Process Using fork() Socket Programming Signal Handling Shared Memory IPC A Bit About mmap Dealing with Multiple file descriptor : poll() system call Clone system call example Error Handling : setjmp \u0026amp; longjmp Thread Conditional Wait with Mutex : pthread_cond_t) A Bit About vfork Unix Domain Socket Misc How Does Virtual Memory Work? Watchdog Timer(WDT) \u0026amp; Window Watchdog Timer(WWDT) 4 Levels of Vim Editor Commands How to Install and Configure VNC Server on Linux! GNU Build System: Automake, Autoconf, Libtool ","permalink":"https://vishalchovatiya.github.io/pages/start-here/","summary":"This page gives you a quick start index for entire blog, segregated topic-wise:\nC++ Fundamentals Memory Layout of C++ Object in Different Scenarios Inside the C++ Object Model Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally? Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally? Part 3: All About Virtual Keyword in C++: How Does Virtual Destructor Works? Complications of Using the Virtual Base Class 2 Wrong Way to Learn Copy Assignment Operator in C++ With Example When to Use const vs constexpr in C++ All About Copy Constructor in C++ With Example How to hack C/C++ application using RTLD_NEXT with an easy example Lvalue Rvalue and Their References With Example in C++ Move Constructor \u0026amp; Assignment Operator With std::shared_ptr Understanding unique_ptr with Example in C++11 Advanced All About Lambda Function in C++(From C++11 to C++20) C++ Template: A Quick UpToDate Look(C++11/14/17/20) 7 Advance C++ Concepts \u0026amp; Idiom Examples You Should Know C++ Type Casting With Example for C Developers Mastering C++: Books | Courses | Tools | Tutorials | Blogs | Communities Variadic Template C++: Implementing Unsophisticated Tuple Regex C++ 21 New Features of Modern C++ to Use in Your Project CRTP C++ Examples C++ Exception Handling Best Practices: 7 Things To Know Using std::map Wisely With Modern C++ What Exactly nullptr Is in C++?","title":"Start Here"},{"content":"Do not get carried away with tittle Mastering C++. This is a never-ending journey. Because ISOCPP is releasing the baby elephants every three years. With the standard covering almost 1500 pages currently, C++ is not the simplest language to learn and master. I have spent quite enough time in the industry. But still feel imposter sometimes. It\u0026rsquo;s been quite a while I was thinking of sharing my Modern C++ journey. Although, I am sharing the knowledge piece-by-piece through such articles. But, there are other things as well which helped me through this journey like online tools, books, courses, blogs, etc. So, following is the list of such items in an unordered way.\nSome of the Best C++ Websites www.learncpp.com en.cppreference.com C++ Books Apart from classic \u0026amp; latest Effective series, there are some modern \u0026amp; pragmatic books I found useful.\nC++17 STL Cookbook Inside the C++ Object Model(Classic) C++17 in Detail Expert C++ C++ Notes For Professionals The Modern C++ Challenge(Practice Problem Only) Mastering C++ Programming C++ Concurrency in Action C++ Best Practices If you see packt publishing \u0026amp; leanpub, there is a plethora of C++ book available targeting a different area of language pragmatically. Will keep adding this list in future. . .!\nC++ Courses C9 Lectures: Stephan T. Lavavej - Core C++ C9 Lectures: Stephan T. Lavavej - Standard Template Library (STL) C9 Lectures: Stephan T Lavavej - Advanced STL Design Patterns in Modern C++ Complete Modern C++ (C++11/14/17) Modern C++ Concurrency in Depth Functional Programming using C++ Mastering C++ Standard Library Features C++17 in Detail: A Deep Dive Embedded Programming with Modern C++ If you see the structure \u0026amp; content of the above courses, they are mostly targeted to experienced C++ devs. It is certainly not for beginners. Though, I haven\u0026rsquo;t completed some of these courses. But I consider them a best \u0026amp; upto-date.\nC++ Blogs/Bloggers Jonathan Boccara : www.fluentcpp.com Rainer Grimm : www.modernescpp.com Bartlomiej Filipek : www.bfilipek.com Jonathan : foonathan.net Same as book list. These are the blogs I have explored \u0026amp; enjoyed reading.\nC++ Tools Online Debugger www.onlinegdb.com is an online compiler as well as debugger tool. It supports many languages but for C++ at the time of writing this article, it supports till C++17. The good feature of this tool that I like most about is code formatting(i.e. Beautify option) and the sublime keybinding.\nLatest Compilers + Support Of Boost Library https://wandbox.org: The less you say the better. One of my favourite tool. I test almost all my blog post code snippets here. wandbox has a variety of compiler with choice of selecting specific version. You can also pass the compilation flags \u0026amp; runtime arguments explicitly. Creating multiple file option is also there.\nAnalysing Performance Oriented C++ Code http://quick-bench.com: Quick-benchmark is a handy micro benchmarking tool. Intended to quickly \u0026amp; simply compare the performance of two or more code snippets. Internally it uses google-benchmark.\nA thing to note here is the benchmark runs on a pool of AWS machines whose load is unknown and potentially next to multiple other benchmarks. Any duration it could output would be meaningless. The fact that a snippet takes 100ms to run in quick-bench at a given time gives no information whatsoever about what time it will take to run in your application, with your given architecture.\nQuick-bench can, however, give a reasonably good comparison between two snippets of code run in the same conditions. That is the purpose this tool was created for; removing any units ensures only meaningful comparison.\nhttps://build-bench.com: is another similar platform. But rather than comparing the run time results. It compares the compile-time(i.e. build time) performance of two or more code snippets. This is quite useful while writing template metaprogramming or variadic template code. As we all know C++ is famous for its compile-time performance. ; )\nSeeing Things Through C++ Compiler\u0026rsquo;s Eye cppinsights.io C++ Insights is a clang-based tool which does a source to source transformation. Its goal is to make things visible which normally, and intentionally, happen behind the scenes. It\u0026rsquo;s about the magic the compiler does for us to make things work. Or looking through the classes of a compiler.\nThis is the best tool to see things through compiler\u0026rsquo;s eye. I have understood the importance of this tool when I was writing article :\u0026quot;How C++ Variadic Template Works?\u0026quot;.\nTypical use case of this tool is to see the transformation of a lambda expression, range-based for-loop, auto, etc.\ngodbolt.org This is an interactive tool that lets you type code in one window and see the results of its compilation in another window. Using the site should be pretty self-explanatory: by default, the left-hand panel is the source window and the right hand has the assembly output that shows How compiler converted your code into the assembly!.\nOnline Developer Documentation If you are going to cppreference many times in a day through google, in a search of standard library functions. Then runebook.dev might be very useful to you. Its just compilation of cppreference in some sort of dictionary form. You can get whatever API you want with a single place search.\nJumping on New C++ Code Base Sourcetrail is free and open-source cross-platform source explorer that simplifies navigation in existing source code by indexing your code and gathering data about its structure. Sourcetrail then provides a simple interface consisting of three interactive views, each playing a key role in helping you obtain the information you need:\nSearch: Use the search field to quickly find and select indexed symbols in your source code. The autocompletion box will instantly provide an overview of all matching results throughout your codebase. Graph: The graph displays the structure of your source code. It focuses on the currently selected symbol and directly shows all incoming and outgoing dependencies to other symbols. Code: The Code view displays all source locations of the currently selected symbol in a list of code snippets. Clicking on a different source location allows you to change the selection and dig deeper. It also supports C, Java \u0026amp; Python apart from C++.\nCode Sharing codeshare.io Codeshare enables developers to share code in real-time. Write or paste code in your browser, share the URL, code in real-time with friends and team mates. The only drawback of this platform is that you can not compile code. It just shares the code in real-time with audio-video support.\ncoliru Compile, Link \u0026amp; Run. Clutter-free simple yet subtle code editor. This is just to share compilable code with an online code editor. You \u0026amp; your teammates can play around it.\nrepl.it The repl(read-eval-print loop) is a simple yet powerful online compiler, IDE, interpreter and interactive environment for programming languages. As far as C++ is concerned this is limited till C++17. I use this platform mostly in conducting real-time interviews or to try out small code snippets. They are currently integrating GitHub. Maybe we can make use of a complete development environment online in the near future.\nAttaching C++ Code Into E-Mail As a developer, you have to collaborate with other developers. And there are a lot of tools already out there to collaborate in real-time. But when teams scattered globally, have to support multiple timezones \u0026amp; work asynchronously. Often you find yourself in playing mail games.\nAnd if you have ever attached your code in the mail, you might understand the pain. Even if your mail has rich text format, your code snippet may look ugly. And ugly code demotivates other people to look into. In such a case, you can use tohtml, to generate HTML of your code with highlighted syntax according to your choice of programming language.\nC++ Communities CppIndia Cpplang slack C/C++ telegram C++ reddit Awesome C++ Useful Links C++ Standards Support for All Compilers C++ Standards Support in GCC C++ Standards Support in Clang Awesome Modern C++ Quick Look Of All Modern C++ Features Wrap-Up Apart from all these online tools, there are many other offline(not considering proprietary) tools. Like profiler, linter, formatter, etc. Which I have not discussed as I consider them to be too specific. But those tools have certainly its place in stack \u0026amp; development cycle. Out of all these, I like clang-tooling(swiss army knife) the most.\nEven after all this! To be perfectly honest, I am still learning or I would say Mastering C++ \u0026amp; getting better day-by-day. As I have mentioned in earlier, this is a never-ending journey, but the complexity of this language attracts me \u0026amp; gives me the drive to keep learning.\nNote: There are many other books, blogs, courses, tools \u0026amp; tutorials available also to learn Modern C++. But, here I have mentioned the ones that I liked the most \u0026amp; helpful. If you feel that there are other things also I am missing or have any suggestions? You can always reach me from here.\n","permalink":"https://vishalchovatiya.github.io/posts/mastering-c-books-courses-tools-tutorials-blogs-communities/","summary":"Do not get carried away with tittle Mastering C++. This is a never-ending journey. Because ISOCPP is releasing the baby elephants every three years. With the standard covering almost 1500 pages currently, C++ is not the simplest language to learn and master. I have spent quite enough time in the industry. But still feel imposter sometimes. It\u0026rsquo;s been quite a while I was thinking of sharing my Modern C++ journey. Although, I am sharing the knowledge piece-by-piece through such articles.","title":"Mastering C++: Books | Courses | Tools | Tutorials | Blogs | Communities"},{"content":"Regular expressions (or regex in short) is a much-hated \u0026amp; underrated topic so far with Modern C++. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy).\nInitially, In this article, I have decided to include regex-in-general also. But it doesn\u0026rsquo;t make sense, as there is already people/tutorial out there who does better than me in teaching regex. But still, I left a small section to address Motivation \u0026amp; Learning Regex. For the rest of the article, I will be focusing on functionality provided by C++ to work with regex. And if you are already aware of regex, you can use the above mind-map as a refresher.\nPointer: The C++ standard library offers several different \u0026ldquo;flavours\u0026rdquo; of regex syntax, but the default flavour (the one you should always use \u0026amp; I am demonstrating here) was borrowed wholesale from the standard for ECMAScript.\nMotivation I know its pathetic and somewhat confusing tool-set. Consider the below regex pattern for an example that extract time in 24-hour format i.e. HH:MM. 1 \\b([01]?[0-9]|2[0-3]):([0-5]\\d)\\b I mean! Who wants to work with this cryptic text? And whatever running in your mind is 100% reasonable. In fact, I have procrastinated learning regex twice due to the same reason. But, believe me, all the ugly looking things are not that bad. The way(↓) I am describing here won\u0026rsquo;t take more than 2-3 hours to learn regex that too intuitively. And After learning it you will see the compounding effect with return on investment over-the-time. Learning Regex Do not google much \u0026amp; try to analyse which tutorial is best. In fact, don\u0026rsquo;t waste time in such analysis. Because there is no point in doing so. At this point in time(well! if you don\u0026rsquo;t know the regex) what really matters is \u0026ldquo;Getting Started\u0026rdquo; rather than \u0026ldquo;What Is Best!\u0026rdquo;. Just go to https://regexone.com without much overthinking. And complete all the lessons. Trust me here, I have explored many articles, courses(\u0026lt;=this one is free, BTW) \u0026amp; books. But this is best among all for getting started without losing motivation. And after it, if you still have an appetite to solve more problem \u0026amp; exercises. Consider the below links: Exercises on regextutorials.com Practice problem on regex by hackerrank std::regex \u0026amp; std::regex_error Example 1 2 3 4 5 6 7 8 9 int main() { try { static const auto r = std::regex(R\u0026#34;(\\)\u0026#34;); // Escape sequence error } catch (const std::regex_error \u0026amp;e) { assert(strcmp(e.what(), \u0026#34;Unexpected end of regex when escaping.\u0026#34;) == 0); assert(e.code() == std::regex_constants::error_escape); } return EXIT_SUCCESS; } You see! I am using raw string literals. You can also use the normal string. But, in that case, you have to use a double backslash for an escape sequence. The current implementation of std::regex is slow(as it needs regex interpretation \u0026amp; data structure creation at runtime), bloated and unavoidably require heap allocation(not allocator-aware). So, beware if you are using std::regex in a loop(see C++ Weekly - Ep 74 - std::regex optimize by Jason Turner). Also, there is only a single member function that I think could be of use is std::regex::mark_count() which returns a number of capture groups. Moreover, if you are using multiple strings to create a regex pattern at run time. Then you may need exception handling i.e. std::regex_error to validate its correctness. std::regex_search Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { const string input = \u0026#34;ABC:1-\u0026gt; PQR:2;;; XYZ:3\u0026lt;\u0026lt;\u0026lt;\u0026#34;s; const regex r(R\u0026#34;((\\w+):(\\w+);)\u0026#34;); smatch m; if (regex_search(input, m, r)) { assert(m.size() == 3); assert(m[0].str() == \u0026#34;PQR:2;\u0026#34;); // Entire match assert(m[1].str() == \u0026#34;PQR\u0026#34;); // Substring that matches 1st group assert(m[2].str() == \u0026#34;2\u0026#34;); // Substring that matches 2nd group assert(m.prefix().str() == \u0026#34;ABC:1-\u0026gt; \u0026#34;); // All before 1st character match assert(m.suffix().str() == \u0026#34;;; XYZ:3\u0026lt;\u0026lt;\u0026lt;\u0026#34;); // All after last character match // for (string \u0026amp;\u0026amp;str : m) { // Alternatively. You can also do // cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; // } } return EXIT_SUCCESS; } smatch is the specializations of std::match_results that stores the information about matches to be retrieved. std::regex_match Example Short \u0026amp; sweet example that you may always find in every regex book is email validation. And that is where our std::regex_match function fits perfectly. 1 2 3 4 5 6 7 8 9 10 bool is_valid_email_id(string_view str) { static const regex r(R\u0026#34;(\\w+@\\w+\\.(?:com|in))\u0026#34;); return regex_match(str.data(), r); } int main() { assert(is_valid_email_id(\u0026#34;vishalchovatiya@ymail.com\u0026#34;) == true); assert(is_valid_email_id(\u0026#34;@abc.com\u0026#34;) == false); return EXIT_SUCCESS; } I know this is not full proof email validator regex pattern. But my intention is also not that. Rather you should wonder why I have used std::regex_match! not std::regex_search! The rationale is simple std::regex_match matches the whole input sequence. Also, Noticeable thing is static regex object to avoid constructing (\u0026ldquo;compiling/interpreting\u0026rdquo;) a new regex object every time the function entered. The irony of above tiny code snippet is that it produces around 30k lines of assembly that too with -O3 flag. And that is ridiculous. But don\u0026rsquo;t worry this is already been brought to the ISO C++ community. And soon we may get some updates. Meanwhile, we do have other alternatives (mentioned at the end of this article). Difference Between std::regex_match \u0026amp; std::regex_search? You might be wondering why do we have two functions doing almost the same work? Even I had the doubt initially. But, after reading the description provided by cppreference over and over. I found the answer. And to explain that answer, I have created the example(obviously with the help of StackOverflow): 1 2 3 4 5 6 7 8 9 10 11 int main() { const string input = \u0026#34;ABC:1-\u0026gt; PQR:2;;; XYZ:3\u0026lt;\u0026lt;\u0026lt;\u0026#34;s; const regex r(R\u0026#34;((\\w+):(\\w+);)\u0026#34;); smatch m; assert(regex_match(input, m, r) == false); assert(regex_search(input, m, r) == true \u0026amp;\u0026amp; m.ready() == true \u0026amp;\u0026amp; m[1] == \u0026#34;PQR\u0026#34;); return EXIT_SUCCESS; } std::regex_match only returns true when the entire input sequence has been matched, while std::regex_search will succeed even if only a sub-sequence matches the regex. std::regex_iterator Example std::regex_iterator is helpful when you need very detailed information about matches \u0026amp; sub-matches. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #define C_ALL(X) cbegin(X), cend(X) int main() { const string input = \u0026#34;ABC:1-\u0026gt; PQR:2;;; XYZ:3\u0026lt;\u0026lt;\u0026lt;\u0026#34;s; const regex r(R\u0026#34;((\\w+):(\\d))\u0026#34;); const vector\u0026lt;smatch\u0026gt; matches{ sregex_iterator{C_ALL(input), r}, sregex_iterator{} }; assert(matches[0].str(0) == \u0026#34;ABC:1\u0026#34; \u0026amp;\u0026amp; matches[0].str(1) == \u0026#34;ABC\u0026#34; \u0026amp;\u0026amp; matches[0].str(2) == \u0026#34;1\u0026#34;); assert(matches[1].str(0) == \u0026#34;PQR:2\u0026#34; \u0026amp;\u0026amp; matches[1].str(1) == \u0026#34;PQR\u0026#34; \u0026amp;\u0026amp; matches[1].str(2) == \u0026#34;2\u0026#34;); assert(matches[2].str(0) == \u0026#34;XYZ:3\u0026#34; \u0026amp;\u0026amp; matches[2].str(1) == \u0026#34;XYZ\u0026#34; \u0026amp;\u0026amp; matches[2].str(2) == \u0026#34;3\u0026#34;); return EXIT_SUCCESS; } Earlier(in C++11), there was a limitation that using std::regex_interator is not allowed to be called with a temporary regex object. Which has been rectified with overload from C++14. std::regex_token_iterator Example std::regex_token_iterator is the utility you are going to use 80% of the time. It has a slight variation as compared to std::regex_iterator. The difference between std::regex_iterator \u0026amp; std::regex_token_iterator is std::regex_iterator points to match results. std::regex_token_iterator points to sub-matches. In std::regex_token_iterator, each iterator contains only a single matched result. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #define C_ALL(X) cbegin(X), cend(X) int main() { const string input = \u0026#34;ABC:1-\u0026gt; PQR:2;;; XYZ:3\u0026lt;\u0026lt;\u0026lt;\u0026#34;s; const regex r(R\u0026#34;((\\w+):(\\d))\u0026#34;); // Note: vector\u0026lt;string\u0026gt; here, unlike vector\u0026lt;smatch\u0026gt; as in std::regex_iterator const vector\u0026lt;string\u0026gt; full_match{ sregex_token_iterator{C_ALL(input), r, 0}, // Mark `0` here i.e. whole regex match sregex_token_iterator{} }; assert((full_match == decltype(full_match){\u0026#34;ABC:1\u0026#34;, \u0026#34;PQR:2\u0026#34;, \u0026#34;XYZ:3\u0026#34;})); const vector\u0026lt;string\u0026gt; cptr_grp_1st{ sregex_token_iterator{C_ALL(input), r, 1}, // Mark `1` here i.e. 1st capture group sregex_token_iterator{} }; assert((cptr_grp_1st == decltype(cptr_grp_1st){\u0026#34;ABC\u0026#34;, \u0026#34;PQR\u0026#34;, \u0026#34;XYZ\u0026#34;})); const vector\u0026lt;string\u0026gt; cptr_grp_2nd{ sregex_token_iterator{C_ALL(input), r, 2}, // Mark `2` here i.e. 2nd capture group sregex_token_iterator{} }; assert((cptr_grp_2nd == decltype(cptr_grp_2nd){\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;})); return EXIT_SUCCESS; } Inverted Match With std::regex_token_iterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define C_ALL(X) cbegin(X), cend(X) int main() { const string input = \u0026#34;ABC:1-\u0026gt; PQR:2;;; XYZ:3\u0026lt;\u0026lt;\u0026lt;\u0026#34;s; const regex r(R\u0026#34;((\\w+):(\\d))\u0026#34;); const vector\u0026lt;string\u0026gt; inverted{ sregex_token_iterator{C_ALL(input), r, -1}, // `-1` = parts that are not matched sregex_token_iterator{} }; assert((inverted == decltype(inverted){ \u0026#34;\u0026#34;, \u0026#34;-\u0026gt; \u0026#34;, \u0026#34;;;; \u0026#34;, \u0026#34;\u0026lt;\u0026lt;\u0026lt;\u0026#34;, })); return EXIT_SUCCESS; } std::regex_replace Example 1 2 3 4 5 6 7 8 9 10 11 12 string transform_pair(string_view text, regex_constants::match_flag_type f = {}) { static const auto r = regex(R\u0026#34;((\\w+):(\\d))\u0026#34;); return regex_replace(text.data(), r, \u0026#34;$2\u0026#34;, f); } int main() { assert(transform_pair(\u0026#34;ABC:1, PQR:2\u0026#34;s) == \u0026#34;1, 2\u0026#34;s); // Things that aren\u0026#39;t matched are not copied assert(transform_pair(\u0026#34;ABC:1, PQR:2\u0026#34;s, regex_constants::format_no_copy) == \u0026#34;12\u0026#34;s); return EXIT_SUCCESS; } You see in 2nd call of transform_pair, we passed flag std::regex_constants::format_no_copy which suggest do not copy thing that isn\u0026rsquo;t matched. There are many such useful flags under std::regex_constant. Also, we have constructed the fresh string holding the results. But what if we do not want a new string. Rather wants to append the results directly to somewhere(probably container or stream or already existing string). Guess what! the standard library has covered this also with overloaded std::regex_replace as follows: 1 2 3 4 5 6 7 8 9 int main() { const string input = \u0026#34;ABC:1-\u0026gt; PQR:2;;; XYZ:3\u0026lt;\u0026lt;\u0026lt;\u0026#34;s; const regex r(R\u0026#34;(-|\u0026gt;|\u0026lt;|;| )\u0026#34;); // Prints \u0026#34;ABC:1 PQR:2 XYZ:3 \u0026#34; regex_replace(ostreambuf_iterator\u0026lt;char\u0026gt;(cout), C_ALL(input), r, \u0026#34; \u0026#34;); return EXIT_SUCCESS; } Use Cases Splitting a String With Delimiter Although std::strtok is best suitable \u0026amp; optimal candidate for such a task. But just to demonstrate how you can do it with regex: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #define C_ALL(X) cbegin(X), cend(X) vector\u0026lt;string\u0026gt; split(const string\u0026amp; str, string_view pattern) { const auto r = regex(pattern.data()); return vector\u0026lt;string\u0026gt;{ sregex_token_iterator(C_ALL(str), r, -1), sregex_token_iterator() }; } int main() { assert((split(\u0026#34;/root/home/vishal\u0026#34;, \u0026#34;/\u0026#34;) == vector\u0026lt;string\u0026gt;{\u0026#34;\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;home\u0026#34;, \u0026#34;vishal\u0026#34;})); return EXIT_SUCCESS; } Trim Whitespace From a String 1 2 3 4 5 6 7 8 9 string trim(string_view text) { static const auto r = regex(R\u0026#34;(\\s+)\u0026#34;); return regex_replace(text.data(), r, \u0026#34;\u0026#34;); } int main() { assert(trim(\u0026#34;12 3 4 5\u0026#34;s) == \u0026#34;12345\u0026#34;s); return EXIT_SUCCESS; } Finding Lines Containing or Not Containing Certain Words From a File 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 string join(const vector\u0026lt;string\u0026gt;\u0026amp; words, const string\u0026amp; delimiter) { return accumulate(next(begin(words)), end(words), words[0], [\u0026amp;delimiter](string\u0026amp; p, const string\u0026amp; word) { return p + delimiter + word; }); } vector\u0026lt;string\u0026gt; lines_containing(const string\u0026amp; file, const vector\u0026lt;string\u0026gt;\u0026amp; words) { auto prefix = \u0026#34;^.*?\\\\b(\u0026#34;s; auto suffix = \u0026#34;)\\\\b.*$\u0026#34;s; // ^.*?\\b(one|two|three)\\b.*$ const auto pattern = move(prefix) + join(words, \u0026#34;|\u0026#34;) + move(suffix); ifstream infile(file); vector\u0026lt;string\u0026gt; result; for (string line; getline(infile, line);) { if(regex_match(line, regex(pattern))) { result.emplace_back(move(line)); } } return result; } int main() { assert((lines_containing(\u0026#34;test.txt\u0026#34;, {\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;}) == vector\u0026lt;string\u0026gt;{\u0026#34;This is one\u0026#34;, \u0026#34;This is two\u0026#34;})); return EXIT_SUCCESS; } /* test.txt This is one This is two This is three This is four */ Same goes for finding lines that are not containing words with the pattern ^((?!(one|two|three)).)*$. Finding Files in a Directory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace fs = std::filesystem; vector\u0026lt;fs::directory_entry\u0026gt; find_files(const fs::path \u0026amp;path, string_view rg) { vector\u0026lt;fs::directory_entry\u0026gt; result; regex r(rg.data()); copy_if( fs::recursive_directory_iterator(path), fs::recursive_directory_iterator(), back_inserter(result), [\u0026amp;r](const fs::directory_entry \u0026amp;entry) { return fs::is_regular_file(entry.path()) \u0026amp;\u0026amp; regex_match(entry.path().filename().string(), r); }); return result; } int main() { const auto dir = fs::temp_directory_path(); const auto pattern = R\u0026#34;(\\w+\\.png)\u0026#34;; const auto result = find_files(fs::current_path(), pattern); for (const auto \u0026amp;entry : result) { cout \u0026lt;\u0026lt; entry.path().string() \u0026lt;\u0026lt; endl; } return EXIT_SUCCESS; } Tips For Using Regex-In-General Use raw string literal for describing the regex pattern in C++. Use the regex validating tool like https://regex101.com. What I like about regex101 is code generation \u0026amp; time-taken(will be helpful when optimizing regex) feature. Also, try to add generated explanation from validation tool as a comment exactly above the regex pattern in your code. Performance: If you are using alternation, try to arrange options in high probability order like com|net|org. Try to use lazy quantifiers if possible. Use non-capture groups wherever possible. Disable Backtracking. Using the negated character class is more efficient than using a lazy dot. Parting Words It\u0026rsquo;s not just that you will use regex with only C++ or any other language. I myself use it mostly on IDE(in vscode to analyse log files) \u0026amp; on Linux terminal. But, bear in mind that overusing regex gives the feel of cleverness. And, it\u0026rsquo;s a great way to make your co-workers (and anyone else who needs to work with your code) very angry with you. Also, regex is overkill for most parsing tasks that you\u0026rsquo;ll face in your daily work.\nThe regexes really shine for complicated tasks where hand-written parsing code would be just as slow anyway; and for extremely simple tasks where the readability and robustness of regular expressions outweigh their performance costs.\nOne more notable thing is current regex implementation(till 19th June 2020) in standard libraries have performance \u0026amp; code bloating issues. So choose wisely between Boost, CTRE and Standard library versions. Most probably you might go with the Hana Dusíková\u0026rsquo;s work on Compile Time Regular Expression. Also, her CppCon talk from 2018 \u0026amp; 2019\u0026rsquo;s would be helpful especially if you plan to use regex in embedded systems.\n","permalink":"https://vishalchovatiya.github.io/posts/regex-c/","summary":"Regular expressions (or regex in short) is a much-hated \u0026amp; underrated topic so far with Modern C++. But at the same time, correct use of regex can spare you writing many lines of code. If you have spent quite enough time in the industry. And not knowing regex then you are missing out on 20-30% productivity. In that case, I highly recommend you to learn regex, as it is one-time investment(something similar to learn once, write anywhere philosophy).","title":"Regex C++"},{"content":"std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C++, we now have more reasons to use std::map. That\u0026rsquo;s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let\u0026rsquo;s dive-in directly.\nstd::map::contains(C++20) std::map::contains member function is a good step towards code expressiveness. And I am also tire of writing : 1 2 3 4 if (auto search = freq_of.find(2); search != freq_of.end()) { cout \u0026lt;\u0026lt; \u0026#34;Found\u0026#34; \u0026lt;\u0026lt; endl; } // Where assume, freq_of = map\u0026lt;uint32_t, uint32_t\u0026gt;{{3, 1}, {1, 1}, {2, 1}}; Rather, from C++20, you can write: 1 2 3 if (freq_of.contains(2)) { cout \u0026lt;\u0026lt; \u0026#34;Found\u0026#34; \u0026lt;\u0026lt; endl; } The code we write is written first for human consumption \u0026amp; only secondarily for the computer to understand. - John Sonmez\nstd::map::try_emplace(C++17) While inserting into the map, we have 2 different possibilities: The key doesn\u0026rsquo;t exist yet. Create a fresh key-value pair. The key does exist already. Take the existing item and modify it. A typical approach to insert an element in std::map is by using operator[ ], std::map::insert or std::map::emplace . But, in all of these cases, we have to bear the cost of default/specialized constructor or assignment call. And the worst part is if an item already exists, we have to drop the freshly created item. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { vector v{3, 4, 5, 8, 7, 3, 5, 2, 4}; map\u0026lt;uint32_t, uint32_t\u0026gt; freq_of; for (const auto \u0026amp;n : v) { if (const auto \u0026amp;[it, inserted] = freq_of.emplace(n, 1); !inserted) { it-\u0026gt;second++; // Exists already } } assert(freq_of[3] == 2); return EXIT_SUCCESS; } Instead: 1 2 3 if (const auto \u0026amp;[it, inserted] = freq_of.try_emplace(n, 1); !inserted) { it-\u0026gt;second++; } But, since C++17, there is this std::map::try_emplace method that creates items only if the key doesn\u0026rsquo;t exist yet. This boosts the performance in case objects of that type are expensive to create. Although the above example hasn\u0026rsquo;t showcased the expensive to create items. But, yes! whenever you encounter such a situation, must be known how to handle it with std::map::try_emplace. std::map::insert_or_assign(C++17) When you have to insert element anyhow. For the sake of convenience, you use std::map::operator[ ]. Which is OK( and dangerous)! Unless you have any constraint on insertion or assignment. For example, while counting the frequency of elements with the added constraint that when an element is repeated(i.e. assigned) you have to remove all the element lesser than the current one. In such a situation, std::map::operator[ ] isn\u0026rsquo;t feasible. Rather, std::map::insert_or_assign is more appropriate and returns more information than [std::map::operator[ ]](std::map::operator[ ]). It also does not require default-constructibility of the mapped type. Consider the following example for the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { vector v{8, 3, 9, 5, 8}; map\u0026lt;uint32_t, uint32_t\u0026gt; freq_of; for (auto \u0026amp;\u0026amp;n : v) { const auto \u0026amp;[it, is_inserted] = freq_of.insert_or_assign(n, 1); if (!is_inserted) { // remove all lesser element then current one if repeated freq_of.erase(begin(freq_of), it); } } assert((freq_of == decltype(freq_of){ {8, 1}, {9, 1}, })); return EXIT_SUCCESS; } std::map::insert With Hint(C++11/17) Looking up items in an std::map takes O(log(n)) time. This is the same for inserting new items. Because the position where to insert them must looked up. Naive insertion of M new items would thus take O(M * log(n)) time. In order to make this more efficient, std::map insertion functions accept an optional insertion hint parameter. The insertion hint is basically an iterator, which points near the future position of the item that is to be inserted. If the hint is correct, then we get amortized O(1) insertion time. This is quite useful from a performance point of view when the insertion sequence of items is somewhat predictable. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { map\u0026lt;uint32_t, string\u0026gt; m{{2, \u0026#34;\u0026#34;}, {3, \u0026#34;\u0026#34;}}; auto where(end(m)); for (const auto \u0026amp;n : {8, 7, 6, 5, 4, 3, 2, 1}) { // Items in non-incremental order where = m.insert(where, {n, \u0026#34;\u0026#34;}); } // How it is not done! // m.insert(end(m), {0, \u0026#34;\u0026#34;}); for (const auto \u0026amp;[key, value] : m) { cout \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34; : \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; } return EXIT_SUCCESS; } A correct hint will point to an existing element, which is greater than the element to be inserted so that the newly inserted key will be just before the hint. If this does not apply for the hint the user provided during insertion, the insert function will fall back to a nonoptimized insertion, yielding `O(log(n)) performance again. For the above example, the first insertion, we got the end iterator of the map, because we had no better hint to start with. After installing an 8 in the tree, we knew that installing 7 will insert a new item just in front of the 8, which qualified it to be a correct hint. This applies to 6 as well, if put into the tree after inserting the 7, and so on. This is why it is possible to use the iterator, which was returned in the last insertion for the next insertion. You can play around the above example to justify the performance gain with quick-benchmark. Note: It is important to know that before C++11, insertion hints were considered correct when they pointed before the position of the newly inserted item.\nstd::map::merge(C++17) Same as std::list:splice, which transfers the elements from one list to another. we have std::map::merge which can merge the two same type of std::map. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { map\u0026lt;uint32_t, string\u0026gt; fruits{{5, \u0026#34;grapes\u0026#34;}, {2, \u0026#34;tomoto\u0026#34;}}; map\u0026lt;uint32_t, string\u0026gt; person{{2, \u0026#34;mickel\u0026#34;}, {10, \u0026#34;shree\u0026#34;}}; map\u0026lt;uint32_t, string\u0026gt; fruits_and_persons; fruits_and_persons.merge(fruits); assert(fruits.size() == 0); fruits_and_persons.merge(person); assert(person.size() == 1); assert(person.at(2) == \u0026#34;mickel\u0026#34;); // Won\u0026#39;t overwrite value at 2 i.e.`mickel` assert((fruits_and_persons == decltype(fruits){ {2, \u0026#34;tomoto\u0026#34;}, {5, \u0026#34;grapes\u0026#34;}, {10, \u0026#34;shree\u0026#34;}, })); return EXIT_SUCCESS; } The thing here to note is what happens when there are duplicates! The duplicated elements are not transferred. They\u0026rsquo;re left behind in the right-hand-side map. std::map::extract(C++17) Unlike std::map::merge that transfers the elements in bulk, std::map::extract along with std::map::insert transfers element piecewise. But what is the more compelling application of std::map::extract is modifying keys. As we know, for std::map keys are always unique and sorted. Hence, It is crucial that users cannot modify the keys of map nodes that are already inserted. In order to prevent the user from modifying the key items of perfectly sorted map nodes, the const qualifier is added to the key type. This kind of restriction is perfectly valid because it makes harder for the user to use std::map the wrong way. But what if we really need to change the keys of some map items? Prior to C++17, we had to remove \u0026amp; reinsert the items in order to change the key. The downside of this approach is memory allocation \u0026amp; deallocation, which sounds bad in terms of performance. But, from C++17, we can remove \u0026amp; reinsert std::map nodes without any reallocation of memory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int main() { map\u0026lt;int, string\u0026gt; race_scoreboard{{1, \u0026#34;Mickel\u0026#34;}, {2, \u0026#34;Shree\u0026#34;}, {3, \u0026#34;Jenti\u0026#34;}}; using Pair = map\u0026lt;int, string\u0026gt;::value_type; { auto Jenti(race_scoreboard.extract(3)); auto Mickel(race_scoreboard.extract(1)); swap(Jenti.key(), Mickel.key()); auto [it, is_inserted, nh] = race_scoreboard.insert(move(Jenti)); // nh = node handle assert(*it == Pair(1, \u0026#34;Jenti\u0026#34;) \u0026amp;\u0026amp; is_inserted == true \u0026amp;\u0026amp; nh.empty()); race_scoreboard.insert(move(Mickel)); } assert((race_scoreboard == decltype(race_scoreboard){ {1, \u0026#34;Jenti\u0026#34;}, {2, \u0026#34;Shree\u0026#34;}, {3, \u0026#34;Mickel\u0026#34;}, })); return EXIT_SUCCESS; } Consider the above example of the racing scoreboard where you have employed std::map to imitate the racing position. And after a while, Jenti took the lead \u0026amp; Mickel left behind. In this case, how we have switched the keys(position on a race track) of those players. std::map::extract comes in two flavours: 1 2 node_type extract(const_iterator position); node_type extract(const key_type\u0026amp; x); In the above example, we used the second one, which accepts a key and then finds \u0026amp; extracts the map node that matches the key parameter. The first one accepts an iterator, which implies that it is faster because it doesn\u0026rsquo;t need to search for the item. What If the Node With a Particular Key Does Not Exist? If we try to extract an item that doesn\u0026rsquo;t exist with the second method (the one that searches using a key), it returns an empty node_type instance i.e. node handle. The empty()member method or overloaded bool operator tells us that whether a node_type instance is empty or not. OK! Then How Do I Modify std::map Keys? After extracting nodes, we were able to modify their keys using the key()method, which gives us non-const access to the key, although keys are usually const. Note that in order to reinsert the nodes into the map again, we had to move them into the insert function. This makes sense because the extract is all about avoiding unnecessary copies and allocations. Moreover, while we move a node_type instance, this does not result in actual moves of any of the container values. Can I Modify Associated Values in std::map Also? Yes! You can _use the accessor methods nh.mapped()(instead of nh.key() to manipulate the pieces of the entry in a std::map (or nh.value()for the single piece of data in an element of a std::set). Thus you can extract, manipulate, and reinsert a key without ever copying or moving its actual data. But What About Safety? If you extract a node from a map and then throw an exception before you\u0026rsquo;ve managed to re-insert it into the destination map. A node handle\u0026rsquo;s destructor is called and will correctly clean up the memory associated with the node. So, technically std::map::extract by-default(without insert) will act as std::map::erase! There Is More! Interoperability Map nodes that have been extracted using the std::map::extract are actually very versatile. We can extract nodes from a map instance and insert it into any other map or even multimap instance. It does also work between unordered_map and unordered_multimap instances, as well as with set/multiset and respective unordered_set/unordered_multiset. In order to move items between different map/set structures, the types of key, value and allocator need to be identical. Difference Between operator[ ] vs insert() vs at() This is trivial for experienced devs but, still I want to go over it quickly.\nstd::map::operator[ ] Operation: find-or-add; try to find an element with the given key inside the map, and if it exists it will return a reference to the stored value. If it does not, it will create a new element inserted in place with default initialization and return a reference to it. Applicability: Not usable for const std::map, as it will create the element if it doesn\u0026rsquo;t exist. Not suitable for value type that does not default constructible and assignable(in layman term, doesn\u0026rsquo;t have default constructor \u0026amp; copy/move constructor). When key exists: Overwrites it. std::map::insert Operation: insert-or-nop; accepts a value_type (std::pair) and uses the key(first member) and to insert it. Asstd::map does not allow for duplicates, if there is an existing element it will not insert anything. Applicability: Liberty in calling insert different ways that require the creation of the value_type externally and the copy of that object into the container. Highly applicable when item insertion sequence is somewhat predictable to gain the performance. When key exists: Not modify the state of the map, but instead return an iterator to the element that prevented the insertion. std::map::at Operation: find-or-throw; returns a reference to the mapped value of the element with key equivalent to input key. If no such element exists, an exception of type std::out_of_range is thrown. Applicability: Not recommended using at()when accessing const maps and when element absence is a logic error. Yes, it\u0026rsquo;s better to use std::map::find()when you\u0026rsquo;re not sure element is there. Because, throwing and catching std::logic_error exception will not be a very elegant way of programming, even if we don\u0026rsquo;t think about performance. When key exists: returns a reference to mapped value. Parting Words If you see the table of content for this article above, more than half of the member functions are around inserting the elements into the map. To the newbie, this is the reason for anxiety(or standard committee would say modernness). But if you account for the new features \u0026amp; complexity of language those are pretty much justified. BTW, this modernness doesn\u0026rsquo;t stop here, we do have other specialization also available for map like std::swap(C++17), std::erase_if(C++20) \u0026amp; bunch of comparison operators.\n","permalink":"https://vishalchovatiya.github.io/posts/using-std-map-wisely-with-modern-cpp/","summary":"std::map and its siblings(std::multimap, std::unordered_map/multimap) used to be my favourite containers when I was doing competitive programming. In fact, I still like them(though using less frequently nowadays). And with Modern C++, we now have more reasons to use std::map. That\u0026rsquo;s why I have decided to address this topic by writing an article summarizing these new features. So, without much gibberish, let\u0026rsquo;s dive-in directly.\nstd::map::contains(C++20) std::map::contains member function is a good step towards code expressiveness.","title":"Using std::map Wisely With Modern C++"},{"content":"Curiously Recurring Template Pattern(CRTP) in C++ is definitely a powerful technique \u0026amp; static alternative to virtual functions. But at the same time, learning it may seem a bit weird at first. If you are like me who struggled to grasp anything in one go. Then this article might help you to provide a thought process on where CRTP fits in day-to-day coding. And, if you are an Embedded Programmer, you may run into CRTP more often. Although, std::variant + std::visit will also help but 90% of the compilers for embedded processors are either not up to date with standard or dumb.\nThere is various material effectively accessible for \u0026ldquo;How\u0026rdquo; and \u0026ldquo;What\u0026rdquo; on CRTP. So, I won\u0026rsquo;t centre there rather address \u0026ldquo;Where\u0026rdquo; part i.e. CRTP Applicability.\nCRTP and Static Polymorphism In C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;typename specific_animal\u0026gt; struct animal { void who() { static_cast\u0026lt;specific_animal*\u0026gt;(this)-\u0026gt;who(); } }; struct dog : animal\u0026lt;dog\u0026gt; { void who() { cout \u0026lt;\u0026lt; \u0026#34;dog\u0026#34; \u0026lt;\u0026lt; endl; } }; struct cat : animal\u0026lt;cat\u0026gt; { void who() { cout \u0026lt;\u0026lt; \u0026#34;cat\u0026#34; \u0026lt;\u0026lt; endl; } }; template\u0026lt;typename specific_animal\u0026gt; void who_am_i(animal\u0026lt;specific_animal\u0026gt; \u0026amp;animal) { animal.who(); } cat c; who_am_i(c); // prints `cat` dog d; who_am_i(d); // prints `dog` Curiously Recurring Template Pattern widely employed for static polymorphism without bearing the cost of virtual dispatch mechanism. Consider the above code, we haven\u0026rsquo;t used virtual keyword \u0026amp; still achieved the functionality of polymorphism. How it works is not the topic of this article. So, I am leaving it to you to figure out. Limiting Object Count with CRTP There are times when you have to manage the critical resource with single or predefined object count. And we have Singleton \u0026amp; Monotone Design Patterns for this. But this works as long as your object counts are smaller in number. When you want to limit the arbitrary type to be limited with an arbitrary number of instances. CRTP will come to rescue: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 template \u0026lt;class ToBeLimited, uint32_t maxInstance\u0026gt; struct LimitNoOfInstances { static atomic\u0026lt;uint32_t\u0026gt; cnt; LimitNoOfInstances() { if (cnt \u0026gt;= maxInstance) throw logic_error{\u0026#34;Too Many Instances\u0026#34;}; ++cnt; } ~LimitNoOfInstances() { --cnt; } }; // Copy, move \u0026amp; other sanity checks to be complete struct One : LimitNoOfInstances\u0026lt;One, 1\u0026gt; {}; struct Two : LimitNoOfInstances\u0026lt;Two, 2\u0026gt; {}; template \u0026lt;class T, uint32_t maxNoOfInstace\u0026gt; atomic\u0026lt;uint32_t\u0026gt; LimitNoOfInstances\u0026lt;T, maxNoOfInstace\u0026gt;::cnt(0); void use_case() { Two _2_0, _2_1; try { One _1_0, _1_1; } catch (exception \u0026amp;e) { cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } } You might be wondering that what is the point of the template parameter ToBeLimited, if it isn\u0026rsquo;t used. In that case, you should have brush up your C++ Template fundamentals or use cppinsights.io. As it isn\u0026rsquo;t useless. CRTP to Avoid Code Duplication Let say you have a set of containers that support the functions begin() \u0026amp; end() But, the standard library\u0026rsquo;s requirements for containers require more functionalities like front(), back(), size(), etc. We can design such functionalities with a CRTP base class that provides common utilities solely based on derived class member function i.e. begin() \u0026amp; end()in our cases: 1 2 3 4 5 6 7 8 9 10 11 template \u0026lt;typename T\u0026gt; class Container { T \u0026amp;actual() { return *static_cast\u0026lt;T *\u0026gt;(this); } T const \u0026amp;actual() const { return *static_cast\u0026lt;T const *\u0026gt;(this); } public: decltype(auto) front() { return *actual().begin(); } decltype(auto) back() { return *std::prev(actual().end()); } decltype(auto) size() const { return std::distance(actual().begin(), actual().end()); } decltype(auto) operator[](size_t i) { return *std::next(actual().begin(), i); } }; The above class provides the functions front(), back(), size() and operator[ ] for any subclass that has begin() \u0026amp; end() For example, subclass could be a simple dynamically allocated array as: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template \u0026lt;typename T\u0026gt; class DynArray : public Container\u0026lt;DynArray\u0026lt;T\u0026gt;\u0026gt; { size_t m_size; unique_ptr\u0026lt;T[]\u0026gt; m_data; public: DynArray(size_t s) : m_size{s}, m_data{make_unique\u0026lt;T[]\u0026gt;(s)} {} T *begin() { return m_data.get(); } const T *begin() const { return m_data.get(); } T *end() { return m_data.get() + m_size; } const T *end() const { return m_data.get() + m_size; } }; DynArray\u0026lt;int\u0026gt; arr(10); arr.front() = 2; arr[2]\t= 5; asssert(arr.size() == 10); Modern C++ Composite Design Pattern Leveraging CRTP Composite Design Pattern states that we should treat the group of objects in the same manner as a single object. And to implement such pattern we can leverage the CRTP. For example, as a part of machine learning, we have to deal with Neuron which for simplicity defined as: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 struct Neuron { vector\u0026lt;Neuron*\u0026gt; in, out; // Stores the input-output connnections to other Neurons uint32_t id; Neuron() { static int id = 1; this-\u0026gt;id = id++; } void connect_to(Neuron \u0026amp;other) { out.push_back(\u0026amp;other); other.in.push_back(this); } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const Neuron \u0026amp;obj) { for (Neuron *n : obj.in) os \u0026lt;\u0026lt; n-\u0026gt;id \u0026lt;\u0026lt; \u0026#34;\\t--\u0026gt;\\t[\u0026#34; \u0026lt;\u0026lt; obj.id \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; for (Neuron *n : obj.out) os \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; obj.id \u0026lt;\u0026lt; \u0026#34;]\\t--\u0026gt;\\t\u0026#34; \u0026lt;\u0026lt; n-\u0026gt;id \u0026lt;\u0026lt; endl; return os; } }; Neuron n1, n2; n1.connect_to(n2); cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; endl; /* Output [1]\t--\u0026gt;\t2 1\t--\u0026gt;\t[2] */ And there is also a NeuronLayer i.e. collection of Neuron which for simplicity defined as: 1 2 3 4 5 6 7 8 9 10 11 12 struct NeuronLayer : vector\u0026lt;Neuron\u0026gt; { NeuronLayer(int count) { while (count --\u0026gt; 0) emplace_back(Neuron{}); } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, NeuronLayer \u0026amp;obj) { for (auto \u0026amp;n : obj) os \u0026lt;\u0026lt; n; return os; } }; Now, if you want to connect the Neuron with NeuronLayer and vice-versa. You\u0026rsquo;re going to have a total of four different functions as follows: 1 2 3 4 5 Neuron::connect_to(Neuron\u0026amp;) Neuron::connect_to(NeuronLayer\u0026amp;) NeuronLayer::connect_to(NeuronLayer\u0026amp;) NeuronLayer::connect_to(Neuron\u0026amp;) You see this is state-space explosion(permutation in layman terms) problem and it\u0026rsquo;s not good. Because we want a single function that enumerable both the layer as well as individual neurons. CRTP comes handy here as: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 template \u0026lt;typename Self\u0026gt; struct SomeNeurons { template \u0026lt;typename T\u0026gt; void connect_to(T \u0026amp;other); }; struct Neuron : SomeNeurons\u0026lt;Neuron\u0026gt; { vector\u0026lt;Neuron*\u0026gt; in, out; uint32_t id; Neuron() { static int id = 1; this-\u0026gt;id = id++; } Neuron* begin() { return this; } Neuron* end() { return this + 1; } }; struct NeuronLayer : vector\u0026lt;Neuron\u0026gt;, SomeNeurons\u0026lt;NeuronLayer\u0026gt; { NeuronLayer(int count) { while (count-- \u0026gt; 0) emplace_back(Neuron{}); } }; /* ----------------------------------------------------------------------- */ template \u0026lt;typename Self\u0026gt; template \u0026lt;typename T\u0026gt; void SomeNeurons\u0026lt;Self\u0026gt;::connect_to(T \u0026amp;other) { for (Neuron \u0026amp;from : *static_cast\u0026lt;Self *\u0026gt;(this)) { for (Neuron \u0026amp;to : other) { from.out.push_back(\u0026amp;to); to.in.push_back(\u0026amp;from); } } } /* ----------------------------------------------------------------------- */ template \u0026lt;typename Self\u0026gt; ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, SomeNeurons\u0026lt;Self\u0026gt; \u0026amp;object) { for (Neuron \u0026amp;obj : *static_cast\u0026lt;Self *\u0026gt;(\u0026amp;object)) { for (Neuron *n : obj.in) os \u0026lt;\u0026lt; n-\u0026gt;id \u0026lt;\u0026lt; \u0026#34;\\t--\u0026gt;\\t[\u0026#34; \u0026lt;\u0026lt; obj.id \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; for (Neuron *n : obj.out) os \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; obj.id \u0026lt;\u0026lt; \u0026#34;]\\t--\u0026gt;\\t\u0026#34; \u0026lt;\u0026lt; n-\u0026gt;id \u0026lt;\u0026lt; endl; } return os; } int main() { Neuron n1, n2; NeuronLayer l1{1}, l2{2}; n1.connect_to(l1); // Scenario 1: Neuron connects to Layer l2.connect_to(n2); // Scenario 2: Layer connects to Neuron l1.connect_to(l2); // Scenario 3: Layer connects to Layer n1.connect_to(n2); // Scenario 4: Neuron connects to Neuron cout \u0026lt;\u0026lt; \u0026#34;Neuron \u0026#34; \u0026lt;\u0026lt; n1.id \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Neuron \u0026#34; \u0026lt;\u0026lt; n2.id \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Layer \u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; l1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Layer \u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; l2 \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } /* Output Neuron 1 [1] --\u0026gt; 3 [1] --\u0026gt; 2 Neuron 2 4 --\u0026gt; [2] 5 --\u0026gt; [2] 1 --\u0026gt; [2] Layer 1 --\u0026gt; [3] [3] --\u0026gt; 4 [3] --\u0026gt; 5 Layer 3 --\u0026gt; [4] [4] --\u0026gt; 2 3 --\u0026gt; [5] [5] --\u0026gt; 2 */ As you can see we have covered all four different permutation scenarios using a single SomeNeurons::connect_to method. And both Neuron \u0026amp; NeuronLayer conforms to this interface via self templatization. C++20 Spaceship Operator With the Help of CRTP Problem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct obj_type_1 { bool operator\u0026lt;(const value \u0026amp;rhs) const { return m_x \u0026lt; rhs.m_x; } // bool operator==(const value \u0026amp;rhs) const; // bool operator!=(const value \u0026amp;rhs) const; // List goes on. . . . . . . . . . . . . . . . . . . . private: // data members to compare }; struct obj_type_2 { bool operator\u0026lt;(const value \u0026amp;rhs) const { return m_x \u0026lt; rhs.m_x; } // bool operator==(const value \u0026amp;rhs) const; // bool operator!=(const value \u0026amp;rhs) const; // List goes on. . . . . . . . . . . . . . . . . . . . private: // data members to compare }; struct obj_type_3 { ... struct obj_type_4 { ... // List goes on. . . . . . . . . . . . . . . . . . . . For each comparable objects, you need to define respective comparison operators. This is redundant because if we have an operator \u0026lt; , we can overload other operators on the basis of it. Thus, operator \u0026lt; is the only one operator having type information, other operators can be made type independent for reusability purpose. Solution till C++17 with CRTP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template \u0026lt;class derived\u0026gt; struct compare {}; struct value : compare\u0026lt;value\u0026gt; { int m_x; value(int x) : m_x(x) {} bool operator \u0026lt; (const value \u0026amp;rhs) const { return m_x \u0026lt; rhs.m_x; } }; template \u0026lt;class derived\u0026gt; bool operator \u0026gt; (const compare\u0026lt;derived\u0026gt; \u0026amp;lhs, const compare\u0026lt;derived\u0026gt; \u0026amp;rhs) { // static_assert(std::is_base_of_v\u0026lt;compare\u0026lt;derived\u0026gt;, derived\u0026gt;); // Compile time safety measures return (static_cast\u0026lt;const derived\u0026amp;\u0026gt;(rhs) \u0026lt; static_cast\u0026lt;const derived\u0026amp;\u0026gt;(lhs)); } /* Same goes with other operators == :: returns !(lhs \u0026lt; rhs) and !(rhs \u0026lt; lhs) != :: returns !(lhs == rhs) \u0026gt;= :: returns (rhs \u0026lt; lhs) or (rhs == lhs) \u0026lt;= :: returns (lhs \u0026lt; rhs) or (rhs == lhs) */ int main() { value v1{5}, v2{10}; cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; \u0026#34;v1 \u0026gt; v2: \u0026#34; \u0026lt;\u0026lt; (v1 \u0026gt; v2) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return EXIT_SUCCESS; } // Now no need to write comparator operators for all the classes, // Write only type dependent `operator \u0026lt;` \u0026amp; inherit with `compare\u0026lt;T\u0026gt;` C++20 Solution : Spaceship Operator 1 2 3 4 5 6 7 struct value{ int m_x; value(int x) : m_x(x) {} auto operator\u0026lt;=\u0026gt;(const value \u0026amp;rhs) const = default; }; // Defaulted equality comparisons // More Info: https://en.cppreference.com/w/cpp/language/default_comparisons Enabling Polymorphic Method Chaining Method Chaining is a common syntax for invoking multiple methods on a single object back to back. That too, in a single statement without requiring variables to store the intermediate results. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Printer { ostream \u0026amp;m_stream; public: Printer(ostream \u0026amp;s) : m_stream(s) { } Printer \u0026amp;print(auto \u0026amp;\u0026amp;t) { m_stream \u0026lt;\u0026lt; t; return *this; } Printer \u0026amp;println(auto \u0026amp;\u0026amp;t) { m_stream \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return *this; } }; Printer{cout}.println(\u0026#34;hello\u0026#34;).println(500); // Method Chaining But, when method chaining applied to an object hierarchy, things can go wrong. For example: 1 2 3 4 5 6 7 8 9 10 11 struct ColorPrinter : Printer { enum Color{red, blue, green}; ColorPrinter(ostream \u0026amp;s) : Printer(s) {} ColorPrinter \u0026amp;SetConsoleColor(Color c) { // ... return *this; } }; ColorPrinter(cout).print(\u0026#34;Hello\u0026#34;).SetConsoleColor(ColorPrinter::Color::red).println(\u0026#34;Printer!\u0026#34;); // Not OK Compiling above code prompt you with the following error: 1 2 3 4 5 error: \u0026#39;class Printer\u0026#39; has no member named \u0026#39;SetConsoleColor\u0026#39; ColorPrinter(cout).print(\u0026#34;Hello\u0026#34;).SetConsoleColor(ColorPrinter::Color::red).println(\u0026#34;Printer!\u0026#34;); ^ |____________ We have a \u0026#39;Printer\u0026#39; here, not a \u0026#39;ColorPrinter\u0026#39; This happens because we \u0026ldquo;lose\u0026rdquo; the concrete class as soon as we invoke a function of the base class. The CRTP can be useful to avoid such problem and to enable Polymorphic Method Chaining. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template \u0026lt;typename ConcretePrinter\u0026gt; class Printer { ostream \u0026amp;m_stream; public: Printer(ostream \u0026amp;s) : m_stream(s) { } ConcretePrinter \u0026amp;print(auto \u0026amp;\u0026amp;t) { m_stream \u0026lt;\u0026lt; t; return static_cast\u0026lt;ConcretePrinter \u0026amp;\u0026gt;(*this); } ConcretePrinter \u0026amp;println(auto \u0026amp;\u0026amp;t) { m_stream \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return static_cast\u0026lt;ConcretePrinter \u0026amp;\u0026gt;(*this); } }; struct ColorPrinter : Printer\u0026lt;ColorPrinter\u0026gt; { enum Color { red, blue, green }; ColorPrinter(ostream \u0026amp;s) : Printer(s) {} ColorPrinter \u0026amp;SetConsoleColor(Color c) { // ... return *this; } }; int main() { ColorPrinter(cout).print(\u0026#34;Hello \u0026#34;).SetConsoleColor(ColorPrinter::Color::red).println(\u0026#34;Printer!\u0026#34;); return EXIT_SUCCESS; } Enabling Polymorphic Copy Construction in C++ with CRTP Problem C++ has the support of polymorphic object destruction using it’s base class’s virtual destructor. But, equivalent support for creation and copying of objects is missing as С++ doesn’t support virtual constructor/copy-constructors. Moreover, you can’t create an object unless you know its static type, because the compiler must know the amount of space it needs to allocate. For the same reason, copy of an object also requires its type to known at compile-time. 1 2 3 4 5 6 7 8 9 10 11 struct animal { virtual ~animal(){ cout \u0026lt;\u0026lt; \u0026#34;~animal\\n\u0026#34;; } }; struct dog : animal { ~dog(){ cout \u0026lt;\u0026lt; \u0026#34;~dog\\n\u0026#34;; } }; struct cat : animal { ~cat(){ cout \u0026lt;\u0026lt; \u0026#34;~cat\\n\u0026#34;; } }; void who_am_i(animal *who) { // not sure whether `dog` would be passed here or `cat` // How to `copy` object of the same type i.e. pointed by who? delete who; // you can delete object pointed by who } Solution 1 : Dynamic Polymorphism As the name suggests, we will use virtual methods to delegate the act of copying(and/or creation) of the object as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct animal { virtual unique_ptr\u0026lt;animal\u0026gt; clone() = 0; }; struct dog : animal { unique_ptr\u0026lt;animal\u0026gt; clone() override { return make_unique\u0026lt;dog\u0026gt;(*this); } }; struct cat : animal { unique_ptr\u0026lt;animal\u0026gt; clone() override { return make_unique\u0026lt;cat\u0026gt;(*this); } }; void who_am_i(animal *who) { auto duplicate_who = who-\u0026gt;clone(); // `copy` object of same type i.e. pointed by who ? } Solution 2 : Static Polymorphism Same thing can be accomplished with CRTP as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template \u0026lt;class specific\u0026gt; struct animal { unique_ptr\u0026lt;animal\u0026gt; clone() { return make_unique\u0026lt;specific\u0026gt;(static_cast\u0026lt;specific \u0026amp;\u0026gt;(*this)); } protected: // Forcing animal class to be inherited animal(const animal \u0026amp;) = default; }; struct dog : animal\u0026lt;dog\u0026gt; { dog(const dog \u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;copied dog\u0026#34; \u0026lt;\u0026lt; endl; } }; struct cat : animal\u0026lt;cat\u0026gt; { cat(const cat \u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;copied cat\u0026#34; \u0026lt;\u0026lt; endl; } }; template \u0026lt;class specific\u0026gt; void who_am_i(animal\u0026lt;specific\u0026gt; *who) { auto duplicate_who = who-\u0026gt;clone(); // `copy` object of same type i.e. pointed by who ? } Wrap-Up Everything comes with its own price. And CRTP is no exception. For example, if you are using CRTP with run time object creation, your code may behave weird. Moreover,\nAs the base class is templated, you can not point derived class object with the base class pointer. Also, you can not create generic container like std::vector\u0026lt;animal*\u0026gt; because animal is not a class, but a template needing specialization. A container defined as std::vector\u0026lt;animal\u0026lt;dog\u0026gt;*\u0026gt; can only store dogs, not cats. This is because each of the classes derived from the CRTP base class animal is a unique type. A common solution to this problem is to add one more layer of indirection i.e. abstract class with a virtual destructor, like the abstract_animal \u0026amp; inherit animal class, allowing for the creation of a std::vector\u0026lt;`abstract_animal`*\u0026gt;. There are other useful application of CRTP as well. If you think I am missing any major one \u0026amp; have any suggestion you can always reach me here.\nReferences wikipedia C++ Notes for Professionals Stack Overflow Documentation Advanced C++ Concepts ","permalink":"https://vishalchovatiya.github.io/posts/crtp-c-examples/","summary":"Curiously Recurring Template Pattern(CRTP) in C++ is definitely a powerful technique \u0026amp; static alternative to virtual functions. But at the same time, learning it may seem a bit weird at first. If you are like me who struggled to grasp anything in one go. Then this article might help you to provide a thought process on where CRTP fits in day-to-day coding. And, if you are an Embedded Programmer, you may run into CRTP more often.","title":"CRTP C++ Examples"},{"content":"I know, it’s been a while since the last time I published something newbies-friendly on my blog. The main reason is that most of my readers are either experienced devs or from C background having modest C++ encounter. But while programming in C++ you need a completely different mindset as both C \u0026amp; C++ belongs to different programming paradigm. And I always strive to show them a better way of doing things in C++. Anyway, I found the topic which is lengthy, reasonably complex(at least it was for me), newbies-friendly as well as energizing for experienced folks(if Modern C++ jargons, rules \u0026amp; features added) i.e. C++ Template.\nI will start with a simple class/function template and as we move along, will increase the complexity. And also cover the advance topics like the variadic template, nested template, CRTP, template vs fold-expression, etc. But, yes! we would not take deeper dive otherwise this would become a book rather than an article.\nNote: I would recommend you to use cppinsights online tool wherever you feel confused. It helps you to see Template Instances, Template Argument Deduction, etc. Basically, it helps you to see code from the compiler\u0026rsquo;s perspective.\nTerminology/Jargon/Idiom You May Face Template Instantiation: It is a process of generating a concrete class/struct/union/function out of templated class/struct/union/function for a particular combination of template arguments. For example, if you use vector\u0026lt;int\u0026gt; \u0026amp; vector\u0026lt;char\u0026gt;, it will create two different concrete classes during compilation. This process of creating concrete classes is known as Template Instantiation. Template Instances: Outcome of Template Instantiation is Template Instances i.e. concrete classes. Explicit Template Instantiation: Usually template instantiation done at the time of object declaration. But you can also force the compiler to instantiate class/struct/union/function with particular type without even creating the object. It may appear in the program anywhere after the template definition, and for a given argument-list. Will see this later in the article. Template Argument vs Template Parameter: In expression template\u0026lt;typename _T_\u0026gt; void print(_T a_){ };, T is parameter \u0026amp; when you call print(5);, 5 which is of type int is template argument. This is a trivial thing for some pips. But not for non-native English speaker or beginners. So, this ambiguity has to be clear. C++ Template Types Class Template 1 2 3 4 5 6 7 8 9 template \u0026lt;typename T1, typename T2\u0026gt; class pair { public: T1 first; T2 second; }; pair\u0026lt;int, char\u0026gt; p1; pair\u0026lt;float, float\u0026gt; p2; The basic idea of a class template is that the template parameter i.e. T1 \u0026amp; T2 gets substituted by an appropriate deduced type at compile time. The result is that the same class can be reused for multiple types. And the user has to specify which type they want to use when an object of the class is declared. Function Template 1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; T min(T a, T b) { return a \u0026lt; b ? a : b; } min\u0026lt;int\u0026gt;(4, 5); // Case 1 min\u0026lt;float\u0026gt;(4.1f, 5.1f); // Case 2 In both of the above case, the template arguments used to replace the types of the parameters i.e. T. One additional property of template functions (unlike class template till C++17) is that the compiler can infer the template parameters based on the parameters passed to the function. So, passing \u0026lt;int\u0026gt; \u0026amp; \u0026lt;float\u0026gt; after the function name is redundant. Union Template Yes! a union can also be templatized. In fact, the standard library provides some utilities like std::optional, std::variant, etc. which directly or indirectly uses templatized union. 1 2 3 4 5 template \u0026lt;typename T\u0026gt; union test { uint8_t ch[sizeof(T)]; T variable; }; As you can see above, templatized unions are also particularly useful to represent a type simultaneously as a byte array. Variable Template Yes! This may a bit socking. But, you can templatise the variable also since C++14. 1 2 3 4 5 template \u0026lt;class T\u0026gt; constexpr T pi = T(3.1415926535897932385L); // variable template cout \u0026lt;\u0026lt; pi\u0026lt;float\u0026gt; \u0026lt;\u0026lt; endl; // 3.14159 cout \u0026lt;\u0026lt; pi\u0026lt;int\u0026gt; \u0026lt;\u0026lt; endl; // 3 Now, you might be wondering that what is the point of the templatizing variable. But, consider the following example: 1 2 3 4 5 6 7 8 9 10 template \u0026lt;uint32_t val\u0026gt; constexpr auto fib = fib\u0026lt;val - 1\u0026gt; + fib\u0026lt;val - 2\u0026gt;; template \u0026lt;\u0026gt; constexpr auto fib\u0026lt;0\u0026gt; = 0; template \u0026lt;\u0026gt; constexpr auto fib\u0026lt;1\u0026gt; = 1; cout \u0026lt;\u0026lt; fib\u0026lt;10\u0026gt; \u0026lt;\u0026lt; endl; // 55 Above code gives you 10th Fibonacci term at compile time, without even creating class or function. C++ Template Argument Overriding Template Argument Deduction 1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; T min(T a, T b) { cout \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; // T will be deduce as `int` return a \u0026lt; b ? a : b; } min\u0026lt;int\u0026gt;(5.5f, 6.6f); // Implicit conversion happens here Default Template Arguments 1 2 3 4 5 6 template \u0026lt;class T, size_t N = 10\u0026gt; struct array { T arr[N]; }; array\u0026lt;int\u0026gt; arr; Just like in case of the function arguments, template parameters can also have their default values. All template parameters with a default value have to be declared at the end of the template parameter list. Template Argument Deduction Function Template Argument Deduction Function template argument deduction is done by comparing the types of function arguments to function parameters, according to rules in the Standard. Which makes function templates far more usable than they would otherwise be. For example, given a function template like: 1 2 3 4 template \u0026lt;typename RanIt\u0026gt; void sort(RanIt first, RanIt last){ // . . . } You can and should sort a std::vector\u0026lt;int\u0026gt; without explicitly specifying that RanIt is std::vector\u0026lt;int\u0026gt;::iterator. When the compiler sees sort(v.begin(), v.end());, it knows what the types of v.begin() and v.end()are, so it can determine what RanIt` should be. Class Template Argument Deduction(CTAD) Until C++17, template classes could not apply type deduction in their initialization as template function do. For example 1 2 3 //... pair p4{1, \u0026#39;A\u0026#39;}; // Not OK until C++17: Can\u0026#39;t deduce type in initialization //... But from C++17, the compiler can deduce types in class/struct initialization \u0026amp; this to work, class/struct must have an appropriate constructor. But this limitation is also relaxed in C++20. So technically from C++20, you can construct the object with aggregate initialization \u0026amp; without specifying types explicitly. Until C++17, the standard provided some std::make_ utility functions to counter such situations as below. Inferring Template Argument Through Function Template You might have seen many functions like std::make_pair(), std::make_unique(), `std::make_share(), etc. Which can typically \u0026amp; unsophistically implement as: 1 2 3 4 template \u0026lt;typename T1, typename T2\u0026gt; pair\u0026lt;T1, T2\u0026gt; make_pair(T1\u0026amp;\u0026amp; t1, T2\u0026amp;\u0026amp; t2) { return {forward\u0026lt;T1\u0026gt;(t1), forward\u0026lt;T2\u0026gt;(t2)}; } But have you ever wonder why these helper functions are there in the standard library? How does this even help? 1 2 3 4 pair\u0026lt;int, char\u0026gt; p1{1, \u0026#39;A\u0026#39;}; // Rather using this auto p2 = make_pair(1, 2); // Use this instead auto p3 = make_pair\u0026lt;float\u0026gt;(1, 2.4f); // Or specify types explicitly Rather than specifying the arguments explicitly, you can leverage the feature of inferring template argument from function template to construct the object. In the above case, template argument deduction is done by the utility function make_pair. As a result, we have created the object of pair without specifying the type explicitly. And as discussed earlier from C++17, you can construct the object without even specifying types explicitly so std::vector v{1,2,3,4}; is perfectly valid statement. Template Argument Forwarding C++ Template Reference Collapsing Rules Apart from accepting type \u0026amp; value in the template parameter. You can enable the template to accept both lvalue and rvalue references. And to do this you need to adhere to the rules of reference collapsing as follows: T\u0026amp; \u0026amp; becomes T\u0026amp; T\u0026amp; \u0026amp;\u0026amp; become T\u0026amp; T\u0026amp;\u0026amp; \u0026amp; becomes T\u0026amp; T\u0026amp;\u0026amp; \u0026amp;\u0026amp; becomes T\u0026amp;\u0026amp; 1 2 template \u0026lt;typename T\u0026gt; void f(T \u0026amp;\u0026amp;t); In the above case, the real type of t depends on the context. For example: 1 2 3 4 int x = 0; f(0); // deduces as rvalue reference i.e. f(int\u0026amp;\u0026amp;) f(x); // deduces as lvalue reference i.e. f(int\u0026amp;) In case of f(0);, 0 is rvalue of type int, hence T = int\u0026amp;\u0026amp;, thus f(int\u0026amp;\u0026amp; \u0026amp;\u0026amp;t) becomes f(int\u0026amp;\u0026amp; t). In case of f(x);, x is lvalue of type int, hence T = int\u0026amp;, thus f(int\u0026amp; \u0026amp;\u0026amp;t) becomes f(int\u0026amp; t). Perfect Forwarding | Forwarding Reference | Universal Reference In order to perfectly forward t to another function, one must use std::forward as: 1 2 3 4 template \u0026lt;typename T\u0026gt; void func1(T \u0026amp;\u0026amp;t) { func2(std::forward\u0026lt;T\u0026gt;(t)); // Forward appropriate lvalue or rvalue reference to another function } Forwarding references can also be used with variadic templates: 1 2 3 4 template \u0026lt;typename... Args\u0026gt; void func1(Args\u0026amp;\u0026amp;... args) { func2(std::forward\u0026lt;Args\u0026gt;(args)...); } Why Do We Need Forwarding Reference in First Place? Answer to this question lies in move semantics. Though, short answer to this question is \u0026ldquo;To perform copy/move depending upon value category type\u0026rdquo;. C++ Template Category Full Template Specialization Template has a facility to define implementation for specific instantiations of a template class/struct/union/function/method. Function Template Specialization 1 2 3 4 5 template \u0026lt;typename T\u0026gt; T sqrt(T t) { /* Some generic implementation */ } template\u0026lt;\u0026gt; int sqrt\u0026lt;int\u0026gt;(int i) { /* Highly optimized integer implementation */ } In the above case, a user that writes sqrt(4.0) will get the generic implementation whereas sqrt(4) will get the specialized implementation. Class Template Specialization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename T\u0026gt; // Common case struct Vector { void print() {} }; template \u0026lt;\u0026gt; // Special case struct Vector\u0026lt;bool\u0026gt; { void print_bool() {} }; Vector\u0026lt;int\u0026gt; v1; v1.print_bool(); // Not OK: Chose common case Vector\u0026lt;T\u0026gt; v1.print() // OK Vector\u0026lt;bool\u0026gt; v2; // OK : Chose special case Vector\u0026lt;bool\u0026gt; Partial Template Specialization Partial Class Template Specialization In contrast of a full template specialization, you can also specialise template partially with some of the arguments of existing template fixed. Partial template specialization is only available for template class/structs/union: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template \u0026lt;typename T1, typename T2\u0026gt; // Common case struct Pair { T1 first; T2 second; void print_first() {} }; template \u0026lt;typename T\u0026gt; // Partial specialization on first argument as int struct Pair\u0026lt;int, T\u0026gt; { void print() {} }; // Use case 1 ---------------------------------------------------------- Pair\u0026lt;char, float\u0026gt; p1; // Chose common case p1.print_first(); // OK // p1.print(); // Not OK: p1 is common case \u0026amp; it doesn\u0026#39;t have print() method // Use case 2 ---------------------------------------------------------- Pair\u0026lt;int, float\u0026gt; p2; // Chose special case p2.print(); // OK // p2.print_first(); // Not OK: p2 is special case \u0026amp; it does not have print_first() // Use case 3 ---------------------------------------------------------- // Pair\u0026lt;int\u0026gt; p3; // Not OK: Number of argument should be same as Primary template Partial Function Template Specialization You cannot partially specialize method/function. Function templates may only be fully specialized 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template \u0026lt;typename T, typename U\u0026gt; void foo(T t, U u) { cout \u0026lt;\u0026lt; \u0026#34;Common case\u0026#34; \u0026lt;\u0026lt; endl; } // OK. template \u0026lt;\u0026gt; void foo\u0026lt;int, int\u0026gt;(int a1, int a2) { cout \u0026lt;\u0026lt; \u0026#34;Fully specialized case\u0026#34; \u0026lt;\u0026lt; endl; } // Compilation error: partial function specialization is not allowed. template \u0026lt;typename U\u0026gt; void foo\u0026lt;string, U\u0026gt;(string t, U u) { cout \u0026lt;\u0026lt; \u0026#34;Partial specialized case\u0026#34; \u0026lt;\u0026lt; endl; } foo(1, 2.1); // Common case foo(1, 2); // Fully specialized case Alternative To Partial Function Template Specialization As I have mentioned earlier, partial specialization of function templates is not allowed. You can use SFINAE with std::enable_if for work around as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T, typename std::enable_if_t\u0026lt;!std::is_pointer\u0026lt;T\u0026gt;::value\u0026gt; * = nullptr\u0026gt; void func(T val) { cout \u0026lt;\u0026lt; \u0026#34;Value\u0026#34; \u0026lt;\u0026lt; endl; } template \u0026lt;typename T, typename std::enable_if_t\u0026lt;std::is_pointer\u0026lt;T\u0026gt;::value\u0026gt; * = nullptr\u0026gt; void func(T val) { // NOTE: function signature is NOT-MODIFIED cout \u0026lt;\u0026lt; \u0026#34;Pointer\u0026#34; \u0026lt;\u0026lt; endl; } int a = 0; func(a); func(\u0026amp;a); Non-Type Template Parameter As the name suggests, apart from types, you can also declare the template parameter as constant expressions like addresses, references, integrals, std::nullptr_t, enums, etc. Like all other template parameters, non-type template parameters can be explicitly specified, defaulted, or derived implicitly via Template Argument Deduction. The more specific use case of a non-type template is passing a plain array into a function without specifying its size explicitly. A more relevant example of this is std::begin \u0026amp; std::end specialisation for array literal from the standard library: 1 2 3 4 5 6 7 8 template \u0026lt; class T, size_t size\u0026gt; // Non Type Template T* begin(T (\u0026amp;arr)[size]) { // Array size deduced implicitly return arr; } int arr[] = {1,2,3,4}; begin(arr); // Do not have to pass size explicitly Non-type template parameters are one of the ways to achieve template recurrence \u0026amp; enables Template Meta-programming. Nested Template: Template Template Parameter Sometimes we have to pass templated type into another templated type. And in such case, you not only have to take care of main template type but also a nested template type. Very simple template- template parameter examples is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt; template \u0026lt;typename\u0026gt; class C, typename T \u0026gt; void print_container(C\u0026lt;T\u0026gt; \u0026amp;c) { // . . . } template \u0026lt;typename T\u0026gt; class My_Type { // . . . }; My_Type\u0026lt;int\u0026gt; t; print_container(t); Variadic Template It is often useful to define class/struct/union/function that accepts a variable number and type of arguments. If you have already used C you\u0026rsquo;ll know that printf function can accept any number of arguments. Such functions are entirely implemented through macros or ellipses operator. And because of that it has several disadvantages like type-safety, cannot accept references as arguments, etc. Variadic Class Template Implementing Unsophisticated Tuple Class(\u0026gt;=C++14) Since C++11 standard library introduced std::tuple class that accept variable data members at compile time using the variadic template. And to understand its working, we will build our own ADT same as std::tuple `` The variadic template usually starts with the general (empty) definition, that also serves as the base-case for recursion termination in the later specialisation: 1 2 template \u0026lt;typename... T\u0026gt; struct Tuple { }; This already allows us to define an empty structure i.e. Tuple\u0026lt;\u0026gt; object;, albeit that isn\u0026rsquo;t very useful yet. Next comes the recursive case specialisation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt; typename T, typename... Rest \u0026gt; struct Tuple\u0026lt;T, Rest...\u0026gt; { T first; Tuple\u0026lt;Rest...\u0026gt; rest; Tuple(const T\u0026amp; f, const Rest\u0026amp; ... r) : first(f) , rest(r...) { } }; Tuple\u0026lt;bool\u0026gt; t1(false); // Case 1 Tuple\u0026lt;int, char, string\u0026gt; t2(1, \u0026#39;a\u0026#39;, \u0026#34;ABC\u0026#34;); // Case 2 How Does Variadic Class Template Works? To understand variadic class template, consider use case 2 above i.e. Tuple\u0026lt;int, char, string\u0026gt; t2(1, 'a', \u0026quot;ABC\u0026quot;);\nThe declaration first matches against the specialization, yielding a structure with int first; and Tuple\u0026lt;char, string\u0026gt; rest; data members. The rest definition again matches with specialization, yielding a structure with char first; and Tuple\u0026lt;string\u0026gt; rest; data members. The rest definition again matches this specialization, creating its own string first; and Tuple\u0026lt;\u0026gt; rest; members. Finally, this last rest matches against the base-case definition, producing an empty structure. You can visualize this as follows:\n1 2 3 4 5 6 7 8 Tuple\u0026lt;int, char, string\u0026gt; -\u0026gt; int first -\u0026gt; Tuple\u0026lt;char, string\u0026gt; rest -\u0026gt; char first -\u0026gt; Tuple\u0026lt;string\u0026gt; rest -\u0026gt; string first -\u0026gt; Tuple\u0026lt;\u0026gt; rest -\u0026gt; (empty) I have written a separate article on Variadic Template C++: Implementing Unsophisticated Tuple, if you are interested more in the variadic temple.\nVariadic Function Template As we have seen earlier, variadic template starts with empty definition i.e. base case for recursion. 1 void print() {} Then the recursive case specialisation: 1 2 3 4 5 6 7 8 template\u0026lt; typename First, typename... Rest // Template parameter pack \u0026gt; void print(First first, Rest... rest) { // Function parameter pack cout \u0026lt;\u0026lt; first \u0026lt;\u0026lt; endl; print(rest...); // Parameter pack expansion } This is now sufficient for us to use the print function with variable number and type of arguments. For example: 1 print(500, \u0026#39;a\u0026#39;, \u0026#34;ABC\u0026#34;); You can further optimize the print function with forwarding reference, if constexpr() \u0026amp; sizeof()`operator as: 1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt; typename First, typename... Rest \u0026gt; void print(First\u0026amp;\u0026amp; first, Rest\u0026amp;\u0026amp;... rest) { if constexpr(sizeof...(rest) \u0026gt; 0) { // Size of parameter pack cout \u0026lt;\u0026lt; first \u0026lt;\u0026lt; endl; print(std::forward\u0026lt;Rest\u0026gt;(rest)...); // Forwarding reference } else { cout \u0026lt;\u0026lt; first \u0026lt;\u0026lt; endl; } } How Does Variadic Function Template Works? As you can see we have called print with 3 arguments i.e. print(500, 'a', \u0026quot;ABC\u0026quot;); At the time of compilation compiler instantiate 3 different print function as follows: `void print(int first, char __rest1, const char* __rest2) `void print(char first, const char* __rest1) `void print(const char* first) The first print(i.e. accept 3 arguments) will be called which prints the first argument \u0026amp; line print(rest…); expand with second print(i.e. accept 2 arguments). This will go on till argument count reaches to zero. That means in each call to print, the number of arguments is reduced by one \u0026amp; the rest of the arguments will be handled by a subsequent instance of print. Thus, the number of print instance after compilation is equal to the number of arguments, plus the base case instance of print. Hence, the variadic template also contributes to more code bloating. You can get this much better if you put the above example in cppinsights. And try to understand all the template instances. Fold Expressions vs Variadic Template As we saw, from C++11, the variadic template is a great addition to C++ Template. But it has nuisance like you need base case \u0026amp; recursive template implementation, etc. So, with C++17 standard introduced a new feature named as Fold Expression. Which you can use with parameter pack as follows: 1 2 3 4 template \u0026lt;typename... Args\u0026gt; void print(Args \u0026amp;\u0026amp;... args) { (void(cout \u0026lt;\u0026lt; std::forward\u0026lt;Args\u0026gt;(args) \u0026lt;\u0026lt; endl), ...); } See, no cryptic boilerplate required. Isn\u0026rsquo;t this solution looks neater? There are total 3 types of folding: Unary fold, Binary fold \u0026amp; Fold over a comma. Here we have done left folding over a comma. You can read more about Fold Expression here. Misc C++ Template `typename` vs `class` typename and class are interchangeable in most of the cases. A general convention is typename used with the concrete type(i.e. in turn, does not depend on further template parameter) while class used with dependent type. But there are cases where either typename or class has to be certain. For example To Refer Dependent Types 1 2 3 4 5 template\u0026lt;typename container\u0026gt; class Example { using t1 = typename container::value_type; // value_type depends on template argument of container using t2 = std::vector\u0026lt;int\u0026gt;::value_type; // value_type is concrete type, so doesn\u0026#39;t require typename }; typename is a must while referencing a nested type that depends on template parameter. To Specify Template Template Type 1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt; template \u0026lt;typename, typename\u0026gt; class C, // `class` is must prior to C++17 typename T, typename Allocator \u0026gt; void print_container(C\u0026lt;T, Allocator\u0026gt; container) { for (const T\u0026amp; v : container) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } vector\u0026lt;int\u0026gt; v; print_container(v); This is rectified in C++17, So now you can use typename also. C++11: Template Type Alias 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; using pointer = T*; pointer\u0026lt;int\u0026gt; p = new int; // Equivalent to: int* p = new int; template \u0026lt;typename T\u0026gt; using v = vector\u0026lt;T\u0026gt;; v\u0026lt;int\u0026gt; dynamic_arr; // Equivalent to: vector\u0026lt;int\u0026gt; dynamic_arr; typedef will also work fine, but would not encourage you to use. As it isn\u0026rsquo;t part of Modern C++. C++14/17: Template \u0026amp; auto Keyword Since C++14, you can use auto in function argument. It\u0026rsquo;s kind of template shorthand as follows: 1 2 3 4 5 6 void print(auto \u0026amp;c) { /*. . .*/ } // Equivalent to template \u0026lt;typename T\u0026gt; void print(T \u0026amp;c) { /*. . .*/ } Although auto in function return-type is supported from C++11. But, you have to mention the trailing return type. Which is rectified in C++14 \u0026amp; now return type is automatically deduced by compiler. From C++17, you can also use auto in non-type template(I will cover this in later part this article) parameters. C++20: Template Lambda Expression A generic lambda expression is supported since C++14 which declare parameters as auto. But there was no way to change this template parameter and use real template arguments. For example: 1 2 3 4 template \u0026lt;typename T\u0026gt; void f(std::vector\u0026lt;T\u0026gt;\u0026amp;\tvec) { //. . . } How do you write the lambda for the above function which takes std::vector of type T? This was the limitation till C++17, but with C++20 it is possible templatized lambda as : 1 2 3 4 5 6 auto f = []\u0026lt;typename T\u0026gt;(std::vector\u0026lt;T\u0026gt;\u0026amp; vec) { // . . . }; std::vector\u0026lt;int\u0026gt; v; f(v); Explicit Template Instantiation An explicit instantiation creates and declares a concrete class/struct/union/function/variable from a template, without using it just yet. Generally, you have to implement the template in header files only. You can not put the implementation/definition of template methods in implementation files(i.e. cpp or .cc). If this seems new to you, then consider following minimalist example: value.hpp\n1 2 3 4 5 6 7 8 #pragma once template \u0026lt;typename T\u0026gt; class value { T val; public: T get_value(); }; value.cpp\n1 2 3 4 5 6 #include \u0026#34;value.hpp\u0026#34; template \u0026lt;typename T\u0026gt; T value\u0026lt;T\u0026gt;::get_value() { return val; } main.cpp\n1 2 3 4 5 6 7 #include \u0026#34;value.hpp\u0026#34; int main() { value\u0026lt;int\u0026gt; v1{9}; cout \u0026lt;\u0026lt; v1.get_value() \u0026lt;\u0026lt; endl; return 0; } If you compile above code you will get following error: 1 2 3 4 /tmp/main-4b4bef.o: In function `main\u0026#39;: main.cpp:(.text+0x1e): undefined reference to `value\u0026lt;int\u0026gt;::get_value()` clang: error: linker command failed with exit code 1 (use -v to see invocation) compiler exit status 1 If you do explicit initialization i.e. add template class value\u0026lt;int\u0026gt;; line at the end of value.cpp. Then the compilation gets successful. The \u0026ldquo;template class\u0026rdquo; command causes the compiler to explicitly instantiate the template class. In the above case, the compiler will stencil out value\u0026lt;int\u0026gt; inside of value.cpp. There are other solutions as well. Check out this StackOverflow link. C++ Template Example Use Cases Curiously Recurring Template Pattern CRTP widely employed for static polymorphism or code reusability without bearing the cost of virtual dispatch mechanism. Consider the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template \u0026lt;typename specific_animal\u0026gt; struct animal { void who() { implementation().who(); } private: specific_animal \u0026amp;implementation() { return *static_cast\u0026lt;specific_animal *\u0026gt;(this); } }; struct dog : animal\u0026lt;dog\u0026gt; { void who() { cout \u0026lt;\u0026lt; \u0026#34;dog\u0026#34; \u0026lt;\u0026lt; endl; } }; struct cat : animal\u0026lt;cat\u0026gt; { void who() { cout \u0026lt;\u0026lt; \u0026#34;cat\u0026#34; \u0026lt;\u0026lt; endl; } }; template \u0026lt;typename specific_animal\u0026gt; void who_am_i(animal\u0026lt;specific_animal\u0026gt; *animal) { animal-\u0026gt;who(); } who_am_i(new dog); // Prints `dog` who_am_i(new cat); // Prints `cat` We have not used virtual keyword \u0026amp; still achieved the functionality of polymorphism(more-specifically static polymorphism). I have written a separate article covering practical Examples of Curiously Recurring Template Pattern(CRTP). Passing `std` Container as C++ Template Argument If you wanted to accept anything and figure it out later, you could write: 1 2 3 4 5 template \u0026lt;typename C\u0026gt; void print_container(const C \u0026amp;container) { for (const auto \u0026amp;v : container) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } This naive way may fail if you pass anything other than standard container as other types may not have begin \u0026amp; end iterator. Passing std::vector to C++ Template Function Naive Way to Capture Container\u0026rsquo;s Value Type But let say, you want to pass container \u0026amp; want to work with container\u0026rsquo;s storage type also. You can do: 1 2 3 4 5 6 7 8 template\u0026lt; typename C, typename T = typename C::value_type \u0026gt; void print_container(const C \u0026amp;container) { for (const T \u0026amp;v : container) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } We can provide the second type parameter to our function that uses SFINAE to verify that the thing is actually a container. All standard containers have a member type named value_type which is the type of the thing inside the container. We sniff for that type, and if no such type exists, then SFINAE kicks in, and that overload is removed from consideration. Capturing Container\u0026rsquo;s Value Type Explicitly But what if you are passing vector class which doesn\u0026rsquo;t has value_type member? std::vector is defined as: 1 2 3 4 5 template\u0026lt; class T, class Allocator = std::allocator\u0026lt;T\u0026gt; \u0026gt; class vector; And you can capture two template arguments of std::vector container explicitly as: 1 2 3 4 5 6 7 8 9 template\u0026lt; template \u0026lt;typename, typename\u0026gt; class C, typename T, typename Allocator \u0026gt; void print_container(C\u0026lt;T, Allocator\u0026gt; container) { for (const T\u0026amp; v : container) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } Above template pattern would be same if you want pass container to class/struct/union. Passing Any Container to C++ Template Function You see if you pass any other containers to the above solution. It won\u0026rsquo;t work. So to make it generic we can use variadic template: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u0026lt; template \u0026lt;typename...\u0026gt; class C, typename... Args \u0026gt; void print_container(C\u0026lt;Args...\u0026gt; container) { for (const auto \u0026amp;v : container) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } vector\u0026lt;int\u0026gt; v{1, 2, 3, 4}; // takes total 2 template type argument print_container(v); set\u0026lt;int\u0026gt; s{1, 2, 3, 4}; // takes total 3 template type argument print_container(s); Passing Container-of-Container/2D-std::vector as C++ Template Argument This is the case of nested template i.e. template-template parameter. And there are the following solutions: Explicit \u0026amp; Complex Solution 1 2 3 4 5 6 7 8 9 10 11 template\u0026lt; template \u0026lt;typename, typename\u0026gt; class C1, template \u0026lt;typename, typename\u0026gt; class C2, typename Alloc_C1, typename Alloc_C2, typename T \u0026gt; void print_container(const C1\u0026lt;C2\u0026lt;T, Alloc_C2\u0026gt;, Alloc_C1\u0026gt; \u0026amp;container) { for (const C2\u0026lt;T, Alloc_C2\u0026gt; \u0026amp;container_in : container) for (const T \u0026amp;v : container_in) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } I know this is ugly, but seems more explicit. Neat Solution 1 2 3 4 5 6 7 8 9 10 template\u0026lt; typename T1, typename T2 = typename T1::value_type, typename T3 = typename T2::value_type \u0026gt; void print_container(const T1 \u0026amp;container) { for (const T2 \u0026amp;e : container) for (const T3 \u0026amp;x : e) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } As seen earlier including SFINAE. Generic Solution: Using Variadic Template 1 2 3 4 5 6 7 8 9 template\u0026lt; template \u0026lt;typename...\u0026gt; class C, typename... Args \u0026gt; void print_container(C\u0026lt;Args...\u0026gt; container) { for (const auto \u0026amp;container_2nd : container) for (const auto \u0026amp;v : container_2nd) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } This is our standard solution using the variadic template will work for a single container or any number of the nested container. Passing Function to Class Template Argument Passing class/struct/union to another class/struct/union as template argument is common thing. But passing function to class/struct/union as template argument is bit rare. But yes it\u0026rsquo;s possible indeed. Consider the Functional Decorator using a variadic class template. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Need partial specialization for this to work template \u0026lt;typename T\u0026gt; struct Logger; // Return type and argument list template \u0026lt;typename R, typename... Args\u0026gt; struct Logger\u0026lt;R(Args...)\u0026gt; { function\u0026lt;R(Args...)\u0026gt; m_func; string m_name; Logger(function\u0026lt;R(Args...)\u0026gt; f, const string \u0026amp;n) : m_func{f}, m_name{n} { } R operator()(Args... args) { cout \u0026lt;\u0026lt; \u0026#34;Entering \u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; R result = m_func(args...); cout \u0026lt;\u0026lt; \u0026#34;Exiting \u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; return result; } }; template \u0026lt;typename R, typename... Args\u0026gt; auto make_logger(R (*func)(Args...), const string \u0026amp;name) { return Logger\u0026lt;R(Args...)\u0026gt;(function\u0026lt;R(Args...)\u0026gt;(func), name); } double add(double a, double b) { return a + b; } int main() { auto logged_add = make_logger(add, \u0026#34;Add\u0026#34;); auto result = logged_add(2, 3); return EXIT_SUCCESS; } Above example may seem a bit complex to you at first sight. But if you have a clear understanding of variadic class temple then it won\u0026rsquo;t take more than 30 seconds to understand what\u0026rsquo;s going on here. Conclusion I hope I have covered most of the topics around C++ Template. And yes, this was a very long \u0026amp; intense article. But I bet you that if you do master the C++ template well, it will really give you an edge. And also open a door to sub-world of C++ i.e. template meta-programming.\nC++ Template: C++\u0026rsquo;s its own interpreted sub language\n","permalink":"https://vishalchovatiya.github.io/posts/c-template-a-quick-uptodate-look/","summary":"I know, it’s been a while since the last time I published something newbies-friendly on my blog. The main reason is that most of my readers are either experienced devs or from C background having modest C++ encounter. But while programming in C++ you need a completely different mindset as both C \u0026amp; C++ belongs to different programming paradigm. And I always strive to show them a better way of doing things in C++.","title":"C++ Template: A Quick UpToDate Look(C++11/14/17/20)"},{"content":"From C++11, std::tuple is an incredible expansion to Modern C++, that offers a fixed-size col­lec­tion of het­ero­ge­neous values. Un­for­tu­nately, tu­ples can be somewhat dubious to manage in a conventional fash­ion. But, subsequently released C++ stan­dard in­tro­duced a few fea­tures \u0026amp; helpers that greatly re­duce the nec­es­sary boil­er­plate. So, in this article, I will explain the variadic template in C++ with the help of unsophisticated tuple implementation. And also walks you through a tricky part of tuple i.e. loop through tuple element. In spite of the fact that I have shrouded the variadic template in my prior article i.e. C++ Template: A Quick UpToDate Look. So, my focus here would be a blend of variadic template \u0026amp; tuple implementation with more up to date C++ gauges.\nMotivation It is often useful to define class/struct/union/function that accepts a variable number and type of arguments. If you have already used C you\u0026rsquo;ll know that printf function can accept any number of arguments. Such functions are entirely implemented through macros or ellipses operator. And because of that it has several disadvantages like type-safety, cannot accept references as arguments, etc. Variadic Class Template: Implementing Tuple Class So, let\u0026rsquo;s build our own ADT same as [`std::tuple`](https://en.cppreference.com/w/cpp/utility/tuple) with the help of variadic template. The variadic template in C++ usually starts with the general (empty) definition, that also serves as the base-case for template recursion termination in the later specialisation: 1 2 template \u0026lt;typename... T\u0026gt; struct Tuple { }; This already allows us to define an empty structure i.e. Tuple\u0026lt;\u0026gt; object;, albeit that isn\u0026rsquo;t very useful yet. Next comes the recursive case specialisation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt; typename T, typename... Rest // Template parameter pack \u0026gt; struct Tuple\u0026lt;T, Rest...\u0026gt; { // Class parameter pack T first; Tuple\u0026lt;Rest...\u0026gt; rest; // Parameter pack expansion Tuple(const T\u0026amp; f, const Rest\u0026amp; ... r) : first(f) , rest(r...) { } }; Tuple\u0026lt;bool\u0026gt; t1(false); // Case 1 Tuple\u0026lt;int, char, string\u0026gt; t2(1, \u0026#39;a\u0026#39;, \u0026#34;ABC\u0026#34;); // Case 2 How Does Variadic Class Template Works? To understand variadic class template, consider use case 2 above i.e. Tuple\u0026lt;int, char, string\u0026gt; t2(1, 'a', \u0026quot;ABC\u0026quot;);\nThe declaration first matches against the specialization, yielding a structure with int first; and Tuple\u0026lt;char, string\u0026gt; rest; data members. The rest definition again matches with specialization, yielding a structure with char first; and Tuple\u0026lt;string\u0026gt; rest; data members. The rest definition again matches this specialization, creating its own string first; and Tuple\u0026lt;\u0026gt; rest; members. Finally, this last rest matches against the base-case definition, producing an empty structure. You can visualize this as follows:\n1 2 3 4 5 6 7 8 Tuple\u0026lt;int, char, string\u0026gt; -\u0026gt; int first -\u0026gt; Tuple\u0026lt;char, string\u0026gt; rest -\u0026gt; char first -\u0026gt; Tuple\u0026lt;string\u0026gt; rest -\u0026gt; string first -\u0026gt; Tuple\u0026lt;\u0026gt; rest -\u0026gt; (empty) Variadic Function Template: Implementing get\u0026lt;\u0026gt;() Function for Tuple Class So far we have designed data structure with variable number and type of data members. But still, it isn\u0026rsquo;t useful as there is no mechanism to retrieve data from our Tuple class. So let\u0026rsquo;s design one: 1 2 3 4 5 6 7 8 template\u0026lt; size_t idx, template \u0026lt;typename...\u0026gt; class Tuple, typename... Args \u0026gt; auto get(Tuple\u0026lt;Args...\u0026gt; \u0026amp;t) { return GetHelper\u0026lt;idx, Tuple\u0026lt;Args...\u0026gt;\u0026gt;::get(t); } As you can see this get function is templatized on the idx. So usage can be like get\u0026lt;1\u0026gt;(t), similar to std::tuple. Though, the actual work is done by a static function in a helper class i.e. GetHelper. Note also the use of a C++14-style auto return type that makes our lives significantly simpler as otherwise, we would need quite a complicated expression for the return type. So on to the helper class. This time we will need an empty forward declaration and two specializations. First the empty declaration: 1 2 3 4 5 template\u0026lt; size_t idx, typename T \u0026gt; struct GetHelper; Now the base-case (when idx==0). In this specialisation, we just return the first member: 1 2 3 4 5 6 7 8 9 template\u0026lt; typename T, typename... Rest \u0026gt; struct GetHelper\u0026lt;0, Tuple\u0026lt;T, Rest...\u0026gt;\u0026gt; { static T get(Tuple\u0026lt;T, Rest...\u0026gt; \u0026amp;data) { return data.first; } }; In the recursive case, we decrement idx and invoke the GetHelper for the rest member: 1 2 3 4 5 6 7 8 9 10 template\u0026lt; size_t idx, typename T, typename... Rest \u0026gt; struct GetHelper\u0026lt;idx, Tuple\u0026lt;T, Rest...\u0026gt;\u0026gt; { static auto get(Tuple\u0026lt;T, Rest...\u0026gt; \u0026amp;data) { return GetHelper\u0026lt;idx - 1, Tuple\u0026lt;Rest...\u0026gt;\u0026gt;::get(data.rest); } }; To work through an example, suppose we have Tuple data and we need `get\u0026lt;1\u0026gt;(data). This invokes `GetHelper\u0026lt;1, Tuple\u0026lt;T, Rest\u0026hellip;\u0026raquo;\u0026gt;::get(data) (the 2nd specialization). Which in turn invokes `GetHelper\u0026lt;0, Tuple\u0026lt;T, Rest\u0026hellip;\u0026raquo;\u0026gt;::get(data.rest). And finally returns (by the 1st specialization as now idx is 0) data.rest.first. So that\u0026rsquo;s it! Here is the whole functioning code, with some example use in the main function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // Forward Declaration \u0026amp; Base Case ----------------------------------------- template\u0026lt; size_t idx, typename T \u0026gt; struct GetHelper { }; template \u0026lt;typename... T\u0026gt; struct Tuple { }; // ------------------------------------------------------------------------- // GetHelper --------------------------------------------------------------- template\u0026lt; typename T, typename... Rest \u0026gt; struct GetHelper\u0026lt;0, Tuple\u0026lt;T, Rest...\u0026gt;\u0026gt; { // Specialization for index 0 static T get(Tuple\u0026lt;T, Rest...\u0026gt; \u0026amp;data) { return data.first; } }; template\u0026lt; size_t idx, typename T, typename... Rest \u0026gt; struct GetHelper\u0026lt;idx, Tuple\u0026lt;T, Rest...\u0026gt;\u0026gt; { // GetHelper Implementation static auto get(Tuple\u0026lt;T, Rest...\u0026gt; \u0026amp;data) { return GetHelper\u0026lt;idx - 1, Tuple\u0026lt;Rest...\u0026gt;\u0026gt;::get(data.rest); } }; // ------------------------------------------------------------------------- // Tuple Implementation ---------------------------------------------------- template\u0026lt; typename T, typename... Rest \u0026gt; struct Tuple\u0026lt;T, Rest...\u0026gt; { T first; Tuple\u0026lt;Rest...\u0026gt; rest; Tuple(const T \u0026amp;f, const Rest \u0026amp;... r) : first(f) , rest(r...) { } }; // ------------------------------------------------------------------------- // get Implementation ------------------------------------------------------ template\u0026lt; size_t idx, template \u0026lt;typename...\u0026gt; class Tuple, typename... Args \u0026gt; auto get(Tuple\u0026lt;Args...\u0026gt; \u0026amp;t) { return GetHelper\u0026lt;idx, Tuple\u0026lt;Args...\u0026gt;\u0026gt;::get(t); } // ------------------------------------------------------------------------- int main() { Tuple\u0026lt;int, char, string\u0026gt; t(500, \u0026#39;a\u0026#39;, \u0026#34;ABC\u0026#34;); cout \u0026lt;\u0026lt; get\u0026lt;1\u0026gt;(t) \u0026lt;\u0026lt; endl; return 0; } Variadic Template vs Fold Expression There is two way to process C++ parameter pack i.e. Recursion Fold Expression(From C++17) At whatever point conceivable, we should process a parameter pack with fold expression instead of using recursion. Because it has some benefits as: Less code to write Faster code (without optimizations), as you just have a single expression instead of multiple function calls Faster to compile, as you deal with fewer template instantiation Processing a Parameter Pack With Recursion As we have seen earlier, variadic template starts with empty definition i.e. base case for recursion. 1 void print() {} Then the recursive case specialisation: 1 2 3 4 5 6 7 8 template\u0026lt; typename First, typename... Rest // Template parameter pack \u0026gt; void print(First first, Rest... rest) { // Function parameter pack cout \u0026lt;\u0026lt; first \u0026lt;\u0026lt; endl; print(rest...); // Parameter pack expansion } This is now sufficient for us to use the print function with variable number and type of arguments. For example: 1 print(500, \u0026#39;a\u0026#39;, \u0026#34;ABC\u0026#34;); Processing a Parameter Pack With Fold Expression 1 2 3 4 template \u0026lt;typename... Args\u0026gt; void print(Args... args) { (void(cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; endl), ...); } See, no cryptic boilerplate required. Isn’t this solution looks neater? There are total 3 types of folding: Unary fold, Binary fold \u0026amp; Fold over a comma. Here we have done left folding over a comma. You can read more about Fold Expression here. Loop-Through/Iterate Over Tuple Elements in C++ If I give you a task to print the elements of tuple, the first thing that comes to your mind is: 1 2 3 4 5 template \u0026lt;typename... Args\u0026gt; void print(const std::tuple\u0026lt;Args...\u0026gt; \u0026amp;t) { for (const auto \u0026amp;elem : t) // Error: no begin/end iterator cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; endl; } But, this just can\u0026rsquo;t work. std::tuple doesn\u0026rsquo;t have begin \u0026amp; end iterator. OK! So, now you might try raw loop right? 1 2 3 4 5 template \u0026lt;typename... Args\u0026gt; void print(const std::tuple\u0026lt;Args...\u0026gt;\u0026amp; t) { for (int i = 0; i \u0026lt; sizeof...(Args); ++i) cout \u0026lt;\u0026lt; std::get\u0026lt;i\u0026gt;(t) \u0026lt;\u0026lt; endl; // Error :( , `i` needs to be compile time constant } No! you can\u0026rsquo;t. I know that std::get\u0026lt;\u0026gt; works with a number as non-type template argument. But, that number has to be compile-time constant to make this working. So there are many solutions \u0026amp; we will go through quite enough ones. C++11: Loop Through Tuple Elements 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Template recursion template \u0026lt;size_t i, typename... Args\u0026gt; struct printer { static void print(const tuple\u0026lt;Args...\u0026gt; \u0026amp;t) { cout \u0026lt;\u0026lt; get\u0026lt;i\u0026gt;(t) \u0026lt;\u0026lt; endl; printer\u0026lt;i + 1, Args...\u0026gt;::print(t); } }; // Terminating template specialisation template \u0026lt;typename... Args\u0026gt; struct printer\u0026lt;sizeof...(Args), Args...\u0026gt; { static void print(const tuple\u0026lt;Args...\u0026gt; \u0026amp;) {} }; template \u0026lt;typename... Args\u0026gt; void print(const tuple\u0026lt;Args...\u0026gt; \u0026amp;t) { printer\u0026lt;0, Args...\u0026gt;::print(t); } tuple\u0026lt;int, char, string\u0026gt; t(1, \u0026#39;A\u0026#39;, \u0026#34;ABC\u0026#34;); print(t); // Note: might not work in GCC, I\u0026#39;ve used clang This isn\u0026rsquo;t that complicated as it looks, believe me. If you know recursion \u0026amp; template specialisation, it won\u0026rsquo;t take you more than 30 seconds to figure out what\u0026rsquo;s going on here. For our example tuple\u0026lt;int, char, string\u0026gt; t(1, 'A', \u0026quot;ABC\u0026quot;);, printer::print()calls template recursion i,e, template\u0026lt;size_t i, typename… Args\u0026gt; struct printer{}; each time with incremented non-type template parameter i. And when i == sizeof…(Args), our recusion stops by calling template specialization i.e. template\u0026lt;typename… Args\u0026gt; struct printer\u0026lt;sizeof…(Args), Args…\u0026gt; { };. C++17: Loop Through Tuple Elements With C++ 17, it\u0026rsquo;s slightly better because we have Fold Expressions. So, we don\u0026rsquo;t need recursion any more. 1 2 3 4 5 6 template \u0026lt;typename... Args\u0026gt; void print(const std::tuple\u0026lt;Args...\u0026gt; \u0026amp;t) { std::apply([](const auto \u0026amp;... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; endl), ...); }, t); } std::apply designed as tuple helper that accepts functor or lambda expression. Though you can do better if wants to dispatch to different implementation according to type, you might use overloaded class as: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;class... Ts\u0026gt; struct overloaded : Ts... { using Ts::operator()...; }; // Deduction guide, google `CTAD for aggregates` for more info template \u0026lt;class... Ts\u0026gt; overloaded(Ts...) -\u0026gt; overloaded\u0026lt;Ts...\u0026gt;; // not needed from C++20 auto f = overloaded { [](const int \u0026amp;a) { cout \u0026lt;\u0026lt; \u0026#34;From int: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; }, [](const char \u0026amp;b) { cout \u0026lt;\u0026lt; \u0026#34;From char: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; }, [](const string \u0026amp;c) { cout \u0026lt;\u0026lt; \u0026#34;From string: \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; }, }; tuple\u0026lt;int, char, string\u0026gt; t(1, \u0026#39;A\u0026#39;, \u0026#34;ABC\u0026#34;); std::apply([\u0026amp;](const auto \u0026amp;... e) { (f(e), ...); }, t); C++23: Loop Through Tuple Elements 1 2 3 4 5 template \u0026lt;typename... Args\u0026gt; void print(const std::tuple\u0026lt;Args...\u0026gt; \u0026amp;t) { for... (const auto \u0026amp;elem : t) cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; endl; } So, from C++23 we might have expansion statement i.e. for...() That looks like a loop, though it isn\u0026rsquo;t. It just stencil out each call with scope as: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename... Args\u0026gt; void print(const tuple\u0026lt;Args...\u0026gt; \u0026amp;t) { { const auto \u0026amp;elem = get\u0026lt;0\u0026gt;(t); cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; endl; } { const auto \u0026amp;elem = get\u0026lt;1\u0026gt;(t); cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; endl; } { const auto \u0026amp;elem = get\u0026lt;2\u0026gt;(t); cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; endl; } } And it is obvious that there is no break \u0026amp; continue as it isn\u0026rsquo;t loop. It basically works for every standard container which can access by std::get\u0026lt;\u0026gt;() For example, a plain array, std::tuple, std::pair, std::array, unexpanded argument packs, constexpr ranges, etc. Closing Words There are still many things missing in our tuple class like copy constructor, move constructors, some operators and helper classes(like std::tuple_size). But I hope now you get the idea of how it can be implemented using the variadic template. By the way, implementing those missing things will be a good start for learning variadic template on your own.\n","permalink":"https://vishalchovatiya.github.io/posts/variadic-template-cpp-implementing-unsophisticated-tuple/","summary":"From C++11, std::tuple is an incredible expansion to Modern C++, that offers a fixed-size col­lec­tion of het­ero­ge­neous values. Un­for­tu­nately, tu­ples can be somewhat dubious to manage in a conventional fash­ion. But, subsequently released C++ stan­dard in­tro­duced a few fea­tures \u0026amp; helpers that greatly re­duce the nec­es­sary boil­er­plate. So, in this article, I will explain the variadic template in C++ with the help of unsophisticated tuple implementation. And also walks you through a tricky part of tuple i.","title":"Variadic Template C++: Implementing Unsophisticated Tuple"},{"content":"In the embedded systems/SoCs, Watchdog Timer(WDT) is the basic, subtle and essential circuit/ic. No matter, how good you write your firmware/software. There are always unexpected situations like your program may stick in an infinite loop, hung somewhere or hardware burn-out/failure. To combat these unexpected situations, we need some circuitry that keeps monitoring the main system/application and in case of unexpected events, it restarts the system. Even the windows-like operating system use the watchdog timer. But with more sophisticated software \u0026amp; hardware i.e. window’s Blue Screen of Death (BSoD).\nWDT comes as an integral part of Microcontrollers/SoCs or you may also get it as a separate chip.\nWhat Is Watchdog Timer? A Watchdog Timer(WDT) is a piece of hardware that uses to automatically detect software anomalies. And reset the processor if any occur. Generally speaking, a watchdog timer is kind of timer/counter that counts down from some preset value to zero. The embedded software selects the counter\u0026rsquo;s initial value and periodically restarts the timer before it reaches zero. If WDT reaches to zero, software presumes to malfunction. And the processor\u0026rsquo;s reset signal asserted. The processor will restart as if a human operator had cycled the power. Block Diagram Above figure shows a typical arrangement of external WDT to CPU. Depending upon vendors \u0026amp; types, Watchdog Timer has numbers of CPU programmable memory-mapped registers. CPU receives the reset signal from WDT to identify the timeout condition. There could be many other interfaces as well(depending upon microcontroller or chip vendor) but I have taken a minimalistic example to show boiled down interfacing. Programming Procedure Although this is a subjective matter as there are many SoCs in the market and they use a different type of watchdog timer but the overall concept is the same more or less. Following is a general procedure to program the WDT: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const uint32_t timeout_cnt = 0x12345678; main() { hw_init(); wdt_init(timeout_cnt); for (;;) { extract_data_from_sensors(); // task 1: may take 800 micro-seconds handle_motor_control(); // task 2: may take 6 milli-seconds display_status(); // task 3: may take 2 milli-seconds // ... some other tasks re_set_wdt(); // set timeout of 8 milli-seconds approximately } } In bare-metal software, we generally have a single main loop comprising of all the tasks \u0026amp; we simply put the watchdog reset mechanism at the end of this loop as you can see above. But before reset mechanism kick-in, we have to initialize WDT register related to control, tick count, etc with proper values which usually carried out in hardware initialization phase or in the start-up of application. Calculation of tick count includes Approximate time consumed by all the tasks Plus some buffer amount of time(for speed variation due to other parameters like temperature, etc). On top of this, WDT count register value(i.e. tick count) decided with the help of WDT input frequency(and Prescaler if used any). How Does Watchdog Timer Work? As I said earlier, WDT is basically a timer. So it keeps counting down till zero. As long as all the tasks completed in approximate precomputed time before tick count reaches zero. WDT repeatedly reinitialize with tick count at the end of the loop(as shown in the code snippet above). But in some unexpected situations, there might be chances that some task stuck, hangs or taking a longer time than usual. In such cases timer expires(means tick count reaches to zero) \u0026amp; reset signal asserts to CPU. CPU resets(as like you just power-on) and your code again start executing from main(precisely program counter set to starting of 1st instruction of your code). Although, this is not necessarily true that the reset signal directly driven to CPU. Because in most of the complex(or I would say advanced) embedded systems which have multicore \u0026amp; separate reset/fault management unit. There has an interconnect circuitry to route this kind of signals to appropriate CPU or reset/fault management block to check criticality state of the system before to reset it. Issue With Traditional Watchdog Timer Older/normal watchdogs are only watching upon overrun condition like some task taking longer time, hangs, stuck, etc. But what if some component detached from the system, burn-out or giving false results without process or doing anything meaningful. In such cases, your watchdog timer will keep resetting too frequently. This is also underrun \u0026amp; an error-prone scenario that should be checked too. And hence the Window Watchdog Timer: Window Watchdog Timer Window Watchdog Timer not only checks for overrunning. But also look upon underrun condition with the help of two tick count registers rather than one. Start/Low tick count register used to measure start point of window \u0026amp; End/Low used to measure the endpoint of the window. If all the task complete within this(marked in green above) time frame/window then only WDT re-sets. Otherwise, it asserts the reset signal. See this microchip or maxim’s WWDT for example. Summary What is a watchdog timer(WDT)?\nA watchdog timer is a fail-safe hardware mechanism that resets the microcontroller when its timer expires/reaches-zero.\nHow does watchdog timer work?\nWatchdog timer keeps counting down till zero. As long as all the tasks completed in approximate precomputed time before tick count reaches zero. WDT repeatedly reinitialize with tick count at the end of the loop(as shown in the code snippet example above). If it reaches zero, software presumes to malfunction. And the processor’s reset signal asserted. What is the purpose/function/application of the watchdog timer?\nWatchdog timer prevents software malfunction \u0026amp; provide soft real-time behaviour for embedded systems/SoC.\nWatchdog timer role in modern embedded systems/SoCs?\nWatchdog timers in modern embedded systems/SoCs are way more complex than they have to be in earlier days:\nHave Prescaler to divide clock to increase tick count period, Also, use window mode as we discussed above, Uses more than one reset signal to indicate the type of fault to CPU/fault-generator, Able to detect sleep mode of CPUs to shut down its operation, Also tracks the state of system SFRs, May have an interface to Power-On Reset (POR), Brown Out Reset (BOR), Low Power Brown Out Reset (LPBOR, etc) for some advanced functionality. ","permalink":"https://vishalchovatiya.github.io/posts/watchdog-timer/","summary":"In the embedded systems/SoCs, Watchdog Timer(WDT) is the basic, subtle and essential circuit/ic. No matter, how good you write your firmware/software. There are always unexpected situations like your program may stick in an infinite loop, hung somewhere or hardware burn-out/failure. To combat these unexpected situations, we need some circuitry that keeps monitoring the main system/application and in case of unexpected events, it restarts the system. Even the windows-like operating system use the watchdog timer.","title":"Watchdog Timer(WDT) \u0026 Window Watchdog Timer(WWDT)"},{"content":"Double Dispatch in C++ is a mechanism that dispatches a function call to different concrete functions depending on the runtime types of two objects involved in the call. In more simple words, its function calling using two different virtual tables of respective two objects. I know this sounds cryptic, but don\u0026rsquo;t worry I will come to double dispatch solution after trying most of the naive solution so that you will come away with the full understanding of concept without having needless confusions.\nMotivation At first, a pointer to a base class made sense; you didn’t need to know the actual derived class. So you decided to expose a single collection of base class pointers to your clients like so: 1 2 3 4 5 struct Animal { virtual const char *name() = 0; }; using AnimalList = vector\u0026lt;Animal*\u0026gt;; As you added your first few classes, your assumptions were validated; you never needed to know the actual type. 1 2 3 4 5 6 7 struct Cat : Animal { const char *name() { return \u0026#34;Cat\u0026#34;; } }; struct Dog : Animal { const char *name() { return \u0026#34;Dog\u0026#34;; } }; But the requirements change. One day the client came to you and said \u0026ldquo;I’m trying to model a person that is afraid of dogs, so they run away when they see one. But they love cats, so they try to pet them when they see them.\u0026rdquo; Dammit. Now your assumptions are wrong. You do need to know the type. And you’re under pressure to meet a deadline. Run-Time Type Identification Then you thought \u0026ldquo;Well there’s only two types of animals, this isn’t so bad\u0026rdquo;. So you wrote code like this: 1 2 3 4 5 6 7 8 9 10 11 struct Person { void ReactTo(Animal *_animal) { if (dynamic_cast\u0026lt;Dog *\u0026gt;(_animal)) RunAwayFrom(_animal); else if (dynamic_cast\u0026lt;Cat *\u0026gt;(_animal)) TryToPet(_animal); } void RunAwayFrom(Animal *_animal) { cout \u0026lt;\u0026lt; \u0026#34;Run Away From \u0026#34; \u0026lt;\u0026lt; _animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } void TryToPet(Animal *_animal) { cout \u0026lt;\u0026lt; \u0026#34;Try To Pet \u0026#34; \u0026lt;\u0026lt; _animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } }; Then the client said that if the Animal was a Horse, they wanted to try to ride it. 1 2 3 4 5 6 7 8 void Person::ReactTo(Animal *_animal) { if (dynamic_cast\u0026lt;Dog *\u0026gt;(_animal)) RunAwayFrom(_animal); else if (dynamic_cast\u0026lt;Cat *\u0026gt;(_animal)) TryToPet(_animal); else if (dynamic_cast\u0026lt;Horse *\u0026gt;(_animal)) TryToRide(_animal); } You see this is going crazy. At some point in future, you might not like working with your own code. We\u0026rsquo;ve all been there. Nonetheless, the trend continued for some time until you may found yourself with a mess like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Person::ReactTo(Animal *_animal) { if (dynamic_cast\u0026lt;Dog *\u0026gt;(_animal) || dynamic_cast\u0026lt;Gerbil *\u0026gt;(_animal)) { if (dynamic_cast\u0026lt;Dog *\u0026gt;(_animal) \u0026amp;\u0026amp; dynamic_cast\u0026lt;Dog\u0026gt;()-\u0026gt;GetBreed() == DogBreed.Daschund) // Daschund\u0026#39;s are the exception TryToPet(_animal); else RunAwayFrom(_animal); } else if (dynamic_cast\u0026lt;Cat *\u0026gt;(_animal) || dynamic_cast\u0026lt;Pig *\u0026gt;(_animal)) TryToPet(_animal); else if (dynamic_cast\u0026lt;Horse *\u0026gt;(_animal)) TryToRide(_animal); else if (dynamic_cast\u0026lt;Lizard *\u0026gt;(_animal)) TryToFeed(_animal); else if (dynamic_cast\u0026lt;Mole *\u0026gt;(_animal)) Attack(_animal) // etc. } This list is getting pretty long, you thought to yourself one day. All these dynamic_cast\u0026lt;\u0026gt;() seem wrong, and they\u0026rsquo;re kind of slow as well. So on a side note of refactorization, you come up with a solution which identifies typeid(), this is a bit faster than dynamic_cast\u0026lt;\u0026gt;() but still, it\u0026rsquo;s not optimum performance. Exploiting Polymorphism As someone from your senior/mentor suggests you to use an enum with polymorphic methods to identify type \u0026amp; you wrote following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 enum class AnimalType { Dog, Cat }; struct Animal { virtual const char *name() = 0; virtual AnimalType type() = 0; }; struct Cat : Animal { const char *name() { return \u0026#34;Cat\u0026#34;; } AnimalType type() { return AnimalType::Cat; } }; struct Dog : Animal { const char *name() { return \u0026#34;Dog\u0026#34;; } AnimalType type() { return AnimalType::Dog; } }; struct Person { void ReactTo(Animal *_animal) { if (_animal-\u0026gt;type() == AnimalType::Cat) TryToPet(_animal); else if (_animal-\u0026gt;type() == AnimalType::Dog) RunAwayFrom(_animal); } void RunAwayFrom(Animal *_animal) { cout \u0026lt;\u0026lt; \u0026#34;Run Away From \u0026#34; \u0026lt;\u0026lt; _animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } void TryToPet(Animal *_animal) { cout \u0026lt;\u0026lt; \u0026#34;Try To Pet \u0026#34; \u0026lt;\u0026lt; _animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } }; int main() { Person p; Animal *animal_0 = new Dog; p.ReactTo(animal_0); Animal *animal_1 = new Cat; p.ReactTo(animal_1); return 0; } You may get the performance improvement, but still, you will be left with a long list of if/else-if. More Functional \u0026amp; Modular Approach 1 2 3 4 5 6 7 8 9 10 11 12 13 using PersonMethodPtr = void (Person::*)(Animal *); using ReactionHash = unordered_map\u0026lt;AnimalType, PersonMethodPtr\u0026gt;; void Person::ReactTo(Animal *_animal) { static const ReactionHash reactionFunctions{ {AnimalType::Cat, \u0026amp;TryToPet}, {AnimalType::Dog, \u0026amp;RunAwayFrom}, // etc. }; reactionFunctions[_animal-\u0026gt;type()](_animal); } But here you are indirectly writing your own virtual table(a very bad virtual table) which may not provide any performance gain at all, thanks to the overhead of hashing \u0026amp; lookup. Moreover, you are paying a little extra in memory to store your lookup table. Single-Dispatch So rather than keeping any identifier for each type or RTTI, we can use a middle man to route function call to appropriate behaviour. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 struct Animal { virtual string name() = 0; virtual void Visit(class ReactVisitor *visitor) = 0; }; struct ReactVisitor { class Person *person = nullptr; }; struct Person { void ReactTo(Animal *_animal) { ReactVisitor visitor{this}; _animal-\u0026gt;Visit(\u0026amp;visitor); } void RunAwayFrom(Animal *_animal) { cout \u0026lt;\u0026lt; \u0026#34;Run Away From \u0026#34; \u0026lt;\u0026lt; _animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } void TryToPet(Animal *_animal) { cout \u0026lt;\u0026lt; \u0026#34;Try To Pet \u0026#34; \u0026lt;\u0026lt; _animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } }; struct Cat : public Animal { string name() { return \u0026#34;Cat\u0026#34;; } void Visit(ReactVisitor *visitor) { visitor-\u0026gt;person-\u0026gt;TryToPet(this); } }; struct Dog : public Animal { string name() { return \u0026#34;Dog\u0026#34;; } void Visit(ReactVisitor *visitor) { visitor-\u0026gt;person-\u0026gt;RunAwayFrom(this); } }; int main() { Person p; vector\u0026lt;Animal*\u0026gt; animals = {new Dog, new Cat}; for(auto\u0026amp;\u0026amp; animal : animals) p.ReactTo(animal); return 0; } To keep the middle man to a route function call, we have to add visit(ReactVisitor *) method which accepts middle man i.e. ReactVisitor as a parameter. Then we add appropriate behaviour to each type of Animal i.e. Dog \u0026amp; Cat. Problems With the Single Dispatch Approach Why should the Dog class dictate how a Person reacts to it? We have leaked implementation details of the Person class and therefore have violated encapsulation. What if the Person class has other behaviours they want to implement? Are we really going to add a new virtual method on the base class for each of them? The solution to the above problem will lead us to use Double-Dispatch Mechanism.\nDouble Dispatch in C++ We can overcome the shortcoming of Single-Dispatch by adding one more layer of indirection(i.e. AnimalVisitor). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* -------------------------------- Added Visitor Classes ------------------------------- */ struct AnimalVisitor { virtual void Visit(struct Cat *) = 0; virtual void Visit(struct Dog *) = 0; }; struct ReactVisitor : AnimalVisitor { ReactVisitor(struct Person *p) : person{p} {} void Visit(struct Cat *c); void Visit(struct Dog *d); struct Person *person = nullptr; }; /* --------------------------------------------------------------------------------------- */ struct Animal { virtual string name() = 0; virtual void Visit(struct AnimalVisitor *visitor) = 0; }; struct Cat : Animal { string name() { return \u0026#34;Cat\u0026#34;; } void Visit(AnimalVisitor *visitor) { visitor-\u0026gt;Visit(this); } // 2nd dispatch \u0026lt;\u0026lt;--------- }; struct Dog : Animal { string name() { return \u0026#34;Dog\u0026#34;; } void Visit(AnimalVisitor *visitor) { visitor-\u0026gt;Visit(this); } // 2nd dispatch \u0026lt;\u0026lt;--------- }; struct Person { void ReactTo(Animal *_animal) { ReactVisitor visitor{this}; _animal-\u0026gt;Visit(\u0026amp;visitor); // 1st dispatch \u0026lt;\u0026lt;--------- } void RunAwayFrom(Animal *_animal) { cout \u0026lt;\u0026lt; \u0026#34;Run Away From \u0026#34; \u0026lt;\u0026lt; _animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } void TryToPet(Animal *_animal) { cout \u0026lt;\u0026lt; \u0026#34;Try To Pet \u0026#34; \u0026lt;\u0026lt; _animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } }; /* -------------------------------- Added Visitor Methods ------------------------------- */ void ReactVisitor::Visit(Cat *c) { // Finally comes here \u0026lt;\u0026lt;------------- person-\u0026gt;TryToPet(c); } void ReactVisitor::Visit(Dog *d) { // Finally comes here \u0026lt;\u0026lt;------------- person-\u0026gt;RunAwayFrom(d); } /* --------------------------------------------------------------------------------------- */ int main() { Person p; for(auto\u0026amp;\u0026amp; animal : vector\u0026lt;Animal*\u0026gt;{new Dog, new Cat}) p.ReactTo(animal); return 0; } As you can see above, rather depending directly on ReactVisitor, we have taken AnimalVisitor as one more layer of indirection. And visit(AnimalVisitor *) method in Cat \u0026amp; Dog class accept AnimalVisitor as a parameter. This gives us two benefits, i). we do not have to write person\u0026rsquo;s behaviour in Cat \u0026amp; Dog class, so we are not breaking the rule of encapsulation, and ii). we are clubbing the reaction of Person in a separate class(i.e. ReactVisitor), so we are encouraging the Single Responsibility Principle. How does Double Dispatch Mechanism work? I know so things are getting complex, but it is reasonably complex I would say. Function stack frame \u0026amp; single image of function calling chain with code snippet will simplify it a lot.\nFrom Person::ReactTo, we call Animal::visit, which will dispatch to the appropriate overridden visit i.e. either Cat::visit or Dog::visit. From the overridden Cat::visit(AnimalVisitor*), we call AnimalVisitor::visit, which will again dispatch to the appropriate overridden i.e. either ReactionVisitor::visit(Cat*) or ReactionVisitor::visit(Dog*)`. Alternate Approach to Double Dispatch in Modern C++ using std::variant \u0026amp; std::visit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct Animal { virtual string name() = 0; }; struct Cat : Animal { string name() { return \u0026#34;Cat\u0026#34;; } }; struct Dog : Animal { string name() { return \u0026#34;Dog\u0026#34;; } }; struct Person { void RunAwayFrom(Animal *animal) { cout \u0026lt;\u0026lt; \u0026#34;Run Away From \u0026#34; \u0026lt;\u0026lt; animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } void TryToPet(Animal *animal) { cout \u0026lt;\u0026lt; \u0026#34;Try To Pet \u0026#34; \u0026lt;\u0026lt; animal-\u0026gt;name() \u0026lt;\u0026lt; endl; } }; struct ReactVisitor { void operator()(Cat *c) { person-\u0026gt;TryToPet(c); } void operator()(Dog *d){ person-\u0026gt;RunAwayFrom(d); } Person *person = nullptr; }; using animal_ptr = std::variant\u0026lt;Cat*, Dog*\u0026gt;; int main() { Person p; ReactVisitor rv{\u0026amp;p}; for(auto\u0026amp;\u0026amp; animal : vector\u0026lt;animal_ptr\u0026gt;({new Dog, new Cat})) std::visit(rv, animal); return 0; } So for those of you who are not familiar with the std::variant, you can consider it as a union. And line std::variant\u0026lt;Cat*, Dog*\u0026gt;, suggest that you can use/assign/access either Cat* or Dog* at a time. And Modern C++ provide us std::visit which accept callable i.e. ReactVisitor in our case having overloaded function operator for each type and std::variant. You also make use of lambda functions rather using functor i.e. ReactVisitor. Benefits of Double Dispatch Mechanism Adhering Single Responsibility Principle meaning separating type-specific logic in the separate entity/class. In our case, ReactVisitor only handles the reaction for different Animal types. Adhering Open-Closed Principle meaning new functionality can be added without touching any class headers once we inserted visit() method for hierarchy, For example, if you want to add sound()method for each different Animal, you can create SoundVisitor \u0026amp; rest of the edit goes as same ReactVisitor. This will be much useful when you already have done the unit-testing for your entire hierarchy, and now you do not want to touch that \u0026amp; wants to add new functionality. Performance over dynamic_cast, typeid()and check for enum/string comparison. Usecase of Double Dispatch Mechanism Sorting a mixed set of objects: You can implement filtering with double-dispatch. E.g., \u0026ldquo;Give me all theCats from a vector\u0026lt;Animal*\u0026gt;\u0026rdquo;. You can add additional functionality to the whole inheritance hierarchy without modifying it over \u0026amp; over E.g. if you want to add sound()method for each different Animal, you can create SoundVisitor \u0026amp; rest of the edit goes as same ReactVisitor. Event handling systems that use both the event type and the type of the receptor object in order to call the correct event handling routine. Adaptive collision algorithms usually require that collisions between different objects be handled in different ways. A typical example is in a game environment where the collision between a spaceship and an asteroid is computed differently from the collision between a spaceship and a space station. Conclusion Each solution has its advantages and issues, and choosing one depends on the exact needs of your project. C++ presents unique challenges in designing such high-level abstractions because it\u0026rsquo;s comparatively rigid and statically typed. Abstractions in C++ also tend to strive to be as cheap as possible in terms of runtime performance and memory consumption, which adds another dimension of complexity to the problem.\nReference This article becomes by-product while I was writing about classic Visitor Design Pattern because without double dispatch mechanism in C++ classic visitor doesn\u0026rsquo;t exist. Most of the credit for this article \u0026amp; images goes to Andy G. The code snippets you see in this article is simplified not sophisticated.\n","permalink":"https://vishalchovatiya.github.io/posts/double-dispatch-in-cpp/","summary":"Double Dispatch in C++ is a mechanism that dispatches a function call to different concrete functions depending on the runtime types of two objects involved in the call. In more simple words, its function calling using two different virtual tables of respective two objects. I know this sounds cryptic, but don\u0026rsquo;t worry I will come to double dispatch solution after trying most of the naive solution so that you will come away with the full understanding of concept without having needless confusions.","title":"Double Dispatch in C++: Recover Original Type of the Object Pointed by Base Class Pointer"},{"content":"So you know how to code in general, understand the object-oriented programming, learned C++, and completed at least one Software Development Course (if you’re not there yet, these articles aren\u0026rsquo;t for you). You can write software easily if you know at least one programming language, but is your code any good? Could it be done any better? Is it clean (and what on earth does that mean)? Is your architecture any good? Should you use a different one? What about Design Patterns? These were some of the questions I\u0026rsquo;ve had when I started, and answering them helped me to step up to a professional level. Which is why I have written these series SOLID as a Rock design principle. Liskov\u0026rsquo;s Substitution Principle in C++ is the second principle in this series which I will discuss here.\nBy the way, If you haven\u0026rsquo;t gone through my previous articles on design principles, then below is the quick links:\nSRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent Subtypes must be substitutable for their base types without altering the correctness of the program\nIf I address this in the context of C++, this literally means that functions that use pointers/references to base classes must be able to substitute by its derived classes. The Liskov Substitution Principle revolves around ensuring that inheritance is used correctly. Motivation: Violating the Liskov\u0026rsquo;s Substitution Principle A great \u0026amp; traditional example illustrating LSP was how sometimes something that sounds right in natural language doesn\u0026rsquo;t quite work in code. In mathematics, a Square is a Rectangle. Indeed it is a specialization of a rectangle. The \u0026ldquo;IS A\u0026rdquo; makes you want to model this with inheritance. However if in code you made Square derive from Rectangle, then a Square should be usable anywhere you expect a Rectangle. This makes for some strange behaviour as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct Rectangle { Rectangle(const uint32_t width, const uint32_t height) : m_width{width}, m_height{height} {} uint32_t get_width() const { return m_width; } uint32_t get_height() const { return m_height; } virtual void set_width(const uint32_t width) { this-\u0026gt;m_width = width; } virtual void set_height(const uint32_t height) { this-\u0026gt;m_height = height; } uint32_t area() const { return m_width * m_height; } protected: uint32_t m_width, m_height; }; struct Square : Rectangle { Square(uint32_t size) : Rectangle(size, size) {} void set_width(const uint32_t width) override { this-\u0026gt;m_width = m_height = width; } void set_height(const uint32_t height) override { this-\u0026gt;m_height = m_width = height; } }; void process(Rectangle \u0026amp;r) { uint32_t w = r.get_width(); r.set_height(10); assert((w * 10) == r.area()); // Fails for Square \u0026lt;-------------------- } int main() { Rectangle r{5, 5}; process(r); Square s{5}; process(s); return EXIT_SUCCESS; } As you can see above, we have violated Liskovs\u0026rsquo;s Substitution Principle in the void process(Rectangle \u0026amp;r) function. Therefore Square is not a valid substitute of Rectangle. If you see from the design perspective, the very idea of inheriting Square from Rectangle is not a good idea. Because Square does not have height \u0026amp; width, rather it has the size/length of sides. Solution: Example of Liskov\u0026rsquo;s Substitution Principle in C++ Not so good 1 2 3 4 5 6 7 8 9 void process(Rectangle \u0026amp;r) { uint32_t w = r.get_width(); r.set_height(10); if (dynamic_cast\u0026lt;Square *\u0026gt;(\u0026amp;r) != nullptr) assert((r.get_width() * r.get_width()) == r.area()); else assert((w * 10) == r.area()); } A common code smell that frequently indicates an LSP violation is the presence of type checking code within a code block that is polymorphic. For instance, if you have a std::for_each loop over a collection of objects of type Foo, and within this loop, there is a check to see if Foo is in fact Bar(a subtype of Foo), then this is almost certainly an LSP violation. Rather you should ensure Bar is in all ways substitutable for Foo, there should be no need to include such a check. An OK way to do it 1 2 3 4 5 6 7 8 9 void process(Rectangle \u0026amp;r) { uint32_t w = r.get_width(); r.set_height(10); if (r.is_square()) assert((r.get_width() * r.get_width()) == r.area()); else assert((w * 10) == r.area()); } No need to create a separate class for Square. Instead, you can simply check for bool flag within the Rectangle class to validate Square property. Though not a recommended way. Use proper inheritance hierarchy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct Shape { virtual uint32_t area() const = 0; }; struct Rectangle : Shape { Rectangle(const uint32_t width, const uint32_t height) : m_width{width}, m_height{height} {} uint32_t get_width() const { return m_width; } uint32_t get_height() const { return m_height; } virtual void set_width(const uint32_t width) { this-\u0026gt;m_width = width; } virtual void set_height(const uint32_t height) { this-\u0026gt;m_height = height; } uint32_t area() const override { return m_width * m_height; } private: uint32_t m_width, m_height; }; struct Square : Shape { Square(uint32_t size) : m_size(size) {} void set_size(const uint32_t size) { this-\u0026gt;m_size = size; } uint32_t area() const override { return m_size * m_size; } private: uint32_t m_size; }; void process(Shape \u0026amp;s) { // Use polymorphic behaviour only i.e. area() } With Factory Pattern Still, creation or change is needed to process Shape, then you should try to use Virtual Constructor \u0026amp; Virtual Copy Constructor i.e. Factory Pattern. 1 2 3 4 struct ShapeFactory { static Shape CreateRectangle(uint32_t width, uint32_t height); static Shape CreateSquare(uint32_t size); }; Benefits of Liskov\u0026rsquo;s Substitution Principle =\u0026gt; Compatibility It enables the binary compatibility between multiple releases \u0026amp; patches. In other words, It keeps the client code away from being impacted. =\u0026gt; Type Safety It\u0026rsquo;s the easiest approach to handle type safety with inheritance, as types are not allowed to vary when inheriting. =\u0026gt; Maintainability Code that adheres to LSP is loosely dependent on each other \u0026amp; encourages code reusability. Code that adheres to the LSP is code that makes the right abstractions. Yardstick to Craft Liskov\u0026rsquo;s Substitution Principle Friendly Software in C++ In most introductions to object-oriented programming, inheritance discussed as an \u0026ldquo;IS-A\u0026rdquo; relationship with the inherited object. However, this is necessary, but not sufficient. It is more appropriate to say that one object can be designed to inherit from another if it always has an \u0026ldquo;IS-SUBSTITUTABLE-FOR\u0026rdquo; relationship with the inherited object. The whole point of using an abstract base class is so that, in the future, you can write a new subclass \u0026amp; insert it into existing, working, tested code. A noble goal, but how to achieve it? First, start with decomposing your problem space \u0026mdash; domain. Second, express your contract/interfaces/virtual-methods in plain English. Closing Notes Don’t get me wrong, I like SOLID and the approaches it promotes. But it’s just a shape of deeper principles lying in its foundation. The examples above made it clear what this principle is striving for i.e. loose coupling \u0026amp; ensuring correct inheritance.\nNow, go out there and make your subclasses swappable, and thank Dr. Barbara Liskov for such a useful principle.\n","permalink":"https://vishalchovatiya.github.io/posts/liskovs-substitution-principle-in-cpp-solid-as-a-rock/","summary":"So you know how to code in general, understand the object-oriented programming, learned C++, and completed at least one Software Development Course (if you’re not there yet, these articles aren\u0026rsquo;t for you). You can write software easily if you know at least one programming language, but is your code any good? Could it be done any better? Is it clean (and what on earth does that mean)? Is your architecture any good?","title":"Liskov's Substitution Principle in C++ | SOLID as a Rock"},{"content":"This is the second part of a five-part article series about SOLID as Rock design principle. The SOLID design principles, when combined together, make it easy for a programmer to craft software that is easy to maintain, reuse \u0026amp; extend. Open-Closed Principle(OCP) is the second principle in this series which I will discuss here with minimalistic example in Modern C++ along with its benefits \u0026amp; generic guideline.\nBy the way, If you haven\u0026rsquo;t gone through my previous articles on design principles, then below is the quick links:\nSRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent classes should be open for extension, closed for modification\nThis literally means you should be able to extend a classes behaviour, without modifying it. This might seems weird to you \u0026amp; may raise a question that how can you change the behaviour of a class without modifying it? But there are many answers to this in object-oriented design like dynamic polymorphism, static polymorphism, C++ template, etc. Motivation: Violating the Open Closed Principle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 enum class COLOR { RED, GREEN, BLUE }; enum class SIZE { SMALL, MEDIUM, LARGE }; struct Product { string m_name; COLOR m_color; SIZE m_size; }; using Items = vector\u0026lt;Product*\u0026gt;; #define ALL(C) begin(C), end(C) struct ProductFilter { static Items by_color(Items items, const COLOR e_color) { Items result; for (auto \u0026amp;i : items) if (i-\u0026gt;m_color == e_color) result.push_back(i); return result; } static Items by_size(Items items, const SIZE e_size) { Items result; for (auto \u0026amp;i : items) if (i-\u0026gt;m_size == e_size) result.push_back(i); return result; } static Items by_size_and_color(Items items, const SIZE e_size, const COLOR e_color) { Items result; for (auto \u0026amp;i : items) if (i-\u0026gt;m_size == e_size \u0026amp;\u0026amp; i-\u0026gt;m_color == e_color) result.push_back(i); return result; } }; int main() { const Items all{ new Product{\u0026#34;Apple\u0026#34;, COLOR::GREEN, SIZE::SMALL}, new Product{\u0026#34;Tree\u0026#34;, COLOR::GREEN, SIZE::LARGE}, new Product{\u0026#34;House\u0026#34;, COLOR::BLUE, SIZE::LARGE}, }; for (auto \u0026amp;p : ProductFilter::by_color(all, COLOR::GREEN)) cout \u0026lt;\u0026lt; p-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; is green\\n\u0026#34;; for (auto \u0026amp;p : ProductFilter::by_size_and_color(all, SIZE::LARGE, COLOR::GREEN)) cout \u0026lt;\u0026lt; p-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; is green \u0026amp; large\\n\u0026#34;; return EXIT_SUCCESS; } /* Apple is green Tree is green Tree is green \u0026amp; large */ So we have a bunch of products \u0026amp; we filtered it by some of its attributes. There is nothing wrong with the above code as far as the requirement is fixed(which will never be the case in software engineering). But just imagine the situations: You already shipped the code to the client. Later on, requirement changes \u0026amp; some new filters are required. In this case, you again need to modify the class \u0026amp; add new filter methods. This is a problematic approach because we have 2 attributes(i.e. color \u0026amp; size) \u0026amp; need to implement 3 function(i.e. color, size \u0026amp; its combination), one more attributes \u0026amp; need to implement 8 functions. You see where this is going. You need to go again \u0026amp; again in the existing implemented code \u0026amp; have to modify it which may break other parts of code as well. This is not a scalable solution. The open-closed principle states that your system should be open to extension but should be closed for modification. Unfortunately what we are doing here is modifying the existing code which is a violation of OCP. Solution: Open Closed Principle Example in C++ There is more than one way to achieve OCP. Here I am demonstrating the popular one i.e. interface design or abstraction level. So here is our scalable solution:\nAdding the level of abstraction for extensibility 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template \u0026lt;typename T\u0026gt; struct Specification { virtual ~Specification() = default; virtual bool is_satisfied(T *item) const = 0; }; struct ColorSpecification : Specification\u0026lt;Product\u0026gt; { COLOR e_color; ColorSpecification(COLOR e_color) : e_color(e_color) {} bool is_satisfied(Product *item) const { return item-\u0026gt;m_color == e_color; } }; struct SizeSpecification : Specification\u0026lt;Product\u0026gt; { SIZE e_size; SizeSpecification(SIZE e_size) : e_size(e_size) {} bool is_satisfied(Product *item) const { return item-\u0026gt;m_size == e_size; } }; template \u0026lt;typename T\u0026gt; struct Filter { virtual vector\u0026lt;T *\u0026gt; filter(vector\u0026lt;T *\u0026gt; items, const Specification\u0026lt;T\u0026gt; \u0026amp;spec) = 0; }; struct BetterFilter : Filter\u0026lt;Product\u0026gt; { vector\u0026lt;Product *\u0026gt; filter(vector\u0026lt;Product *\u0026gt; items, const Specification\u0026lt;Product\u0026gt; \u0026amp;spec) { vector\u0026lt;Product *\u0026gt; result; for (auto \u0026amp;p : items) if (spec.is_satisfied(p)) result.push_back(p); return result; } }; // ------------------------------------------------------------------------------------------------ BetterFilter bf; for (auto \u0026amp;x : bf.filter(all, ColorSpecification(COLOR::GREEN))) cout \u0026lt;\u0026lt; x-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; is green\\n\u0026#34;; As you can see we do not have to modify filter method of BetterFilter. It can work with all kind of specification now. For two or more combined specifications 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;typename T\u0026gt; struct AndSpecification : Specification\u0026lt;T\u0026gt; { const Specification\u0026lt;T\u0026gt; \u0026amp;first; const Specification\u0026lt;T\u0026gt; \u0026amp;second; AndSpecification(const Specification\u0026lt;T\u0026gt; \u0026amp;first, const Specification\u0026lt;T\u0026gt; \u0026amp;second) : first(first), second(second) {} bool is_satisfied(T *item) const { return first.is_satisfied(item) \u0026amp;\u0026amp; second.is_satisfied(item); } }; template \u0026lt;typename T\u0026gt; AndSpecification\u0026lt;T\u0026gt; operator\u0026amp;\u0026amp;(const Specification\u0026lt;T\u0026gt; \u0026amp;first, const Specification\u0026lt;T\u0026gt; \u0026amp;second) { return {first, second}; } // ----------------------------------------------------------------------------------------------------- auto green_things = ColorSpecification{COLOR::GREEN}; auto large_things = SizeSpecification{SIZE::LARGE}; BetterFilter bf; for (auto \u0026amp;x : bf.filter(all, green_things \u0026amp;\u0026amp; large_things)) cout \u0026lt;\u0026lt; x-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; is green and large\\n\u0026#34;; // warning: the following will compile but will NOT work // auto spec2 = SizeSpecification{SIZE::LARGE} \u0026amp;\u0026amp; // ColorSpecification{COLOR::BLUE}; SizeSpecification{SIZE::LARGE} \u0026amp;\u0026amp; ColorSpecification{COLOR::BLUE} will not work. Experienced C++ eyes can easily recognize the reason. Though temporary object creation is a hint here. If you do so, you may get the error of pure virtual function as follows: 1 2 3 pure virtual method called terminate called without an active exception The terminal process terminated with exit code: 3 For more than two specifications, you can use a variadic template. Benefits of Open Closed Principle =\u0026gt; Extensibility \u0026ldquo;When a single change to a program results in a cascade of changes to dependent modules, that program exhibits the undesirable attributes that we have come to associate with \u0026lsquo;bad\u0026rsquo; design. The program becomes fragile, rigid, unpredictable and unreusable. The open-closed principle attacks this in a very straightforward way. It says that you should design modules that never change. When requirements change, you extend the behaviour of such modules by adding new code, not by changing old code that already works.\u0026rdquo;\n— Robert Martin\n=\u0026gt; Maintainability The main benefit of this approach is that an interface introduces an additional level of abstraction which enables loose coupling. The implementations of an interface are independent of each other and don’t need to share any code. Thus, you can easily cope-up with client\u0026rsquo;s keep changing requirements. Very useful in agile methodologies. =\u0026gt; Flexibility The open-closed principle also applies to plugin and middleware architecture. In that case, your base software entity is your application core functionality. In the case of plugins, you have a base or core module that can be plugged with new features \u0026amp; functionality through a common gateway interface. A good example of this is web browser extensions. Binary compatibility will also be in-tact in subsequent releases. Yardstick to Craft Open Closed Principle Friendly Software in C++ In the SRP, you make a judgement about decomposition and where to draw encapsulation boundaries in your code. In the OCP, you make a judgement about what in your module you will make abstract and leave to your module’s consumers to make concrete, and what concrete functionality to provide yourself. There are many design patterns that help us to extend code without changing it. For instance, the Decorator pattern helps us to follow Open Close principle. Also, the Factory Method, Strategy pattern or the Observer pattern might be used to design an application easy to change with minimum changes in the existing code. Conclusion Keep in mind that classes can never be completely closed. There will always be unforeseen changes which require a class to be modified. However, if changes can be foreseen, such as seen above i.e. filters, then you have a perfect opportunity to apply the OCP to be future-ready when those change requests come rolling in.\n","permalink":"https://vishalchovatiya.github.io/posts/open-closed-principle-in-cpp-solid-as-a-rock/","summary":"This is the second part of a five-part article series about SOLID as Rock design principle. The SOLID design principles, when combined together, make it easy for a programmer to craft software that is easy to maintain, reuse \u0026amp; extend. Open-Closed Principle(OCP) is the second principle in this series which I will discuss here with minimalistic example in Modern C++ along with its benefits \u0026amp; generic guideline.\nBy the way, If you haven\u0026rsquo;t gone through my previous articles on design principles, then below is the quick links:","title":"Open Closed Principle in C++ | SOLID as a Rock"},{"content":"This article is the first part of a five-part series about SOLID as Rock design principle series. The SOLID design principles focus on developing software that is easy to maintainable, reusable \u0026amp; extendable. In this article, we will see an example of the Single Responsibility Principle in C++ along with its benefits \u0026amp; generic guideline.\nBy the way, If you want to directly jumps to other design principles, then below is the quick links:\nSRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent A class should have only one reason to change\nIn other words, SRP states that classes should be cohesive to the point that it has a single responsibility, where responsibility defines as \u0026ldquo;a reason for the change.\u0026rdquo;\nMotivation: Violating the Single Responsibility Principle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Journal { string m_title; vector\u0026lt;string\u0026gt; m_entries; public: explicit Journal(const string \u0026amp;title) : m_title{title} {} void add_entries(const string \u0026amp;entry) { static uint32_t count = 1; m_entries.push_back(to_string(count++) + \u0026#34;: \u0026#34; + entry); } auto get_entries() const { return m_entries; } void save(const string \u0026amp;filename) { ofstream ofs(filename); for (auto \u0026amp;s : m_entries) ofs \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } }; int main() { Journal journal{\u0026#34;Dear XYZ\u0026#34;}; journal.add_entries(\u0026#34;I ate a bug\u0026#34;); journal.add_entries(\u0026#34;I cried today\u0026#34;); journal.save(\u0026#34;diary.txt\u0026#34;); return EXIT_SUCCESS; } Above C++ example seems fine as long as you have a single domain object i.e. Journal. but this is not usually the case in a real-world application. As we start adding domain objects like Book, File, etc. you have to implement save method for everyone separately which is not the actual problem. The real problem arises when you have to change or maintain save functionality. For instance, some other day you will no longer save data on files \u0026amp; adopted database. In this case, you have to go through every domain object implementation \u0026amp; need to change code all over which is not good. Here, we have violated the Single Responsibility Principle by providing Journal class two reason to change i.e. Things related to Journal Saving the Journal Moreover, code will also become repetitive, bloated \u0026amp; hard to maintain. Solution: Single Responsibility Principle Example in C++ As a solution what we do is a separation of concerns. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Journal { string m_title; vector\u0026lt;string\u0026gt; m_entries; public: explicit Journal(const string \u0026amp;title) : m_title{title} {} void add_entries(const string \u0026amp;entry) { static uint32_t count = 1; m_entries.push_back(to_string(count++) + \u0026#34;: \u0026#34; + entry); } auto get_entries() const { return m_entries; } //void save(const string \u0026amp;filename) //{ //\tofstream ofs(filename); //\tfor (auto \u0026amp;s : m_entries) ofs \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; //} }; struct SavingManager { static void save(const Journal \u0026amp;j, const string \u0026amp;filename) { ofstream ofs(filename); for (auto \u0026amp;s : j.get_entries()) ofs \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } }; SavingManager::save(journal, \u0026#34;diary.txt\u0026#34;); Journal should only take care of entries \u0026amp; things related to the journal. And there should be one separate central location or entity which does the work of saving. In our case, its SavingManager. As your SavingManager grows, you have all the saving related code will be at one place. You can also templatize it to accept more domain objects. Benefits of Single Responsibility Principle =\u0026gt; Expressiveness When the class only does one thing, its interface usually has a small number of methods which is more expressive. Hence, It also has a small number of data members. This improves your development speed \u0026amp; makes your life as a software developer a lot easier. =\u0026gt; Maintainability We all know that requirements change over time \u0026amp; so does the design/architecture. The more responsibilities your class has, the more often you need to change it. If your class implements multiple responsibilities, they are no longer independent of each other. Isolated changes reduce the breaking of other unrelated areas of the software. As programming errors are inversely proportional to complexity, being easier to understand makes the code less prone to bugs \u0026amp; easier to maintain. =\u0026gt; Reusability If a class has multiple responsibilities and only one of those needs in another area of the software, then the other unnecessary responsibilities hinder reusability. Having a single responsibility means the class should be reusable without or less modification. Yardstick to Craft SRP Friendly Software in C++ SRP is a double-edged sword. Be too specific \u0026amp; you will end up having hundreds of ridiculously interconnected classes, that could easily be one. You should not use SOLID principles when you feel you are over-engineering. If you boil down the Single Responsibility Principle, the generic idea would be like this: The SRP is about limiting the impact of change. So, gather together the things that change for the same reasons. Separate those things that change for different reasons.\nAdding more to this, If your class constructor has more than 5-6 parameters then it means either you are not followed SRP or you are not aware of builder design pattern. Conclusion The SRP is a widely quoted justification for refactoring. This is often done without a full understanding of the point of the SRP and its context, leading to fragmentation of codebases with a range of negative consequences. Instead of being a one-way street to minimally sized classes, the SRP is actually proposing a balance point between aggregation and division.\n","permalink":"https://vishalchovatiya.github.io/posts/single-responsibility-principle-in-cpp-solid-as-a-rock/","summary":"This article is the first part of a five-part series about SOLID as Rock design principle series. The SOLID design principles focus on developing software that is easy to maintainable, reusable \u0026amp; extendable. In this article, we will see an example of the Single Responsibility Principle in C++ along with its benefits \u0026amp; generic guideline.\nBy the way, If you want to directly jumps to other design principles, then below is the quick links:","title":"Single Responsibility Principle in C++ | SOLID as a Rock"},{"content":"After hitting a certain level of experience \u0026amp; spending quite enough time in the industry, I have realised the importance of designing/architecting system \u0026amp; software. So I have started looking into system/software design \u0026amp; got to know nothing can better start than a Design Pattern. And the first thing I have done is googling \u0026ldquo;What is Design Pattern?\u0026rdquo; Hence got the idea of this article.\nBut as someone without a computer science background(I am from electronics background), learning them was a struggle. Every material, article, explanation or book was riddled with jargon to sift through. Some of them I still don\u0026rsquo;t quite understand. I barely know how the Flyweight \u0026amp; Classical Visitor pattern work and anyone who says they do is a liar.\nSo, after taking the online course, YouTube videos, lots of googling, tons compiling \u0026amp; spaced repetition with learning \u0026amp; unlearning. Here is what I have gained so far.\nWhat Is Design Pattern? From Wikipedia:\nIn software engineering, a software design pattern is a general, reusable solution to a commonly occurring problem within a given context in software design.\nIt is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations.\nDesign patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system.\nDesign Patterns establishes solutions to common problems which helps to keep code maintainable, extensible \u0026amp; loosely coupled.\nDevelopers have given a name to solutions which solve a particular type of problem. And this is how it all started.\nThe more one knows them, the easier it gets to solve all the problems we face.\nIt is popularized by Gang Of Four(1994) book.\nWhat Is Not Design Pattern? It isn\u0026rsquo;t code reuse, as it usually does not specify code. The actual implementation depends on the programming language and even the person that is doing it. Design Pattern \u0026amp; Principle(SOLID) are two different things. A Design Pattern is neither a static solution nor is it an algorithm, No hard rule of the coding standard. Software Architecture is not a Design Pattern. Software Architecture dictates what\u0026rsquo;s going to implemented \u0026amp; where it will be put. While Design Patterns states how it should be done. Design Patterns are not ready to code solutions they are more like a description of what the solution should look like. What you should retain from Design Patterns is that the problem and the solution to the problem are closely related. They are both equally important to learn. Why Do We Need Design Patterns? As Software Developers, we often evaluate our code through some attributes like how clean, expressive, taking less memory footprint \u0026amp; fast our code is. But the most important concern which we often neglect is that you should be able to easily change anything later. What you decide today could be irrelevant tomorrow. And your code should be flexible enough so that it\u0026rsquo;s not too costly to alter. So Design Patterns are best practices to cover such attributes. For me, the core of Design Patterns consists of the following 6 rules:\nThey Are Proven Solutions Because Design Patterns often uses by many developers, you can be certain that they work. And not only that, you can be certain that they were revised multiple times and optimizations were probably implemented. They Are Easily Reusable Design Patterns document a reusable solution which can modify to solve multiple particular problems. As they are not tie-up to a specific problem. For example, consider the Iterator Design Pattern, it is reusable throughout STL despite container \u0026amp; algorithm variation. Iterators are working like glue between container \u0026amp; algorithm. They Are Expressive Design Patterns can explain a large solution quite elegantly. For instance, the Visitor pattern uses to perform a new operation on a range/group of classes. And thus, the standard library adopted such pattern with single function i.e. std::visit algorithm. Same goes for boost::flyweight\u0026lt;\u0026gt;. They Ease Communication When developers are familiar with Design Patterns, they can more easily communicate with one another about potential solutions to a given problem. If you’re working with colleagues in a team of multiple developers, agree with them about the Design Patterns, as they can help you better with a problem. Also with regard to the maintenance of software, you should follow such procedures, as you make maintenance operations faster and more efficient. They Prevent the Need for Refactoring Code If an application is written with Design Patterns in mind, it is often the case that you won’t need to refactor the code later on because applying the correct Design Pattern to a given problem is already an optimal solution. If such solutions are then updates, they can seamlessly apply by any good software developer and do not cause any problems. They Lower the Size of the Codebase Because Design Patterns are usually elegant and optimal solutions, they usually require less code than other solutions. This does not always have to be the case as many developers write more code to improve understanding. Why You Should Learn Design Patterns? If you boil-down the definition of Object-Oriented Design, it combining data \u0026amp; its operation into a context-bound entity(i.e. class/struct). And it stands true while designing an individual object. But when you are designing complete software you need to take into the account that Creational Design Patterns: How do those objects going to be instantiated/created? Structural Design Patterns: How do those objects combine with other object \u0026amp; formalize bigger entity? which should also be scalable in future. Behavioural Design Patterns: You also need to think in terms of communication between those objects which can anticipate future changes easily \u0026amp; with fewer side effects. Do you see where this lead us to? you need to think in terms of object everywhere considering maintainability, scalability, expressiveness \u0026amp; stability. So in nutshell, this is a mindset for good coding. And I am pretty sure if you are coming from C background, you don\u0026rsquo;t have this mindset \u0026amp; thought process. Before Dive-Into the Design Patterns But, before dive-into the Design Patterns you should learn some of the basic design principles called SOLID. SOLID is one of the most popular sets of design principles in object-oriented software development introduced by Robert C. Martin, popularly known as Uncle Bob. The SOLID principles comprise of these five principles:\nSRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle Dev also refers to this SOLID design principle as \u0026ldquo;The First 5 Principles of Object-Oriented Design\u0026rdquo;. These principles also make it easy for developers to avoid code smells, easily refactor code, and are also a part of the agile or adaptive software development. SOLID are \u0026ldquo;not principles to adopt\u0026rdquo; but \u0026ldquo;frameworks to use\u0026rdquo;\nTypes of Design Patterns Creational Design Patterns in C++ Factory Builder Prototype Singleton Structural Design Patterns in C++ Adapter Bridge Composite Decorator Facade Flyweight Proxy Behavioural Design Patterns in C++ Chain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor Benefits of Design Patterns Foresee \u0026amp; rectify future problems easily. Helps in maintaining binary compatibility with subsequent releases. Just by following SOLID Principles helps greatly in agile or adaptive software development. The solution facilitates the development of highly cohesive modules with minimal coupling. Thus, increasing extensibility \u0026amp; reusability. There are some patterns like Facade, Proxy, etc which encapsulates the complexity in itself to provide easy \u0026amp; intuitive interface to the client. Thus, making the overall system easier to understand \u0026amp; reduce learning curve. Design Patterns make communication between designers \u0026amp; developers more crystal \u0026amp; precise. A developer can immediately picture the high-level design in their heads when they refer to the name of the pattern used to solve a particular issue when discussing software design. What Next? I\u0026rsquo;m not advocating to learn everything by heart, but you should try to understand as much as you can about these concepts as you will encounter them often in your work. By practising to implement them, you will understand better their use cases and the reasons behind them.\nI hope to cover most of the classic Gang of Four Design Patterns throughout this series. I struggled to find beginner-friendly material while learning them, and hope these help others avoid the same fate. By the way, I will be using Modern C++ for all of the patterns. So you can also smell C++ from thought process \u0026amp; some of the definitions(this line is hard for me to put it into the words). This is by no means that you can not apply these patterns to other languages.\nFAQs Do you need design pattern all the time?\nInitially, you should not think about Design Pattern. An expressive \u0026amp; less code is always the first line of defence. You should not complicate the solution because complication is given by the problem.\nWhy you should learn the Design Patterns?\nIf you are a self-taught developer \u0026amp; does not expose to industry projects then you may not have thought process for using Object-Oriented Design. You can not think every aspect of design in terms of objects. In this case, Design Pattern will give you a new thought process of thinking everything in terms of objects. And if you follow it strictly, you will see your classes \u0026amp; software represent the Domain Specific Language.\n","permalink":"https://vishalchovatiya.github.io/posts/what-is-design-pattern/","summary":"After hitting a certain level of experience \u0026amp; spending quite enough time in the industry, I have realised the importance of designing/architecting system \u0026amp; software. So I have started looking into system/software design \u0026amp; got to know nothing can better start than a Design Pattern. And the first thing I have done is googling \u0026ldquo;What is Design Pattern?\u0026rdquo; Hence got the idea of this article.\nBut as someone without a computer science background(I am from electronics background), learning them was a struggle.","title":"What Is Design Pattern?"},{"content":"In software engineering, Creational Design Patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic or ordinary form of object creation could result in design problems or added complexity to the design. Builder Design Pattern in C++ solves this specific problem by separating the construction of a complex object from its representation.\nBy the way, If you haven’t check out my other articles on Creational Design Patterns, then here is the list:\nFactory Builder Prototype Singleton The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To create/instantiate complex \u0026amp; complicated object piecewise \u0026amp; succinctly by providing an API in a separate entity.\nBuilder Design Pattern is used when we want to construct a complex object. However, we do not want to have a complex constructor member or one that would need many arguments. The Builder Design Pattern constructs a complex object step by step \u0026amp; the final step will return the object. The process of constructing an object should be generic so that it can be used to create different representations of the same object with the help of a variety of methods. Life Without Builders Suppose you have to create the HTML generator using C++ then very naïve way to do it is : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // \u0026lt;p\u0026gt;hello\u0026lt;/p\u0026gt; auto text = \u0026#34;hello\u0026#34;; string output; output += \u0026#34;\u0026lt;p\u0026gt;\u0026#34;; output += text; output += \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; printf(\u0026#34;\u0026lt;p\u0026gt;%s\u0026lt;/p\u0026gt;\u0026#34;, text); // \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;hello\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;world\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; string words[] = {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; ostringstream oss; oss \u0026lt;\u0026lt; \u0026#34;\u0026lt;ul\u0026gt;\u0026#34;; for (auto w : words) oss \u0026lt;\u0026lt; \u0026#34; \u0026lt;li\u0026gt;\u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; oss \u0026lt;\u0026lt; \u0026#34;\u0026lt;/ul\u0026gt;\u0026#34;; printf(oss.str().c_str()); A sophisticated dev will create a class with a bunch of constructor argument \u0026amp; method to add a child node. This is a good approach though but it may complicate the object representation. In general, some objects are simple \u0026amp; can be created in a single constructor call while other objects require a lot of ceremonies to create. Having an object with 10 constructor arguments is not productive. Instead, we should opt for piecewise construction. Builder provides an API for constructing an object step-by-step without revealing actual object representation. Builder Design Pattern Example in Modern C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class HtmlBuilder; class HtmlElement { string m_name; string m_text; vector\u0026lt;HtmlElement\u0026gt; m_childs; constexpr static size_t m_indent_size = 4; HtmlElement() = default; HtmlElement(const string \u0026amp;name, const string \u0026amp;text) : m_name(name), m_text(text) {} friend class HtmlBuilder; public: string str(int32_t indent = 0) { ostringstream oss; oss \u0026lt;\u0026lt; string(m_indent_size * indent, \u0026#39; \u0026#39;) \u0026lt;\u0026lt; \u0026#34;\u0026lt;\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; if (m_text.size()) oss \u0026lt;\u0026lt; string(m_indent_size * (indent + 1), \u0026#39; \u0026#39;) \u0026lt;\u0026lt; m_text \u0026lt;\u0026lt; endl; for (auto \u0026amp;element : m_childs) oss \u0026lt;\u0026lt; element.str(indent + 1); oss \u0026lt;\u0026lt; string(m_indent_size * indent, \u0026#39; \u0026#39;) \u0026lt;\u0026lt; \u0026#34;\u0026lt;/\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; return oss.str(); } static unique_ptr\u0026lt;HtmlBuilder\u0026gt; build(string root_name) { return make_unique\u0026lt;HtmlBuilder\u0026gt;(root_name); } }; class HtmlBuilder { HtmlElement m_root; public: HtmlBuilder(string root_name) { m_root.m_name = root_name; } HtmlBuilder *add_child(string child_name, string child_text) { m_root.m_childs.emplace_back(HtmlElement{child_name, child_text}); return this; } string str() { return m_root.str(); } operator HtmlElement() { return m_root; } }; int main() { auto builder = HtmlElement::build(\u0026#34;ul\u0026#34;); builder-\u0026gt;add_child(\u0026#34;li\u0026#34;, \u0026#34;hello\u0026#34;)-\u0026gt;add_child(\u0026#34;li\u0026#34;, \u0026#34;world\u0026#34;); cout \u0026lt;\u0026lt; builder-\u0026gt;str() \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } /* \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; hello \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; world \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; */ We are forcing users here to use builder by making data members of HtmlElements private. As you can see, we have declared the HtmlBuilder \u0026amp; HtmlElement in the same file \u0026amp; to do so, we need forward declaration i.e. class HtmlBuilder; as it is an incomplete type. And we can not create the object of incomplete type before compiler parses its actual declaration. The reason is simple, the compiler needs the size of an object to allocate memory for it. Hence pointer is only way around so we have taken unique_ptr. Sophisticated \u0026amp; Fluent Builder Design Pattern Example Following is the more sophisticated example of the Builder Design Pattern in C++ organized in four different files(i.e. Person.h, Person.cpp, PersonBuilder.h PersonBuilder.cpp). Person.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #pragma once #include \u0026lt;iostream\u0026gt; using namespace std; class PersonBuilder; class Person { std::string m_name, m_street_address, m_post_code, m_city; // Personal Detail std::string m_company_name, m_position, m_annual_income; // Employment Detail Person(std::string name) : m_name(name) {} public: friend class PersonBuilder; friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Person\u0026amp; obj); static PersonBuilder create(std::string name); }; Person.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026#34;Person.h\u0026#34; #include \u0026#34;PersonBuilder.h\u0026#34; PersonBuilder Person::create(string name) { return PersonBuilder{name}; } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Person\u0026amp; obj) { return os \u0026lt;\u0026lt; obj.m_name \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;lives : \u0026#34; \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;at \u0026#34; \u0026lt;\u0026lt; obj.m_street_address \u0026lt;\u0026lt; \u0026#34; with postcode \u0026#34; \u0026lt;\u0026lt; obj.m_post_code \u0026lt;\u0026lt; \u0026#34; in \u0026#34; \u0026lt;\u0026lt; obj.m_city \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;works : \u0026#34; \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;with \u0026#34; \u0026lt;\u0026lt; obj.m_company_name \u0026lt;\u0026lt; \u0026#34; as a \u0026#34; \u0026lt;\u0026lt; obj.m_position \u0026lt;\u0026lt; \u0026#34; earning \u0026#34; \u0026lt;\u0026lt; obj.m_annual_income; } As you can see from the above example Person may have many details like Personal \u0026amp; Professional. And so does the count of data members. In our case, there are 7 data members. Having a single class for all the actions needed to create a Person through constructor might make our class bloated \u0026amp; lose its original purpose. Moreover, the library user needs to take care of all those constructor parameters sequence. PersonBuilder.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #pragma once #include \u0026#34;Person.h\u0026#34; class PersonBuilder { Person person; public: PersonBuilder(string name) : person(name) {} operator Person() const { return move(person); } PersonBuilder\u0026amp; lives(); PersonBuilder\u0026amp; at(std::string street_address); PersonBuilder\u0026amp; with_postcode(std::string post_code); PersonBuilder\u0026amp; in(std::string city); PersonBuilder\u0026amp; works(); PersonBuilder\u0026amp; with(string company_name); PersonBuilder\u0026amp; as_a(string position); PersonBuilder\u0026amp; earning(string annual_income); }; PersonBuilder.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026#34;PersonBuilder.h\u0026#34; PersonBuilder\u0026amp; PersonBuilder::lives() { return *this; } PersonBuilder\u0026amp; PersonBuilder::works() { return *this; } PersonBuilder\u0026amp; PersonBuilder::with(string company_name) { person.m_company_name = company_name; return *this; } PersonBuilder\u0026amp; PersonBuilder::as_a(string position) { person.m_position = position; return *this; } PersonBuilder\u0026amp; PersonBuilder::earning(string annual_income) { person.m_annual_income = annual_income; return *this; } PersonBuilder\u0026amp; PersonBuilder::at(std::string street_address) { person.m_street_address = street_address; return *this; } PersonBuilder\u0026amp; PersonBuilder::with_postcode(std::string post_code) { person.m_post_code = post_code; return *this; } PersonBuilder\u0026amp; PersonBuilder::in(std::string city) { person.m_city = city; return *this; } Rather stuffing all those construction related APIs into Person, we can delegate that task to separate entity i.e. PersonBuilder. Main.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026#34;Person.h\u0026#34; #include \u0026#34;PersonBuilder.h\u0026#34; using namespace std; int main() { Person p = Person::create(\u0026#34;John\u0026#34;) .lives() .at(\u0026#34;123 London Road\u0026#34;) .with_postcode(\u0026#34;SW1 1GB\u0026#34;) .in(\u0026#34;London\u0026#34;) .works() .with(\u0026#34;PragmaSoft\u0026#34;) .as_a(\u0026#34;Consultant\u0026#34;) .earning(\u0026#34;10e6\u0026#34;); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } Isn\u0026rsquo;t the above construction looks more intuitive, natural \u0026amp; plain English? If you are concerned about blank methods like lives() \u0026amp; works(), then do not worry, it will be eliminated in optimization. You can also observe that we are forcing user\u0026rsquo;s to use builder rather than constructor by making the constructor private \u0026amp; exposing only create(std::string name) API. Do not over complicate things by designing an interface or abstract classes unless you need it. I have seen this in many Builder Design Pattern Examples on Web. Benefits of Builder Design Pattern The number of lines of code increases at least to double in builder pattern. But the effort pays off in terms of design flexibility, fewer or no parameters to the constructor and much more readable code. Builder Design Pattern also helps in minimizing the number of parameters in constructor \u0026amp; thus there is no need to pass in null for optional parameters to the constructor. Immutable objects can be built without much complex logic in the object building process. Segregating construction from object representation makes the object representation slice \u0026amp; precise. Having a builder entity separate provides the flexibility of creating \u0026amp; instantiating different objects representations. Summary by FAQs When should the Builder Design Pattern be used?\nWhenever creation of new object requires setting many parameters and some of them (or all of them) are optional.\nWhy do we need a Builder class when implementing a Builder Design Pattern?\nIt isn\u0026rsquo;t necessary but there are some benefits in doing so:\nThe concern of building object should be in the separate entity as per SRP. The original object would not be bloated. Easy \u0026amp; maintainable code. Testing \u0026amp; understanding a constructor with many input arguments gets exponentially more complicated. Greatest Advantage of Builder Design Pattern!\nMore expressive code.\n1 MyClass o = new MyClass(5, 5.5, \u0026#39;A\u0026#39;, var, 1000, obj9, \u0026#34;hello\u0026#34;); Instead 1 MyClass o = MyClass.builder().a(5).b(5.5).c(\u0026#39;A\u0026#39;).d(var).e(1000).f(obj9).g(\u0026#34;hello\u0026#34;); You can see which data member is being assigned by what \u0026amp; even change the order of assignment. What\u0026rsquo;s the difference between Abstract Factory and Builder Design Pattern?\nFactory produces the objects in wholesale that could be any object from inheritance hierarchy(like Point, Point2D, Point3D). While Builder deals with instantiation of an object that is limited to a single object(Although this statement is still debatable). You see Factory is all about wholesale object creation while the builder is piecewise object creation. In both the patterns, you can separate out the mechanism related to object creation in other classes. ","permalink":"https://vishalchovatiya.github.io/posts/builder-design-pattern-in-modern-cpp/","summary":"In software engineering, Creational Design Patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic or ordinary form of object creation could result in design problems or added complexity to the design. Builder Design Pattern in C++ solves this specific problem by separating the construction of a complex object from its representation.\nBy the way, If you haven’t check out my other articles on Creational Design Patterns, then here is the list:","title":"Builder Design Pattern in Modern C++"},{"content":"Dependency Inversion Principle in C++ is the fifth \u0026amp; last design principle of a series SOLID as a Rock design principles. The SOLID design principles focus on developing software that is easy to maintainable, reusable \u0026amp; extendable. In this article, we will see an example code with the flaw \u0026amp; correct it with help of DIP. We will also see guideline \u0026amp; benefits of DIP in closure of the article.\nBy the way, If you haven\u0026rsquo;t gone through my previous articles on design principles, then below is the quick links:\nSRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent =\u0026gt; High-level modules should not depend on low-level modules. Both should depend on abstractions.\n=\u0026gt; Abstractions should not depend on details. Details should depend on abstractions.\nAbove lines might seem cryptic at first but don\u0026rsquo;t stick here keep going. You will get it by example. What are the High-level \u0026amp; Low-level modules?\n=\u0026gt; High-level modules: describes operations which is more abstract in nature \u0026amp; contain more complex logic. These modules orchestrate low-level modules in our application.\n=\u0026gt; Low-level modules: describes implementations more specific \u0026amp; individual to components focusing on details \u0026amp; smaller parts of the application. These modules are used inside the high-level modules.\nMotivation: Violating Dependency Inversion Principle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 enum class Relationship { parent, child, sibling }; struct Person { string m_name; }; struct Relationships { // Low-level \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;------------------------- vector\u0026lt;tuple\u0026lt;Person, Relationship, Person\u0026gt;\u0026gt; m_relations; void add_parent_and_child(const Person \u0026amp;parent, const Person \u0026amp;child) { m_relations.push_back({parent, Relationship::parent, child}); m_relations.push_back({child, Relationship::child, parent}); } }; struct Research { // High-level \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;------------------------ Research(const Relationships \u0026amp;relationships) { for (auto \u0026amp;\u0026amp;[first, rel, second] : relationships.m_relations) {// Need C++17 here if (first.m_name == \u0026#34;John\u0026#34; \u0026amp;\u0026amp; rel == Relationship::parent) cout \u0026lt;\u0026lt; \u0026#34;John has a child called \u0026#34; \u0026lt;\u0026lt; second.m_name \u0026lt;\u0026lt; endl; } } }; int main() { Person parent{\u0026#34;John\u0026#34;}; Person child1{\u0026#34;Chris\u0026#34;}; Person child2{\u0026#34;Matt\u0026#34;}; Relationships relationships; relationships.add_parent_and_child(parent, child1); relationships.add_parent_and_child(parent, child2); Research _(relationships); return EXIT_SUCCESS; } When later on the container of Relationships changes from vector to set or any other container, you need to change in many places which isn\u0026rsquo;t a very good design. Even if just the name of data member i.e. Relationships::m_relations changes, you will find yourself breaking other parts of code. As you can see Low-level module i.e. Relationships directly depend on High-level module i.e. Research which is essentially a violation of DIP. Solution: Example of Dependency Inversion Principle in C++ Rather we should create an abstraction and bind Low-level \u0026amp; High-level module to that abstraction. Consider the following fix: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 struct RelationshipBrowser { virtual vector\u0026lt;Person\u0026gt; find_all_children_of(const string \u0026amp;name) = 0; }; struct Relationships : RelationshipBrowser { // Low-level \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;------------------------ vector\u0026lt;tuple\u0026lt;Person, Relationship, Person\u0026gt;\u0026gt; m_relations; void add_parent_and_child(const Person \u0026amp;parent, const Person \u0026amp;child) { m_relations.push_back({parent, Relationship::parent, child}); m_relations.push_back({child, Relationship::child, parent}); } vector\u0026lt;Person\u0026gt; find_all_children_of(const string \u0026amp;name) { vector\u0026lt;Person\u0026gt; result; for (auto \u0026amp;\u0026amp;[first, rel, second] : m_relations) { if (first.name == name \u0026amp;\u0026amp; rel == Relationship::parent) { result.push_back(second); } } return result; } }; struct Research { // High-level \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;---------------------- Research(RelationshipBrowser \u0026amp;browser) { for (auto \u0026amp;child : browser.find_all_children_of(\u0026#34;John\u0026#34;)) { cout \u0026lt;\u0026lt; \u0026#34;John has a child called \u0026#34; \u0026lt;\u0026lt; child.name \u0026lt;\u0026lt; endl; } } // Research(const Relationships\u0026amp; relationships) // { // auto\u0026amp; relations = relationships.relations; // for (auto\u0026amp;\u0026amp; [first, rel, second] : relations) // { // if (first.name == \u0026#34;John\u0026#34; \u0026amp;\u0026amp; rel == Relationship::parent) // { // cout \u0026lt;\u0026lt; \u0026#34;John has a child called \u0026#34; \u0026lt;\u0026lt; second.name \u0026lt;\u0026lt; endl; // } // } // } }; Now no matter, the name of container or container itself changes in Low-level module, High-level module or other parts of code which followed DIP will be in-tact. The Dependency Inversion Principle (DIP) suggest that the most flexible systems are those in which source code dependencies refer only to abstractions, not to concretions. This is the reason why most experienced dev uses STL or library functions along with generic containers. Even using an auto keyword at appropriate places may help in creating generic behaviour with less fragile code. There are many ways you can implement DIP, as long as C++ concerns most people use static polymorphism(i.e. CRTP unless they need dynamic one), template specialization, Adapter Design Pattern, type-erasure, etc. Yardstick to Craft Dependency Inversion Principle(DIP) Friendly Software in C++ If you find enforcing DIP difficult then just design abstraction first \u0026amp; implement your high-level module on the bases of abstraction. Without having any knowledge of the low-level module or its implementation. Because of this process DIP is also known as Coding To Interface. Keep in mind that all Low-level-modules/subclasses adhere to the Liskov Substitution Principle. This is because the Low-level-modules/subclasses will be used via the abstract interface, not the concrete classes interface. Benefits =\u0026gt; Reusability Effectively, the DIP reduces coupling between different pieces of code. Thus we get reusable code. =\u0026gt; Maintainability It is also important to mention that changing already implemented modules is risky. By depending on abstraction \u0026amp; not on concrete implementation, we can reduce that risk by not having to change high-level modules in our project. Finally, DIP when applied correctly gives us flexibility and stability at the level of the entire architecture of our application. Our application will be able to evolve more securely and become stable \u0026amp; robust. Conclusion As you can see we took a basic example of code \u0026amp; converted it into a reusable, flexible \u0026amp; modular piece of code. If I would have to summarize DIP in simple \u0026amp; short sentence then it would be like:\nDo not use the concrete object directly unless you have a strong reason to do so. Use abstraction instead. DIP trains us to think about classes in terms of behaviour, rather than construction or implementation. ","permalink":"https://vishalchovatiya.github.io/posts/dependency-inversion-principle-in-cpp-solid-as-a-rock/","summary":"Dependency Inversion Principle in C++ is the fifth \u0026amp; last design principle of a series SOLID as a Rock design principles. The SOLID design principles focus on developing software that is easy to maintainable, reusable \u0026amp; extendable. In this article, we will see an example code with the flaw \u0026amp; correct it with help of DIP. We will also see guideline \u0026amp; benefits of DIP in closure of the article.","title":"Dependency Inversion Principle in C++ | SOLID as a Rock"},{"content":"In software engineering, Creational Design Patterns deal with object creation mechanisms, i.e. try to create objects in a manner suitable to the situation. In addition to this basic or ordinary form of object creation could result in design problems or added complexity to the design. Factory Design Pattern in C++ helps to mitigate this issue by creating objects using separate methods or polymorphic classes.\nBy the way, If you haven’t check out my other articles on Creational Design Patterns, then here is the list:\nFactory Builder Prototype Singleton The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent For the creation of wholesale objects unlike builder(which creates piecewise).\nMotivation Let say you have a Point class having x \u0026amp; y as co-ordinates which can be Cartesian or Polar coordinate as below: 1 2 3 4 5 6 7 8 struct Point { Point(float x, float y){ /*...*/ } // Cartesian co-ordinates // Not OK: Cannot overload with same type of arguments // Point(float a, float b){ /*...*/ } // Polar co-ordinates // ... Implementation }; This isn\u0026rsquo;t possible as you might know you can not create two constructors with the same type of arguments. Other way around is: 1 2 3 4 5 6 7 8 9 10 11 12 13 enum class PointType{ cartesian, polar }; class Point { Point(float a, float b, PointTypetype = PointType::cartesian) { if (type == PointType::cartesian) { x = a; b = y; } else { x = a * cos(b); y = a * sin(b); } } }; But this isn\u0026rsquo;t a sophisticated way of doing this. Rather we should delegate separate instantiation to separate methods. Factory Design Pattern Examples in C++ So as you can guess. We are going to mitigate constructor limitation by moving the initialization process from constructor to other structure. And we gonna be using the Factory Method for that. And just as the name suggests it uses the method or member function to initialize the object. Factory Method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 enum class PointType { cartesian, polar }; class Point { float m_x; float m_y; PointType m_type; // Private constructor, so that object can\u0026#39;t be created directly Point(const float x, const float y, PointType t) : m_x{x}, m_y{y}, m_type{t} {} public: friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const Point \u0026amp;obj) { return os \u0026lt;\u0026lt; \u0026#34;x: \u0026#34; \u0026lt;\u0026lt; obj.m_x \u0026lt;\u0026lt; \u0026#34; y: \u0026#34; \u0026lt;\u0026lt; obj.m_y; } static Point NewCartesian(float x, float y) { return {x, y, PointType::cartesian}; } static Point NewPolar(float a, float b) { return {a * cos(b), a * sin(b), PointType::polar}; } }; int main() { // Point p{ 1,2 }; // will not work auto p = Point::NewPolar(5, M_PI_4); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; // x: 3.53553 y: 3.53553 return EXIT_SUCCESS; } As you can observe from the implementation. It actually disallows the use of constructor \u0026amp; forcing users to use static methods instead. And this is the essence of the Factory Method i.e. private constructor \u0026amp; static method. Classical Factory Design Pattern If you have dedicated code for construction then why don\u0026rsquo;t we move it to a dedicated class! And Just to separation the concerns i.e. Single Responsibility Principle from SOLID design principles. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Point { // ... as it is from above friend class PointFactory; }; class PointFactory { public: static Point NewCartesian(float x, float y) { return { x, y }; } static Point NewPolar(float r, float theta) { return { r*cos(theta), r*sin(theta) }; } }; Mind that this is not the abstract factory this is a concrete factory. Making the PointFactory friend class of Point we have violated the Open-Closed Principle(OCP). As friend keyword itself contrary to OCP. Inner Factory There is a critical thing we missed in our Factory that there is no strong link between PointFactory \u0026amp; Point which confuses user to use Point just by seeing everything is private. So rather than designing a factory outside the class. We can simply put it in the class which encourage users to use Factory. Thus, we also serve the second problem which is breaking the Open-Closed Principle. And this will be somewhat more intuitive for the user to use Factory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Point { float m_x; float m_y; Point(float x, float y) : m_x(x), m_y(y) {} public: struct Factory { static Point NewCartesian(float x, float y) { return { x,y }; } static Point NewPolar(float r, float theta) { return{ r*cos(theta), r*sin(theta) }; } }; }; int main() { auto p = Point::Factory::NewCartesian(2, 3); return EXIT_SUCCESS; } Abstract Factory Why do we need an Abstract Factory? C++ has the support of polymorphic object destruction using it’s base class’s virtual destructor. Similarly, equivalent support for creation \u0026amp; copying of objects is missing as C++ doesn\u0026rsquo;t support virtual constructor \u0026amp; virtual copy constructors. Moreover, you can’t create an object unless you know its static type, because the compiler must know the amount of space it needs to allocate. For the same reason, copy of an object also requires its type to known at compile-time. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Point { virtual ~Point(){ cout\u0026lt;\u0026lt;\u0026#34;~Point\\n\u0026#34;; } }; struct Point2D : Point { ~Point2D(){ cout\u0026lt;\u0026lt;\u0026#34;~Point2D\\n\u0026#34;; } }; struct Point3D : Point { ~Point3D(){ cout\u0026lt;\u0026lt;\u0026#34;~Point3D\\n\u0026#34;; } }; void who_am_i(Point *who) { // Not sure whether Point2D would be passed here or Point3D // How to `create` the object of same type i.e. pointed by who ? // How to `copy` object of same type i.e. pointed by who ? delete who; // you can delete object pointed by who, thanks to virtual destructor } Example of Abstract Factory Design Pattern The Abstract Factory is useful in a situation that requires the creation of many different types of objects, all derived from a common base type. The Abstract Factory defines a method for creating the objects, which subclasses can then override to specify the derived type that will be created. Thus, at run time, the appropriate Abstract Factory Method will be called depending upon the type of object referenced/pointed \u0026amp; return a base class pointer to a new instance of that object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct Point { virtual ~Point() = default; virtual unique_ptr\u0026lt;Point\u0026gt; create() = 0; virtual unique_ptr\u0026lt;Point\u0026gt; clone()\t= 0; }; struct Point2D : Point { unique_ptr\u0026lt;Point\u0026gt; create() { return make_unique\u0026lt;Point2D\u0026gt;(); } unique_ptr\u0026lt;Point\u0026gt; clone() { return make_unique\u0026lt;Point2D\u0026gt;(*this); } }; struct Point3D : Point { unique_ptr\u0026lt;Point\u0026gt; create() { return make_unique\u0026lt;Point3D\u0026gt;(); } unique_ptr\u0026lt;Point\u0026gt; clone() { return make_unique\u0026lt;Point3D\u0026gt;(*this); } }; void who_am_i(Point *who) { auto new_who\t= who-\u0026gt;create(); // `create` the object of same type i.e. pointed by who ? auto duplicate_who = who-\u0026gt;clone();\t// `copy` the object of same type i.e. pointed by who ? delete who; } As shown above, we have leveraged polymorphic methods by delegating the act of creation \u0026amp; copying the object to the derived class through the use of pure virtual methods. Above code is not only implement virtual constructor(i.e. create()) but also implements virtual copy constructor(i.e. clone()). Make sure while using Abstract Factory you have ensured the Liskov\u0026rsquo;s Substitution Principle(LSP). Functional Approach to Factory Design Pattern using Modern C++ In our Abstract Factory example, we have followed the object-oriented approach but its equally possible nowadays to a more functional approach. So, let\u0026rsquo;s build a similar kind of Factory without relying on polymorphic functionality as it might not suit some time-constrained application like an embedded system. Because the virtual table \u0026amp; dynamic dispatch mechanism may troll system during critical functionality. This is pretty straight forward as it uses functional \u0026amp; lambda functions as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct Point { /* . . . */ }; struct Point2D : Point {/* . . . */}; struct Point3D : Point {/* . . . */}; class PointFunctionalFactory { map\u0026lt;PointType, function\u0026lt;unique_ptr\u0026lt;Point\u0026gt;() \u0026gt;\u0026gt; m_factories; public: PointFunctionalFactory() { m_factories[PointType::Point2D] = [] { return make_unique\u0026lt;Point2D\u0026gt;(); }; m_factories[PointType::Point3D] = [] { return make_unique\u0026lt;Point3D\u0026gt;(); }; } unique_ptr\u0026lt;Point\u0026gt; create(PointType type) { return m_factories[type](); } }; int main() { PointFunctionalFactory pf; auto p2D = pf.create(PointType::Point2D); return EXIT_SUCCESS; } If you are thinking that we are over-engineering, then keep in mind that our object construction is simple here just to demonstrate the technique \u0026amp; so does our lambda function. When your object representation increases, it requires a lot of methods to call in order to instantiate object properly, in such case you just need to modify lambda expression of the factory or introduce Builder Design Pattern. Benefits of Factory Design Pattern Single point/class for different object creation. Thus easy to maintain \u0026amp; understand software. You can create the object without even knowing its type by using Abstract Factory. It provides great modularity. Imagine programming a video game, where you would like to add new types of enemies in the future, each of which has different AI functions and can update differently. By using a factory method, the controller of the program can call to the factory to create the enemies, without any dependency or knowledge of the actual types of enemies. Now, future developers can create new enemies, with new AI controls and new drawing member functions, add it to the factory, and create a level which calls the factory, asking for the enemies by name. Combine this method with an XML description of levels, and developers could create new levels without having to recompile their program. All this, thanks to the separation of creation of objects from the usage of objects. Allows you to change the design of your application more readily, this is known as loose coupling. Summary by FAQs What is the correct way to implement the Factory Design Pattern in C++?\nAbstract Factory \u0026amp; Functional Factory is always a good choice.\nFactory vs Abstract Factory vs Functional Factory?\nFactory: Create an object with varied instantiation. Abstract Factor: Create an object without knowing its type \u0026amp; refer using base class pointer \u0026amp; reference. Access using polymorphic methods. Functional Factory: When object creation is more complex. Abstract Factory + Builder Design Pattern. Although I have not included Builder in Functional Factory example. What\u0026rsquo;s the difference between Abstract Factory and Builder Design Pattern?\nFactory produces the objects in wholesale that could be any object from inheritance hierarchy(like Point, Point2D, Point3D). While Builder deals with instantiation of an object that is limited to a single object(Although this statement is still debatable). You see Factory is all about wholesale object creation while the builder is piecewise object creation. In both the patterns, you can separate out the mechanism related to object creation in other classes. When to use the Factory Design Pattern?\nEmploy Factory Design Pattern to create an object of required functionality(s) but the type of object will remain undecided or it will be decided on dynamic parameters being passed.\n","permalink":"https://vishalchovatiya.github.io/posts/factory-design-pattern-in-modern-cpp/","summary":"In software engineering, Creational Design Patterns deal with object creation mechanisms, i.e. try to create objects in a manner suitable to the situation. In addition to this basic or ordinary form of object creation could result in design problems or added complexity to the design. Factory Design Pattern in C++ helps to mitigate this issue by creating objects using separate methods or polymorphic classes.\nBy the way, If you haven’t check out my other articles on Creational Design Patterns, then here is the list:","title":"Factory Design Pattern in Modern C++"},{"content":"Interface Segregation Principle in C++ is the fourth \u0026amp; by far the simplest design principle of a series SOLID as a Rock design principles. The SOLID design principles focus on developing software that is easy to maintainable, reusable \u0026amp; extendable. In this article, we will see a code violating ISP, a solution to the same code, guideline \u0026amp; benefits of ISP.\nBy the way, If you haven\u0026rsquo;t gone through my previous articles on design principles, then below is the quick links:\nSRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent Clients should not be forced to depend on interfaces that they do not use.\nInterface Segregation Principle is very much related to the Single Responsibility Principle. What it really means is that you should always design your abstractions in such a way that the clients that are using the exposed methods do not have to get the whole pie instead. That imposing the clients with the burden of implementing methods that they don’t actually need. Motivation: Violating the Interface Segregation Principle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct Document; struct IMachine { virtual void print(Document \u0026amp;doc) = 0; virtual void fax(Document \u0026amp;doc) = 0; virtual void scan(Document \u0026amp;doc) = 0; }; struct MultiFunctionPrinter : IMachine { // OK void print(Document \u0026amp;doc) override { } void fax(Document \u0026amp;doc) override { } void scan(Document \u0026amp;doc) override { } }; struct Scanner : IMachine { // Not OK void print(Document \u0026amp;doc) override { /* Blank */ } void fax(Document \u0026amp;doc) override { /* Blank */ } void scan(Document \u0026amp;doc) override { // Do scanning ... } }; As you can see, as far as MultiFunctionPrinter was concerned it\u0026rsquo;s ok to implement print(), fax() \u0026amp; scan() methods enforced by IMachine interface. But what if you only need a Scanner or Printer, some dev still inherits IMachine \u0026amp; leave unnecessary methods blank or throw NotImplemented exception, either way, you are doing it wrong. Solution: Example of Interface Segregation Principle in C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* -------------------------------- Interfaces ----------------------------- */ struct IPrinter { virtual void print(Document \u0026amp;doc) = 0; }; struct IScanner { virtual void scan(Document \u0026amp;doc) = 0; }; /* ------------------------------------------------------------------------ */ struct Printer : IPrinter { void print(Document \u0026amp;doc) override; }; struct Scanner : IScanner { void scan(Document \u0026amp;doc) override; }; struct IMachine : IPrinter, IScanner { }; struct Machine : IMachine { IPrinter\u0026amp; m_printer; IScanner\u0026amp; m_scanner; Machine(IPrinter \u0026amp;p, IScanner \u0026amp;s) : printer{p}, scanner{s} { } void print(Document \u0026amp;doc) override { printer.print(doc); } void scan(Document \u0026amp;doc) override { scanner.scan(doc); } }; This gives the flexibility for the clients to combine the abstractions as they may see fit and to provide implementations without unnecessary cargo. As explained in the Single Responsibility Principle. You should avoid classes \u0026amp; interfaces with multiple responsibilities. Because they change often and make your software hard to maintain. You should try to split up the interface into multiple interfaces based on role. Benefits =\u0026gt; Faster Compilation If you have violated ISP i.e. stuffed methods together in the interface, and when method signature changes, you need to recompile all the derived classes. This is an important aspect for some compiled languages like C++ which is well known for slow compilation. While another way around is self explainable. =\u0026gt; Reusability Martin also mentions that \u0026ldquo;fat interfaces\u0026rdquo; — interfaces with additional useless methods — lead to inadvertent coupling between classes. Thus, an experienced dev knows coupling is the bane of reusability. =\u0026gt; Maintainability The much more universal ISP benefit is that by avoiding unneeded dependencies, the system becomes easier to understand; lighter to test; quicker to change. Similarly, to the reader of your code, it would be harder to get an idea of what your class does from the class declaration line. So, if dev sees only the one god-interface that may have inherited other interfaces it will likely not be obvious. Compare 1 MyMachine : IMachine to\n1 MyMachine : IPrinter, IScanner, IFaxer The latter tells you a lot, the former makes you guess at best. Yardstick to Craft Interface Segregation Principle Friendly Software in C++ This principle comes naturally when you start decomposing your problem space by identifying major roles that take part in your domain. Hence, it\u0026rsquo;s never a mechanical action. Following a single question to your self may help you to rectify your design: Do I need all the methods on this interface I\u0026rsquo;m using?\nClosing Notes Even though big interfaces are a potential problem, the ISP isn\u0026rsquo;t about the size of interfaces. Rather, it\u0026rsquo;s about whether classes use the methods of the interfaces on which they depend. So ISP is poor guidance when designing software, but an excellent indicator of whether it’s healthy or not.\n","permalink":"https://vishalchovatiya.github.io/posts/interface-segregation-principle-in-cpp-solid-as-a-rock/","summary":"Interface Segregation Principle in C++ is the fourth \u0026amp; by far the simplest design principle of a series SOLID as a Rock design principles. The SOLID design principles focus on developing software that is easy to maintainable, reusable \u0026amp; extendable. In this article, we will see a code violating ISP, a solution to the same code, guideline \u0026amp; benefits of ISP.\nBy the way, If you haven\u0026rsquo;t gone through my previous articles on design principles, then below is the quick links:","title":"Interface Segregation Principle in C++ | SOLID as a Rock"},{"content":"Prototype Design Pattern is a Creational Design Pattern that helps in the prototyping(creating/copying cheaply) of an object using separate methods or polymorphic classes. You can consider the prototype as a template of an object before the actual object is constructed. In this article of the Creational Design Patterns, we\u0026rsquo;re going to take a look at why we need a Prototype Design Pattern in C++ i.e. motivation, prototype factory \u0026amp; leveraging prototype design pattern to implement virtual copy constructor.\nBy the way, If you haven’t check out my other articles on Creational Design Patterns, then here is the list:\nFactory Builder Prototype Singleton The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To create a new object cheaply with the help of an already constructed or pre-initialized stored object.\nThe prototype provides flexibility to create complex object cheaply. The concept is to copy an existing object rather than creating a new instance from scratch, something that may include costly operations. The existing object then acts as a prototype \u0026amp; newly copied object may change the same properties only if required. This approach saves costly resources and time, especially when the object creation is a heavy process. So essentially the prototype is quite simply a partially or fully initialized object that you make a copy of. And then you subsequently use for your own benefit with variations. Motivation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct Office { string m_street; string m_city; int32_t m_cubical; Office(string s, string c, int32_t n):m_street(s), m_city(c), m_cubical(n){} }; struct Employee { string m_name; Office\tm_office; Employee(string n, Office o):m_name(n), m_office(o){} }; int main() { Employee john{ \u0026#34;John Doe\u0026#34;, Office{\u0026#34;123 East Dr\u0026#34;, \u0026#34;London\u0026#34;, 123} }; Employee jane{ \u0026#34;Jane Doe\u0026#34;, Office{\u0026#34;123 East Dr\u0026#34;, \u0026#34;London\u0026#34;, 124} }; Employee jack{ \u0026#34;jack Doe\u0026#34;, Office{\u0026#34;123 ORR\u0026#34;, \u0026#34;Bangaluru\u0026#34;, 300} }; return EXIT_SUCCESS; } This is not the right approach as you have to write the main office address again \u0026amp; again for each employee detail. This is cumbersome \u0026amp; become more when you want to create an employee list. Moreover, consider the situation when your main office moved to another address. Prototype Design Pattern Examples in C++ A more pragmatic approach would be like this : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct Employee { string m_name; const Office* m_office; Employee(string n, Office *o):m_name(n), m_office(o){} }; static Office LondonOffice{\u0026#34;123 East Dr\u0026#34;, \u0026#34;London\u0026#34;, 123}; static Office BangaluruOffice{\u0026#34;RMZ Ecoworld ORR\u0026#34;, \u0026#34;London\u0026#34;, 123}; int main() { Employee john{ \u0026#34;John Doe\u0026#34;, \u0026amp;LondonOffice }; Employee jane{ \u0026#34;Jane Doe\u0026#34;, \u0026amp;LondonOffice }; Employee jack{ \u0026#34;jack Doe\u0026#34;, \u0026amp;BangaluruOffice }; return EXIT_SUCCESS; } Above solution is suitable for our use case but sometimes we want to customize that office address. And when it comes to pointers \u0026amp; references and any sort of indirection, ordinary copying using operator equals quite simply does not work. A standard way to implement this is by implementing the copy constructor Prototype Factory So in the previous example of the Prototype Design Pattern, we basically had a global object for office addresses and used their address for creating prototypes. Now, this isn\u0026rsquo;t particularly convenient to the consumers of your API because you might want to give them a prototype to work with. And you should explicit enough in terms of letting people know there is the only a unified way by which they create instances from a prototype and so that they cannot make individual instances by themselves. And in this case, what you would build is off-course is a Prototype Factory: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 struct Office { string m_street; string m_city; int32_t m_cubical; }; class Employee { string m_name; Office* m_office; // Private constructor, so direct instance can not be created except for `class EmployeeFactory` Employee(string n, Office *o) : m_name(n), m_office(o) {} friend class EmployeeFactory; public: Employee(const Employee \u0026amp;rhs) : m_name{rhs.m_name}, m_office{new Office{*rhs.m_office}} { } Employee\u0026amp; operator=(const Employee \u0026amp;rhs) { if (this == \u0026amp;rhs) return *this; m_name = rhs.m_name; m_office = new Office{*rhs.m_office}; return *this; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const Employee \u0026amp;o) { return os \u0026lt;\u0026lt; o.m_name \u0026lt;\u0026lt; \u0026#34; works at \u0026#34; \u0026lt;\u0026lt; o.m_office-\u0026gt;m_street \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; o.m_office-\u0026gt;m_city \u0026lt;\u0026lt; \u0026#34; seats @\u0026#34; \u0026lt;\u0026lt; o.m_office-\u0026gt;m_cubical; } }; class EmployeeFactory { static Employee main; static Employee aux; static unique_ptr\u0026lt;Employee\u0026gt; NewEmployee(string n, int32_t c, Employee \u0026amp;proto) { auto e = make_unique\u0026lt;Employee\u0026gt;(proto); e-\u0026gt;m_name = n; e-\u0026gt;m_office-\u0026gt;m_cubical = c; return e; } public: static unique_ptr\u0026lt;Employee\u0026gt; NewMainOfficeEmployee(string name, int32_t cubical) { return NewEmployee(name, cubical, main); } static unique_ptr\u0026lt;Employee\u0026gt; NewAuxOfficeEmployee(string name, int32_t cubical) { return NewEmployee(name, cubical, aux); } }; // Static Member Initialization Employee EmployeeFactory::main{\u0026#34;\u0026#34;, new Office{\u0026#34;123 East Dr\u0026#34;, \u0026#34;London\u0026#34;, 123}}; Employee EmployeeFactory::aux{\u0026#34;\u0026#34;, new Office{\u0026#34;RMZ Ecoworld ORR\u0026#34;, \u0026#34;London\u0026#34;, 123}}; int main() { auto jane = EmployeeFactory::NewMainOfficeEmployee(\u0026#34;Jane Doe\u0026#34;, 125); auto jack = EmployeeFactory::NewAuxOfficeEmployee(\u0026#34;jack Doe\u0026#34;, 123); cout \u0026lt;\u0026lt; *jane \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; *jack \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } /* Jane Doe works at 123 East Dr London seats @125 jack Doe works at RMZ Ecoworld ORR London seats @123 */ The subtle thing to note here is the private constructor of Employee \u0026amp; friend EmployeeFactory. This is how we enforce the client/API-user to create an instance of Employee only through EmployeeFactory . Leveraging Prototype Design Pattern to Implement Virtual Copy Constructor In C++, Prototype is also useful to create a copy of an object without knowing its concrete type. Hence, it is also known as Virtual Copy Constructor. Problem C++ has the support of polymorphic object destruction using it\u0026rsquo;s base class\u0026rsquo;s virtual destructor. Equivalent support for creation and copying of objects is missing as С++ doesn\u0026rsquo;t support virtual constructor \u0026amp; virtual copy constructors. Moreover, you can\u0026rsquo;t create an object unless you know its static type, because the compiler must know the amount of space it needs to allocate. For the same reason, copy of an object also requires its type to known at compile-time. Consider the following example as problem statement: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct animal { virtual ~animal(){ cout\u0026lt;\u0026lt;\u0026#34;~animal\\n\u0026#34;; } }; struct dog : animal { ~dog(){ cout\u0026lt;\u0026lt;\u0026#34;~dog\\n\u0026#34;; } }; struct cat : animal { ~cat(){ cout\u0026lt;\u0026lt;\u0026#34;~cat\\n\u0026#34;; } }; void who_am_i(animal *who) { // not sure whether dog would be passed here or cat // How to `create` the object of same type i.e. pointed by who ? // How to `copy` object of same type i.e. pointed by who ? delete who; // you can delete appropriate object pointed by who, thanks to virtual destructor } Just don\u0026rsquo;t think of dynamic_cast\u0026lt;\u0026gt;, its code smell. Solution The Virtual Constructor/Copy-Constructor technique allows polymorphic creation \u0026amp; copying of objects in C++ by delegating the act of creation \u0026amp; copying the object to the derived class through the use of virtual methods. Following code is not only implements virtual copy constructor (i.e. clone()) but also implement virtual constructor(i.e. create()`. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct animal { virtual ~animal() = default; virtual std::unique_ptr\u0026lt;animal\u0026gt; create() = 0; virtual std::unique_ptr\u0026lt;animal\u0026gt; clone() = 0; }; struct dog : animal { std::unique_ptr\u0026lt;animal\u0026gt; create() { return std::make_unique\u0026lt;dog\u0026gt;(); } std::unique_ptr\u0026lt;animal\u0026gt; clone() { return std::make_unique\u0026lt;dog\u0026gt;(*this); } }; struct cat : animal { std::unique_ptr\u0026lt;animal\u0026gt; create() { return std::make_unique\u0026lt;cat\u0026gt;(); } std::unique_ptr\u0026lt;animal\u0026gt; clone() { return std::make_unique\u0026lt;cat\u0026gt;(*this); } }; void who_am_i(animal *who) { auto new_who = who-\u0026gt;create();// `create` the object of same type i.e. pointed by who ? auto duplicate_who = who-\u0026gt;clone(); // `copy` object of same type i.e. pointed by who ? delete who; } Benefits of Prototype Design Pattern Prototypes are useful when the object instantiation is expensive, thus avoid expensive \u0026ldquo;creation from scratch\u0026rdquo;, and support cheap cloning of a pre-initialized prototype. The prototype provides the flexibility to create highly dynamic systems by defining new behaviour through object composition \u0026amp; specifying values for an object\u0026rsquo;s data members at the time of instantiation unlike defining new classes. You can simplify the system by producing complex objects more conveniently. Especially in C++, Prototype Design Pattern is helpful in creating copy of an object without even knowing its type. Summary by FAQs What\u0026rsquo;s the point of using the Prototype Design Pattern?\nTo create an object rapidly based on cloning a pre-configured object. Useful to remove a bunch of boilerplate code. Handly while working with object without knowing its type. Prototype Design Pattern is an obvious choice while you are working with the Command Design Pattern. For example, in HTTP request most of the time header \u0026amp; footer content remains the same, what changes are data. In such a scenario, you should not create an object from scratch. Rather leverage Prototype Design Pattern. Is the Prototype Design Pattern Really Just Clone?\nIt isn\u0026rsquo;t if you combine it with the Factory Design Pattern.\nPrototype design pattern to be used when creation is costly, but we do create in the clone.\nYou must be wondering that in Prototype Factory we show above, we are creating instances in the copy constructor. Isn\u0026rsquo;t that expensive. Yes, it is. But just think about HTTP request, its header consist version, encoding type, content type, server-type, etc. Initially, you need a find out these parameters using respective function calls. But once you got these, these are not going to change until connection closed. So there is no point in doing function calls to extract these params over \u0026amp; over. What cost us here is not parameters but their functions to extract value.\n","permalink":"https://vishalchovatiya.github.io/posts/prototype-design-pattern-in-modern-cpp/","summary":"Prototype Design Pattern is a Creational Design Pattern that helps in the prototyping(creating/copying cheaply) of an object using separate methods or polymorphic classes. You can consider the prototype as a template of an object before the actual object is constructed. In this article of the Creational Design Patterns, we\u0026rsquo;re going to take a look at why we need a Prototype Design Pattern in C++ i.e. motivation, prototype factory \u0026amp; leveraging prototype design pattern to implement virtual copy constructor.","title":"Prototype Design Pattern in Modern C++"},{"content":"In software engineering, Creational Design Patterns deal with object creation mechanisms, i.e. try to create objects in a manner suitable to the situation. The basic or ordinary form of object creation could result in design problems or added complexity to the design. In this article of the Creational Design Patterns, we\u0026rsquo;re going to take a look at the much-hated \u0026amp; commonly asked design pattern in a programming interview. That is Singleton Design Pattern in Modern C++ which criticizes for its extensibility \u0026amp; testability. I will also cover the Multiton Design Pattern which quite contrary to Singleton.\nBy the way, If you haven’t check out my other articles on Creational Design Patterns, then here is the list:\nFactory Builder Prototype Singleton The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To ensure one \u0026amp; only one instance of a class exist at any point in time.\nThe Singleton Design Pattern ensures that a class has only one instance and provides a global point of access to that instance. This is useful when exactly one object need to coordinate actions across the system. So, essentially, the Singleton Design Pattern is nothing more than specifying a lifetime. Singleton Design Pattern C++ Example The motivation for using a Singleton Design Pattern is fairly obvious. Some components in our system only need to have a single instance. For example, a database that loads up from its constructor into memory \u0026amp; then gives out information about its contents. Once it\u0026rsquo;s loaded up you don\u0026rsquo;t really want more than one instance of it because there is no point. And you also want to prevent your clients/API-users from making any additional copies of that object. Following is a trivial example of the Singleton Design Pattern in C++. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* country.txt Japan 1000000 India 2000000 America 123500 */ class SingletonDatabase { std::map\u0026lt;std::string, int32_t\u0026gt; m_country; SingletonDatabase() { std::ifstream ifs(\u0026#34;country.txt\u0026#34;); std::string city, population; while (getline(ifs, city)) { getline(ifs, population); m_country[city] = stoi(population); } } public: SingletonDatabase(SingletonDatabase const \u0026amp;) = delete; SingletonDatabase \u0026amp;operator=(SingletonDatabase const \u0026amp;) = delete; static SingletonDatabase \u0026amp;get() { static SingletonDatabase db; return db; } int32_t get_population(const std::string \u0026amp;name) { return m_country[name]; } }; int main() { SingletonDatabase::get().get_population(\u0026#34;Japan\u0026#34;); return EXIT_SUCCESS; } Some of the things to note here from the design perspective are:\nPrivate constructor\nDeleted copy constructor \u0026amp; copy assignment operator\nStatic object creation \u0026amp; static method to access\nThe Problem of Testability With Singleton So we have our Singleton database and let\u0026rsquo;s suppose that we decide to use this database to do some research and we actually made a new class called a SingletonRecordFinder which is going to find the total population from the collection of city names provided in the argument as follow. 1 2 3 4 5 6 7 8 struct SingletonRecordFinder { static int32_t total_population(const vector\u0026lt;string\u0026gt;\u0026amp; countries) { int32_t result = 0; for (auto \u0026amp;country : countries) result += SingletonDatabase::get().get_population(country); return result; } }; But let\u0026rsquo;s suppose that we decide that we want to test the SingletonRecordFinder and this is where all the problems show up. 1 2 vector\u0026lt;string\u0026gt; countries= {\u0026#34;Japan\u0026#34;, \u0026#34;India\u0026#34;}; // Strongly tied to data base entries TEST(1000000 + 2000000, SingletonRecordFinder::total_population(countries)); Unfortunately, because we are strongly tied to the real database and there is no way to substitute this database. I have to use the values taken from the actual file. And when later on these entries change, your test will start failing as you may have not updated the code. And this going to be a continuous problem. Moreover, this is not going to be a unit-test rather it is integration test as we are not only testing our code but also a production database which is not good design. Surely there is a better way of actually implementing this particular construct so that we can still use the singleton but if need we can supply an alternative to the singleton implementation with some dummy data of our own. Singleton Design Pattern With Dependency Injection The problem that we\u0026rsquo;re encountering in the testing of the SingletonRecordFinder is to do with the fact that we have a dependency upon essentially the details of how a database provides its data because we\u0026rsquo;re depending directly on the singleton database and the fact that it\u0026rsquo;s a singleton. So why don\u0026rsquo;t we use a little bit of dependency injection on an interface or abstract class! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct Database { // Dependency virtual int32_t get_population(const string\u0026amp; country) = 0; }; class SingletonDatabase : Database { map\u0026lt;string, int32_t\u0026gt; m_countries; SingletonDatabase() { ifstream ifs(\u0026#34;countries.txt\u0026#34;); string city, population; while (getline(ifs, city)) { getline(ifs, population); m_countries[city] = stoi(population); } } public: SingletonDatabase(SingletonDatabase const \u0026amp;) = delete; SingletonDatabase \u0026amp;operator=(SingletonDatabase const \u0026amp;) = delete; static SingletonDatabase \u0026amp;get() { static SingletonDatabase db; return db; } int32_t get_population(const string \u0026amp;country) { return m_countries[country]; } }; class DummyDatabase : public Database { map\u0026lt;string, int32_t\u0026gt; m_countries; public: DummyDatabase() : m_countries{{\u0026#34;alpha\u0026#34;, 1}, {\u0026#34;beta\u0026#34;, 2}, {\u0026#34;gamma\u0026#34;, 3}} {} int32_t get_population(const string \u0026amp;country) { return m_countries[country]; } }; /* Testing class ------------------------------------------------------------ */ class ConfigurableRecordFinder { Database\u0026amp; m_db; // Dependency Injection public: ConfigurableRecordFinder(Database \u0026amp;db) : m_db{db} {} int32_t total_population(const vector\u0026lt;string\u0026gt; \u0026amp;countries) { int32_t result = 0; for (auto \u0026amp;country : countries) result += m_db.get_population(country); return result; } }; /* ------------------------------------------------------------------------- */ int main() { DummyDatabase db; ConfigurableRecordFinder rf(db); rf.total_population({\u0026#34;Japan\u0026#34;, \u0026#34;India\u0026#34;, \u0026#34;America\u0026#34;}); return EXIT_SUCCESS; } Due to Dependency Injection i.e. Database interface, our both following issues are resolved: We have done a proper unit test rather an integration test, Now our testing class is not directly tie-up to Singleton. So no need to change our unit-test over \u0026amp; over in accordance with a database change. Multiton Design Pattern Multiton is a variation to singleton but not directly linked to it. Remember that singleton prevents you to have additional instances while Multiton Design Pattern sets up kind of key-value pair along with the limitation for the number of instance creation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 enum class Importance { PRIMARY, SECONDARY, TERTIARY }; template \u0026lt;typename T, typename Key = std::string\u0026gt; struct Multiton { static shared_ptr\u0026lt;T\u0026gt; get(const Key \u0026amp;key) { if (const auto it = m_instances.find(key); it != m_instances.end()) { // C++17 return it-\u0026gt;second; } return m_instances[key] = make_shared\u0026lt;T\u0026gt;(); } private: static map\u0026lt;Key, shared_ptr\u0026lt;T\u0026gt;\u0026gt; m_instances; }; template \u0026lt;typename T, typename Key\u0026gt; map\u0026lt;Key, shared_ptr\u0026lt;T\u0026gt;\u0026gt; Multiton\u0026lt;T, Key\u0026gt;::m_instances; // Just initialization of static data member struct Printer { Printer() { cout \u0026lt;\u0026lt; \u0026#34;Total instances so far = \u0026#34; \u0026lt;\u0026lt; ++InstCnt \u0026lt;\u0026lt; endl; } private: static int InstCnt; }; int Printer::InstCnt = 0; int main() { using mt = Multiton\u0026lt;Printer, Importance\u0026gt;; auto main = mt::get(Importance::PRIMARY); auto aux = mt::get(Importance::SECONDARY); auto aux2 = mt::get(Importance::SECONDARY); // Will not create additional instances return EXIT_SUCCESS; } So as you can see we have three printers i.e. primary, secondary \u0026amp; tertiary whose access \u0026amp; instantiation is controlled by Multiton. Rest of the code is self-explanatory I hope. Benefits of Singleton Design Pattern The Singleton Design Pattern is quite helpful for application configurations as configurations may need to be accessible globally, and future expansions to the application configurations can be consolidated at single place. A second common use of this class is in updating old code to work in a new architecture. Since developers may have used globals liberally, moving them into a single class and making it a singleton, can be an intermediary step to bring the program inline to the stronger object-oriented structure. Singleton Design Pattern also enhance the maintainability as it provides a single point of access to a particular instance. Summary by FAQs What is so bad about the Singleton Design Pattern?\nSingleton object holds the state for the lifetime of the application. Which is bad for testing since you can end up with a situation where tests need to be ordered which is a big no-no for unit tests. Why? Because each unit test should be independent of the other. Singleton object causes code to be tightly coupled. This makes guessing the expected result under test scenarios rather difficult as we have seen above in database example. But you can overcome it by using Dependency Injection along with Singleton Design Pattern. Imagine the situation where you have a concurrent application accessing Singleton object from every part of your application, It just mashes up things or slows it down if you use a mutex or any other synchronization primitives. What is the correct way to implement Singleton Design Pattern?\nThe right way to implement Singleton is by dependency injection, So instead of directly depending on a singleton, you might want to consider it depending on an abstraction(e.g. an interface). I would also encourage you to use synchronization primitives(like a mutex, semaphores, etc) to control access.\nWhen should you use the Singleton Design Pattern?\nUsually, Singleton is used in hardware interface usage limitation. For example, Printers are limited in numbers, so in such case, a singleton or multiton design pattern is used to manage access. Singleton Design Pattern is also widely employed in managing configuration or properties file to manage access. We can use the cache as a singleton object as it can have a global point of reference and for all future calls to the cache object, the client application will use the in-memory object. ","permalink":"https://vishalchovatiya.github.io/posts/singleton-design-pattern-in-modern-cpp/","summary":"In software engineering, Creational Design Patterns deal with object creation mechanisms, i.e. try to create objects in a manner suitable to the situation. The basic or ordinary form of object creation could result in design problems or added complexity to the design. In this article of the Creational Design Patterns, we\u0026rsquo;re going to take a look at the much-hated \u0026amp; commonly asked design pattern in a programming interview. That is Singleton Design Pattern in Modern C++ which criticizes for its extensibility \u0026amp; testability.","title":"Singleton Design Pattern in Modern C++"},{"content":" SRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle ","permalink":"https://vishalchovatiya.github.io/reusable_block/solid-design-principles/","summary":" SRP – Single Responsibility Principle OCP – Open/Closed Principle LSP – Liskov Substitution Principle ISP – Interface Segregation Principle DIP – Dependency Inversion Principle ","title":"SOLID Design Principles"},{"content":"In software engineering, Structural Design Patterns deal with the relationship between object \u0026amp; classes i.e. how object \u0026amp; classes interact or build a relationship in a manner suitable to the situation. The structural design patterns simplify the structure by identifying relationships. In this article of the Structural Design Patterns, we\u0026rsquo;re going to take a look at Adapter Design Pattern in Modern C++ which used to convert the interface of an existing class into another interface that client/API-user expect. Adapter Design Pattern makes classes work together that could not otherwise because of incompatible interfaces.\nBy the way, If you haven’t check out my other articles on Structural Design Patterns, then here is the list:\nAdapter Bridge Composite Decorator Facade Flyweight Proxy The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To get the interface you want from the interface you have.\nAn adapter allows two incompatible classes to work together by converting the interface of one class into an interface expected by the client/API-user without changing them. Basically, adding intermediate class i.e. Adapter. If you find yourself in a situation of using Adapter then you might be working on compatibility between libraries, modules, plugins, etc. If not then you might have serious design issues because, if you have followed Dependency Inversion Principle early in the design. Use of Adapter Design Pattern won\u0026rsquo;t be the case. Adapter Design Pattern Examples in C++ Implementing an Adapter Design Pattern is easy, just determine the API you have \u0026amp; the API you need. Create a component which aggregates(has a reference to,…) the adaptee. Classical Adapter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Point { int32_t m_x; virtual void draw(){ cout\u0026lt;\u0026lt;\u0026#34;Point\\n\u0026#34;; } }; struct Point2D : Point { int32_t m_y; void draw(){ cout\u0026lt;\u0026lt;\u0026#34;Point2D\\n\u0026#34;; } }; void draw_point(Point \u0026amp;p) { p.draw(); } struct Line { Point2D m_start; Point2D m_end; void draw(){ cout\u0026lt;\u0026lt;\u0026#34;Line\\n\u0026#34;; } }; struct LineAdapter : Point { Line\u0026amp; m_line; LineAdapter(Line \u0026amp;line) : m_line(line) {} void draw(){ m_line.draw(); } }; int main() { Line l; LineAdapter lineAdapter(l); draw_point(lineAdapter); return EXIT_SUCCESS; } You can also create a generic adapter by leveraging C++ template as follows: 1 2 3 4 5 6 template\u0026lt;class T\u0026gt; struct GenericLineAdapter : Point { T\u0026amp; m_line; GenericLineAdapter(T \u0026amp;line) : m_line(line) {} void draw(){ m_line.draw(); } }; The usefulness of the generic approach hopefully becomes more apparent when you consider that when you need to make other things Point-like, the non-generic approach becomes quickly very redundant. Pluggable Adapter Design Pattern using Modern C++ The Adapter should support the adaptees(which are unrelated and have different interfaces) using the same old target interface known to the client/API-user. Below example satisfy this property by using C++11\u0026rsquo;s lambda function \u0026amp; functional header. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Legacy code -------------------------------------------------------------- */ struct Beverage { virtual void getBeverage() = 0; }; struct CoffeeMaker : Beverage { void Brew() { cout \u0026lt;\u0026lt; \u0026#34;brewing coffee\u0026#34; \u0026lt;\u0026lt; endl;} void getBeverage() { Brew(); } }; void make_drink(Beverage \u0026amp;drink){ drink.getBeverage(); // Interface already shipped \u0026amp; known to client } /* --------------------------------------------------------------------------- */ struct JuiceMaker { // Introduced later on void Squeeze() { cout \u0026lt;\u0026lt; \u0026#34;making Juice\u0026#34; \u0026lt;\u0026lt; endl; } }; struct Adapter : Beverage { // Making things compatible function\u0026lt;void()\u0026gt; m_request; Adapter(CoffeeMaker* cm) { m_request = [cm] ( ) { cm-\u0026gt;Brew(); }; } Adapter(JuiceMaker* jm) { m_request = [jm] ( ) { jm-\u0026gt;Squeeze(); }; } void getBeverage() { m_request(); } }; int main() { Adapter adp1(new CoffeeMaker()); make_drink(adp1); Adapter adp2(new JuiceMaker()); make_drink(adp2); return EXIT_SUCCESS; } The pluggable adapter sorts out which object is being plugged in at the time. Once an object has been plugged in and its methods have been assigned to the delegate objects(i.e. m_request in our case), the association lasts until another set of methods is assigned. What characterizes a pluggable adapter is that it will have constructors for each of the types that it adapts. In each of them, it does the delegate assignments (one, or more than one if there are further methods for rerouting). Pluggable adapter provides the following two main benefits: You can bind an interface(bypassing lambda function in constructor argument), unlike the object we did in the above example. This also helps when adapter \u0026amp; adaptee have a different number of the argument. Benefits of Adapter Design Pattern Open-Closed Principle: One advantage of the Adapter Pattern is that you don\u0026rsquo;t need to change the existing class or interface. By introducing a new class, which acts as an adapter between the interface and the class, you avoid any changes to the existing code. This also limits the scope of your changes to your software component and avoids any changes and side-effects in other components or applications. By above two-point i.e. separate class(i.e. Single Responsibility Principle) for special functionality \u0026amp; fewer side-effects, it\u0026rsquo;s obvious we do requires less maintenance, learning curve \u0026amp; testing. AdapterDesing Pattern also adheres to the Dependency Inversion Principle, due to which you can preserve binary compatibility between multiple releases. Summary by FAQs When to use the Adapter Design Pattern?\nUse the Adapter class when you want to use some existing class, but its interface isn\u0026rsquo;t compatible with the rest of your code. When you want to reuse several existing subclasses that lack some common functionality that can’t be added to the superclass. For example, let say you have a function which accepts weather object \u0026amp; prints temperature in Celsius. But now you need to print the temperature in Fahrenheit. In this case of an incompatible situation, you can employ the Adapter Design Pattern. Real-life \u0026amp; practical example of the Adapter Design Pattern?\nIn STL, stack, queue \u0026amp; priority_queue are adaptors from deque \u0026amp; vector. When stack executes stack::push(), the underlying vector does vector::push_back() A card reader which acts as an adapter between the memory card and a laptop. Your mobile \u0026amp; laptop charges are kind of adapter which converts standard voltage \u0026amp; current to the required one for your device. What are the differences between Bridge \u0026amp; Adapter Design Pattern?\nAdapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely. Bridge is usually designed up-front, letting you develop parts of an application independently of each other. What is the difference between Decorator \u0026amp; Adapter Design Pattern?\nAdapter converts one interface to another, without adding additional functionalities Decorator adds new functionality into an existing interface. What is the difference between Proxy \u0026amp; Adapter Design Pattern?\nAdapter Design Pattern translates the interface for one class into a compatible but different interface. Proxy provides the same but easy interface or some time act as the only wrapper. ","permalink":"https://vishalchovatiya.github.io/posts/adapter-design-pattern-in-modern-cpp/","summary":"In software engineering, Structural Design Patterns deal with the relationship between object \u0026amp; classes i.e. how object \u0026amp; classes interact or build a relationship in a manner suitable to the situation. The structural design patterns simplify the structure by identifying relationships. In this article of the Structural Design Patterns, we\u0026rsquo;re going to take a look at Adapter Design Pattern in Modern C++ which used to convert the interface of an existing class into another interface that client/API-user expect.","title":"Adapter Design Pattern in Modern C++"},{"content":"Bridge Design Pattern is a Structural Design Pattern used to decouple a class into two parts – abstraction and it’s implementation – so that both can be developed independently. This promotes the loose coupling between class abstraction \u0026amp; its implementation. You get this decoupling by adding one more level of indirection i.e. an interface which acts as a bridge between your original class \u0026amp; functionality. Insulation is another name of Bridge Design Pattern in C++ world.\n\u0026ldquo;All problems in computer science can be solved by another level of indirection.\u0026rdquo; – David Wheeler\nBy the way, If you haven’t check out my other articles on Structural Design Patterns, then here is the list:\nAdapter Bridge Composite Decorator Facade Flyweight Proxy The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To separate the interface from its implementation.\nIn other words, It\u0026rsquo;s all about connecting components together through flexible abstractions using aggregation/composition rather than inheritance/generalization. This pattern involves an interface which acts as a bridge. That makes the functionality of concrete classes independent from interface implementer classes. Both types of classes can alter structurally without affecting each other. Motivation for Bridge Design Pattern Bridge Design Pattern prevents Cartesian Product complexity explosion. Don\u0026rsquo;t be scared with this mathematical term, I have simplified it with an example below. So, for example, let\u0026rsquo;s suppose that you have some base class called Shape and then the Shape can be Circle or Square and it can also be drawn by API 1 or API 2. 1 2 3 4 5 6 7 8 9 10 11 struct DrawingAPI_1 { }; struct DrawingAPI_2 { }; struct Shape { virtual void draw() = 0; }; /* 2 x 2 scenario */ struct Circle : Shape, DrawingAPI_1 { }; struct Circle : Shape, DrawingAPI_2 { }; struct Square : Shape, DrawingAPI_1 { }; struct Square : Shape, DrawingAPI_2 { }; This way you end up having a two by two(2x2) scenario. So if you decide to implement it you have to implement four classes. One for you know the Circle with API_1, Circle with API_2 and so on. The Bridge Design Pattern is precisely the pattern that actually avoids this whole entity explosion. So instead of having something like above, what we can do is we design the DrawingAPI interface(which later on used to derive API 1 \u0026amp; 2) and aggregate it in Circle \u0026amp; Square. Bridge Design Pattern C++ Example So following is the typical implementation of the Bridge Design Pattern. We are not going to look at anything quite so complicated here. But essentially a bridge is a mechanism that decouples the interface or the hierarchy from the implementation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct DrawingAPI { virtual void drawCircle() = 0; }; struct DrawingAPI_1 : DrawingAPI { void drawCircle() { cout \u0026lt;\u0026lt; \u0026#34;Drawn by API 1\u0026#34;\u0026lt;\u0026lt; endl; } }; struct DrawingAPI_2 : DrawingAPI { void drawCircle() { cout \u0026lt;\u0026lt; \u0026#34;Drawn by API 2\u0026#34;\u0026lt;\u0026lt; endl; } }; struct Shape { Shape(DrawingAPI \u0026amp;drawingAPI) : m_drawingAPI{drawingAPI} {} virtual void draw() = 0; protected: DrawingAPI \u0026amp;m_drawingAPI; // Now Shapes does not need to worry about drawing APIs }; struct Circle : Shape { Circle(DrawingAPI \u0026amp;drawingAPI) : Shape{drawingAPI} {} void draw() { m_drawingAPI.drawCircle(); } }; int main() { DrawingAPI_1 API_1; DrawingAPI_2 API_2; Circle(API_1).draw(); Circle(API_2).draw(); return EXIT_SUCCESS; } This way you don\u0026rsquo;t rely as much as on inheritance and aggregation. Rather you rely on the interface. Bridge Design Pattern using C++ Idiom: Pointer to Implementation(PIMPL) How can we forget the PIMPLE idiom while we are discussing the Bridge Design Pattern! PIMPLE is the manifestation of the bridge design pattern albeit a slightly different one. PIMPL idiom is all about hiding the implementation details of a particular class by sticking it into separate implementation pointed by pointer just as the name suggests. Let me show you how this works: Person.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #pragma once #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; struct Person { /* PIMPL ------------------------------------ */ class PersonImpl; unique_ptr\u0026lt;PersonImpl\u0026gt; m_impl; // bridge - not necessarily inner class, can vary /* ------------------------------------------ */ string m_name; Person(); ~Person(); void greet(); private: // secret data members or methods are in `PersonImpl` not here // as we are going to expose this class to client }; Person.cpp \u0026lt;\u0026ndash; will be turned into shared library(.so/.dll), to hide the business logic\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026#34;Person.h\u0026#34; /* PIMPL Implementation ------------------------------------ */ struct Person::PersonImpl { void greet(Person *p) { cout \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; p-\u0026gt;name.c_str() \u0026lt;\u0026lt; endl; } }; /* --------------------------------------------------------- */ Person::Person() : m_impl(new PersonImpl) { } Person::~Person() { delete m_impl; } void Person::greet() { m_impl-\u0026gt;greet(this); } OK, so this is the pimple idiom in it\u0026rsquo;s kind of concise form shall we say. And the question is Well why would you want to do this in the first place. Security purpose, you might have a question that any way we are going to expose header file to the client which contains API of a class, then how do we get security here? Well, just think about the data members \u0026amp; private methods. If you have trade secrets \u0026amp; having a data member which contains critical information. Why do you even let the client know the name of the object? One more benefit of PIMPL is compilation time which is critical for C++ as it widely criticized for it. But this is becoming less and less relevant as the compilers become more and more incremental. And they are really fantastic nowadays. Secure \u0026amp; Faster PIMPL As we have to use all the API using indirection provided by unique_ptr which accounts for some run-time overhead as we have to dereference the pointer every time for access. Plus we also have construction \u0026amp; destruction overhead of unique_ptrbecause it creates a memory in a heap which involves many other functions calling along with system calls. Moreover, we also have to baer some indirection if we want to access the data member of Person in PersonImpl like passing this pointer or so. Person.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #pragma once #include \u0026lt;string\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;type_traits\u0026gt; struct Person { Person(); ~Person(); void greet(); private: static constexpr size_t m_size = 1024; using pimpl_storage_t = aligned_storage\u0026lt;m_size, alignment_of_v\u0026lt;max_align_t\u0026gt;\u0026gt;::type; string m_name; pimpl_storage_t m_impl; }; Person.cpp \u0026lt;\u0026ndash; will be turned into shared library(.so/.dll), to hide the business logic\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026#34;Person.h\u0026#34; #include \u0026lt;iostream\u0026gt; struct PersonImpl { void greet(string \u0026amp;name) { cout \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } }; Person::Person() { static_assert(sizeof(impl) \u0026gt;= sizeof(PersonImpl)); // Compile time safety new(\u0026amp;impl) PersonImpl; } Person::~Person() { reinterpret_cast\u0026lt;PersonImpl*\u0026gt;(\u0026amp;impl)-\u0026gt;~PersonImpl(); } void Person::greet() { reinterpret_cast\u0026lt;PersonImpl*\u0026gt;(\u0026amp;impl)-\u0026gt;greet(name); } So let\u0026rsquo;s address this issue with placement new operator \u0026amp; preallocated aligned memory buffer. reinterpret_cast is just compile-time substitute so there won\u0026rsquo;t be any other indirection. Benefits of Bridge Design Pattern Bridge Design Pattern provides flexibility to develop abstraction(i.e. interface) and the implementation independently. And the client/API-user code can access only the abstraction part without being concerned about the Implementation part. It preserves the Open-Closed Principle, in other words, improves extensibility as client/API-user code relies on abstraction only so implementation can modify or augmented any time. By using the Bridge Design Pattern in the form of PIMPL. We can hide the implementation details from the client as we did in PIMPL idiom example above. The Bridge Design Pattern is an application of the old advice, “prefer composition over inheritance” but in a smarter way. It comes handy when you must subclass different times in ways that are orthogonal with one another(say 2x2 problem discuss earlier). A compile-time binding between an abstraction and its implementation should be avoided. So that an implementation can select at run-time. Summary by FAQs What is the practical use case of Bridge Design Pattern?\nPlugins in any internet browser leverage this pattern directly where browser specifies only abstraction \u0026amp; implementation varies by different types of plugins.\nWhen to use Bridge Design Pattern?\nWhen you are unsure of implementation or its variations \u0026amp; still you want to move forward with development. In case of a behaviour permutation problem i.e. Cartesian Product Complexity Explosion. What are the differences between Adapter \u0026amp; Bridge Design Pattern?\nAdapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely. Bridge is usually designed up-front, letting you develop parts of an application independently of each other. What are the differences between Strategy \u0026amp; Bridge Design Pattern?\nStrategy is a single dimension problem like Multi-bit screwdriver. Bridge is a multi-dimension problem like communication types \u0026amp; devices. ","permalink":"https://vishalchovatiya.github.io/posts/bridge-design-pattern-in-modern-cpp/","summary":"Bridge Design Pattern is a Structural Design Pattern used to decouple a class into two parts – abstraction and it’s implementation – so that both can be developed independently. This promotes the loose coupling between class abstraction \u0026amp; its implementation. You get this decoupling by adding one more level of indirection i.e. an interface which acts as a bridge between your original class \u0026amp; functionality. Insulation is another name of Bridge Design Pattern in C++ world.","title":"Bridge Design Pattern in Modern C++"},{"content":"GoF describes the Composite Design Pattern as “Compose objects into a tree structure to represent part-whole hierarchies. Composite lets the client treat individual objects and compositions of objects uniformly”. This seems over-complicated to me. So, I would not go into tree-leaf kind of jargon. Rather I directly saw you 2 or 3 different ways to implement Composite Design Pattern in Modern C++. But in simple words, the Composite Design Pattern is a Structural Design Pattern with a goal to treat the group of objects in the same manner as a single object.\nBy the way, If you haven’t check out my other articles on Structural Design Patterns, then here is the list:\nAdapter Bridge Composite Decorator Facade Flyweight Proxy The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To treat individual \u0026amp; group of objects in a uniform manner.\nSo what is it all about and why do we need it. Well, we know that objects typically use other objects fields or properties or members through either inheritance or composition. For example, in drawing applications, you have a Shape(e.g. Circle) that you can draw on the screen but you can also have a group of Shapes(e.g. vector\u0026lt;Circle\u0026gt;) which inherits from a collection Shape. And they have certain common API which you can then call on one or the other without knowing in advance whether you\u0026rsquo;re working with a single element or with the entire collection. Composite Design Pattern Examples in C++ So if you think about an application such as PowerPoint or any kind of vector drawing application you know that you can draw \u0026amp; drag individual shapes around. But you can also group shapes together. And when you group several shapes together you can treat them as if they were a single shape. So you can grab the entire thing and also drag it and resize it and whatnot. So, we\u0026rsquo;re going to implement the Composite Design Pattern around this idea of several different shapes. Classical Composite Design Pattern 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 struct Shape { virtual void draw() = 0; }; struct Circle : Shape { void draw() { cout \u0026lt;\u0026lt; \u0026#34;Circle\u0026#34; \u0026lt;\u0026lt; endl; } }; struct Group : Shape { string m_name; vector\u0026lt;Shape*\u0026gt; m_objects; Group(const string \u0026amp;n) : m_name{n} {} void draw() { cout \u0026lt;\u0026lt; \u0026#34;Group \u0026#34; \u0026lt;\u0026lt; m_name.c_str() \u0026lt;\u0026lt; \u0026#34; contains:\u0026#34; \u0026lt;\u0026lt; endl; for (auto \u0026amp;\u0026amp;o : m_objects) o-\u0026gt;draw(); } }; int main() { Group root(\u0026#34;root\u0026#34;); root.m_objects.push_back(new Circle); Group subgroup(\u0026#34;sub\u0026#34;); subgroup.m_objects.push_back(new Circle); root.m_objects.push_back(\u0026amp;subgroup); root.draw(); return EXIT_SUCCESS; } /* Group root contains: Circle Group sub contains: Circle */ Composite Design Pattern using Curiously Recurring Template Pattern(CRTP) As you\u0026rsquo;ve probably noticed machine learning is a really hot topic nowadays. And part of the machine learning mechanics is to use of neural networks so that\u0026rsquo;s what we\u0026rsquo;re going to take a look at now. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct Neuron { vector\u0026lt;Neuron*\u0026gt; in, out; uint32_t id; Neuron() { static int id = 1; this-\u0026gt;id = id++; } void connect_to(Neuron \u0026amp;other) { out.push_back(\u0026amp;other); other.in.push_back(this); } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const Neuron \u0026amp;obj) { for (Neuron *n : obj.in) os \u0026lt;\u0026lt; n-\u0026gt;id \u0026lt;\u0026lt; \u0026#34;\\t--\u0026gt;\\t[\u0026#34; \u0026lt;\u0026lt; obj.id \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; for (Neuron *n : obj.out) os \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; obj.id \u0026lt;\u0026lt; \u0026#34;]\\t--\u0026gt;\\t\u0026#34; \u0026lt;\u0026lt; n-\u0026gt;id \u0026lt;\u0026lt; endl; return os; } }; int main() { Neuron n1, n2; n1.connect_to(n2); cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } /* Output [1]\t--\u0026gt;\t2 1\t--\u0026gt;\t[2] */ As you can see we have a neuron structure which has connections to other neurons that modelled as vectors of pointers for input-output neuron connection. This is a very basic implementation and it works just fine as long as you just have individual neurons. Now the one thing that we haven\u0026rsquo;t accounted for is what happens when you have more than one neuron or group of neurons to connect. Let\u0026rsquo;s suppose that we decide to make a neuron layer and now a layer of neurons is basically like a collection. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct NeuronLayer : vector\u0026lt;Neuron\u0026gt; { NeuronLayer(int count) { while (count-- \u0026gt; 0) emplace_back(Neuron{}); } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, NeuronLayer \u0026amp;obj) { for (auto \u0026amp;n : obj) os \u0026lt;\u0026lt; n; return os; } }; int main() { NeuronLayer l1{1}, l2{2}; Neuron n1, n2; n1.connect_to(l1); // Neuron connects to Layer l2.connect_to(n2); // Layer connects to Neuron l1.connect_to(l2); // Layer connects to Layer n1.connect_to(n2); // Neuron connects to Neuron return EXIT_SUCCESS; } Now as you probably guessed if you were to implement this head-on you\u0026rsquo;re going to have a total of four different functions. i.e. 1 2 3 4 Neuron::connect_to(NeuronLayer\u0026amp;) NeuronLayer::connect_to(Neuron\u0026amp;) NeuronLayer::connect_to(NeuronLayer\u0026amp;) Neuron::connect_to(Neuron\u0026amp;) So this is state-space explosion \u0026amp; permutation problem and it\u0026rsquo;s not good because we want a single function that enumerable both the layer as well as individual neurons. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 template \u0026lt;typename Self\u0026gt; struct SomeNeurons { template \u0026lt;typename T\u0026gt; void connect_to(T \u0026amp;other); }; struct Neuron : SomeNeurons\u0026lt;Neuron\u0026gt; { vector\u0026lt;Neuron*\u0026gt; in, out; uint32_t id; Neuron() { static int id = 1; this-\u0026gt;id = id++; } Neuron* begin() { return this; } Neuron* end() { return this + 1; } }; struct NeuronLayer : vector\u0026lt;Neuron\u0026gt;, SomeNeurons\u0026lt;NeuronLayer\u0026gt; { NeuronLayer(int count) { while (count-- \u0026gt; 0) emplace_back(Neuron{}); } }; template \u0026lt;typename Self\u0026gt; template \u0026lt;typename T\u0026gt; void SomeNeurons\u0026lt;Self\u0026gt;::connect_to(T \u0026amp;other) { for (Neuron \u0026amp;from : *static_cast\u0026lt;Self *\u0026gt;(this)) { for (Neuron \u0026amp;to : other) { from.out.push_back(\u0026amp;to); to.in.push_back(\u0026amp;from); } } } template \u0026lt;typename Self\u0026gt; ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, SomeNeurons\u0026lt;Self\u0026gt; \u0026amp;object) { for (Neuron \u0026amp;obj : *static_cast\u0026lt;Self *\u0026gt;(\u0026amp;object)) { for (Neuron *n : obj.in) os \u0026lt;\u0026lt; n-\u0026gt;id \u0026lt;\u0026lt; \u0026#34;\\t--\u0026gt;\\t[\u0026#34; \u0026lt;\u0026lt; obj.id \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; for (Neuron *n : obj.out) os \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; obj.id \u0026lt;\u0026lt; \u0026#34;]\\t--\u0026gt;\\t\u0026#34; \u0026lt;\u0026lt; n-\u0026gt;id \u0026lt;\u0026lt; endl; } return os; } int main() { Neuron n1, n2; NeuronLayer l1{1}, l2{2}; n1.connect_to(l1); // Scenario 1: Neuron connects to Layer l2.connect_to(n2); // Scenario 2: Layer connects to Neuron l1.connect_to(l2); // Scenario 3: Layer connects to Layer n1.connect_to(n2); // Scenario 4: Neuron connects to Neuron cout \u0026lt;\u0026lt; \u0026#34;Neuron \u0026#34; \u0026lt;\u0026lt; n1.id \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Neuron \u0026#34; \u0026lt;\u0026lt; n2.id \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Layer \u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; l1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Layer \u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; l2 \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } /* Output Neuron 1 [1]\t--\u0026gt;\t3 [1]\t--\u0026gt;\t2 Neuron 2 4\t--\u0026gt;\t[2] 5\t--\u0026gt;\t[2] 1\t--\u0026gt;\t[2] Layer 1\t--\u0026gt;\t[3] [3]\t--\u0026gt;\t4 [3]\t--\u0026gt;\t5 Layer 3\t--\u0026gt;\t[4] [4]\t--\u0026gt;\t2 3\t--\u0026gt;\t[5] [5]\t--\u0026gt;\t2 */ As you can see we have covered all four different permutation scenarios using a single SomeNeurons::connect_to method with the help of CRTP. And both Neuron \u0026amp; NeuronLayer conforms to this interface via self templatization. Curiously Recurring Template Pattern comes handy here \u0026amp; has very straight implementation rule i.e. separate out the type-dependent \u0026amp; independent functionality and bind type independent functionality with the base class using self-referencing template. I have written a separate article on Advanced C++ Concepts \u0026amp; Idioms including CRTP. Benefits of Composite Design Pattern Reduces code complexity by eliminating many loops over the homogeneous collection of objects. This intern increases the maintainability \u0026amp; testability of code with fewer chances to break existing running \u0026amp; tested code. The relationship is described in the Composite Design Pattern isn\u0026rsquo;t a subclass relationship, it\u0026rsquo;s a collection relationship. Which means client/API-user does not need to care about operations(like translating, rotating, scaling, drawing, etc.) whether it is a single object or an entire collection. Summary by FAQs When should I use the Composite Design Pattern?\nYou want clients to be able to ignore the difference between the group of objects and individual objects. When you find that you are using multiple objects in the same way, and looping over to perform a somewhat similar action, then composite is a good choice. What is the common example of the Composite Design Pattern?\nFile \u0026amp; Folder(collection of files): Here File is a single class. Folder inherits File and holds a collection of Files. What is the difference between Decorator \u0026amp; Composite Design Pattern?\nDecorator works on enhancing interface. Composition works to unify interfaces for single \u0026amp; group of objects. ","permalink":"https://vishalchovatiya.github.io/posts/composite-design-pattern-in-modern-cpp/","summary":"GoF describes the Composite Design Pattern as “Compose objects into a tree structure to represent part-whole hierarchies. Composite lets the client treat individual objects and compositions of objects uniformly”. This seems over-complicated to me. So, I would not go into tree-leaf kind of jargon. Rather I directly saw you 2 or 3 different ways to implement Composite Design Pattern in Modern C++. But in simple words, the Composite Design Pattern is a Structural Design Pattern with a goal to treat the group of objects in the same manner as a single object.","title":"Composite Design Pattern in Modern C++"},{"content":"In software engineering, Structural Design Patterns deal with the relationship between object \u0026amp; classes i.e. how object \u0026amp; classes interact or build a relationship in a manner suitable to the situation. The Structural Design Patterns simplify the structure by identifying relationships. In this article of the Structural Design Patterns, we\u0026rsquo;re going to take a look at the not so complex yet subtle design pattern that is Decorator Design Pattern in Modern C++ due to its extensibility \u0026amp; testability. It is also known as Wrapper.\nBy the way, If you haven’t check out my other articles on Structural Design Patterns, then here is the list:\nAdapter Bridge Composite Decorator Facade Flyweight Proxy The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To facilitates the additional functionality to objects.\nSometimes we have to augment the functionality of existing objects without rewrite or altering existing code, just to stick to the Open-Closed Principle. This also preserves the Single Responsibility Principle to have extra functionality on the side. Decorator Design Pattern Examples in C++ And to achieve this we have two different variants of Decorator Design Pattern in C++: Dynamic Decorator: Aggregate the decorated object by reference or pointer. Static Decorator: Inherit from the decorated object. Dynamic Decorator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 struct Shape { virtual operator string() = 0; }; struct Circle : Shape { float m_radius; Circle(const float radius = 0) : m_radius{radius} {} void resize(float factor) { m_radius *= factor; } operator string() { ostringstream oss; oss \u0026lt;\u0026lt; \u0026#34;A circle of radius \u0026#34; \u0026lt;\u0026lt; m_radius; return oss.str(); } }; struct Square : Shape { float m_side; Square(const float side = 0) : m_side{side} {} operator string() { ostringstream oss; oss \u0026lt;\u0026lt; \u0026#34;A square of side \u0026#34; \u0026lt;\u0026lt; m_side; return oss.str(); } }; So, we have a hierarchy of two different Shapes(i.e. Square \u0026amp; Circle) \u0026amp; we want to enhance this hierarchy by adding colour to it. Now we\u0026rsquo;re suddenly not going to create two other classes e.g. coloured circle \u0026amp; a coloured square. That would be too much \u0026amp; not a scalable option. Rather we can just have ColoredShape as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct ColoredShape : Shape { const Shape\u0026amp; m_shape; string m_color; ColoredShape(const Shape \u0026amp;s, const string \u0026amp;c) : m_shape{s}, m_color{c} {} operator string() { ostringstream oss; oss \u0026lt;\u0026lt; string(const_cast\u0026lt;Shape\u0026amp;\u0026gt;(m_shape)) \u0026lt;\u0026lt; \u0026#34; has the color \u0026#34; \u0026lt;\u0026lt; m_color; return oss.str(); } }; // we are not changing the base class of existing objects // cannot make, e.g., ColoredSquare, ColoredCircle, etc. int main() { Square square{5}; ColoredShape green_square{square, \u0026#34;green\u0026#34;}; cout \u0026lt;\u0026lt; string(square) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; string(green_square) \u0026lt;\u0026lt; endl; // green_circle.resize(2); // Not available return EXIT_SUCCESS; } Why this is a dynamic decorator?\nBecause you can instantiate the ColoredShape at runtime by providing needed arguments. In other words, you can decide at runtime that which Shape(i.e. Circle or Square) is going to be coloured.\nYou can even mix the decorators as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct TransparentShape : Shape { const Shape\u0026amp; m_shape; uint8_t m_transparency; TransparentShape(const Shape\u0026amp; s, const uint8_t t) : m_shape{s}, m_transparency{t} {} operator string() { ostringstream oss; oss \u0026lt;\u0026lt; string(const_cast\u0026lt;Shape\u0026amp;\u0026gt;(m_shape)) \u0026lt;\u0026lt; \u0026#34; has \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;float\u0026gt;(m_transparency) / 255.f * 100.f \u0026lt;\u0026lt; \u0026#34;% transparency\u0026#34;; return oss.str(); } }; int main() { TransparentShape TransparentShape{ColoredShape{Square{5}, \u0026#34;green\u0026#34;}, 51}; cout \u0026lt;\u0026lt; string(TransparentShape) \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } Limitation of Dynamic Decorator If you look at the definition of Circle, You can see that the circle has a method called resize() we can not use this method as we did aggregation on-base interface Shape \u0026amp; bound by the only method exposed in it.\nStatic Decorator The dynamic decorator is great if you don\u0026rsquo;t know which object you are going to decorate and you want to be able to pick them at runtime but sometimes you know the decorator you want at compile time in which case you can use a combination of C++ templates \u0026amp; inheritance. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 template \u0026lt;class T\u0026gt; // Note: `class`, not typename struct ColoredShape : T { static_assert(is_base_of\u0026lt;Shape, T\u0026gt;::value, \u0026#34;Invalid template argument\u0026#34;); // Compile time safety string m_color; template \u0026lt;typename... Args\u0026gt; ColoredShape(const string \u0026amp;c, Args \u0026amp;\u0026amp;... args) : m_color(c), T(std::forward\u0026lt;Args\u0026gt;(args)...) { } operator string() { ostringstream oss; oss \u0026lt;\u0026lt; T::operator string() \u0026lt;\u0026lt; \u0026#34; has the color \u0026#34; \u0026lt;\u0026lt; m_color; return oss.str(); } }; template \u0026lt;typename T\u0026gt; struct TransparentShape : T { uint8_t m_transparency; template \u0026lt;typename... Args\u0026gt; TransparentShape(const uint8_t t, Args... args) : m_transparency{t}, T(std::forward\u0026lt;Args\u0026gt;(args)...) { } operator string() { ostringstream oss; oss \u0026lt;\u0026lt; T::operator string() \u0026lt;\u0026lt; \u0026#34; has \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;float\u0026gt;(m_transparency) / 255.f * 100.f \u0026lt;\u0026lt; \u0026#34;% transparency\u0026#34;; return oss.str(); } }; int main() { ColoredShape\u0026lt;Circle\u0026gt; green_circle{\u0026#34;green\u0026#34;, 5}; green_circle.resize(2); cout \u0026lt;\u0026lt; string(green_circle) \u0026lt;\u0026lt; endl; // Mixing decorators TransparentShape\u0026lt;ColoredShape\u0026lt;Circle\u0026gt;\u0026gt; green_trans_circle{51, \u0026#34;green\u0026#34;, 5}; green_trans_circle.resize(2); cout \u0026lt;\u0026lt; string(green_trans_circle) \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } As you can see we can now call the resize()method which was the limitation of Dynamic Decorator. You can even mix the decorators as we did earlier. So essentially what this example demonstrates is that if you\u0026rsquo;re prepared to give up on the dynamic composition nature of the decorator and if you\u0026rsquo;re prepared to define all the decorators at compile time you get the added benefit of using inheritance. And that way you actually get the members of whatever object you are decorating being accessible through the decorator \u0026amp; mixed decorator. Functional Approach to Decorator Design Pattern using Modern C++ Up until now, we were talking about the Decorator Design Pattern which decorates over a class but you can do the same for functions. Following is a typical logger example for the same: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Need partial specialization for this to work template \u0026lt;typename T\u0026gt; struct Logger; // Return type and argument list template \u0026lt;typename R, typename... Args\u0026gt; struct Logger\u0026lt;R(Args...)\u0026gt; { function\u0026lt;R(Args...)\u0026gt; m_func; string m_name; Logger(function\u0026lt;R(Args...)\u0026gt; f, const string \u0026amp;n) : m_func{f}, m_name{n} { } R operator()(Args... args) { cout \u0026lt;\u0026lt; \u0026#34;Entering \u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; R result = m_func(args...); cout \u0026lt;\u0026lt; \u0026#34;Exiting \u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; return result; } }; template \u0026lt;typename R, typename... Args\u0026gt; auto make_logger(R (*func)(Args...), const string \u0026amp;name) { return Logger\u0026lt;R(Args...)\u0026gt;(std::function\u0026lt;R(Args...)\u0026gt;(func), name); } double add(double a, double b) { return a + b; } int main() { auto logged_add = make_logger(add, \u0026#34;Add\u0026#34;); auto result = logged_add(2, 3); return EXIT_SUCCESS; } Above example may seem a bit complex to you but if you have a clear understanding of variadic template then it won\u0026rsquo;t take more than 30 seconds to understand what\u0026rsquo;s going on here. Benefits of Decorator Design Pattern Decorator facilitates augmentation of the functionality for an existing object at run-time \u0026amp; compile time. Decorator also provides flexibility for adding any number of decorators, in any order \u0026amp; mixing it. Decorators are a nice solution to permutation issues because you can wrap a component with any number of Decorators. It is a wise choice to apply the Decorator Design Pattern for already shipped code. Because it enables backward compatibility of application \u0026amp; less unit level testing as changes do not affect other parts of code. Summary by FAQs When to use the Decorator Design Pattern?\nEmploy the Decorator Design Pattern when you need to be able to assign extra behaviours to objects at runtime without breaking the code that uses these objects. When the class has final keyword which means the class is not further inheritable. In such cases, the Decorator Design Pattern may come to rescue. What are the drawbacks of using the Decorator Design Pattern?\nDecorators can complicate the process of instantiating the component because you not only have to instantiate the component but wrap it in a number of Decorators. Overuse of Decorator Design Pattern may complicate the system in terms of both i.e. Maintainance \u0026amp; learning curve. Difference between Adapter \u0026amp; Decorator Design Pattern?\nAdapter changes the interface of an existing object Decorator enhances the interface of an existing object Difference between Proxy \u0026amp; Decorator Design Pattern?\nProxy provides a somewhat same or easy interface Decorator provides enhanced interface ","permalink":"https://vishalchovatiya.github.io/posts/decorator-design-pattern-in-modern-cpp/","summary":"In software engineering, Structural Design Patterns deal with the relationship between object \u0026amp; classes i.e. how object \u0026amp; classes interact or build a relationship in a manner suitable to the situation. The Structural Design Patterns simplify the structure by identifying relationships. In this article of the Structural Design Patterns, we\u0026rsquo;re going to take a look at the not so complex yet subtle design pattern that is Decorator Design Pattern in Modern C++ due to its extensibility \u0026amp; testability.","title":"Decorator Design Pattern in Modern C++"},{"content":"Facade Design Pattern is a Structural Design Pattern used to provide a unified interface to a complex system. It is same as Facade in building architecture, a Facade is an object that serves as a front-facing interface masking a more complex underlying system. A Facade Design Pattern in C++ can:\nImprove the readability \u0026amp; usability of a software library by masking interaction with more complex components by providing a single simplified API. Provide a context-specific interface to more generic functionality. Serve as a launching point for a broader refactor of monolithic or tightly-coupled systems in favour of more loosely-coupled code. Frankly speaking, even I don\u0026rsquo;t understand this point. I have just copied this from Wikipedia. Before we move forward, Let me correct the spelling of Facade i.e. \u0026ldquo;Façade\u0026rdquo; \u0026amp; it pronounces as \u0026ldquo;fa;sa;d\u0026rdquo;. A hook or tail added under the letters C called a cedilla used in most of the European languages to indicate a change of pronunciation for that particular letter. We will not go into details of it, otherwise, we would be out of topic.\nBy the way, If you haven’t check out my other articles on Structural Design Patterns, then here is the list:\nAdapter Bridge Composite Decorator Facade Flyweight Proxy The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To provide unified interface by hiding system complexities.\nThis is by far the simplest \u0026amp; easiest design pattern I have ever come across. In other words, the Facade Design Pattern is all about providing a simple \u0026amp; easy to understand interface over a large and sophisticated body of code. Facade Design Pattern Example in C++ Imagine you set up a smart house where everything is on the remote. So to turn the lights on you push lights on-button - And same for TV, AC, Alarm, Music, etc… When you leave a house you would need to push 100 buttons to make sure everything is off \u0026amp; are good to go which could be a little annoying if you are lazy like me. So I defined a Facade for leaving \u0026amp; coming back. (Facade functions represent buttons…). So when I come \u0026amp; leave I just make one call \u0026amp; it takes care of everything… 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 struct Alarm { void alarm_on() { cout \u0026lt;\u0026lt; \u0026#34;Alarm is on and house is secured\u0026#34;\u0026lt;\u0026lt;endl; } void alarm_off() { cout \u0026lt;\u0026lt; \u0026#34;Alarm is off and you can go into the house\u0026#34;\u0026lt;\u0026lt;endl; } }; struct Ac { void ac_on() { cout \u0026lt;\u0026lt; \u0026#34;Ac is on\u0026#34;\u0026lt;\u0026lt;endl; } void ac_off() { cout \u0026lt;\u0026lt; \u0026#34;AC is off\u0026#34;\u0026lt;\u0026lt;endl; } }; struct Tv { void tv_on() { cout \u0026lt;\u0026lt; \u0026#34;Tv is on\u0026#34;\u0026lt;\u0026lt;endl; } void tv_off() { cout \u0026lt;\u0026lt; \u0026#34;TV is off\u0026#34;\u0026lt;\u0026lt;endl; } }; struct HouseFacade { void go_to_work() { m_ac.ac_off(); m_tv.tv_off(); m_alarm.alarm_on(); } void come_home() { m_alarm.alarm_off(); m_ac.ac_on(); m_tv.tv_on(); } private: Alarm m_alarm; Ac m_ac; Tv m_tv; }; int main() { HouseFacade hf; //Rather than calling 100 different on and off functions thanks to facade I only have 2 functions... hf.go_to_work(); hf.come_home(); return EXIT_SUCCESS; } // Stolen from: https://en.wikibooks.org/wiki/C%2B%2B_Programming/Code/Design_Patterns Note that we have just combined the different none/somewhat-related classes into HouseFacade. We would also be able to use interface with polymorphic turn_on() \u0026amp; turn_off() method with override in respective subclasses, to create a collection of Ac, Tv, Alarm objects to add Composite Design Pattern for more sophistication. But that will complicate system further \u0026amp; add the learning curve. Which is exactly opposite for what Facade Design Pattern is used in the first place. Benefits of Facade Design Pattern Facade defines a higher-level interface that makes the subsystem easier to use by wrapping a complicated subsystem. This reduces the learning curve necessary to successfully leverage the subsystem. Summary by FAQs Is Facade a class which contains a lot of other classes?\nYes. It is a wrapper for many sub-systems in the application.\nWhat makes it a design pattern? For me, it is like a normal class.\nAll design patterns too are normal classes.\nWhat is the practical use case of the Facade Design Pattern?\nA typical application of Facade Design Pattern is console/terminal/command-prompt you find in Linux or Windows is a unified way to access machine functionality provided by OS.\nDifference between Adapter \u0026amp; Facade Design Pattern?\nAdapter wraps one class and the Facade may represent many classes\n","permalink":"https://vishalchovatiya.github.io/posts/facade-design-pattern-in-modern-cpp/","summary":"Facade Design Pattern is a Structural Design Pattern used to provide a unified interface to a complex system. It is same as Facade in building architecture, a Facade is an object that serves as a front-facing interface masking a more complex underlying system. A Facade Design Pattern in C++ can:\nImprove the readability \u0026amp; usability of a software library by masking interaction with more complex components by providing a single simplified API.","title":"Facade Design Pattern in Modern C++"},{"content":"Flyweight Design Pattern is a Structural Design Pattern that concerned with space optimization. It is a technique to minimizes memory footprint by sharing or avoiding redundancy as much as possible with other similar objects. Flyweight Design Pattern in Modern C++ is often used in a situation where object count is higher which uses an unacceptable amount of memory. Often some parts of these objects can be shared \u0026amp; kept in common data structures that can be used by multiple objects.\nIf you haven’t check out my other articles on Structural Design Patterns, then here is the list:\nAdapter Bridge Composite Decorator Facade Flyweight Proxy The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To avoid redundancy when storing data.\nFlyway Design Pattern is quite simply a space optimization technique. That allows you to use less memory by storing some of the common data to several items or several objects. We store it externally and simply refer(by reference, pointer or any other mechanism) to it when we actually need it. Flyweight Design Pattern Example in C++ Well, the one thing that we want to do if we\u0026rsquo;re storing lots of data is to avoid any redundancy. It\u0026rsquo;s like compression in images or films if you have the same block repeating over and over again. You probably want to actually avoid having that block take up memory. But instead, you just write it and say how many times it repeats. For example, let say you are designing a game. You\u0026rsquo;re going to have lots of users with identical first and/or last names. You are going to have lots of people called `John Smith`. But you\u0026rsquo;re also going to have lots of people called `John` and lots of people whose last name is `Smith`. And there are no point in actually storing the same first \u0026amp; last name combinations over \u0026amp; over again. Because you are simply wasting memory. So what you would do instead is you would store a list of names somewhere else. And then you would keep the pointers to those names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Note: You can try following code at https://wandbox.org/. #include \u0026lt;boost/bimap.hpp\u0026gt; struct User { User(string f, string l) : m_first_name{add(f)}, m_last_name{add(l)} { } string get_first_name() {return names.left.find(m_first_name)-\u0026gt;second;} string get_last_name() {return names.left.find(m_last_name)-\u0026gt;second;} friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, User\u0026amp; obj) { return os \u0026lt;\u0026lt; obj.get_first_name() \u0026lt;\u0026lt; \u0026#34;(id=\u0026#34; \u0026lt;\u0026lt; obj.m_first_name \u0026lt;\u0026lt; \u0026#34;), \u0026#34; \u0026lt;\u0026lt; obj.get_last_name() \u0026lt;\u0026lt; \u0026#34;(id=\u0026#34; \u0026lt;\u0026lt; obj.m_last_name \u0026lt;\u0026lt; \u0026#34;)\u0026#34; ; } protected: using key = uint32_t; static boost::bimap\u0026lt;key, string\u0026gt; names; static key seed; static key add(string s) { auto it = names.right.find(s); if (it == names.right.end()) { names.insert({++seed, s}); return seed; } return it-\u0026gt;second; } key m_first_name, m_last_name; }; User::key User::seed = 0; boost::bimap\u0026lt;User::key, string\u0026gt; User::names{}; int main() { User john_doe {\u0026#34;John\u0026#34;,\u0026#34;Doe\u0026#34;}; User jane_doe {\u0026#34;Jane\u0026#34;,\u0026#34;Doe\u0026#34;}; cout \u0026lt;\u0026lt; \u0026#34;John Details: \u0026#34; \u0026lt;\u0026lt; john_doe \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Jane Details: \u0026#34; \u0026lt;\u0026lt; jane_doe \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } /* John Details: John(id=1), Doe(id=2) Jane Details: Jane(id=3), Doe(id=2) */ If you see the essence from above flyweight implementation, it just storing data in the static qualified data structure by taking care of redundancy. So that it can be reusable between multiple objects of the same type. Implementing Flyweight Design Pattern using Boost The Flyweight Design Pattern isn\u0026rsquo;t exactly new. And this approach of caching information is something that people have already packaged into different libraries for you to use. So instead of building all these wonderful by maps and whatnot what you can do is just use a library solution. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;boost/flyweight.hpp\u0026gt; struct User { boost::flyweight\u0026lt;string\u0026gt; m_first_name, m_last_name; User(string f, string l) : m_first_name(f), m_last_name(l) { } }; int main() { User john_doe{ \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34; }; User jane_doe{ \u0026#34;Jane\u0026#34;, \u0026#34;Doe\u0026#34; }; cout\u0026lt;\u0026lt;boolalpha ; cout\u0026lt;\u0026lt;(\u0026amp;jane_doe.m_first_name.get() == \u0026amp;john_doe.m_first_name.get())\u0026lt;\u0026lt;endl; // False cout\u0026lt;\u0026lt;(\u0026amp;jane_doe.m_last_name.get() == \u0026amp;john_doe.m_last_name.get())\u0026lt;\u0026lt;endl; // True return EXIT_SUCCESS; } // Try @ https://wandbox.org/. As you can see, we are comparing the address of John\u0026rsquo;s last name \u0026amp; Jane\u0026rsquo;s last name in the main()function which prints out to be true if you run the above code suggesting that redundancy is perfectly taken cared by boost::flyweight\u0026lt;\u0026gt;. Benefits of Flyweight Design Pattern Facilitates the reuse of many fine-grained objects, making the utilization of large numbers of objects more efficient. - verbatim GoF. Improves data caching for higher response time. Data caching intern increases performance due to a lesser number of heavy objects Provide a centralized mechanism to control the states/common-attributes objects. Summary by FAQs When to use a Flyweight Design Pattern?\nIn need of a large number of objects When there is a repetitive creation of heavy objects which can be replaced by a few shared objects Difference between Singleton and Flyweight Design Pattern?\nIn Singleton Design Pattern, you cannot create more than one object. You need to reuse the existing object in all parts of the application. While in Flyweight Design Pattern you can have a large number of similar objects which can share a common single resource. Drawbacks of Flyweight Design Pattern?\nAs similar to Singleton Design Pattern, concurrency is also a headache in the Flyweight Design Pattern. Without appropriate measures, if you create Flyweight objects in a concurrent environment, you may end up having multiple instances of the same object which is not desirable.\n","permalink":"https://vishalchovatiya.github.io/posts/flyweight-design-pattern-in-modern-cpp/","summary":"Flyweight Design Pattern is a Structural Design Pattern that concerned with space optimization. It is a technique to minimizes memory footprint by sharing or avoiding redundancy as much as possible with other similar objects. Flyweight Design Pattern in Modern C++ is often used in a situation where object count is higher which uses an unacceptable amount of memory. Often some parts of these objects can be shared \u0026amp; kept in common data structures that can be used by multiple objects.","title":"Flyweight Design Pattern in Modern C++"},{"content":"In software engineering, Structural Design Patterns deal with the relationship between objects i.e. how objects/classes interact or build a relationship in a manner suitable to the situation. The Structural Design Patterns simplify the structure by identifying relationships. In this article of the Structural Design Patterns, we\u0026rsquo;re going to take a look at Proxy Design Pattern in C++ which dictates the way you access the object.\nIf you haven’t check out other Structural Design Patterns, then here is the list:\nAdapter Bridge Composite Decorator Facade Flyweight Proxy The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent An interface for accessing a particular resource.\nThe proxy acts as an interface to a particular resource which may be remote, expensive to construct or require some additional functionality like logging or something else. But the key thing about the proxy is that its interface looks just like the interface of the object that you are actually attempting to access. This interface could be a method, overloaded operator or another object of different/local class. Proxy Design Pattern Examples in C++ A very sophisticated example of the Proxy Design Pattern in C++ that you\u0026rsquo;re probably using every day already is a smart pointer (like std::unique_ptr, std::shared_ptr, etc.) from the standard library 1 2 3 // Ways to access object through pointer ptr-\u0026gt;print(); *ptr = 5; So let me give you an explanation as to why a smart pointer would be a proxy. Well just by seeing the above code snippet, you can not decide that ptr is a raw pointer or smart pointer. Thus smart pointer are proxies as they satisfy both the condition of proxy i.e. Provide an interface to access the resource. The interface looks just like the interface of the object. There are many different kinds of proxy available like Remote proxy, Virtual proxy, Protection proxy, Communication Proxy. We will see some of them here. Property Proxy As you probably know other programming languages such as C# have this idea of properties. There probably is nothing more than a field plus a getter \u0026amp; setter methods for that field. Let\u0026rsquo;s suppose that we wanted to get properties in C++ so we have written Property class as: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;typename T\u0026gt; struct Property { T m_value; Property(const T initialValue) { * this = initialValue; } operator T() { return m_value; } T operator = (T newValue) { return m_value = newValue; } }; struct Creature { Property\u0026lt;int32_t\u0026gt; m_strength{10}; Property\u0026lt;int32_t\u0026gt; m_agility{5}; }; int main() { Creature creature; creature.m_agility = 20; cout \u0026lt;\u0026lt; creature.m_agility \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } But seeing above code, you might be wondering that why don\u0026rsquo;t we just declare strength \u0026amp; agility as int32_t. Now let\u0026rsquo;s suppose that for some reason you actually wanted to \u0026ldquo;intercept\u0026rdquo; or \u0026ldquo;have to log\u0026rdquo; the assignments as well as the access to these fields. So you want something which is effective as a Property rather than designing the getter \u0026amp; setter method for all the attributes. Virtual Proxy So another type of proxy that you\u0026rsquo;re bound to encounter at some point is what\u0026rsquo;s called a Virtual Proxy. Now a Virtual Proxy gives you the appearance of working with the same object that you\u0026rsquo;re used to working with even though the object might not have even been created. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct Image { virtual void draw() = 0; }; struct Bitmap : Image { Bitmap(const string \u0026amp;filename) : m_filename(filename) { cout \u0026lt;\u0026lt; \u0026#34;Loading image from \u0026#34; \u0026lt;\u0026lt; m_filename \u0026lt;\u0026lt; endl; // Steps to load the image } void draw() { cout \u0026lt;\u0026lt; \u0026#34;Drawing image \u0026#34; \u0026lt;\u0026lt; m_filename \u0026lt;\u0026lt; endl; } string m_filename; }; int main() { Bitmap img_1{\u0026#34;image_1.png\u0026#34;}; Bitmap img_2{\u0026#34;image_2.png\u0026#34;}; (rand() % 2) ? img_1.draw() : img_2.draw(); return EXIT_SUCCESS; } As you can see above, Bitmap image is derived from the Image interface having polymorphic behaviour as draw() Bitmap loads the image eagerly in its constructor. At first sight, this seems ok, but the problem with this Bitmap is that we don\u0026rsquo;t really need to load the image until the drawing code fires. So there is no point on loading both the images in memory at the time of construction. Now let me show you how you can improve the above code without changing Bitmap. This kind of technique is quite useful when you are working with a third-party library \u0026amp; wants to write a wrapper around it for some performance improvements. 1 2 3 4 5 6 7 8 9 10 11 12 13 struct LazyBitmap : Image { LazyBitmap(const string \u0026amp;filename) : m_filename(filename) {} void draw() { if (!m_bmp) m_bmp = make_unique\u0026lt;Bitmap\u0026gt;(m_filename); m_bmp-\u0026gt;draw(); } unique_ptr\u0026lt;Bitmap\u0026gt; m_bmp{nullptr}; string m_filename; }; LazyBitmap img_1{\u0026#34;image_1.png\u0026#34;}; LazyBitmap img_2{\u0026#34;image_2.png\u0026#34;}; As you can see, we are not using Bitmap until we need it. Rather we are just caching file name to create Bitmap whenever somebody wants to draw an image. So if nobody wants to draw the image there is really no point in loading it from the file. Communication Proxy(Intuitive Proxy Design Pattern in C++) Communication Proxy is by far the most common \u0026amp; intuitive Proxy Design Pattern in C++ you might have come across. A straight forward example of communication proxy is subscript operator overloading. Consider the following example of user-defined type i.e. arr2D which works exactly as primitive type 2 dimensional array: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template \u0026lt;typename T\u0026gt; struct arr2D { struct proxy { proxy(T *arr) : m_arr_1D(arr) {} T \u0026amp;operator[](int32_t idx) { return m_arr_1D[idx]; } T *m_arr_1D; }; arr2D::proxy operator[](int32_t idx) { return arr2D::proxy(m_arr_2D[idx]); } T m_arr_2D[10][10]; }; int main() { arr2D\u0026lt;int32_t\u0026gt; arr; arr[0][0] = 1; // Uses the proxy object return EXIT_SUCCESS; } Benefits of Proxy Design Pattern The proxy provides a nice \u0026amp; easy interface for even complex data arrangements. Proxy Design Pattern especially Virtual Proxy also provides performance improvement as we have seen in lazy image loading case above. Property proxy provides the flexibility of logging access to object attributes without the client even knowing. Summary by FAQs Is Decorator \u0026amp; Proxy Design Patterns are the same?\nThey are kind of similar(as both use composition) but used for a different purpose. For example, if you consider the above examples, Proxy usually manages the life cycle \u0026amp; access to objects, whereas the Decorators is a wrapper of the original object having more functionality.\nDifference between Adapter, Decorator \u0026amp; Proxy Design Pattern?\nAdapter provides a different/compatible interface to the wrapped object Proxy provides a somewhat same or easy interface Decorator provides enhanced interface What are the use cases of Proxy Design Pattern?\nWhen your objects are resource consuming and you have the most of their time stored on disk, you can use the proxy to act as a placeholder(like we did in lazy image loading above). When you want to add access restrictions like object is accessed read-only or making user-based access control before really doing the operations (e.g. if the user is authorised, do the operation, if not, throw an access control exception) ","permalink":"https://vishalchovatiya.github.io/posts/proxy-design-pattern-in-modern-cpp/","summary":"In software engineering, Structural Design Patterns deal with the relationship between objects i.e. how objects/classes interact or build a relationship in a manner suitable to the situation. The Structural Design Patterns simplify the structure by identifying relationships. In this article of the Structural Design Patterns, we\u0026rsquo;re going to take a look at Proxy Design Pattern in C++ which dictates the way you access the object.\nIf you haven’t check out other Structural Design Patterns, then here is the list:","title":"Proxy Design Pattern in Modern C++"},{"content":"Chain of Responsibility is a Behavioural Design Pattern that provides facility to propagate event/request/command/query to the chain of loosely coupled objects. Chain of Responsibility Design Pattern in Modern C++ lets you pass requests along a chain of handlers \u0026amp; upon receiving a request, each handler decides either to process the request or to forward it to the next handler in the chain.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To provide the chance to handle the request by more than one object/component.\nChain of Responsibility Design Pattern is a chain of loosely coupled objects who all get a chance to process command/query. And they may have some sort of default processing implementation and/or they can also terminate the processing chain and thereby preventing propagation of the event to the rest of the objects. In other words, its processing pipeline where you just launch-and-leave. Classic Examples for Chain of Responsibility Design Pattern in C++ A typical use-case for Chain of Responsibility is the login process. That requires a certain number of steps to complete successfully like user name, password, captcha, etc. to matched properly. Consider the following traditional example for the same: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 struct Authentication { Authentication* m_next{nullptr}; virtual bool authenticate() = 0; void next_authentication(Authentication *nextAuth) { m_next = nextAuth; } }; struct UserName : Authentication { string m_name; UserName(string name) : m_name(name){} bool is_valid_user_name() { return true; } bool authenticate() { if(!is_valid_user_name()) { cout \u0026lt;\u0026lt; \u0026#34;Invalid user name\u0026#34; \u0026lt;\u0026lt; endl; return false; } else if(m_next) return m_next-\u0026gt;authenticate(); return true; } }; struct Password : Authentication { string m_password; Password(string password) : m_password(password){} bool is_valid_password() { return true; } bool authenticate() { if(!is_valid_password()) { cout \u0026lt;\u0026lt; \u0026#34;Invalid password\u0026#34; \u0026lt;\u0026lt; endl; return false; } else if(m_next) return m_next-\u0026gt;authenticate(); return true; } }; int main() { Authentication *login{new UserName(\u0026#34;John\u0026#34;)}; login-\u0026gt;next_authentication(new Password(\u0026#34;password\u0026#34;)); login-\u0026gt;authenticate(); return EXIT_SUCCESS; } I know this is not a very good example but sufficient to convey an idea of Chain of Responsibility. As you can see above, Login is a single process which requires multiple subprocesses to be carried out like username \u0026amp; password authentication. So in our case login-\u0026gt;authenticate(); fires the chain of responsibility to verify each step required for login one-by-one. You can also add more steps in the login process, for example, to add captcha, create captcha class inherited with Authentication \u0026amp; add that class object pointer in the login\u0026rsquo;s next authentication chain as we did for UserName \u0026amp; Password. Now before we move on to the more sophisticated implementations I just wanted to mention the fact that this particular implementation of a chain of responsibility seems quite artificial. Because essentially what\u0026rsquo;s happening here is you\u0026rsquo;re building a singly linked list so the question is well why not just use a std::list or a std::vector. It\u0026rsquo;s certainly a very valid concern. But as I mentioned earlier, this is how people used to build chain irresponsibilities. Boost Example for Chain of Responsibility Design Pattern What you going to see now is a modern way of implementing the Chain of Responsibility Design Pattern that is known as Event Broker. Which is actually a combination of several design patterns like Command, Mediator \u0026amp; Observer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; #include \u0026lt;boost/signals2.hpp\u0026gt; //using namespace boost::signals2; struct Query { // Command int32_t m_cnt{0}; }; struct EventObserver { // Observer boost::signals2::signal\u0026lt;void(Query \u0026amp;)\u0026gt; m_handlers; }; struct ExampleClass : EventObserver { // Mediator void generate_event() { cout \u0026lt;\u0026lt; \u0026#34;Event generated\u0026#34; \u0026lt;\u0026lt; endl; Query q; m_handlers(q); cout \u0026lt;\u0026lt; endl; } }; struct BaseHandler { ExampleClass\u0026amp; m_example; }; struct Handler_1 : BaseHandler { boost::signals2::connection m_conn; Handler_1(ExampleClass \u0026amp;example) : BaseHandler{example} { m_conn = m_example.m_handlers.connect([\u0026amp;](Query \u0026amp;q) { cout \u0026lt;\u0026lt; \u0026#34;Serving by Handler_1 : count = \u0026#34; \u0026lt;\u0026lt; ++q.m_cnt \u0026lt;\u0026lt; endl; }); } ~Handler_1() { m_conn.disconnect(); } }; struct Handler_2 : BaseHandler { boost::signals2::connection m_conn; Handler_2(ExampleClass \u0026amp;example) : BaseHandler{example} { m_conn = m_example.m_handlers.connect([\u0026amp;](Query \u0026amp;q) { cout \u0026lt;\u0026lt; \u0026#34;Serving by Handler_2 : count = \u0026#34; \u0026lt;\u0026lt; ++q.m_cnt \u0026lt;\u0026lt; endl; }); } ~Handler_2() { m_conn.disconnect(); } }; int main() { ExampleClass example; Handler_1 applyThisHandlerOn{example}; example.generate_event(); // Will be served by Handler_1 { Handler_2 TemporaryHandler{example}; example.generate_event(); // Will be served by Handler_1 \u0026amp; Handler_2 } example.generate_event(); // Will be served by Handler_1 return EXIT_SUCCESS; } /* Event generated Serving by Handler_1 : count = 1 Event generated Serving by Handler_1 : count = 1 Serving by Handler_2 : count = 2 Event generated Serving by Handler_1 : count = 1 */ So as you can see, we have ExampleClass which generates an event \u0026amp; having boost::signal2 as an observer. We have Query(i.e. Command Design Pattern) to pass between all the register handlers. Then we have handler arrangement which registers the lambda function to handle the event in constructor \u0026amp; same will be de-register in the destructor. In main, we have facilitated the ad-hoc registration of handlers just by declaring objects which process the Query passed in ExampleClass::generate_event() Handler automatically de-registers itself when it goes out of scope thanks to RAII. Benefits of Chain of Responsibility Design Pattern Decouples the sender \u0026amp; receiver as we saw a more sophisticated approach using Mediator \u0026amp; Command Design Pattern. Simplifies code as the object which is generating event does not need to know the chain structure \u0026amp; command/query. Enhances flexibility of object assigned duties. By changing the members within the chain or change their order, allow dynamically adding or deleting responsibility. Increase extensibility as adding a new handler is very convenient. Summary by FAQs Can I use(or Difference) Chain of Responsibility Design Pattern over Decorator?\nWhen you in need of multiple Decorator. While you want to add new functionality dynamically. When you want a change of order in functionality configurable. For example, you created Decorator of WalkingAnimal \u0026amp; BarkingAnimal of Animal, and now you want both combined at run-time. In such case Chain of Responsibility would be the right choice. When should I use Chain of Responsibility Design Pattern?\nWhen there is more than one object to service a request. These objects \u0026amp; its order determined at run time on the basis of request type. When you do not want to bind request \u0026amp; handler tightly. ","permalink":"https://vishalchovatiya.github.io/posts/chain-of-responsibility-design-pattern-in-modern-cpp/","summary":"Chain of Responsibility is a Behavioural Design Pattern that provides facility to propagate event/request/command/query to the chain of loosely coupled objects. Chain of Responsibility Design Pattern in Modern C++ lets you pass requests along a chain of handlers \u0026amp; upon receiving a request, each handler decides either to process the request or to forward it to the next handler in the chain.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:","title":"Chain of Responsibility Design Pattern in Modern C++"},{"content":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects which in turn make the interaction between the objects easy \u0026amp; loosely coupled. In this article of the Behavioural Design Patterns, we\u0026rsquo;re going to take a look at Command Design Pattern in Modern C++ which encapsulate all the details related to operation into a separate object. Command Design Pattern is widely used in sophisticated software. In fact, you might be using it every day without even knowing that. For example, whenever you press Ctrl + Z(i.e. undo/redo), you are likely firing the object arrangements organised as a Command Pattern.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To decouples the sender \u0026amp; receiver by creating a separate object for a set of operations.\nThe Command Design Pattern is quite simply an object to represent instructions or set of instructions which also facilitates the support of undo-able operations \u0026amp; query/request customization. There is one thing that I want to mention which isn\u0026rsquo;t directly related to the subject of the Command Design Pattern. But still, let me clarify that Command \u0026amp; Query are two different aspects. Command: Asking for action or change e.g. renaming a file. Query: Asking for information(doesn\u0026rsquo;t cause any mutation) e.g. list all the file in the current directory. So, this idea of command query separation is something that used in a lot of things like distributed databases for example. Where you basically split your system into separate components and separate means of sending commands. I just wants to make this point so that you don\u0026rsquo;t get confuse later on. Because GoF mentions command \u0026amp; query as the same thing. Trivial Command Design Pattern Example in C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct walk { void operator()() { cout \u0026lt;\u0026lt; \u0026#34;walk\u0026#34; \u0026lt;\u0026lt; endl; } }; struct jog { void operator()() { cout \u0026lt;\u0026lt; \u0026#34;jog\u0026#34; \u0026lt;\u0026lt; endl; } }; struct run { void operator()() { cout \u0026lt;\u0026lt; \u0026#34;run\u0026#34; \u0026lt;\u0026lt; endl; } }; struct macroCommand : vector\u0026lt;function\u0026lt;void()\u0026gt;\u0026gt; { void operator()() { for (auto \u0026amp;\u0026amp;f : *this) f(); } }; void doIt(function\u0026lt;void()\u0026gt; f) { f(); } int main() { doIt(walk{}); doIt(jog{}); doIt(run{}); macroCommand cardio_workout; cardio_workout.push_back(walk{}); cardio_workout.push_back(jog{}); cardio_workout.push_back(run{}); cardio_workout(); return EXIT_SUCCESS; } I know its silly example with overloaded call operator(i.e functor), but consider it a good start especially for macroCommand. Practical Approach to Command Design Pattern Following is a practical example of the Command Design Pattern with a very familiar scenario of bank account: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 struct BankAccount { int32_t m_balance; void deposit(int32_t amount) { m_balance += amount; } void withdraw(int32_t amount) { m_balance -= amount; } }; struct Command { virtual void execute() = 0; }; struct BankAccountCommand : Command { enum class Action : bool { deposit, withdraw }; BankAccount\u0026amp; m_ac; Action m_action; int32_t m_amount; BankAccountCommand(BankAccount\u0026amp; ac, Action a, int32_t amnt) : m_ac(ac), m_action(a), m_amount(amnt) {} void execute() { (m_action == Action::deposit) ? m_ac.deposit(m_amount) : m_ac.withdraw(m_amount); } }; int main() { BankAccount ba1{1000}; BankAccount ba2{1000}; vector\u0026lt;BankAccountCommand\u0026gt; commands{ BankAccountCommand{ba1, BankAccountCommand::Action::withdraw, 200}, BankAccountCommand{ba2, BankAccountCommand::Action::deposit, 200} }; for (auto\u0026amp; cmd : commands) cmd.execute(); cout \u0026lt;\u0026lt; ba1.m_balance \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ba2.m_balance \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } As you can see BankAccount class with minimalistic implementation having some amount of starting balance. We do also have deposit() \u0026amp; withdraw()methods but rather than using those methods directly we will create a separate entity BankAccountCommand backed by abstract class Command. And in the main(), we have carried out the money transfer of 200 from one bank account to another. Each command has reference to particular BankAccount so it knows on which account to operate on. So this idea of keeping every single command that invokes on a bank account gives us interesting possibilities. One of those possibilities is to implement undo(as you find in Microsoft office applications by pressing Ctrl + Z) functionality so when you want to roll back one of these commands you can actually get it done easily. Another possibility is you can create code more abstract in a way which works like a recorded macro. Think about the implementation of macros in a Microsoft Office application for example. That is a sequence of commands that gets recorded one after another. And you can sort of playback all the commands one after another. And you can also undo them all in reverse order with a single invocation. Following is an improved example incorporating above two possibilities with Composite Design Pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 struct BankAccount { int32_t m_balance; void deposit(int32_t amount) { m_balance += amount; } void withdraw(int32_t amount) { m_balance -= amount; } }; struct Command { virtual void execute() = 0; virtual void undo() = 0; }; struct BankAccountCommand : Command { enum class Action : bool { deposit, withdraw }; BankAccount\u0026amp; m_ac; Action m_cmd; int32_t m_amount; BankAccountCommand(BankAccount\u0026amp; ac, Action a, int32_t amnt) : m_ac(ac), m_cmd(a), m_amount(amnt) {} void execute() { (m_cmd == Action::deposit) ? m_ac.deposit(m_amount) : m_ac.withdraw(m_amount); } void undo() { (m_cmd == Action::deposit) ? m_ac.withdraw(m_amount) : m_ac.deposit(m_amount); } }; struct CompositeBankAccountCommand : vector\u0026lt;BankAccountCommand\u0026gt;, Command { CompositeBankAccountCommand(const initializer_list\u0026lt;value_type\u0026gt;\u0026amp; items) : vector\u0026lt;BankAccountCommand\u0026gt;(items) {} void execute() { for(auto\u0026amp; cmd : *this) cmd.execute(); } void undo() { for(auto\u0026amp; cmd : *this) cmd.undo(); } }; int main() { BankAccount ba1{1000}; BankAccount ba2{1000}; CompositeBankAccountCommand commands{ BankAccountCommand{ba1, BankAccountCommand::Action::withdraw, 200}, BankAccountCommand{ba2, BankAccountCommand::Action::deposit, 200} }; commands.execute(); commands.undo(); cout \u0026lt;\u0026lt; ba1.m_balance \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ba2.m_balance \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } Benefits of Command Design Pattern Command Design Pattern decouples operand \u0026amp; operation. Thus facilitates extensions to add a new command is easy and without changing the existing code. By queueing commands, you can also define a rollback functionality in the system as we did above. It also allows us to create a macro with a bunch of commands can fire together in a single invocation. As the Command Design Pattern has a separate structure to store a set of operations, we have the leverage to schedule it. Summary by FAQs What is the important aspect of the Command Design Pattern?\n1. Interface separation: the invoker is isolated from the receiver.\n2. Time separation: stores a ready-to-go set of instructions that can be scheduled.\nWhat is the reason behind using the Command Design Pattern?\nDecouple the sender \u0026amp; receiver of the command Implement the callback mechanism Implement undo and redo functionality Maintain a history of commands Difference between Command \u0026amp; Memento Design Pattern?\nCommand Design Pattern represents request token\nMemento Design Pattern represents the internal state of an object at a particular time\nPolymorphism is important to Command, but not to Memento.\n","permalink":"https://vishalchovatiya.github.io/posts/command-design-pattern-in-modern-cpp/","summary":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects which in turn make the interaction between the objects easy \u0026amp; loosely coupled. In this article of the Behavioural Design Patterns, we\u0026rsquo;re going to take a look at Command Design Pattern in Modern C++ which encapsulate all the details related to operation into a separate object. Command Design Pattern is widely used in sophisticated software. In fact, you might be using it every day without even knowing that.","title":"Command Design Pattern in Modern C++"},{"content":"Interpreter Design Pattern is a Behavioural Design Pattern which is a component that processes structured text data by turning it into separate lexical tokens(lexing) and then interpreting sequences of tokens(parsing). In this article, we will see the Interpreter Design Pattern in Modern C++.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To process structured text data by tokenizing \u0026amp; parsing.\nInterpreters are everywhere, and especially for us(i.e.programmers), we are dealing with it every day. The front end of almost every compiler is an interpreter. Which parse the textual input \u0026amp; turn it into some sort of meaningful object-oriented representation. Even all mathematical expression is required to be interpreted first. For example, 3 - (4/5) is a candidate for interpretation before processing. In which minus \u0026amp; division is operation whereas 3, 4 \u0026amp; 5 are operand having priority context defined by brackets. Interpreter Design Pattern Example in C++ In the following example, we\u0026rsquo;re going to take a look at the interpretation process by looking at how to tokenize, parse and indeed evaluate simple numeric expressions. And to do so we have divided the example into two parts i.e. i). tokenizing \u0026amp; ii). parsing though it really depends on the kind of data that you work with but considering the general case here. So in the first part, we will process simple mathematical expression which is of type string \u0026amp; convert it into some sort of object-oriented representation i.e. tokens, the sequence of tokens more specifically. Lexing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 struct Token { enum Type { integer, plus, minus, lparen, rparen }; Type m_type; string m_text; Token(Type typ, const string\u0026amp; txt): m_type(typ), m_text(txt) {} friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Token\u0026amp; o) { return os \u0026lt;\u0026lt; \u0026#34;`\u0026#34; \u0026lt;\u0026lt; o.m_text \u0026lt;\u0026lt; \u0026#34;`\u0026#34;; } }; vector\u0026lt;Token\u0026gt; lex(const string\u0026amp; input) { vector\u0026lt;Token\u0026gt; result; for (auto curr = begin(input); curr != end(input); ++curr) { switch (*curr) { case \u0026#39;+\u0026#39;: result.emplace_back(Token::plus, \u0026#34;+\u0026#34;); break; case \u0026#39;-\u0026#39;: result.emplace_back(Token::minus, \u0026#34;-\u0026#34;); break; case \u0026#39;(\u0026#39;: result.emplace_back(Token::lparen, \u0026#34;(\u0026#34;); break; case \u0026#39;)\u0026#39;: result.emplace_back(Token::rparen, \u0026#34;)\u0026#34;); break; default: // number auto first_not_digit = find_if(curr, end(input), [](auto c) { return !isdigit(c); }); string integer = string(curr, first_not_digit); result.emplace_back(Token::integer, integer); curr = --first_not_digit; } } return result; } int main() { auto tokens = lex(\u0026#34;(13-4)-(12+1)\u0026#34;); for (auto\u0026amp; t: tokens) cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t// Output: `(` `13` `-` `4` `) `-` `(` `12` `+` `1` `) return EXIT_SUCCESS; } As you can see in the above example, we are creating the collection of tokens i.e. +, -, (, ) \u0026amp; numbers as a part of the 1st step to evaluate the expression (13-4)-(12+1). Parsing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 struct Element { virtual int eval() const = 0; }; struct Integer : Element { int m_value; explicit Integer(const int v) : m_value(v) {} int eval() const { return m_value; } }; struct BinaryOperation : Element { enum Type { addition, subtraction } m_type; shared_ptr\u0026lt;Element\u0026gt; m_lhs, m_rhs; int eval() const { if (m_type == addition) return m_lhs-\u0026gt;eval() + m_rhs-\u0026gt;eval(); return m_lhs-\u0026gt;eval() - m_rhs-\u0026gt;eval(); } }; shared_ptr\u0026lt;Element\u0026gt; parse(const vector\u0026lt;Token\u0026gt; \u0026amp;tokens) { auto result = make_unique\u0026lt;BinaryOperation\u0026gt;(); for (auto curr_token = begin(tokens); curr_token != end(tokens); ++curr_token) { switch (curr_token-\u0026gt;m_type) { /* ----------------- Normal Expression ----------------- */ case Token::integer: if (!result-\u0026gt;m_lhs) result-\u0026gt;m_lhs = make_shared\u0026lt;Integer\u0026gt;(stoi(curr_token-\u0026gt;m_text)); else result-\u0026gt;m_rhs = make_shared\u0026lt;Integer\u0026gt;(stoi(curr_token-\u0026gt;m_text)); break; case Token::plus: result-\u0026gt;m_type = BinaryOperation::addition; break; case Token::minus: result-\u0026gt;m_type = BinaryOperation::subtraction; break; /* ----------------------------------------------------- */ /* ------------------- Sub Expression ------------------ */ case Token::lparen: auto rparen = find_if(curr_token, end(tokens), [](auto\u0026amp; token) { return token.m_type == Token::rparen; }); vector\u0026lt;Token\u0026gt; subexpression(curr_token + 1, rparen); if (!result-\u0026gt;m_lhs) result-\u0026gt;m_lhs = parse(subexpression); else result-\u0026gt;m_rhs = parse(subexpression); curr_token = rparen; break; /* ----------------------------------------------------- */ } } return result; } int main() { string expression{\u0026#34;(13-4)-(12+1)\u0026#34;}; auto tokens = lex(expression); auto parsed = parse(tokens); cout \u0026lt;\u0026lt; expression \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; parsed-\u0026gt;eval() \u0026lt;\u0026lt; endl; // Output: (13-4)-(12+1) = -4 return EXIT_SUCCESS; } You may be thinking that the parsing algorithm is bit complex, but if you eliminate smart pointer, code would become easy to consume. You can divide the parsing algorithm in two-part: Normal Expression: i.e. 13-4 which is easily parsed by 1st three cases of the switch statement Token::plus, Token::minus \u0026amp; Token::integer. Sub-expression: i.e. expression starting from parenthesis. For example, (13-4) where I am extracting the content within parenthesis \u0026amp; again providing it to parse()as it is a recurring problem. At the end of parsing, you will form the following tree structure: 1 2 3 4 5 6 7 8 // (13-4)-(12+1) BinaryOperation(subtraction) / \\ / \\ BinaryOperation(subtraction) BinaryOperation(addition) / \\ / \\ / \\ / \\ Integer(13) Integer(4) Integer(12) Integer(1) When we call parsed-\u0026gt;eval() in the main function, polymorphic overloaded eval()for all the nodes type(i.e. Integer or BinaryOperation) in the above tree will be called recursively. An evaluation of an expression happens in the bottom-up approach. Benefits of Interpreter Design Pattern It\u0026rsquo;s easy to change and extend the grammar. Because classes used to represent grammar rules i.e. +, -, etc., we can use inheritance to change or extend the grammar. For example, to extend the above example for multiplication operator, you need to add one more case in switch case \u0026amp; a bit of modification in BinaryOperation class. Implementing the grammar is easy, too. As each symbol represents a token that essentially a class. To add a new symbol you need to create a new class. Summary by FAQs Use cases of Interpreter Design Pattern.\nProgramming language compilers, interpreters, IDEs, Document readers like HTML, XML, PDF, etc.A regular expression is a very subtle example of Interpreter.\nWhat problems can the Interpreter Design Pattern solve?\nInterpreter Design Pattern is used to interpret domain languages which can be anything from a simple calculator to a C++ parser.\nWhat solution does the Interpreter Design Pattern describe?\nTokenizing symbols \u0026amp; parsing it as a tree.\n","permalink":"https://vishalchovatiya.github.io/posts/interpreter-design-pattern-in-modern-cpp/","summary":"Interpreter Design Pattern is a Behavioural Design Pattern which is a component that processes structured text data by turning it into separate lexical tokens(lexing) and then interpreting sequences of tokens(parsing). In this article, we will see the Interpreter Design Pattern in Modern C++.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated.","title":"Interpreter Design Pattern in Modern C++"},{"content":"Iterator Design Pattern in Modern C++ is a heavily used pattern i.e. provides facility to traverse data containers sophistically. For simplicity, you can consider a pointer moving across an array, but the real magic comes when you get to the next element of a container, in that case, you need not know anything about how the container is constructed(like sequential(not necessarily be contiguous), associative or hashed). This is handled by the iterator.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To facilitate the traversal of data structure.\nIterator is a core functionality of various containers provided in the standard C++ library. There are lots of cases where you\u0026rsquo;re using iterators without really knowing what you\u0026rsquo;re using them. For instance, if you use a range-based for-loop what you\u0026rsquo;re essentially using is begin, end \u0026amp; operator++ but you don\u0026rsquo;t see any of it. Another example is coroutines that\u0026rsquo;s also something where you have a method which returns a generator but the generator actually gives you the ability to iterate itself and you don\u0026rsquo;t see the iterators explicitly in this case either. Iterator Design Pattern Examples in C++ A typical example to illustrate iterator is to use single dimensional array \u0026amp; traverse it using pointer(with the same type as the element of the array). But this is a very simple \u0026amp; straight forward scenario where you can not imagine how important iterators are? So we will see the example of basic associative container i.e. Binary Tree. Binary Tree Iterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 template\u0026lt;typename T\u0026gt; struct BinaryTree; template\u0026lt;typename T\u0026gt; struct Node { T m_value = T(); Node\u0026lt;T\u0026gt;* m_parent{nullptr}; Node\u0026lt;T\u0026gt;* m_left{nullptr}; Node\u0026lt;T\u0026gt;* m_right{nullptr}; BinaryTree\u0026lt;T\u0026gt;* m_tree{nullptr}; Node(const T\u0026amp; v): m_value(v) {} Node(const T\u0026amp; v, Node\u0026lt;T\u0026gt; *const l, Node\u0026lt;T\u0026gt; *const r): m_value(v), m_left(l), m_right(r) { this-\u0026gt;m_left-\u0026gt;m_tree = this-\u0026gt;m_right-\u0026gt;m_tree = m_tree; this-\u0026gt;m_left-\u0026gt;m_parent = this-\u0026gt;m_right-\u0026gt;m_parent = this; } ~Node() { delete m_left; delete m_right; } void set_tree(BinaryTree\u0026lt;T\u0026gt; *t) { m_tree = t; if (m_left) m_left-\u0026gt;set_tree(t); if (m_right) m_right-\u0026gt;set_tree(t); } }; template\u0026lt;typename T\u0026gt; struct BinaryTree { Node\u0026lt;T\u0026gt;* m_root = nullptr; BinaryTree(Node\u0026lt;T\u0026gt; *const r) : m_root{r} { m_root-\u0026gt;set_tree(this); } ~BinaryTree() { delete m_root; } /* ---------------------------- Iterator Implementation ----------------------------- */ template\u0026lt;typename U\u0026gt; struct PreOrderIterator { Node\u0026lt;U\u0026gt; *current; PreOrderIterator(Node\u0026lt;U\u0026gt; *c): current(c) {} bool operator!=(const PreOrderIterator\u0026lt;U\u0026gt;\u0026amp; rhs) { return current != rhs.current; } PreOrderIterator\u0026lt;U\u0026gt;\u0026amp; operator++() { if (current-\u0026gt;m_right) { current = current-\u0026gt;m_right; while (current-\u0026gt;m_left) current = current-\u0026gt;m_left; } else { Node\u0026lt;T\u0026gt; *p = current-\u0026gt;m_parent; while (p \u0026amp;\u0026amp; current == p-\u0026gt;m_right) { current = p; p = p-\u0026gt;m_parent; } current = p; } return *this; } Node\u0026lt;U\u0026gt;\u0026amp; operator*() { return *current; } }; using iterator = PreOrderIterator\u0026lt;T\u0026gt;; iterator begin() { Node\u0026lt;T\u0026gt; *n = m_root; if (n) while (n-\u0026gt;m_left) n = n-\u0026gt;m_left; return iterator{n}; } iterator end() { return iterator{nullptr}; } /* ---------------------------------------------------------------------------------- */ }; int main() { // me // / \\ // mother father // / \\ // m\u0026#39;m m\u0026#39;f BinaryTree\u0026lt;string\u0026gt; family { new Node\u0026lt;string\u0026gt;{\u0026#34;me\u0026#34;, new Node\u0026lt;string\u0026gt;{\u0026#34;mother\u0026#34;, new Node\u0026lt;string\u0026gt;{\u0026#34;mother\u0026#39;s mother\u0026#34;}, new Node\u0026lt;string\u0026gt;{\u0026#34;mother\u0026#39;s father\u0026#34;} }, new Node\u0026lt;string\u0026gt;{\u0026#34;father\u0026#34;} } }; for_each(begin(family), end(family), // Works with STL algo [](auto\u0026amp;\u0026amp; n) { cout \u0026lt;\u0026lt; n.m_value \u0026lt;\u0026lt; endl; }); for (const auto\u0026amp; it: family) // Works with range-based for loop as well cout \u0026lt;\u0026lt; it.m_value \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } /* mother\u0026#39;s mother mother mother\u0026#39;s father me father mother\u0026#39;s mother mother mother\u0026#39;s father me father */ The most difficult thing in the above example is implementing PreOrderIterator::operator++. So when we\u0026rsquo;re traversing the tree in pre-order. What\u0026rsquo;s happening is every time somebody calls plus-plus we need to move to the subsequent elements of the tree and this is a particularly tricky operation. So as you can see because we don\u0026rsquo;t have any way of asynchronously yielding the elements. It becomes a really ugly chunk of code. I mean I can go through this particular implementation. But essentially it\u0026rsquo;s just the preorder traversal as we use to do. Binary Tree Iterator with C++20 Co-routines In a previous example, I\u0026rsquo;ve deliberately skipped talking about how the traversal was actually implemented. Because if you go up and look at the PreOrderIterator::operator++, you can see that it\u0026rsquo;s a lot of manipulations around the current pointer \u0026amp; is very ugly. If you ever came across recursive pre-order traversal, you know that it is very intuitive \u0026amp; concise as follows: 1 2 3 4 5 6 void pre_order(root) { if (root == NULL) return; cout \u0026lt;\u0026lt; *root \u0026lt;\u0026lt; endl; pre_order(root-\u0026gt;left); pre_order(root-\u0026gt;right); } Now the problem here for not having recursion is that you simply have an operator plus-plus. That gets executed at a time and you need to somehow preserve the state between those consecutive executions. But there was no way of suspending execution and then resuming till C++20. Because if you could do that, you could write a proper recursive algorithm that people could actually read. And instead, we have this monstrosity which I\u0026rsquo;m not going to go through. Since C++20, we have a feature in C++ by which we can write above algorithm in an idiomatic way where you can actually read the algorithm and it looks like the algorithm that reflects what you read in Wikipedia or computer science books and the way this is made possible is thanks to C++ coroutines[TODO]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;iostream\u0026gt; #include \u0026lt;experimental/coroutine\u0026gt; using namespace std; /* Note: include file https://github.com/lewissbaker/cppcoro/blob/master/include/cppcoro/generator.hpp if you are not able to use `experimental::generator`. I have used clang 9.0.0 with cppcoro library for compilation */ template\u0026lt;typename T\u0026gt; struct BinaryTree; template\u0026lt;typename T\u0026gt; struct Node { T m_value = T(); Node\u0026lt;T\u0026gt;* m_parent{nullptr}; Node\u0026lt;T\u0026gt;* m_left{nullptr}; Node\u0026lt;T\u0026gt;* m_right{nullptr}; BinaryTree\u0026lt;T\u0026gt;* m_tree{nullptr}; Node(const T\u0026amp; v): m_value(v) {} Node(const T\u0026amp; v, Node\u0026lt;T\u0026gt; *const l, Node\u0026lt;T\u0026gt; *const r): m_value(v), m_left(l), m_right(r) { this-\u0026gt;m_left-\u0026gt;m_tree = this-\u0026gt;m_right-\u0026gt;m_tree = m_tree; this-\u0026gt;m_left-\u0026gt;m_parent = this-\u0026gt;m_right-\u0026gt;m_parent = this; } ~Node() { delete m_left; delete m_right; } void set_tree(BinaryTree\u0026lt;T\u0026gt; *t) { m_tree = t; if (m_left) m_left-\u0026gt;set_tree(t); if (m_right) m_right-\u0026gt;set_tree(t); } }; template\u0026lt;typename T\u0026gt; struct BinaryTree { Node\u0026lt;T\u0026gt; *root = nullptr; BinaryTree(Node\u0026lt;T\u0026gt; *const r) : root{r} { root-\u0026gt;set_tree(this); } ~BinaryTree() { delete root; } /* ------------------------------- C++ co-routines -------------------------------- */ experimental::generator\u0026lt;Node\u0026lt;T\u0026gt;*\u0026gt; pre_order() { return pre_order_impl(root); } experimental::generator\u0026lt;Node\u0026lt;T\u0026gt;*\u0026gt; pre_order_impl(Node\u0026lt;T\u0026gt;* node) { if (node) { for (auto x : pre_order_impl(node-\u0026gt;m_left)) co_yield x; for (auto y : pre_order_impl(node-\u0026gt;m_right)) co_yield y; co_yield node; } } /* ---------------------------------------------------------------------------------- */ }; int main() { // me // / \\ // mother father // / \\ // m\u0026#39;m m\u0026#39;f BinaryTree\u0026lt;string\u0026gt; family { new Node\u0026lt;string\u0026gt;{\u0026#34;me\u0026#34;, new Node\u0026lt;string\u0026gt;{\u0026#34;mother\u0026#34;, new Node\u0026lt;string\u0026gt;{\u0026#34;mother\u0026#39;s mother\u0026#34;}, new Node\u0026lt;string\u0026gt;{\u0026#34;mother\u0026#39;s father\u0026#34;} }, new Node\u0026lt;string\u0026gt;{\u0026#34;father\u0026#34;} } }; for (auto it: family.pre_order()) cout \u0026lt;\u0026lt; it-\u0026gt;m_value \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } /* mother\u0026#39;s mother mother\u0026#39;s father mother father me */ If you are unable to understand pre_order_impl, I would suggest you go through this talk. After that pre_order_impl would be self explainable. Moreover, I have compiled above snipped using cppcoro library with clang 9.0.0 on wandbox. Boost Iterator Facade Design Pattern in C++ If you have gone through my Facade Design Pattern article, you know that the first word in the above title i.e. Facade pronounces as `fa;sa;d`. Boost Iterator Facade is quite simply a very useful base class that you can add to an iterator very quickly and intuitively i.e. define the operations which make up that iterator. And to explain that I have taken a simple singly-linked list example as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;boost/iterator/iterator_facade.hpp\u0026gt; using namespace std; struct Node { string m_value; Node* m_next = nullptr; Node(const string\u0026amp; v): m_value(v) {} Node(const string \u0026amp;v, Node *const parent): m_value(v) { parent-\u0026gt;m_next = this; } }; struct ListIterator: boost::iterator_facade\u0026lt;ListIterator, Node, boost::forward_traversal_tag\u0026gt; { Node* m_current; ListIterator(Node *const c = nullptr): m_current(c) {} friend class boost::iterator_core_access; void increment() { m_current = m_current-\u0026gt;m_next; } bool equal(const ListIterator \u0026amp;other) const { return other.m_current == m_current; }; Node\u0026amp; dereference() const { return *m_current; } }; int main() { Node alpha { \u0026#34;alpha\u0026#34; }; Node beta { \u0026#34;beta\u0026#34;, \u0026amp;alpha }; Node gamma { \u0026#34;gamma\u0026#34;, \u0026amp;beta }; for_each(ListIterator{\u0026amp;alpha}, ListIterator{}, [ ](const Node\u0026amp; n) { cout \u0026lt;\u0026lt; n.m_value \u0026lt;\u0026lt; endl; }); return EXIT_SUCCESS; } Some quick things to note here: Inheritance mention the type of traversal by boost::forward_traversal_tag. We have some override methods like increment(), equal(), dereference(), etc. You can read more about it in boost Iterator Facade Documentation.\nBenefits of Iterator Design Pattern Maintains good cohesion which means code is easier to understand, use \u0026amp; test since the iterator uses the Single Responsibility Principle and Open-Closed Principle. Loose coupling between data structures \u0026amp; algorithm as an algorithm does not have to know the way of traversal \u0026amp; even underlying data structure in some cases. You can extend the Iterators to traverse collection \u0026amp; collection of the collections. You can combine the Visitor \u0026amp; Iterator Design Pattern to traverse \u0026amp; execute some operation over the collection of different types. Summary by FAQs What is the purpose of Iterator Design Pattern?\nTo abstract away the underlying structure in which the data are kept for traversal \u0026amp; operations.\nHow do I use Iterator for traversing the collection of the collections?\nComposite design pattern\n","permalink":"https://vishalchovatiya.github.io/posts/iterator-design-pattern-in-modern-cpp/","summary":"Iterator Design Pattern in Modern C++ is a heavily used pattern i.e. provides facility to traverse data containers sophistically. For simplicity, you can consider a pointer moving across an array, but the real magic comes when you get to the next element of a container, in that case, you need not know anything about how the container is constructed(like sequential(not necessarily be contiguous), associative or hashed). This is handled by the iterator.","title":"Iterator Design Pattern in Modern C++"},{"content":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects \u0026amp; encapsulating behaviour in an object to delegate requests. In this article of the Behavioural Design Patterns, we\u0026rsquo;re going to take a look at Mediator Design Pattern in Modern C++. And the motivation behind the Mediator Design Pattern is to provide proper communication between components by letting the components be aware(or unaware also, depending upon use case) of each other\u0026rsquo;s presence or absence in the system.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To facilitates communication between objects.\nMediator implements functionality that dictates `how a set of objects interact with each other`. It also promotes loose coupling by keeping objects from referring to each other explicitly. And lets you vary their interaction independently. Mediator Design Pattern Example in C++ The classic \u0026amp; most suitable example of Mediator Design Pattern would be a chat room where your components(most likely people) may go in and out of the system at any time. Therefore, it makes no sense for the different participants to have direct references to one another because those references can go dead at any time. So the solution here is to have all of the components refer to some sort of central component which facilitates the communication and that component happens to be the mediator. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 struct ChatRoom { virtual void broadcast(string from, string msg) = 0; virtual void message(string from, string to, string msg) = 0; }; struct Person { string m_name; ChatRoom* m_room{nullptr}; vector\u0026lt;string\u0026gt; m_chat_log; Person(string n) : m_name(n) {} void say(string msg) const { m_room-\u0026gt;broadcast(m_name, msg); } void pm(string to, string msg) const { m_room-\u0026gt;message(m_name, to, msg); } void receive(string from, string msg) { string s{from + \u0026#34;: \\\u0026#34;\u0026#34; + msg + \u0026#34;\\\u0026#34;\u0026#34;}; cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;\u0026#39;s chat session]\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; m_chat_log.emplace_back(s); } }; struct GoogleChat : ChatRoom { vector\u0026lt;Person*\u0026gt; m_people; void broadcast(string from, string msg) { for (auto p : m_people) if (p-\u0026gt;m_name != from) p-\u0026gt;receive(from, msg); } void join(Person *p) { string join_msg = p-\u0026gt;m_name + \u0026#34; joins the chat\u0026#34;; broadcast(\u0026#34;room\u0026#34;, join_msg); p-\u0026gt;m_room = this; m_people.push_back(p); } void message(string from, string to, string msg) { auto target = find_if(begin(m_people), end(m_people), [\u0026amp;](const Person *p) { return p-\u0026gt;m_name == to; }); if (target != end(m_people)) (*target)-\u0026gt;receive(from, msg); } }; int main() { GoogleChat room; Person john{\u0026#34;John\u0026#34;}; Person jane{\u0026#34;Jane\u0026#34;}; room.join(\u0026amp;john); room.join(\u0026amp;jane); john.say(\u0026#34;hi room\u0026#34;); jane.say(\u0026#34;oh, hey john\u0026#34;); Person simon{\u0026#34;Simon\u0026#34;}; room.join(\u0026amp;simon); simon.say(\u0026#34;hi everyone!\u0026#34;); jane.pm(\u0026#34;Simon\u0026#34;, \u0026#34;glad you found us, simon!\u0026#34;); return EXIT_SUCCESS; } /* [John\u0026#39;s chat session]room: \u0026#34;Jane joins the chat\u0026#34; [Jane\u0026#39;s chat session]John: \u0026#34;hi room\u0026#34; [John\u0026#39;s chat session]Jane: \u0026#34;oh, hey john\u0026#34; [John\u0026#39;s chat session]room: \u0026#34;Simon joins the chat\u0026#34; [Jane\u0026#39;s chat session]room: \u0026#34;Simon joins the chat\u0026#34; [John\u0026#39;s chat session]Simon: \u0026#34;hi everyone!\u0026#34; [Jane\u0026#39;s chat session]Simon: \u0026#34;hi everyone!\u0026#34; [Simon\u0026#39;s chat session]Jane: \u0026#34;glad you found us, simon!\u0026#34; */ So the takeaway from the above example is that you have a central component. In this case, it\u0026rsquo;s the GoogleChat and every person of the chatroom has a reference or pointer to that GoogleChat. Thus, they all communicate exclusively through that point or so they don\u0026rsquo;t communicate directly. They don\u0026rsquo;t have any references or pointers to one another but still, they can send messages for example in this case I\u0026rsquo;m using the name of a person which has the kind of key for actually message passing and the chat room is the mediator who actually takes care of the glue. The thing which kind of binds everything together. Benefits of Mediator Design Pattern You can replace any component in the system without affecting other component \u0026amp; system. Mediator Design Pattern reduces the complexity of communication between the different components in a system. Thus promoting loose coupling \u0026amp; less number of subclasses. As to overcome the limitation of the Observer Design Pattern which works in a one-to-many relationship, Mediator Design Pattern can be employed for a many-to-many relationship. Summary by FAQs Mediator vs Facade Design Pattern?\nMediator pattern can be seen as a multiplexed facade pattern. In mediator, instead of working with an interface of a single object, you are making a multiplexed interface among multiple objects to provide smooth transitions.\nMediator vs Observer Design Pattern?\nObserver Design Pattern = one-to-many relationship Mediator Design Pattern = many-to-many relationship\nDue to centralized control of communication, maintenance of the system designed using Mediator Design Pattern is easy. Senders \u0026amp; Receivers Patterns\nChain of Responsibility, Command, Mediator, and Observer, address how you can decouple senders and receivers, but with different trade-offs. Chain of Responsibility passes a sender request along a chain of potential receivers. Command normally specifies a sender-receiver connection with a subclass. Mediator has senders and receivers reference each other indirectly. Observer defines a very decoupled interface that allows for multiple receivers to be configured at run-time.\n","permalink":"https://vishalchovatiya.github.io/posts/mediator-design-pattern-in-modern-cpp/","summary":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects \u0026amp; encapsulating behaviour in an object to delegate requests. In this article of the Behavioural Design Patterns, we\u0026rsquo;re going to take a look at Mediator Design Pattern in Modern C++. And the motivation behind the Mediator Design Pattern is to provide proper communication between components by letting the components be aware(or unaware also, depending upon use case) of each other\u0026rsquo;s presence or absence in the system.","title":"Mediator Design Pattern in Modern C++"},{"content":"Memento Design Pattern in Modern C++ is a very straight forward Behavioural Design Pattern. The motivation behind using the Memento Design Pattern is to keep some sort of token which then allows you to restore an object to a particular state. This is particularly useful if you have a system with medieval components i.e. an object or indeed a set of objects goes through a set of changes.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To store and restore the state of the component/object.\nIn keep changing \u0026amp; well-designed OOPs software systems, the usual problem you may face while implementing rollback functionality is encapsulation. Because the object\u0026rsquo;s representation (data structure) is hidden. And can\u0026rsquo;t access from outside the object directly without using setter \u0026amp; getter. Memento Design Pattern is the right way to address this problem. Memento is a kind of immutable object. It captures \u0026amp; externalizes an object\u0026rsquo;s internal state at given a particular time without violating encapsulation. So that the object can restore to that state on later point of time. Memento Design Pattern Example in C++ With continuing our previous example of the bank account from Command Design Pattern where we were recording every change as a command \u0026amp; made facility to undo that command using member function. Here in Memento Design Pattern, we simply save the snapshot of the system/component at a particular point of time. And allow the user to roll back the system to that snapshot. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class BankAccount { int32_t m_balance{0}; uint32_t m_current{0}; struct Memento { int32_t m_balance; Memento(int32_t b): m_balance(b) {} }; vector\u0026lt;shared_ptr\u0026lt;const Memento\u0026gt;\u0026gt; m_changes; public: BankAccount(const int32_t b): m_balance(b) { m_changes.emplace_back(make_shared\u0026lt;const Memento\u0026gt;(m_balance)); } const shared_ptr\u0026lt;const Memento\u0026gt; deposit(int32_t amount) { m_balance += amount; m_changes.emplace_back(make_shared\u0026lt;const Memento\u0026gt;(m_balance)); return m_changes[m_current++]; } void restore(const shared_ptr\u0026lt;const Memento\u0026gt;\u0026amp; m) { if (m) { m_balance = m-\u0026gt;m_balance; m_changes.push_back(m); m_current = m_changes.size() - 1; } } const shared_ptr\u0026lt;const Memento\u0026gt; undo() { if (m_current \u0026gt; 0) { m_balance = m_changes[--m_current]-\u0026gt;m_balance; return m_changes[m_current]; } return {}; } const shared_ptr\u0026lt;const Memento\u0026gt; redo() { if ((m_current + 1) \u0026lt; m_changes.size()) { m_balance = m_changes[++m_current]-\u0026gt;m_balance; return m_changes[m_current]; } return {}; } friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const BankAccount \u0026amp; ac) { return os \u0026lt;\u0026lt; \u0026#34;balance: \u0026#34; \u0026lt;\u0026lt; ac.m_balance; } }; int main() { BankAccount ba{100}; ba.deposit(50); ba.deposit(25); cout \u0026lt;\u0026lt; ba \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 175 ba.undo(); cout \u0026lt;\u0026lt; \u0026#34;Undo 1: \u0026#34; \u0026lt;\u0026lt; ba \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; ba.undo(); cout \u0026lt;\u0026lt; \u0026#34;Undo 2: \u0026#34; \u0026lt;\u0026lt; ba \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; ba.redo(); cout \u0026lt;\u0026lt; \u0026#34;Redo 2: \u0026#34; \u0026lt;\u0026lt; ba \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return EXIT_SUCCESS; } /* balance: 175 Undo 1: balance: 150 Undo 2: balance: 100 Redo 2: balance: 150 */ So as you can see the state of the system is sufficiently small in terms of the memory footprint to actually record every single change and as a result not only do you get the user to be able to restore the system to any particular state just by using the memento. But you also have this ability to walk forwards and backwards in terms of the overall timeline. You let the user kind of undo and redo depending on their needs. So this is the proper way by which you can implement memento to jump back from one state to another. Undo mechanism is slightly different from we have seen earlier in the Command Design Pattern. Benefits of Memento Design Pattern Because what we\u0026rsquo;re doing here is Undo-ing at a discrete point of time unlike a line of changes we looked at the Command Design Pattern. By using memento, you can go backwards and forwards or you can go to discrete points of time that you\u0026rsquo;ve saved by saving a memento of that point in time \u0026amp; restore it. A memento is very useful in almost all applications which must restart from their last known working state or draft. An example of this can be an IDE which restarts from changes user-made before closing the IDE. Memento Design Pattern maintains high cohesion. Summary by FAQs Difference between Command \u0026amp; Memento Design Pattern?\nIn Command Design Pattern, the token represents a request; in Memento, it represents the internal state of an object at a particular time. Polymorphism is important to Command Design Pattern, but not to Memento because its interface is so narrow that a memento can only be passed as a value. Difference between State \u0026amp; Memento Design Pattern?\nState Design Pattern is used to dictates the previous, current or future behaviour of the system. While Memento Design Pattern is typically used to store only the historical state of an object which also does not have any direct relation to behaviour. ","permalink":"https://vishalchovatiya.github.io/posts/memento-design-pattern-in-modern-cpp/","summary":"Memento Design Pattern in Modern C++ is a very straight forward Behavioural Design Pattern. The motivation behind using the Memento Design Pattern is to keep some sort of token which then allows you to restore an object to a particular state. This is particularly useful if you have a system with medieval components i.e. an object or indeed a set of objects goes through a set of changes.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:","title":"Memento Design Pattern in Modern C++"},{"content":"The Observer Design Pattern is a type of Behavioural Design Pattern that use to get information when certain events happen i.e. basically one component want information about something happening in the other component. And that can a lot of things like a field changes to a particular value or you want to information when the object does a particular thing, etc. Observer Design Pattern in Modern C++ enables you to create subscription mechanism to notify multiple objects about events that happen to the object they\u0026rsquo;re observing.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To get notifications when events happen.\nThe Observer Design Pattern split into two parts: observer i.e. object which gets a notification about something happening somewhere in the system. observable i.e. entity that\u0026rsquo;s actually generating these notifications or events. You see this are the terminology I am using which may vary people-to-people \u0026amp; domain-to-domain, For example: event \u0026amp; subscriber signal \u0026amp; slot(Boost, Qt, etc.) broadcaster \u0026amp; listeners, etc. Observer Design Pattern Example in C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 template\u0026lt;typename T\u0026gt; struct Observer { virtual void field_changed(T\u0026amp; source, const string\u0026amp; field_name) = 0; }; template\u0026lt;typename T\u0026gt; struct Observable { void notify(T\u0026amp; source, const string\u0026amp; field_name) { for (auto observer: m_observers) observer-\u0026gt;field_changed(source, field_name); } void subscribe(Observer\u0026lt;T\u0026gt;\u0026amp; observer) { m_observers.push_back(\u0026amp;observer); } void unsubscribe(Observer\u0026lt;T\u0026gt;\u0026amp; observer) { m_observers.erase(remove(m_observers.begin(), m_observers.end(), \u0026amp;observer), m_observers.end()); } private: vector\u0026lt;Observer\u0026lt;T\u0026gt;*\u0026gt; m_observers; }; struct Person : Observable\u0026lt;Person\u0026gt;{ // Observable \u0026lt;\u0026lt;\u0026lt;\u0026lt;------------------------------------- void set_age(uint8_t age) { auto old_can_vote = get_can_vote(); this-\u0026gt;m_age = age; notify(*this, \u0026#34;age\u0026#34;); if (old_can_vote != get_can_vote()) notify(*this, \u0026#34;can_vote\u0026#34;); } uint8_t get_age() const { return m_age; } bool get_can_vote() const { return m_age \u0026gt;= 16; } private: uint8_t m_age{0}; }; struct TrafficAdministration : Observer\u0026lt;Person\u0026gt;{ // Observer \u0026lt;\u0026lt;\u0026lt;\u0026lt;----------------------- void field_changed(Person \u0026amp;source, const string\u0026amp; field_name) { if (field_name == \u0026#34;age\u0026#34;) { if (source.get_age() \u0026lt; 17) cout \u0026lt;\u0026lt; \u0026#34;Not old enough to drive!\\n\u0026#34;; else { cout \u0026lt;\u0026lt; \u0026#34;Mature enough to drive!\\n\u0026#34;; source.unsubscribe(*this); } } } }; int main() { Person p; TrafficAdministration ta; p.subscribe(ta); p.set_age(16); p.set_age(17); return EXIT_SUCCESS; } The observer is that thing which wants to monitor something. And the observable is the component that is to monitored. So, in the above case, our Person is observable and the observer is TrafficAdministration. You can also augment above code for passing lambda as a subscriber rather than an object for a more functional approach. Observer Design Pattern with Boost Signals Now what I\u0026rsquo;m going to do is I\u0026rsquo;ll make a small digression. Because instead of showing you something that we\u0026rsquo;ve built ourselves what I want to show you is the observable implementation that comes with the Boost libraries. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;boost/signals2.hpp\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; struct Observable { void subscribe(const auto\u0026amp;\u0026amp; observer) { m_field_changed.connect(observer); } void unsubscribe(const auto\u0026amp;\u0026amp; observer) { m_field_changed.disconnect(observer); } protected: boost::signals2::signal\u0026lt;void(T\u0026amp;, const string\u0026amp;)\u0026gt; m_field_changed; }; struct Person : Observable\u0026lt;Person\u0026gt; { // Observable \u0026lt;\u0026lt;\u0026lt;\u0026lt;------------------------------------- void set_age(uint8_t age) { this-\u0026gt;m_age = age; m_field_changed(*this, \u0026#34;age\u0026#34;); } auto get_age() const { return m_age; } private: uint32_t m_age {0}; }; struct TrafficAdministration { // Observer \u0026lt;\u0026lt;\u0026lt;\u0026lt;----------------------- static void field_changed(Person \u0026amp;source, const string\u0026amp; field_name) { if (field_name == \u0026#34;age\u0026#34;) { if (source.get_age() \u0026lt; 17) cout \u0026lt;\u0026lt; \u0026#34;Not old enough to drive!\\n\u0026#34;; else { cout \u0026lt;\u0026lt; \u0026#34;Mature enough to drive!\\n\u0026#34;; source.unsubscribe(TrafficAdministration::field_changed); } } } }; int main() { Person p; p.subscribe(TrafficAdministration::field_changed); p.set_age(16); p.set_age(20); return EXIT_SUCCESS; } Mind it, I have used boost::signals2 as boost::signals are no longer being actively maintained. Due to boost::signals2, we can get rid of std/boost::bind, and can directly use lambda. You can check out a quick example of boost::signals2 if you want. Benefits of Observer Design Pattern It supports the loose coupling between objects that interact with each other hence Open-Closed Principle will be intact. Above examples also satisfy the Single Responsibility Principle as Observer \u0026amp; Observable are two different templatized classes which can easily be reusable. It provides the flexibility of adding or removing observers at any time which is heavily use in event-driven programming. Summary by FAQs Use cases of Observer Design Pattern.\nUsually, Observer Design Pattern employs when there is a one-to-many relationship between objects so that when one object changes state, all its dependents are notified and updated automatically. Typical use case area involves GUI libraries, Social media, RSS feeds, Email subscription, etc.\nDifference between Observer \u0026amp; Mediator Design Pattern.\nObserver Design Pattern works on the one-to-many relationship.\nMediator Design Pattern works on the many-to-many relationship.\n","permalink":"https://vishalchovatiya.github.io/posts/observer-design-pattern-in-modern-cpp/","summary":"The Observer Design Pattern is a type of Behavioural Design Pattern that use to get information when certain events happen i.e. basically one component want information about something happening in the other component. And that can a lot of things like a field changes to a particular value or you want to information when the object does a particular thing, etc. Observer Design Pattern in Modern C++ enables you to create subscription mechanism to notify multiple objects about events that happen to the object they\u0026rsquo;re observing.","title":"Observer Design Pattern in Modern C++"},{"content":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects. That in turn, make the interaction between the objects easy \u0026amp; loosely coupled. In this article of the design pattern series, we\u0026rsquo;re going to take a look at Visitor Design Pattern in Modern C++ which is also known as a classic technique for recovering lost type information(using Double Dispatch[TODO]). Visitor Design Pattern is used to perform an operation on a group of similar kind of objects or hierarchy. In this article, we will not only see the classical example but also leverage the std::visit from the standard library to cut-short the implementation time of the Visitor Design Pattern.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To define a new operation on a group of similar kind of objects or hierarchy.\nThe classical Visitor Design Pattern has some component which we call a visitor. That is allowed to traverse the entire inheritance hierarchy. But before that what you have to do is you have to implement a single method called visit()in the entire hierarchy once. And from then on you don\u0026rsquo;t have to touch the hierarchy anymore. So the hierarchy can exist on its own and you can create extra visitors sort of thing on the side which is perfectly consistent with both the Open-Closed Principle as well as the Single Responsibility Principle. Visitor Design Pattern Examples in C++ This is a reasonably complex design pattern \u0026amp; I do not want to confuse you by directly jumping on example. So we will come to the Visitor Design Pattern by exploring other available option. And then you will understand the importance of visitor despite the complexity. Intrusive Visitor Let\u0026rsquo;s suppose that you have a hierarchy of documents as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct Document { virtual void add_to_list(const string \u0026amp;line) = 0; }; struct Markdown : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } string m_start = \u0026#34;* \u0026#34;; list\u0026lt;string\u0026gt; m_content; }; struct HTML : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } string m_start = \u0026#34;\u0026lt;li\u0026gt;\u0026#34;; string m_end = \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; list\u0026lt;string\u0026gt; m_content; }; And you need to define some new operation on existing infrastructure. For example, we have a Document class as above and now you want that different documents(i.e. HTML \u0026amp; Markdown) to be printable. So you have this brand new concern of printing and you want to somehow propagate this through the entire hierarchy by making essentially every single class of your document to be independently printable somehow. Now what you don\u0026rsquo;t want to do is you don\u0026rsquo;t want to go back into the existing code and modify each class(with new virtual function) in the hierarchy every time you have a new concern, because, unfortunately, this breaks an Open-Closed Principle, rather we should use inheritance. There\u0026rsquo;s also the Single Responsibility Principle that you have to adhere to because if you are introducing a brand new concern such as printing then that should be a separate class. But still, let say we will do it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct Document { virtual void add_to_list(const string \u0026amp;line) = 0; virtual void print() = 0; }; struct Markdown : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } void print() { for (auto \u0026amp;\u0026amp;item : m_content) cout \u0026lt;\u0026lt; m_start \u0026lt;\u0026lt; item \u0026lt;\u0026lt; endl; } string m_start = \u0026#34;* \u0026#34;; list\u0026lt;string\u0026gt; m_content; }; struct HTML : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } void print() { cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; for (auto \u0026amp;\u0026amp;item : m_content) { cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; m_start \u0026lt;\u0026lt; item \u0026lt;\u0026lt; m_end \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;/ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } string m_start = \u0026#34;\u0026lt;li\u0026gt;\u0026#34;; string m_end = \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; list\u0026lt;string\u0026gt; m_content; }; int main() { Document *d = new HTML; d-\u0026gt;add_to_list(\u0026#34;This is line\u0026#34;); d-\u0026gt;print(); return EXIT_SUCCESS; } As you can see for only 2-3 class it\u0026rsquo;s good even if it is violating some SOLID principles. But imagine if you have 20 classes as part of this hierarchy. It would be really difficult to go into 20 different files \u0026amp; add a print method for every one of them. Moreover, if there is more than one concern like save, process, etc., this approach becomes cumbersome. It would be much nicer to have each concern in a separate class that also goes towards the Single Responsibility Principle. Reflective Visitor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 struct Document { virtual void add_to_list(const string \u0026amp;line) = 0; }; struct Markdown : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } string m_start = \u0026#34;* \u0026#34;; list\u0026lt;string\u0026gt; m_content; }; struct HTML : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } string m_start = \u0026#34;\u0026lt;li\u0026gt;\u0026#34;; string m_end = \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; list\u0026lt;string\u0026gt; m_content; }; struct DocumentPrinter { static void print(Document *e) { if (auto md = dynamic_cast\u0026lt;Markdown *\u0026gt;(e)) { for (auto \u0026amp;\u0026amp;item : md-\u0026gt;m_content) cout \u0026lt;\u0026lt; md-\u0026gt;m_start \u0026lt;\u0026lt; item \u0026lt;\u0026lt; endl; } else if (auto hd = dynamic_cast\u0026lt;HTML *\u0026gt;(e)) { cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; for (auto \u0026amp;\u0026amp;item : hd-\u0026gt;m_content) { cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; hd-\u0026gt;m_start \u0026lt;\u0026lt; item \u0026lt;\u0026lt; hd-\u0026gt;m_end \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;/ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } } }; int main() { Document *d = new HTML; d-\u0026gt;add_to_list(\u0026#34;This is line\u0026#34;); DocumentPrinter::print(d); return EXIT_SUCCESS; } As mentioned above, we created a separate class having printing functionality for the entire hierarchy just to adhere Single Responsibility Principle. But in this approach, we have to identify types for a particular class(using dynamic_cast\u0026lt;\u0026gt;()) as we have to work on individual object of hierarchy independently. This is not an approach which scales efficiently, especially as you expand the set of classes that you\u0026rsquo;re processing, you will end up having a long list of if/else-if along with paying performance cost on RTTI. Classic Visitor So far the approaches that have been sort of half measures what we really want is we really want a mechanism that will allow us to extend the entire hierarchies functionality in various different ways without being intrusive and certainly without having massive if/else-if statements full of dynamic_cast\u0026lt;\u0026gt;() in them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /* --------------------------- Added Visitor Classes ----------------------------- */ struct DocumentVisitor { virtual void visit(class Markdown*) = 0; virtual void visit(class HTML*) = 0; }; struct DocumentPrinter : DocumentVisitor { void visit(class Markdown* md); void visit(class HTML* hd); }; /* -------------------------------------------------------------------------------- */ struct Document { virtual void add_to_list(const string \u0026amp;line) = 0; virtual void visit(DocumentVisitor*) = 0; // \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;-------------------------- }; struct Markdown : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } void visit(DocumentVisitor* dv) { dv-\u0026gt;visit(this); } // \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;--------------- string m_start = \u0026#34;* \u0026#34;; list\u0026lt;string\u0026gt; m_content; }; struct HTML : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } void visit(DocumentVisitor* dv) { dv-\u0026gt;visit(this); } // \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;--------------- string m_start = \u0026#34;\u0026lt;li\u0026gt;\u0026#34;; string m_end = \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; list\u0026lt;string\u0026gt; m_content; }; /* -------------------------- Added Visitor Methods ------------------------------- */ void DocumentPrinter::visit(Markdown* md) { for (auto \u0026amp;\u0026amp;item : md-\u0026gt;m_content) cout \u0026lt;\u0026lt; md-\u0026gt;m_start \u0026lt;\u0026lt; item \u0026lt;\u0026lt; endl; } void DocumentPrinter::visit(HTML* hd) { cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; for (auto \u0026amp;\u0026amp;item : hd-\u0026gt;m_content) cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; hd-\u0026gt;m_start \u0026lt;\u0026lt; item \u0026lt;\u0026lt; hd-\u0026gt;m_end \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;/ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } /* -------------------------------------------------------------------------------- */ int main() { Document *d = new HTML; d-\u0026gt;add_to_list(\u0026#34;This is line\u0026#34;); d-\u0026gt;visit(new DocumentPrinter); return EXIT_SUCCESS; } So as you can see we have added two-layer of indirection to achieve what we wanted without violating the Single Responsibility Principle \u0026amp; Open-Closed Principle. Thanks to Double Dispatch in C++[TODO]. If you see all the classes involved in the process, it may seem a bit complicated. But call stack may help you to understand it easily. From d-\u0026gt;visit(new DocumentPrinter), we call visit()method, which will dispatch to the appropriate overridden visit i.e. `HTML::visit(DocumentVisitor* dv). From the overridden HTML::visit(DocumentVisitor*), we call dv-\u0026gt;visit(this), which will again dispatch to the appropriate overridden method(considering the type of this pointer) i.e. DocumentPrinter::visit(HTML*). Visitor Design Pattern in Modern C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 struct Document { virtual void add_to_list(const string \u0026amp;line) = 0; }; struct Markdown : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } string m_start = \u0026#34;* \u0026#34;; list\u0026lt;string\u0026gt; m_content; }; struct HTML : Document { void add_to_list(const string \u0026amp;line) { m_content.push_back(line); } string m_start = \u0026#34;\u0026lt;li\u0026gt;\u0026#34;; string m_end = \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; list\u0026lt;string\u0026gt; m_content; }; /* ------------------------------------ Visitor ------------------------------------- */ struct DocumentPrinter { void operator()(Markdown \u0026amp;md) { for (auto \u0026amp;\u0026amp;item : md.m_content) cout \u0026lt;\u0026lt; md.m_start \u0026lt;\u0026lt; item \u0026lt;\u0026lt; endl; } void operator()(HTML \u0026amp;hd){ cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; for (auto \u0026amp;\u0026amp;item : hd.m_content) cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; hd.m_start \u0026lt;\u0026lt; item \u0026lt;\u0026lt; hd.m_end \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;/ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } }; /* ---------------------------------------------------------------------------------- */ using document = std::variant\u0026lt;Markdown, HTML\u0026gt;; int main() { HTML hd; hd.add_to_list(\u0026#34;This is line\u0026#34;); document d = hd; DocumentPrinter dp; std::visit(dp, d); return EXIT_SUCCESS; } So for those of you who are not familiar with the std::variant, you can consider it as a union(a type-safe union). And line std::variant\u0026lt;Markdown, HTML\u0026gt;, suggest that you can use/assign/access either Markdown or HTML at a time. And Modern C++ provides us std::visit which accept callable i.e. DocumentPrinter in our case having overloaded function operator and std::variant as the second argument. You also make use of lambda functions rather using functor i.e. DocumentPrinter. Benefits of Visitor Design Pattern Adhering Single Responsibility Principle meaning separating type-specific logic in the separate entity/class. In our case, DocumentPrinter only handles the printing for different document types. Adhering Open-Closed Principle meaning new functionality can be added without touching any class headers once we inserted visit() method for hierarchy, For example, if you want to add scan()method for each different Document, you can create DocumentScanner \u0026amp; rest of the edit goes as same DocumentPrinter. This will be much useful when you already have done the unit-testing for your entire hierarchy. Now you do not want to touch that \u0026amp; wants to add new functionality. Performance over dynamic_cast, typeid()and check for enum/string comparison. Summary by FAQs When should I use the Visitor Design Pattern?\nVisitor Design Pattern is quite useful when your requirement keeps changing which also affects multiple classes in the inheritance hierarchy.\nWhat is the typical use case of the Visitor Design Pattern?\nIn replacement of dynamic_cast\u0026lt;\u0026gt;, `typeid(), etc. To process the collection of different types of objects. Filtering different type of objects from collections. Difference between Visitor vs Decorator Design Pattern?\nDecorator(Structural Design Pattern) works on an object by enhances existing functionality. While\nVisitor(Behavioral Design Pattern) works on a hierarchy of classes where you want to run different method based on concrete type but avoiding dynamic_cast\u0026lt;\u0026gt;() or typeof() operators.\n","permalink":"https://vishalchovatiya.github.io/posts/double-dispatch-visitor-design-pattern-in-modern-cpp/","summary":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects. That in turn, make the interaction between the objects easy \u0026amp; loosely coupled. In this article of the design pattern series, we\u0026rsquo;re going to take a look at Visitor Design Pattern in Modern C++ which is also known as a classic technique for recovering lost type information(using Double Dispatch[TODO]). Visitor Design Pattern is used to perform an operation on a group of similar kind of objects or hierarchy.","title":"Double Dispatch : Visitor Design Pattern in Modern C++"},{"content":"A State Design Pattern is a type of Behavioural Design Pattern that defines objects behaviour(defined as a state) based on some event happens. And that can be the internal or external event. For example, if you design an ATM machine using the State Design Pattern, the external event could be someone inserted debit/credit card \u0026amp; internal event could be a user timeout. So in nutshell, the State Design Pattern in Modern C++ is a systematic way to implement certain behaviour on a particular event considering the context.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To implement the object\u0026rsquo;s behaviour determined by its state.\nA State Design Pattern is to implement the object\u0026rsquo;s behaviour depending upon its state which also clarifies the transition from one state to another state. A formalized construct which manages states \u0026amp; transition is called a state machine. The State Design Pattern solves two main problems: An object should change its behaviour when its internal state changes. State-specific behaviour should define independently(i.e. in class). So, adding new states should not affect the behaviour of existing states. State Design Pattern Examples in C++ Consider the above simple diagram to model three different states along with respective triggers for the transition. We will first see the classical approach where we implement state transition using polymorphism \u0026amp; then move to Modern \u0026amp; Modular approach which involves std::variant \u0026amp; std::visit. Classical State Design Pattern 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /* --------------------------------- Events ------------------------------------------ */ enum event { connect, connected, disconnect, timeout }; inline ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const event \u0026amp;e) { switch (e) { case event::connect: os \u0026lt;\u0026lt; \u0026#34;connect\u0026#34;; break; case event::connected: os \u0026lt;\u0026lt; \u0026#34;connected\u0026#34;; break; case event::disconnect: os \u0026lt;\u0026lt; \u0026#34;disconnect\u0026#34;; break; case event::timeout: os \u0026lt;\u0026lt; \u0026#34;timeout\u0026#34;; break; } return os; } /* ------------------------------------------------------------------------------------- */ struct State { virtual unique_ptr\u0026lt;State\u0026gt; on_event(event e) = 0; }; /* --------------------------------- States ------------------------------------------ */ struct Idle : State { unique_ptr\u0026lt;State\u0026gt; on_event(event e); }; struct Connecting : State { unique_ptr\u0026lt;State\u0026gt; on_event(event e); private: uint32_t m_trial = 0; static constexpr uint8_t m_max_trial = 3; }; struct Connected : State { unique_ptr\u0026lt;State\u0026gt; on_event(event e); }; /* ------------------------------------------------------------------------------------- */ /* ------------------------------- Transitions ---------------------------------------- */ unique_ptr\u0026lt;State\u0026gt; Idle::on_event(event e) { cout \u0026lt;\u0026lt; \u0026#34;Idle -\u0026gt; \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; if (e == event::connect) return make_unique\u0026lt;Connecting\u0026gt;(); return nullptr; } unique_ptr\u0026lt;State\u0026gt; Connecting::on_event(event e) { cout \u0026lt;\u0026lt; \u0026#34;Connecting -\u0026gt; \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; switch (e) { case event::connected: return make_unique\u0026lt;Connected\u0026gt;(); case event::timeout: return ++m_trial \u0026lt; m_max_trial ? nullptr : make_unique\u0026lt;Idle\u0026gt;(); } return nullptr; } unique_ptr\u0026lt;State\u0026gt; Connected::on_event(event e) { cout \u0026lt;\u0026lt; \u0026#34;Connected -\u0026gt; \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; if (e == event::disconnect) return make_unique\u0026lt;Idle\u0026gt;(); return nullptr; } /* ------------------------------------------------------------------------------------- */ struct Bluetooth { unique_ptr\u0026lt;State\u0026gt; m_curr_state = make_unique\u0026lt;Idle\u0026gt;(); void dispatch(event e) { auto new_state = m_curr_state-\u0026gt;on_event(e); if (new_state) m_curr_state = move(new_state); } template \u0026lt;typename... Events\u0026gt; void establish_connection(Events... e) { (dispatch(e), ...); } }; int main() { Bluetooth bl; bl.establish_connection(event::connect, event::timeout, event::connected, event::disconnect); return EXIT_SUCCESS; } /* Idle -\u0026gt; connect Connecting -\u0026gt; timeout Connecting -\u0026gt; connected Connected -\u0026gt; disconnect */ Two subtle part here to take into the account is How we modelled triggers(i.e. events) \u0026amp; states, by considering state machine diagram. And how we have fired steps to establish the connection using Variadic Template Method \u0026amp; Fold expression. Rest of the code is self-explainable though. Functional Approach to State Design Pattern State Design Pattern is bizarre design patterns if you look at the classic definition of it. You will see something very different from how we actually build state machines nowadays so it\u0026rsquo;s a completely different paradigm. Now we see more Modern \u0026amp; Functional approach to address this problem. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /* --------------------------------- Events ------------------------------------------ */ struct EventConnect { string m_address; }; struct EventConnected { }; struct EventDisconnect { }; struct EventTimeout { }; using Event = variant\u0026lt;EventConnect, EventConnected, EventDisconnect, EventTimeout\u0026gt;; /* ------------------------------------------------------------------------------------- */ /* --------------------------------- States ------------------------------------------ */ struct Idle { }; struct Connecting { string m_address; uint32_t m_trial = 0; static constexpr uint8_t m_max_trial = 3; }; struct Connected { }; using State = variant\u0026lt;Idle, Connecting, Connected\u0026gt;; /* ------------------------------------------------------------------------------------- */ /* ------------------------------- Transitions ---------------------------------------- */ struct Transitions { optional\u0026lt;State\u0026gt; operator()(Idle \u0026amp;, const EventConnect \u0026amp;e) { cout \u0026lt;\u0026lt; \u0026#34;Idle -\u0026gt; Connect\u0026#34; \u0026lt;\u0026lt; endl; return Connecting{e.m_address}; } optional\u0026lt;State\u0026gt; operator()(Connecting \u0026amp;, const EventConnected \u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;Connecting -\u0026gt; Connected\u0026#34; \u0026lt;\u0026lt; endl; return Connected{}; } optional\u0026lt;State\u0026gt; operator()(Connecting \u0026amp;s, const EventTimeout \u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;Connecting -\u0026gt; Timeout\u0026#34; \u0026lt;\u0026lt; endl; return ++s.m_trial \u0026lt; Connecting::m_max_trial ? nullopt : optional\u0026lt;State\u0026gt;(Idle{}); } optional\u0026lt;State\u0026gt; operator()(Connected \u0026amp;, const EventDisconnect \u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;Connected -\u0026gt; Disconnect\u0026#34; \u0026lt;\u0026lt; endl; return Idle{}; } template \u0026lt;typename State_t, typename Event_t\u0026gt; optional\u0026lt;State\u0026gt; operator()(State_t \u0026amp;, const Event_t \u0026amp;) const { cout \u0026lt;\u0026lt; \u0026#34;Unkown\u0026#34; \u0026lt;\u0026lt; endl; return nullopt; } }; /* ------------------------------------------------------------------------------------- */ template \u0026lt;typename StateVariant, typename EventVariant, typename Transitions\u0026gt; struct Bluetooth { StateVariant m_curr_state; void dispatch(const EventVariant \u0026amp;Event) { optional\u0026lt;StateVariant\u0026gt; new_state = visit(Transitions{}, m_curr_state, Event); if (new_state) m_curr_state = *move(new_state); } template \u0026lt;typename... Events\u0026gt; void establish_connection(Events... e) { (dispatch(e), ...); } }; int main() { Bluetooth\u0026lt;State, Event, Transitions\u0026gt; bl; bl.establish_connection(EventConnect{\u0026#34;AA:BB:CC:DD\u0026#34;}, EventTimeout{}, EventConnected{}, EventDisconnect{}); return EXIT_SUCCESS; } /* Idle -\u0026gt; Connect Connecting -\u0026gt; Timeout Connecting -\u0026gt; Connected Connected -\u0026gt; Disconnect */ A classical approach is not loosely coupled between events \u0026amp; states if you compare the above example. The changes in the sequence of events or adding new events will impact the condition part of states implemented in on_event()which violates the Open-Closed Principle. But in the case of Functional approach events \u0026amp; states are not related or coupled. Rather it works in combination defined in the transition class. This gives a lot of flexibility along with preserving the Single Responsibility Principle \u0026amp; Open-Closed Principle. Modular Approach to State Design Pattern We have already seen the Functional approach to State Design Pattern with Modern C++ above which is very practical \u0026amp; scalable. But still, there are some of the devs who are not using C++17 yet. So we will consider a modular approach to this by implementing the transition table with different example this time. I\u0026rsquo;m going to model a phone call \u0026amp; phone can be in several different states. And I\u0026rsquo;m going to model those states not as entire types but just as members. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 enum class State { OffHook, Connecting, Connected, OnHold, OnHook }; inline ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, State\u0026amp; s) { switch (s) { case State::OffHook: os \u0026lt;\u0026lt; \u0026#34;off the hook\u0026#34;; break; case State::Connecting: os \u0026lt;\u0026lt; \u0026#34;connecting\u0026#34;; break; case State::Connected: os \u0026lt;\u0026lt; \u0026#34;connected\u0026#34;; break; case State::OnHold: os \u0026lt;\u0026lt; \u0026#34;on hold\u0026#34;; break; case State::OnHook: os \u0026lt;\u0026lt; \u0026#34;on the hook\u0026#34;; break; } return os; } enum class Trigger { CallDialed, HungUp, CallConnected, PlacedOnHold, TakenOffHold, LeftMessage, StopUsingPhone }; inline ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, Trigger\u0026amp; t) { switch (t) { case Trigger::CallDialed: os \u0026lt;\u0026lt; \u0026#34;call dialed\u0026#34;; break; case Trigger::HungUp: os \u0026lt;\u0026lt; \u0026#34;hung up\u0026#34;; break; case Trigger::CallConnected: os \u0026lt;\u0026lt; \u0026#34;call connected\u0026#34;; break; case Trigger::PlacedOnHold: os \u0026lt;\u0026lt; \u0026#34;placed on hold\u0026#34;; break; case Trigger::TakenOffHold: os \u0026lt;\u0026lt; \u0026#34;taken off hold\u0026#34;; break; case Trigger::LeftMessage: os \u0026lt;\u0026lt; \u0026#34;left message\u0026#34;; break; case Trigger::StopUsingPhone: os \u0026lt;\u0026lt; \u0026#34;putting phone on hook\u0026#34;; break; } return os; } int main() { map\u0026lt;State, vector\u0026lt;pair\u0026lt;Trigger, State\u0026gt;\u0026gt;\u0026gt; transition_table; transition_table[State::OffHook] = { { Trigger::CallDialed, State::Connecting }, { Trigger::StopUsingPhone, State::OnHook } }; transition_table[State::Connecting] = { { Trigger::HungUp, State::OffHook }, { Trigger::CallConnected, State::Connected } }; transition_table[State::Connected] = { { Trigger::LeftMessage, State::OffHook }, { Trigger::HungUp, State::OffHook }, { Trigger::PlacedOnHold, State::OnHold } }; transition_table[State::OnHold] = { { Trigger::TakenOffHold, State::Connected }, { Trigger::HungUp, State::OffHook } }; State currentState{State::OffHook}; State exitState{State::OnHook}; for (;;) { cout \u0026lt;\u0026lt; \u0026#34;The phone is currently \u0026#34; \u0026lt;\u0026lt; currentState \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Select a trigger:\\n\u0026#34;; uint32_t i = 0; for (auto item: transition_table[currentState]) cout \u0026lt;\u0026lt; i++ \u0026lt;\u0026lt; \u0026#34;. \u0026#34; \u0026lt;\u0026lt; item.first \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; uint32_t input; cin \u0026gt;\u0026gt; input; currentState = transition_table[currentState][input].second; // Caution: index out of range not checked if (currentState == exitState) break; } cout \u0026lt;\u0026lt; \u0026#34;We are done using the phone\u0026#34;\u0026lt;\u0026lt;endl; return EXIT_SUCCESS; } /* The phone is currently off the hook Select a trigger: 0. call dialed 1. putting phone on hook 0 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; INPUT The phone is currently connecting Select a trigger: 0. hung up 1. call connected 1 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; INPUT The phone is currently connected Select a trigger: 0. left message 1. hung up 2. placed on hold 0 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; INPUT The phone is currently off the hook Select a trigger: 0. call dialed 1. putting phone on hook 1 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; INPUT We are done using the phone */ So as you can see, we have modelled state \u0026amp; triggers as enums with the overloaded streaming operator. A typical phone call process changes the states in the following fashion; if the phone is off the hook; it can connecting; connected to somebody, or it can on-hold. Once connected, you left the message \u0026amp; you put the phone back on the hook when you\u0026rsquo;re done talking. Now we need an essential part i.e. triggers to drive the show, you can think of them as events which cause you to transition from one state to another. And to connect these states \u0026amp; triggers, we have done its mapping as std::map named as transition_table. You can consider it as rules of the game. So this is how you can very quickly hand-roll your own state machine by simply defining a set of states. Similarly, a set of triggers \u0026amp; transition table which kind of relates the rules for going from one state to another state using a particular trigger. And then you orchestrate that state machine and you get your results. Benefits of State Design Pattern The State Design Pattern minimizes conditional complexity, eliminating the need for if/else-if and switch statements in objects that have different behaviour requirements unique to different state transitions. As we have seen, If you are able to represent the object\u0026rsquo;s state machine diagram. It\u0026rsquo;s fairly easy to convert the diagram into the Finite State Machine using Functional \u0026amp; Modular approach. The State Design Pattern also improves Cohesion. Since state-specific behaviours aggregated into the separate classes \u0026amp; placed in one location in the code. Moreover, the State Design Pattern also helps in unit testing as adding new behaviour/states won\u0026rsquo;t affect existing behaviours/states, you do not need to retest the whole system. This is a very helpful case in agile development models. Summary by FAQs Difference between switch case statement \u0026amp; state machine implemented by switch case syntax.\nOrdinary switch case statement does not handle transition rather it just to particular activity based on case type.\nMost of the object\u0026rsquo;s behaviour determined by its data member. Then why is this a separate design pattern?\nWell in the representation of the Gang of Four the State Design Pattern basically suggests that the state of the system kind of controls the way that it operates and it also ties to this idea of Finite State Machine. And as I said earlier State Design Pattern is a systematic \u0026amp; sophisticated way to implement Finite State Machine.\nUse cases of State Design Pattern.\nATM machine, Timers, TV remote, Protocols, etc. Basically, anything that reflects different behaviour on different inputs.\nHow to use state pattern rapidly \u0026amp; correctly?\nFunctional approach seen above is the best way which treats states, events, transitions as a completely separate component.\n","permalink":"https://vishalchovatiya.github.io/posts/state-design-pattern-in-modern-cpp/","summary":"A State Design Pattern is a type of Behavioural Design Pattern that defines objects behaviour(defined as a state) based on some event happens. And that can be the internal or external event. For example, if you design an ATM machine using the State Design Pattern, the external event could be someone inserted debit/credit card \u0026amp; internal event could be a user timeout. So in nutshell, the State Design Pattern in Modern C++ is a systematic way to implement certain behaviour on a particular event considering the context.","title":"State Design Pattern in Modern C++"},{"content":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects which in turn make the interaction between the objects easy \u0026amp; loosely coupled. In this article of the Behavioural Design Pattern series, we\u0026rsquo;re going to take a look at Strategy Design Pattern in Modern C++. It allows you to partially specify the behaviour of the class and then augment it later on. This pattern is also known as policy in many programming languages including especially in the C++ language.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To choose particular algorithm from a family of algorithms depending upon need.\nSo many algorithms can actually decomposed into what I would call the higher \u0026amp; lower-level parts. For example, let\u0026rsquo;s consider the process of making tea. So the process of making tea can decomposed into something higher level like the process of making a hot beverage. Because, whether you\u0026rsquo;re making tea or coffee or any other hot drink you have to boil the water. Then, you have to pour the water into the cup. So that is the high-level part can reuse. And the specific things are to be specific but everything else can be reused for making something else like coffee or hot chocolate for example. And this supports the beverage-specific strategies. So that is where the Strategy Design Pattern actually comes in. Strategy Design Pattern essentially enables the exact behaviour of a system to become selective either at compile time or run time. Strategy Design Pattern Examples in C++ We\u0026rsquo;re going to implement a strategy for printing a list of items in different formats like Markdown \u0026amp; HTML. And I will show you how you can implement Dynamic \u0026amp; Static Strategy with two separate examples. Dynamic Strategy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 enum class Format { Markdown, Html }; struct ListStrategy { virtual ~ListStrategy() = default; virtual void add_list_item(ostringstream\u0026amp; oss, string\u0026amp; item) {}; virtual void start(ostringstream\u0026amp; oss) {}; virtual void end(ostringstream\u0026amp; oss) {}; }; struct MarkdownListStrategy: ListStrategy { void add_list_item(ostringstream\u0026amp; oss, string\u0026amp; item) override { oss \u0026lt;\u0026lt; \u0026#34; - \u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; endl; } }; struct HtmlListStrategy: ListStrategy { void start(ostringstream\u0026amp; oss) override { oss \u0026lt;\u0026lt; \u0026#34;\u0026lt;ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } void end(ostringstream\u0026amp; oss) override { oss \u0026lt;\u0026lt; \u0026#34;\u0026lt;/ul\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } void add_list_item(ostringstream\u0026amp; oss, string\u0026amp; item) override { oss \u0026lt;\u0026lt; \u0026#34;\\t\u0026lt;li\u0026gt;\u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34;\u0026lt;/li\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } }; struct TextProcessor { void clear() { m_oss.str(\u0026#34;\u0026#34;); m_oss.clear(); } void append_list(vector\u0026lt;string\u0026gt;\u0026amp; items) { m_list_strategy-\u0026gt;start(m_oss); for (auto\u0026amp; item: items) m_list_strategy-\u0026gt;add_list_item(m_oss, item); m_list_strategy-\u0026gt;end(m_oss); } void set_output_format(Format\u0026amp; format) { switch (format) { case Format::Markdown: m_list_strategy = make_unique\u0026lt;MarkdownListStrategy\u0026gt;(); break; case Format::Html: m_list_strategy = make_unique\u0026lt;HtmlListStrategy\u0026gt;(); break; } } string str() { return m_oss.str(); } private: ostringstream m_oss; unique_ptr\u0026lt;ListStrategy\u0026gt; m_list_strategy; }; int main() { // markdown TextProcessor tp; tp.set_output_format(Format::Markdown); tp.append_list({ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34; }); cout \u0026lt;\u0026lt; tp.str() \u0026lt;\u0026lt; endl; // html tp.clear(); tp.set_output_format(Format::Html); tp.append_list({ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34; }); cout \u0026lt;\u0026lt; tp.str() \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } /* - foo - bar - baz \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;foo\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;bar\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;baz\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; */ Above example is self-explainable, but the thing here to take into account is a smart pointer to TextProcessor::m_list_strategy which we can use to change the strategy on the fly. Static Strategy I would not consider a static approach to the Strategy Design Pattern as flexible as the dynamic one but it\u0026rsquo;s still there if you need it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 template\u0026lt;typename LS\u0026gt; struct TextProcessor { void append_list(const vector\u0026lt;string\u0026gt; \u0026amp;items) { m_list_strategy.start(m_oss); for (auto \u0026amp; item: items) m_list_strategy.add_list_item(m_oss, item); m_list_strategy.end(m_oss); } string str() const { return m_oss.str(); } private: ostringstream m_oss; LS m_list_strategy; }; int main() { // markdown TextProcessor\u0026lt;MarkdownListStrategy\u0026gt; tp1; tp1.append_list({ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34; }); cout \u0026lt;\u0026lt; tp1.str() \u0026lt;\u0026lt; endl; // html TextProcessor\u0026lt;HtmlListStrategy\u0026gt; tp2; tp2.append_list({ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34; }); cout \u0026lt;\u0026lt; tp2.str() \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } When you looked at the Decorator Design Pattern we saw that the decorator can be implemented as both dynamic as well as static and it just so happens that the Strategy Design Pattern is exactly like this. There is not anything special about static strategy except we are not referring algorithm(i.e. add_list_item() through virtual table(rather passing it as a C++ template parameter) which means you do not have the ability to change your algorithm/strategy at runtime. Benefits of Strategy Design Pattern It\u0026rsquo;s easy to switch between different algorithms(strategies) in runtime as we\u0026rsquo;re using polymorphism in the interfaces. Clean \u0026amp; readable code because we avoid conditional code for algorithms(strategies). More clean code because you separate the concerns into classes (a class to each strategy) so automatically adhering Single Responsibility Principle. Preserving Open-Closed Principle also as I described in the example above, Strategy allows you to extend a logic in some parts of your code (\u0026ldquo;open for extension\u0026rdquo;) without rewriting those parts (\u0026ldquo;closed for modification\u0026rdquo;). Summary by FAQs When should the Strategy Design Pattern be used?\nWhen you need to use several algorithms with different variations. While most of your classes have related behaviours. When there are conditional statements around several related algorithms. Why do we use the Strategy Design Pattern?\nFor clean \u0026amp; readable code To adhere the Single Responsibility Principle \u0026amp; Open-Closed Principle. What is the difference between the Strategy \u0026amp; State Design Pattern?\nStrategy is only an algorithm that you can change it in different circumstances upon your need. State can change whole object behaviour. ","permalink":"https://vishalchovatiya.github.io/posts/strategy-design-pattern-in-modern-cpp/","summary":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects which in turn make the interaction between the objects easy \u0026amp; loosely coupled. In this article of the Behavioural Design Pattern series, we\u0026rsquo;re going to take a look at Strategy Design Pattern in Modern C++. It allows you to partially specify the behaviour of the class and then augment it later on. This pattern is also known as policy in many programming languages including especially in the C++ language.","title":"Strategy Design Pattern in Modern C++"},{"content":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects. And encapsulating behaviour in an object to delegate requests. The Behavioural Design Patterns make the interaction between the objects easy \u0026amp; loosely coupled. In this article of the design pattern series, we\u0026rsquo;re going to take a look at Template Method Design Pattern in Modern C++. It allows us to define the skeleton of the algorithm in the base class with concrete implementations defined in derived classes.\nBy the way, If you haven’t check out my other articles on Behavioural Design Patterns, then here is the list:\nChain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. Intent To provide high-level blueprint of an algorithm to be completed by its inheritors.\nNow, this might seem familiar to you because we\u0026rsquo;ve seen something like this already in the Strategy Design Pattern. So we know that algorithms generally can be decomposed into the common parts(i.e. high-level parts) as well as the specifics. And the Strategy Design Pattern handles that for us quite efficiently. Then why do we need yet another design pattern Strategy Design Pattern does this through composition. In which you have the high-level algorithm that uses some interface. And then the concrete implementations actually implement this interface and then you stick them in as pointer or reference. Template Method Design Pattern is very similar except it does this through inheritance instead. So the overall algorithm would typically be in an abstract base class. And then, of course, you have inheritors of this class which overrides certain key abstract members. But the base class actually keeps the template for the actual algorithms. So the parent class template method is then invoked to actually orchestrate the algorithm at the high level. This might still do not fit in your head right-away but the following example will surely help. Template Method Design Pattern Example in C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 struct Game { explicit Game(uint32_t players): m_no_of_players(players) {} void run() { start(); while (!have_winner()) take_turn(); cout \u0026lt;\u0026lt; \u0026#34;Player \u0026#34; \u0026lt;\u0026lt; get_winner() \u0026lt;\u0026lt; \u0026#34; wins.\\n\u0026#34;; } protected: virtual void start() = 0; virtual bool have_winner() = 0; virtual void take_turn() = 0; virtual uint32_t get_winner() = 0; uint32_t m_current_player{0}; uint32_t m_no_of_players{0}; }; struct Chess : Game { explicit Chess(): Game {2} {} protected: void start() { cout \u0026lt;\u0026lt; \u0026#34;Starting chess with \u0026#34; \u0026lt;\u0026lt; m_no_of_players \u0026lt;\u0026lt; \u0026#34; players\\n\u0026#34;; } bool have_winner() { return m_turns == m_max_turns; } void take_turn() { cout \u0026lt;\u0026lt; \u0026#34;Turn \u0026#34; \u0026lt;\u0026lt; m_turns \u0026lt;\u0026lt; \u0026#34; taken by player \u0026#34; \u0026lt;\u0026lt; m_current_player \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; m_turns++; m_current_player = (m_current_player + 1) % m_no_of_players; } uint32_t get_winner() { return m_current_player; } private: uint32_t m_turns{0}, m_max_turns{4}; }; int main() { Chess chess; chess.run(); return EXIT_SUCCESS; } /* Starting chess with 2 players Turn 0 taken by player 0 Turn 1 taken by player 1 Turn 2 taken by player 0 Turn 3 taken by player 1 Player 0 wins. */ As you can see the Game::run()is our template method that the algorithm itself is defined not in some external class but in an abstract base class. And then we inherit Chess from Game to provide the implementation of the parts(i.e. pure virtual methods) of the run()template method. To implement the Template Method Design Pattern, you have to think in terms of reverse inheritance. For example, you have a bunch of documents like PDF, Doc, HTML, XML. For which you have to create a data mining algorithm. In case of inheritance what you do is you define mine()method as pure virtual in an abstract class. And override it in subclasses while technically you should define the algorithm mine(in abstract class) like: 1 2 3 4 5 6 7 void mine(const string\u0026amp; report_file){ while(!EOF()){ auto line = get_line(); auto data_samples = parse(line); add_to_(report_file, data_samples); } } And make all of this method(i.e. get_line(), parse(), etc.) of the mining algorithm pure virtual to be implemented by derived class as these are the common yet type-dependent steps among the type of documents to extract data. Benefits of Template Method Design Pattern If you have a monolithic algorithm exposed to each \u0026amp; every class. And when steps of that algorithm changes, you might need to modify all the classes. But if you have several classes that contain almost identical algorithms with some minor differences \u0026amp; had employed the Template Method Design Pattern. Then you will have no worries. By pulling the common steps into abstract class, you are limiting code duplicity \u0026amp; encouraging expressiveness of code. Summary by FAQs What is the difference between Strategy \u0026amp; Template Method Design Pattern?\nTemplate Method is based on inheritance which alters parts of an algorithm by extending those parts in derived classes.\nStrategy is based on the composition which alters parts of the object\u0026rsquo;s behaviour by supplying it with different strategies that correspond to different behaviour.\nTemplate Method works at the class level, so it\u0026rsquo;s static.\nStrategy works on the object level, letting you switch behaviours at runtime.\nWhere should we use the Template Method Design Pattern?\nEmploy the Template Method Design Pattern when you want to let clients extend only particular steps of an algorithm, but not the entire algorithm structure.\n","permalink":"https://vishalchovatiya.github.io/posts/template-method-design-pattern-in-modern-cpp/","summary":"In software engineering, Behavioural Design Patterns deal with the assignment of responsibilities between objects. And encapsulating behaviour in an object to delegate requests. The Behavioural Design Patterns make the interaction between the objects easy \u0026amp; loosely coupled. In this article of the design pattern series, we\u0026rsquo;re going to take a look at Template Method Design Pattern in Modern C++. It allows us to define the skeleton of the algorithm in the base class with concrete implementations defined in derived classes.","title":"Template Method Design Pattern in Modern C++"},{"content":" Factory Builder Prototype Singleton ","permalink":"https://vishalchovatiya.github.io/reusable_block/creational-design-patterns/","summary":" Factory Builder Prototype Singleton ","title":"Creational design patterns"},{"content":" Chain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor ","permalink":"https://vishalchovatiya.github.io/reusable_block/behavioural-design-patterns/","summary":" Chain of responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor ","title":"Behavioural Design Patterns"},{"content":"The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally. I also consider myself a pragmatic person who wants to convey an idea in the simplest way possible rather than the standard way or using Jargons.\nNote:\nIf you stumbled here directly, then I would suggest you go through What is design pattern? first, even if it is trivial. I believe it will encourage you to explore more on this topic. All of this code you encounter in this series of articles are compiled using C++20(though I have used Modern C++ features up to C++17 in most cases). So if you don\u0026rsquo;t have access to the latest compiler you can use https://wandbox.org/ which has preinstalled boost library as well. ","permalink":"https://vishalchovatiya.github.io/reusable_block/design-pattern-prerequisites/","summary":"The code snippets you see throughout this series of articles are simplified not sophisticated. So you often see me not using keywords like override, final, public(while inheritance) just to make code compact \u0026amp; consumable(most of the time) in single standard screen size. I also prefer struct instead of class just to save line by not writing \u0026ldquo;public:\u0026rdquo; sometimes and also miss virtual destructor, constructor, copy constructor, prefix std::, deleting dynamic memory, intentionally.","title":"Design Pattern : Prerequisites"},{"content":" Adapter Bridge Composite Decorator Facade Flyweight Proxy ","permalink":"https://vishalchovatiya.github.io/reusable_block/structural-design-patterns/","summary":" Adapter Bridge Composite Decorator Facade Flyweight Proxy ","title":"Structural Design Patterns"},{"content":"The answer to \u0026ldquo;What exactly nullptr is in C++?\u0026rdquo; would be a piece of cake for experienced C++ eyes \u0026amp; for those who are aware of Modern C++ i.e. keyword. But nullptr is more than just a keyword in C++ \u0026amp; to explain that, I have written this article. But before jump-into it, we will see issues with NULL \u0026amp; then we\u0026rsquo;ll dive into the unsophisticated implementation of nullptr \u0026amp; some use-cases of nullptr.\nWhy do we need nullptr? To distinguish between an integer 0(zero) i.e. NULL \u0026amp; actual null of type pointer.\nnullptr vs NULL NULL is 0(zero) i.e. integer constant zero with C-style typecast to void*, while nullptr is prvalue of type nullptr_t which is integer literal evaluates to zero. For those of you who believe that NULL is same i.e. (void*)0 in C \u0026amp; C++. I would like to clarify that no it\u0026rsquo;s not: NULL - cppreference.com (C)\nNULL - cppreference.com (C++)\nC++ requires that macro NULL to be defined as an integral constant expression having the value of 0. So unlike in C, NULL cannot be defined as (void *)0 in the C++ standard library. Issues with NULL Implicit conversion 1 2 char *str = NULL; // Implicit conversion from void * to char * int i = NULL; // OK, but `i` is not pointer type Function calling ambiguity 1 2 3 4 5 void func(int) {} void func(int*){} void func(bool){} func(NULL); // Which one to call? Compilation produces the following error:\n1 2 3 4 5 6 7 8 9 10 11 error: call to \u0026#39;func\u0026#39; is ambiguous func(NULL); ^~~~ note: candidate function void func(bool){} ^ note: candidate function void func(int*){} ^ note: candidate function void func(int){} ^ 1 error generated. compiler exit status 1 Constructor overload 1 2 3 4 5 6 7 8 struct String { String(uint32_t) { /* size of string */ } String(const char*) { /* string */ } }; String s1( NULL ); String s2( 5 ); In such cases, you need explicit cast (i.e., `String s((char*)0)). Implementation of unsophisticated nullptr nullptr is a subtle example of Return Type Resolver idiom to automatically deduce a null pointer of the correct type depending upon the type of the instance it is assigning to. Consider the following simplest \u0026amp; unsophisticated nullptr implementation: 1 2 3 4 5 6 7 8 9 10 11 12 struct nullptr_t { void operator\u0026amp;() const = delete; // Can\u0026#39;t take address of nullptr template\u0026lt;class T\u0026gt; inline operator T*() const { return 0; } template\u0026lt;class C, class T\u0026gt; inline operator T C::*() const { return 0; } }; nullptr_t nullptr; If the above code seems strange \u0026amp; weird to you(although it should not), then I would suggest you go through my earlier article on advanced C++ concepts. The magic here is just the templatized conversion operator. If you are into a more authoritative source, then, here is a concrete implementation of nullptr from LLVM header. Use-cases of nullptr 1 2 3 4 5 6 7 8 9 10 11 struct C { void func(); }; int main(void) { int *ptr = nullptr; // OK void (C::*method_ptr)() = nullptr; // OK nullptr_t n1, n2; n1 = n2; //nullptr_t *null = \u0026amp;n1; // Address can\u0026#39;t be taken. } As shown in the above example, when nullptr is being assigned to an integer pointer, a int type instantiation of the templatized conversion function is created. And same goes for method pointers too. This way by leveraging C++ template functionality, we are actually creating the appropriate type of null pointer every time we do, a new type assignment. As nullptr is an integer literal with value zero, you can not able to use its address which we accomplished by deleting \u0026amp; operator. Function calling clarity with nullptr 1 2 3 4 5 void func(int) { /* ... */} void func(int *) { /* ... */} void func(bool) { /* ... */} func(nullptr); Now, func( int* ) will be called as nullptr will implicitly be deduced to int*`. Typecasting on nullptr_t A cast of nullptr_t to an integral type needs a reinterpret_cast, and has the same semantics as a cast of (void*)0 to an integral type. Casting nullptr_t to an integral type holds true as long as destination type is large enough. Consider this: 1 2 // int ptr_not_ok = reinterpret_cast\u0026lt;int\u0026gt;(nullptr); // Not OK long ptr_ok = reinterpret_cast\u0026lt;long long\u0026gt;(nullptr); // OK A reinterpret_cast cannot convert nullptr_t to any pointer type. Use static_cast instead. 1 2 3 4 5 6 7 void func(int*) { /*...*/ } void func(double*) { /*...*/ } func(nullptr); // compilation error, ambiguous call! // func(reinterpret_cast\u0026lt;int*\u0026gt;(nullptr)); // error: invalid cast from type \u0026#39;std::nullptr_t\u0026#39; to type \u0026#39;int*\u0026#39; func(static_cast\u0026lt;int*\u0026gt;(nullptr)); // OK nullptr is implicitly convertible to any pointer type so explicit conversion with static_cast is only valid. nullptr_t is comparable 1 2 3 4 5 6 int *ptr = nullptr; if (ptr == 0); // OK if (ptr \u0026lt;= nullptr); // OK int a = 0; if (a == nullptr); // error: invalid operands of types \u0026#39;int\u0026#39; and \u0026#39;std::nullptr_t\u0026#39; to binary \u0026#39;operator==\u0026#39; From Wikipedia article:\n…null pointer constant: nullptr. It is of type nullptr_t, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. It is not implicitly convertible or comparable to integral types, except for bool. 1 2 3 4 5 const int a = 0; if (a == nullptr); // OK const int b = 5; if (b == nullptr); // error: invalid operands of types \u0026#39;const int\u0026#39; and \u0026#39;std::nullptr_t\u0026#39; to binary \u0026#39;operator==\u0026#39; Template-argument is of type std::nullptr_t 1 2 3 4 template \u0026lt;typename T\u0026gt; void ptr_func(T *t) {} ptr_func(nullptr); // Can not deduce T As discussed earlier, Return Type Resolver needs an assignee to deduce the type. 1 2 3 4 5 template \u0026lt;typename T\u0026gt; void val_func(T t) {} val_func(nullptr); // deduces T = nullptr_t val_func((int*)nullptr); // deduces T = int*, prefer static_cast though Conversion to bool from nullptr_t From cppreference :\nIn the context of a direct-initialization, a bool object may be initialized from a prvalue of type std::nullptr_t, including nullptr. The resulting value is false. However, this is not considered to be an implicit conversion.\nThe conversion is only allowed for direct-initialization, but not copy-intialization, which including the case for passing an argument to a function by value. e.g.\n1 2 3 4 5 6 bool b1 = nullptr; // Not OK bool b2 {nullptr}; // OK void func(bool){} func(nullptr); // Not OK, need to do func(static_cast\u0026lt;bool\u0026gt;(nullptr)); Misc 1 2 3 4 5 typeid(nullptr); // OK throw nullptr; // OK char *ptr = expr ? nullptr : nullptr; // OK // char *ptr1 = expr ? 0 : nullptr; // Not OK, types are not compatible static_assert(sizeof(NULL) == sizeof(nullptr_t)); Summary by FAQs When was nullptr introduced?\nC++11\nIs nullptr a keyword or an instance of a type std::nullptr_t?\nBoth true and false are keywords \u0026amp; literals, as they have a type ( bool ). nullptr is a pointer literal of type std::nullptr_t, \u0026amp; it\u0026rsquo;s a prvalue (i.e. pure rvalue, you cannot take the address of it using \u0026amp;). For more.\nWhat are the advantages of using nullptr?\nNo function calling ambiguity between overload sets. You can do template specialization with nullptr_t. Code will become more safe, intuitive \u0026amp; expressive. if (ptr == nullptr); rather than if (ptr == 0);. Is NULL in C++ equal to nullptr from C++11?\nNot at all. The following line does not even compile:\ncout\u0026lt;\u0026lt;is_same_v\u0026lt;nullptr, NULL\u0026gt;\u0026lt;\u0026lt;endl;\nCan I convert nullptr to bool?\nYes. But only if you direct-initialization. i.e. bool is_false{nullptr};. Else need to use static_cast.\nHow is nullptr defined?\nIt\u0026rsquo;s just the templatized conversion operator known as Return Type Resolver.\nWhat exactly nullptr is in C++?\nReferences You can find similar resources here, here, and in nullptr proposal(N2431); however, this post will walk you through the ins and outs of the spec step-by-step in a more friendly way so that you come away with a full understanding of the concept without any needless confusion\n","permalink":"https://vishalchovatiya.github.io/posts/what-exactly-nullptr-is-in-cpp/","summary":"The answer to \u0026ldquo;What exactly nullptr is in C++?\u0026rdquo; would be a piece of cake for experienced C++ eyes \u0026amp; for those who are aware of Modern C++ i.e. keyword. But nullptr is more than just a keyword in C++ \u0026amp; to explain that, I have written this article. But before jump-into it, we will see issues with NULL \u0026amp; then we\u0026rsquo;ll dive into the unsophisticated implementation of nullptr \u0026amp; some use-cases of nullptr.","title":"What Exactly nullptr Is in C++?"},{"content":"So I have started updating myself with Modern C++ a while ago \u0026amp; since my post 21 new features of Modern C++ to use in your project \u0026amp; All about lambda function in C++ was popular I decided to write about advance C++ concepts \u0026amp; idioms which I have learned from this wikibook \u0026amp; course.\nThere are many other advance C++ concepts \u0026amp; idioms as well but I consider these 7 as \u0026ldquo;should-know\u0026rdquo;. To explain them, I have taken a more pragmatic approach than sophistication. So, I have weighed more on readability, simplicity over other fancy features, syntax sugars and complexity.\nNote: There are also drawbacks of using some of these techniques which I have not discussed here or maybe I am not qualified enough.\n1. RAII Intent: To guarantee the release of resource(s) at the end of a scope.\nImplementation: Wrap resource into a class; resource acquired in the constructor immediately after its allocation; and automatically released in the destructor; resource used via an interface of the class;\nAlso known as: Execute-around object, Resource release is finalization, Scope-bound resource management\nProblem Resource Acquisition Is Initialization idiom is the most powerful \u0026amp; vastly used idiom although the name is really terrible as the idiom is rather about resource release than acquisition. RAII guarantee the release of resource at the end of a scope/destruction. It thus ensures no resource leaks and provides basic exception safety guarantee. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct resource { resource(int x, int y) { cout \u0026lt;\u0026lt; \u0026#34;resource acquired\\n\u0026#34;; } ~resource() { cout \u0026lt;\u0026lt; \u0026#34;resource destroyed\\n\u0026#34;; } }; void func() { resource *ptr = new resource(1, 2); int x; std::cout \u0026lt;\u0026lt; \u0026#34;Enter an integer: \u0026#34;; std::cin \u0026gt;\u0026gt; x; if (x == 0) throw 0; // the function returns early, and ptr won\u0026#39;t be deleted! if (x \u0026lt; 0) return; // the function returns early, and ptr won\u0026#39;t be deleted! // do stuff with ptr here delete ptr; } In the above code, the early return or throw statement, causing the function to terminate without ptr being deleted. In addition, the memory allocated for variable ptr is now leaked (and leaked again every time this function is called and returns early). Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template\u0026lt;class T\u0026gt; class smart_ptr { T* m_ptr; public: template\u0026lt;typename... Args\u0026gt; smart_ptr(Args\u0026amp;\u0026amp;... args) : m_ptr(new T(std::forward\u0026lt;Args\u0026gt;(args)...)){} ~smart_ptr() { delete m_ptr; } smart_ptr(const smart_ptr\u0026amp; rhs) = delete; smart_ptr\u0026amp; operator=(const smart_ptr\u0026amp; rhs) = delete; smart_ptr(smart_ptr\u0026amp;\u0026amp; rhs) : m_ptr(exchange(rhs.m_ptr, nullptr)){} smart_ptr\u0026amp; operator=(smart_ptr\u0026amp;\u0026amp; rhs){ if (\u0026amp;rhs == this) return *this; delete m_ptr; m_ptr = exchange(rhs.m_ptr,nullptr); return *this; } T\u0026amp; operator*() const { return *m_ptr; } T* operator-\u0026gt;() const { return m_ptr; } }; void func() { auto ptr = smart_ptr\u0026lt;resource\u0026gt;(1, 2); // now ptr guarantee the release of resource // ... } Note that no matter what happens after ptr declaration, ptr will be destroyed when the function terminates (regardless of how it terminates). As the ptr is a local object, the destructor will be called while the function stack frame rewinds. Hence, we are assured that the resource will be properly cleaned up. Usecases Using RAII, resources like new/delete, malloc/free, acquire/release, mutex lock/unlock, file open/close, count ++/--, database connect/disconnect or anything else that exists in limited supply can easily be managed. Examples from C++ Standard Library include std::unique_ptr, std::ofstream, std::lock_guard, etc. 2. Return Type Resolver Intent: To deduce the type of the object being initialize or assign to.\nImplementation: Uses templatized conversion operator.\nAlso known as: Return type overloading\nIssue 1 2 int from_string(const char *str) { return std::stoi(str); } float from_string(const char *str) { return std::stof(str); } // error A function can not overloaded only by its return type. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class from_string { const string m_str; public: from_string(const char *str) : m_str(str) {} template \u0026lt;typename type\u0026gt; operator type(){ if constexpr(is_same_v\u0026lt;type, float\u0026gt;) return stof(m_str); else if (is_same_v\u0026lt;type, int\u0026gt;) return stoi(m_str); } }; int n_int = from_string(\u0026#34;123\u0026#34;); float n_float = from_string(\u0026#34;123.111\u0026#34;); // Will only work with C++17 due to `is_same_v` If you are unaware of constexpr, I have written a short post on when to use const vs constexpr in c++.\nUsecases So, when you use nullptr(introduced in C++11), this is the technique that runs under the hood to deduce the correct type depending upon the pointer variable it is assigning to. You can also overcome the function overloading limitation on the basis of a return type as we have seen above. Return Type Resolver can also used to provide a generic interface for assignment, independent of the object assigned to. 3. Type Erasure Intent: To create generic container that can handle a variety of concrete types.\nImplementation: Can be implemented by void*, templates, polymorphism, union, proxy class, etc.\nAlso known as: Duck-typing\nProblem C++ is a statically typed language with strong typing. In statically typed languages, object type known \u0026amp; set at compile-time. While in dynamically typed languages the type associated with run-time values. In other words, in strongly typed languages the type of an object doesn\u0026rsquo;t change after compilation. However, to overcome this limitation \u0026amp; providing a feature like dynamically typed languages, library designers come up with various generic container kind of things like std::any(C++17), std::variant (C++17), std::function(C++11), etc. Different Type Erasure Techniques There is no one strict rule on how to implement this idiom, it can have various forms with its own drawbacks as follows: =\u0026gt; Type erasure using void* (like in C)\n1 2 void qsort (void* base, size_t num, size_t size, int (*compare)(const void*,const void*)); Drawback: not safe \u0026amp; separate compare function needed for each type\n=\u0026gt; Type erasure using C++ templates\n1 2 template \u0026lt;class RandomAccessIterator\u0026gt; void sort(RandomAccessIterator first, RandomAccessIterator last); Drawback: may lead to many function template instantiations \u0026amp; longer compilation time\n=\u0026gt; Type erasure using polymorphism\n1 2 3 4 5 6 7 struct base { virtual void method() = 0; }; struct derived_1 : base { void method() { cout \u0026lt;\u0026lt; \u0026#34;derived_1\\n\u0026#34;; } }; struct derived_2 : base { void method() { cout \u0026lt;\u0026lt; \u0026#34;derived_2\\n\u0026#34;; } }; // We don\u0026#39;t see a concrete type (it\u0026#39;s erased) though can dynamic_cast void call(base* ptr) { ptr-\u0026gt;method(); }; Drawback: run-time cost (dynamic dispatch, indirection, vtable, etc.)\n=\u0026gt; Type erasure using union\n1 2 3 4 5 6 7 8 9 struct Data {}; union U { Data d; // occupies 1 byte std::int32_t n; // occupies 4 bytes char c; // occupies 1 byte ~U() {} // need to know currently active type }; // an instance of U in total occupies 4 bytes. Drawback: not type-safe\nSolution As I mentioned earlier that standard library already has such generic containers. To understand type erasure better let\u0026rsquo;s implement one i.e. std::any: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 struct any { struct base {}; template\u0026lt;typename T\u0026gt; struct inner: base{ inner(T t): m_t{std::move(t)} {} T m_t; static void type() {} }; any(): m_ptr{nullptr}, typePtr{nullptr} {} template\u0026lt;typename T\u0026gt; any(T \u0026amp;\u0026amp; t): m_ptr{std::make_unique\u0026lt;inner\u0026lt;T\u0026gt;\u0026gt;(t)}, typePtr{\u0026amp;inner\u0026lt;T\u0026gt;::type} {} template\u0026lt;typename T\u0026gt; any\u0026amp; operator=(T\u0026amp;\u0026amp; t){ m_ptr = std::make_unique\u0026lt;inner\u0026lt;T\u0026gt;\u0026gt;(t); typePtr = \u0026amp;inner\u0026lt;T\u0026gt;::type; return *this; } private: template\u0026lt;typename T\u0026gt; friend T\u0026amp; any_cast(const any\u0026amp; var); std::unique_ptr\u0026lt;base\u0026gt; m_ptr = nullptr; void (*typePtr)() = nullptr; }; template\u0026lt;typename T\u0026gt; T\u0026amp; any_cast(const any\u0026amp; var) { if(var.typePtr == any::inner\u0026lt;T\u0026gt;::type) return static_cast\u0026lt;any::inner\u0026lt;T\u0026gt;*\u0026gt;(var.m_ptr.get())-\u0026gt;m_t; throw std::logic_error{\u0026#34;Bad cast!\u0026#34;}; } int main() { any var(10); std::cout \u0026lt;\u0026lt; any_cast\u0026lt;int\u0026gt;(var) \u0026lt;\u0026lt; std::endl; var = std::string{\u0026#34;some text\u0026#34;}; std::cout \u0026lt;\u0026lt; any_cast\u0026lt;std::string\u0026gt;(var) \u0026lt;\u0026lt; std::endl; return 0; } Especially, the thing here to note is how we are leveraging empty static method i.e. inner\u0026lt;T\u0026gt;::type() to determine template instance type in any_cast\u0026lt;T\u0026gt;.\nUsecases Employ to handle multiple types of the return value from function/method(Although that\u0026rsquo;s not recommended advice). 4. CRTP Intent: To achieve static polymorphism.\nImplementation: Make use of base class template spcialization.\nAlso known as: Upside-down inheritance, Static polymorphism\nProblem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct obj_type_1 { bool operator\u0026lt;(const value \u0026amp;rhs) const {return m_x \u0026lt; rhs.m_x;} // bool operator==(const value \u0026amp;rhs) const; // bool operator!=(const value \u0026amp;rhs) const; // List goes on. . . . . . . . . . . . . . . . . . . . private: // data members to compare }; struct obj_type_2 { bool operator\u0026lt;(const value \u0026amp;rhs) const {return m_x \u0026lt; rhs.m_x;} // bool operator==(const value \u0026amp;rhs) const; // bool operator!=(const value \u0026amp;rhs) const; // List goes on. . . . . . . . . . . . . . . . . . . . private: // data members to compare }; struct obj_type_3 { ... struct obj_type_4 { ... // List goes on. . . . . . . . . . . . . . . . . . . . For each comparable objects, you need to define respective comparison operators. This is redundant because if we have an operator \u0026lt; , we can overload other operators on the basis of it. Thus, operator \u0026lt; is the only one operator having type information, other operators can be made type independent for reusability purpose. Solution Curiously Recurring Template Pattern implementation rule is simple, separate out the type-dependent \u0026amp; independent functionality and bind type independent functionality with the base class using self-referencing template. Above line may seem cryptic at first. So, consider the below solution to the above problem for more clarity: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class derived\u0026gt; struct compare {}; struct value : compare\u0026lt;value\u0026gt; { int m_x; value(int x) : m_x(x) {} bool operator\u0026lt;(const value \u0026amp;rhs) const { return m_x \u0026lt; rhs.m_x; } }; template \u0026lt;class derived\u0026gt; bool operator \u0026gt; (const compare\u0026lt;derived\u0026gt; \u0026amp;lhs, const compare\u0026lt;derived\u0026gt; \u0026amp;rhs) { // static_assert(std::is_base_of_v\u0026lt;compare\u0026lt;derived\u0026gt;, derived\u0026gt;); // Compile time safety measures return (static_cast\u0026lt;const derived\u0026amp;\u0026gt;(rhs) \u0026lt; static_cast\u0026lt;const derived\u0026amp;\u0026gt;(lhs)); } /* Same goes with other operators == :: returns !(lhs \u0026lt; rhs) and !(rhs \u0026lt; lhs) != :: returns !(lhs == rhs) \u0026gt;= :: returns (rhs \u0026lt; lhs) or (rhs == lhs) \u0026lt;= :: returns (lhs \u0026lt; rhs) or (rhs == lhs) */ int main() { value v1{5}, v2{10}; cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; \u0026#34;v1 \u0026gt; v2: \u0026#34; \u0026lt;\u0026lt; (v1 \u0026gt; v2) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } // Now no need to write comparator operators for all the classes, // Write only type dependent `operator \u0026lt;` \u0026amp; use CRTP Usecases CRTP widely employed for static polymorphism without bearing the cost of virtual dispatch mechanism. Consider the following code we have not used virtual keyword \u0026amp; still achieved the functionality of polymorphism(specifically static polymorphism). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template\u0026lt;typename specific_animal\u0026gt; struct animal { void who() { implementation().who(); } private: specific_animal\u0026amp; implementation() {return *static_cast\u0026lt;specific_animal*\u0026gt;(this);} }; struct dog : public animal\u0026lt;dog\u0026gt; { void who() { cout \u0026lt;\u0026lt; \u0026#34;dog\u0026#34; \u0026lt;\u0026lt; endl; } }; struct cat : public animal\u0026lt;cat\u0026gt; { void who() { cout \u0026lt;\u0026lt; \u0026#34;cat\u0026#34; \u0026lt;\u0026lt; endl; } }; template\u0026lt;typename specific_animal\u0026gt; void who_am_i(animal\u0026lt;specific_animal\u0026gt; \u0026amp; animal) { animal.who(); } CRTP can also used for optimization as we have seen above it also enables code reusability. Update: The above hiccup of declaring multiple comparisons operator will permanently be sorted from C++20 by using spaceship(\u0026lt;=\u0026gt;)/Three-way-comparison operator.\n5. Virtual Constructor Intent: To create a copy or new object without knowing its concrete type.\nImplementation: Exploits overloaded methods with polymorphic assignment.\nAlso known as: Factory method/design-pattern.\nProblem C++ has the support of polymorphic object destruction using it\u0026rsquo;s base class\u0026rsquo;s virtual destructor. But, equivalent support for creation and copying of objects is missing as С++ doesn\u0026rsquo;t support virtual constructor, copy constructors. Moreover, you can’t create an object unless you know its static type, because the compiler must know the amount of space it needs to allocate. For the same reason, copy of an object also requires its type to known at compile-time. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct animal { virtual ~animal(){ cout\u0026lt;\u0026lt;\u0026#34;~animal\\n\u0026#34;; } }; struct dog : animal { ~dog(){ cout\u0026lt;\u0026lt;\u0026#34;~dog\\n\u0026#34;; } }; struct cat : animal { ~cat(){ cout\u0026lt;\u0026lt;\u0026#34;~cat\\n\u0026#34;; } }; void who_am_i(animal *who) { // not sure whether dog would be passed here or cat // How to `create` the object of same type i.e. pointed by who ? // How to `copy` object of same type i.e. pointed by who ? delete who; // you can delete object pointed by who } Solution The Virtual Constructor technique allows polymorphic creation \u0026amp; copying of objects in C++ by delegating the act of creation \u0026amp; copying the object to the derived class through the use of virtual methods. Following code is not only implement virtual constructor(i.e. create()) but also implements virtual copy constructor (i.e. clone()) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct animal { virtual ~animal() = default; virtual std::unique_ptr\u0026lt;animal\u0026gt; create() = 0; virtual std::unique_ptr\u0026lt;animal\u0026gt; clone() = 0; }; struct dog : animal { std::unique_ptr\u0026lt;animal\u0026gt; create() { return std::make_unique\u0026lt;dog\u0026gt;(); } std::unique_ptr\u0026lt;animal\u0026gt; clone() { return std::make_unique\u0026lt;dog\u0026gt;(*this); } }; struct cat : animal { std::unique_ptr\u0026lt;animal\u0026gt; create() { return std::make_unique\u0026lt;cat\u0026gt;(); } std::unique_ptr\u0026lt;animal\u0026gt; clone() { return std::make_unique\u0026lt;cat\u0026gt;(*this); } }; void who_am_i(animal *who) { auto new_who = who-\u0026gt;create();// `create` the object of same type i.e. pointed by who ? auto duplicate_who = who-\u0026gt;clone(); // `copy` object of same type i.e. pointed by who ? delete who; // you can delete object pointed by who } Usecases To provide a generic interface to produce/copy a variety of classes using only one class. 6. SFINAE and std::enable_if Intent: To filter out functions that do not yield valid template instantiations from a set of overloaded functions.\nImplementation: Achieved automatically by compiler or exploited using std::enable_if.\nAlso known as:\nMotivation Substitution Failure Is Not An Error is a language feature(not an idiom) a C++ compiler uses to filter out some templated function overloads during overload resolution. During overload resolution of function templates, when substituting the explicitly specified or deduced type for the template parameter fails, the specialization discarded from the overload set instead of causing a compile error. Substitution failure happens when type or expression ill-formed. 1 2 3 4 5 6 7 8 9 10 11 template\u0026lt;class T\u0026gt; void func(T* t){ // Single overload set if constexpr(std::is_class_v\u0026lt;T\u0026gt;){ cout \u0026lt;\u0026lt; \u0026#34;T is user-defined type\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;T is primitive type\\n\u0026#34;; } } int primitive_t = 6; struct {char var = \u0026#39;4\u0026#39;;}class_t; func(\u0026amp;class_t); func(\u0026amp;primitive_t); Imagine if you want to create two sets(based on primitive type \u0026amp; user-defined type separately) of a function having the same signature? Solution 1 2 3 4 5 6 7 8 9 template\u0026lt;class T, typename = std::enable_if_t\u0026lt;std::is_class_v\u0026lt;T\u0026gt;\u0026gt;\u0026gt; void func(T* t){ cout \u0026lt;\u0026lt; \u0026#34;T is user-defined type\\n\u0026#34;; } template\u0026lt;class T, std::enable_if_t\u0026lt;std::is_integral_v\u0026lt;T\u0026gt;, T\u0026gt; = 0\u0026gt; void func(T* t){ // NOTE: function signature is NOT-MODIFIED cout \u0026lt;\u0026lt; \u0026#34;T is primitive type\\n\u0026#34;; } Above code snippet is a short example of exploiting SFINAE using std::enable_if, in which first template instantiation will become equivalent to void func\u0026lt;(anonymous), void\u0026gt;((anonymous) * t) and second, void func(int * t). You can read more about std::enable_if here. Usecases Together with std::enable_if, SFINAE is heavily used in template metaprogramming. The standard library also leveraged SFINAE in most type_traits utilities. Consider the following example which checks for the user-defined type or primitive type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Stolen \u0026amp; trimmed from https://stackoverflow.com/questions/982808/c-sfinae-examples. template\u0026lt;typename T\u0026gt; class is_class_type { template\u0026lt;typename C\u0026gt; static char test(int C::*); template\u0026lt;typename C\u0026gt; static double test(...); public: enum { value = sizeof(is_class_type\u0026lt;T\u0026gt;::test\u0026lt;T\u0026gt;(0)) == sizeof(char) }; }; struct class_t{}; int main() { cout\u0026lt;\u0026lt;is_class_type\u0026lt;class_t\u0026gt;::value\u0026lt;\u0026lt;endl; // 1 cout\u0026lt;\u0026lt;is_class_type\u0026lt;int\u0026gt;::value\u0026lt;\u0026lt;endl; // 0 return 0; } Without SFINAE, you would get a compiler error, something like \u0026ldquo;0 cannot be converted to member pointer for a non-class type int\u0026rdquo; as both the overload of test method only differs in terms of the return type. Because int is not a class, so it can\u0026rsquo;t have a member pointer of type int int::* . 7. Proxy Intent: To achieve intuitive functionality using middleware class.\nImplementation: By use of temporary/proxy class.\nAlso known as: operator [](i.e. subscript) proxy, double/twice operator overloading\nMotivation Most of the dev believes this is only about the subscript operator (i.e. operator[ ]), but I believe type/class that comes in between exchanging data is proxy. We have already seen a nice example of this idiom indirectly above in type-erasure(i.e. class any::inner\u0026lt;\u0026gt;). But still, I think one more example will add concreteness to our understanding. operator [ ] solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template \u0026lt;typename T = int\u0026gt; struct arr2D{ private: struct proxy_class{ proxy_class(T *arr) : m_arr_ptr(arr) {} T \u0026amp;operator[](uint32_t idx) { return m_arr_ptr[idx]; } private: T *m_arr_ptr; }; T m_arr[10][10]; public: arr2D::proxy_class operator[](uint32_t idx) { return arr2D::proxy_class(m_arr[idx]); } }; int main() { arr2D\u0026lt;\u0026gt; arr; arr[0][0] = 1; cout \u0026lt;\u0026lt; arr[0][0]; return 0; } Usecases To create intuitive features like double operator overloading, std::any etc. Summary by FAQs When to actually use RAII?\nWhen you have set of steps to carry out a task \u0026amp; two steps are ideal i.e. set-up \u0026amp; clean-up, then that\u0026rsquo;s the place you can employ RAII.\nWhy can\u0026rsquo;t functions be overloaded by return type?\nYou can\u0026rsquo;t overload on return types as it is not mandatory to use the return value of the functions in a function call expression. For example, I can just say\nget_val();`\nWhat does the compiler do now?\nWhen to use return type resolver idiom?\nYou can apply return type resolver idiom when your input types are fixed but output types may vary.\nWhat is type erasure in C++?\nType erasure technique is used to design generic type which relies on the type of assignment(as we do in python). By the way, do you know auto or can you design one now? Best scenarios to apply type erasure idiom?\nUseful in generic programming. Can also be used to handle multiple types of the return value from function/method(Although that\u0026rsquo;s not recommended advice). What is the curiously recurring template pattern (CRTP)?\nCRTP is when a class A has a base class. And that base class is a template specialization for the class A itself. E.g.\ntemplate \u0026lt;class T\u0026gt;\nclass X{...};\nclass A : public X\u0026lt;A\u0026gt; {...};\nIt is curiously recurring, isn\u0026rsquo;t it?\nWhy Curiously Recurring Template Pattern (CRTP) works?\nI think this answer is very appropriate.\nWhat is SFINAE?\nSubstitution Failure Is Not An Error is a language feature(not an idiom) a C++ compiler uses to filter out some templated function overloads during overload resolution.\nWhat is Proxy Class in C++?\nA proxy is a class that provides a modified interface to another class.\nWhy do we not have a virtual constructor in C++?\nA virtual-table(vtable) is made for each Class having one or more \u0026lsquo;virtual-functions\u0026rsquo;. Whenever an object is created of such class, it contains a \u0026lsquo;virtual-pointer\u0026rsquo; which points to the base of the corresponding vtable. Whenever there is a virtual function call, the vtable is used to resolve to the function address. A constructor can not be virtual, because when the constructor of a class is executed there is no vtable in the memory, means no virtual pointer defined yet. Hence the constructor should always be non-virtual. Can we make a class copy constructor virtual in C++?\nSimilar to \u0026ldquo;Why do we not have a virtual constructor in C++?\u0026rdquo; which already answered above.\nWhat are the use cases \u0026amp; need for virtual constructor?\nTo create \u0026amp; copy the object(without knowing its concrete type) using a base class polymorphic method.\n","permalink":"https://vishalchovatiya.github.io/posts/7-advance-cpp-concepts-idiom-examples-you-should-know/","summary":"So I have started updating myself with Modern C++ a while ago \u0026amp; since my post 21 new features of Modern C++ to use in your project \u0026amp; All about lambda function in C++ was popular I decided to write about advance C++ concepts \u0026amp; idioms which I have learned from this wikibook \u0026amp; course.\nThere are many other advance C++ concepts \u0026amp; idioms as well but I consider these 7 as \u0026ldquo;should-know\u0026rdquo;.","title":"7 Advance C++ Concepts \u0026 Idiom Examples You Should Know"},{"content":"Exception handling in C++ is a well-unschooled topic if you observe initial stages of the learning curve. There are numerous tutorials available online on exception handling in C++. But few explains what you should not do \u0026amp; intricacies around it. So here I am to bridge the gap \u0026amp; show you some intricacies, from where \u0026amp; why you should not throw an exception and C++ exception handling best practices. Along with some newer features introduced for exception handling in Modern C++ with example.\nIn the end, we will see the performance cost of using an exception by a quick benchmark code. Finally, we will close the article with a summary of Best practices \u0026amp; some C++ Core Guidelines on exception handling.\nNote: I would not cover anything regarding a dynamic exception as it deprecated from C++11 and removed in C++17.\nTerminology/Jargon/Idiom You May Face potentially throwing: may or may not throw an exception. noexcept: this is specifier as well as operator depending upon where \u0026amp; how you use it. Will see that later. RAII: Resource Acquisition Is Initialization is a scope-bound resource management mechanism. Which means resource allocation done with the constructor \u0026amp; resource deallocation with the destructor during the defined scope of the object. I know it\u0026rsquo;s a terrible name but very powerful concept. Implicitly-declared special member functions: I think this need not require any introduction. 1. Implement Copy And/Or Move Constructor While Throwing User-Defined Type Object 1 2 3 4 5 6 7 8 9 10 11 12 struct demo { demo() = default; demo(demo \u0026amp;\u0026amp;) = delete; demo(const demo \u0026amp;) = delete; }; int main() { throw demo{}; return 0; } Upon throw expression, a copy of the exception object created as the original object goes out of the scope during the stack unwinding process. During that initialization, we may expect copy elision (see this) – omits copy or move constructors (object constructed directly into the storage of the target object). But even though copy elision may or may not apply you should provide proper copy constructor and/or move constructor which is what C++ standard mandates(see 15.1). See below compilation error for reference. 1 2 3 4 5 6 7 8 error: call to deleted constructor of \u0026#39;demo\u0026#39; throw demo{}; ^~~~~~ note: \u0026#39;demo\u0026#39; has been explicitly marked deleted here demo(demo \u0026amp;\u0026amp;) = delete; ^ 1 error generated. compiler exit status 1 Above error stands true till C++14. Since C++17, If the thrown object is a prvalue, the copy/move elision is guaranteed. If we catch an exception by value, we may also expect copy elision(compilers permitted to do so, but it is not mandatory). The exception object is an lvalue argument when initializing catch clause parameters. TL;DR\nclass used for throwing the exception object needs copy and/or move constructors\n2. Be Cautious While Throwing an Exception From the Constructor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct base { base(){cout\u0026lt;\u0026lt;\u0026#34;base\\n\u0026#34;;} ~base(){cout\u0026lt;\u0026lt;\u0026#34;~base\\n\u0026#34;;} }; struct derive : base { derive(){cout\u0026lt;\u0026lt;\u0026#34;derive\\n\u0026#34;; throw -1;} ~derive(){cout\u0026lt;\u0026lt;\u0026#34;~derive\\n\u0026#34;;} }; int main() { try{ derive{}; } catch (...){} return 0; } When an exception is thrown from a constructor, stack unwinding begins, destructors for the object will only be called, if an object creation is successful. So be caution with dynamic memory allocation here. In such cases, you should use RAII. 1 2 3 base derive ~base As you can see in the above case, the destructor of derive is not executed, Because, it is not created successfully. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct base { base() { cout \u0026lt;\u0026lt; \u0026#34;base\\n\u0026#34;; } ~base() { cout \u0026lt;\u0026lt; \u0026#34;~base\\n\u0026#34;; } }; struct derive : base { derive() = default; derive(int) : derive{} { cout \u0026lt;\u0026lt; \u0026#34;derive\\n\u0026#34;; throw - 1; } ~derive() { cout \u0026lt;\u0026lt; \u0026#34;~derive\\n\u0026#34;; } }; int main() { try{ derive{0}; } catch (...){} return 0; } In the case of constructor delegation, it is considered as the creation of object hence destructor of derive will be called. 1 2 3 4 base derive ~derive ~base TL;DR\nWhen an exception is thrown from a constructor, destructors for the object will be called only \u0026amp; only if an object is created successfully\n3. Avoid Throwing Exceptions out of a Destructor 1 2 3 4 5 6 7 8 9 10 11 12 13 struct demo { ~demo() { throw std::exception{}; } }; int main() { try{ demo d; } catch (const std::exception \u0026amp;){} return 0; } Above code seems straight forward but when you run it, it terminates as shown below rather than catching the exception. Reason for this is destructors are by default noexcept (i.e. non-throwing) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ clang++-7 -o main main.cpp warning: \u0026#39;~demo\u0026#39; has a non-throwing exception specification but can still throw [-Wexceptions] ~demo() { throw std::exception{}; } ^ note: destructor has a implicit non-throwing exception specification ~demo() { throw std::exception{}; } ^ 1 warning generated. $ $ ./main terminate called after throwing an instance of \u0026#39;std::exception\u0026#39; what(): std::exception exited, aborted `noexcept(false) will solve our problem as below 1 2 3 4 struct X { ~X() noexcept(false) { throw std::exception{}; } }; But don’t do it. Destructors are by default non-throwing for a reason, and we must not throw exceptions in destructors unless we catch them inside the destructor. Why you should not throw an exception from a destructor?\nBecause destructors are called during stack unwinding when an exception is thrown, and we are not allowed to throw another exception while the previous one is not caught – in such a case std::terminate will be called.\nConsider the following example for more clarity. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct base { ~base() noexcept(false) { throw 1; } }; struct derive : base { ~derive() noexcept(false) { throw 2; } }; int main() { try{ derive d; } catch (...){ } return 0; } An exception will be thrown when the object d will be destroyed as a result of RAII. But at the same time destructor of base will also be called as it is sub-object of derive which will again throw an exception. Now we have two exceptions at the same time which is invalid scenario \u0026amp; std::terminate will be called. There are some type trait utilities like std::is_nothrow_destructible, std::is_nothrow_constructible, etc. from #include\u0026lt;type_traits\u0026gt; by which you can check whether the special member functions are exception-safe or not.\n1 2 3 4 5 6 int main() { cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; std::is_nothrow_destructible\u0026lt;std::string\u0026gt;::value \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; std::is_nothrow_constructible\u0026lt;std::string\u0026gt;::value \u0026lt;\u0026lt; endl; return 0; } TL;DR\n1. Destructors are by default noexcept (i.e. non-throwing).\n2. You should not throw exception out of destructors because destructors are called during stack unwinding when an exception is thrown, and we are not allowed to throw another exception while the previous one is not caught – in such a case std::terminate will be called.\n4. Nested Exception Handling Best Practice With std::exception_ptr( C++11) Example This is more of a demonstration rather the best practice of the nested exception scenario using std::exception_ptr. Although you can simply use std::exception without complicating things much but std::exception_ptr will provide us with the leverage of handling exception out of try / catch clause.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void print_nested_exception(const std::exception_ptr \u0026amp;eptr=std::current_exception(), size_t level=0) { static auto get_nested = [](auto \u0026amp;e) -\u0026gt; std::exception_ptr { try { return dynamic_cast\u0026lt;const std::nested_exception \u0026amp;\u0026gt;(e).nested_ptr(); } catch (const std::bad_cast\u0026amp;) { return nullptr; } }; try{ if (eptr) std::rethrow_exception(eptr); } catch (const std::exception \u0026amp;e){ std::cerr \u0026lt;\u0026lt; std::string(level, \u0026#39; \u0026#39;) \u0026lt;\u0026lt; \u0026#34;exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; print_nested_exception(get_nested(e), level + 1);// rewind all nested exception } } // ----------------------------------------------------------------------------------------------- void func2(){ try { throw std::runtime_error(\u0026#34;TESTING NESTED EXCEPTION SUCCESS\u0026#34;); } catch (...) { std::throw_with_nested(std::runtime_error(\u0026#34;func2() failed\u0026#34;)); } } void func1(){ try { func2(); } catch (...) { std::throw_with_nested(std::runtime_error(\u0026#34;func1() failed\u0026#34;)); } } int main() { try { func1(); } catch (const std::exception\u0026amp;) { print_nested_exception(); } return 0; } // Will only work with C++14 or above Above example looks complicated at first, but once you have implemented nested exception handler(i.e. print_nested_exception). Then you only need to focus on throwing the exception using std::throw_with_nested function. 1 2 3 exception: func1() failed exception: func2() failed exception: TESTING NESTED EXCEPTION SUCCESS The main thing to focus here is print_nested_exception function in which we are rewinding nested exception using std::rethrow_exception \u0026amp; std::exception_ptr. std::exception_ptr is a shared pointer like type though dereferencing it is undefined behaviour. It can hold nullptr or point to an exception object and can be constructed as: 1 2 3 std::exception_ptr e1; // null std::exception_ptr e2 = std::current_exception(); // null or a current exception std::exception_ptr e3 = std::make_exception_ptr(std::exception{}); // std::exception Once std::exception_ptr is created, we can use it to throw or re-throw exceptions by calling `std::rethrow_exception(exception_ptr) as we did above, which throws the pointed exception object. TL;DR\n1. std::exception_ptr extends the lifetime of a pointed exception object beyond a catch clause.\n2. We may use std::exception_ptr to delay the handling of a current exception and transfer it to some other palaces. Though, practical usecase of std::exception_ptr is between threads.\n5. Use noexcept `Specifier` vs `Operator` Appropriately I think this is an oblivious concept among the other concepts of the C++ exceptions. noexcept specifier \u0026amp; operator came in C++11 to replace deprecated(removed from C++17) dynamic exception specification. 1 2 3 4 5 6 7 8 9 10 11 12 void func() throw(std::exception); // dynamic excpetions, removed from C++17 void potentially_throwing(); // may throw void non_throwing() noexcept; // \u0026#34;specifier\u0026#34; specifying non-throwing function void print() {} void (*func_ptr)() noexcept = print; // Not OK from C++17, `print()`should be noexcept too, works in C++11/14 void debug_deep() noexcept(false) {} // specifier specifying throw void debug() noexcept(noexcept(debug_deep())) {} // specifier \u0026amp; operator, will follow exception rule of `debug_deep` auto l_non_throwing = []() noexcept {}; // Yeah..! lambdas are also in party noexcept Specifier I think this needs no introduction it does what its name suggests. So let\u0026rsquo;s quickly go through some pointers:\nCan use for normal functions, methods, lambda functions \u0026amp; function pointer. From C++17, function pointer with noexcept can not points to potentially throwing function. Finally, don’t use noexcept specifier for virtual functions in a base class/interface because it enforces restriction for all overrides. Don’t use noexcept unless you really need it. \u0026ldquo;Specify it when it is useful and correct\u0026rdquo; - Google’s cppguide. noexcept Operator \u0026amp; What Is It Use For? Added in C++11, noexcept operator takes an expression (not necessarily constant) and performs a compile-time check determining if that expression is non-throwing (noexcept) or potentially throwing. The result of such compile-time check can be used, for example, to add noexceptspecifier to the same category, higher-level function `(noexcept(noexcept(expr))) or in if constexpr. We can use noexcept operator to check if some class has noexcept constructor, noexcept copy constructor, noexcept move constructor, and so on as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class demo { public: demo() {} demo(const demo \u0026amp;) {} demo(demo \u0026amp;\u0026amp;) {} void method() {} }; int main() { cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; noexcept(demo()) \u0026lt;\u0026lt; endl; // C cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; noexcept(demo(demo())) \u0026lt;\u0026lt; endl; // CC cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; noexcept(demo(std::declval\u0026lt;demo\u0026gt;())) \u0026lt;\u0026lt; endl; // MC cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; noexcept(std::declval\u0026lt;demo\u0026gt;().method()) \u0026lt;\u0026lt; endl; // Methods } // std::declval\u0026lt;T\u0026gt; returns an rvalue reference to a type You must be wondering why \u0026amp; how this information will be useful?\nThis is more useful when you are using library functions inside your function to suggest compiler that your function is throwing or non-throwing depending upon library implementation. If you remove constructor, copy constructor \u0026amp; move constructor, it will print true reason being implicitly-declared special member functions are always non-throwing. TL;DR\nnoexcept specifier \u0026amp; operator are two different things. noexcept operator performs a compile-time check \u0026amp; doesn’t evaluate the expression. While noexcept specifier can take only constant expressions that evaluate to either true or false.\n6. Move Exception-Safe with std::move_if_noexcept 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct demo { demo() = default; demo(const demo \u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;Copying\\n\u0026#34;; } // Exception safe move constructor demo(demo \u0026amp;\u0026amp;) noexcept { cout \u0026lt;\u0026lt; \u0026#34;Moving\\n\u0026#34;; } private: std::vector\u0026lt;int\u0026gt; m_v; }; int main() { demo obj1; if (noexcept(demo(std::declval\u0026lt;demo\u0026gt;()))){ // if moving safe demo obj2(std::move(obj1)); // then move it } else{ demo obj2(obj1); // otherwise copy it } demo obj3(std::move_if_noexcept(obj1)); // Alternatively you can do this---------------- return 0; } We can use noexcept(T(std::declval\u0026lt;T\u0026gt;()) to check if T’s move constructor exists and is noexcept in order to decide if we want to create an instance of T by moving another instance of T (using std::move). Alternatively, we can use std::move_if_noexcept, which uses noexcept operator and casts to either rvalue or lvalue. Such checks are used in std::vector and other containers. This will be useful while you are processing critical data which you don\u0026rsquo;t want to lose. For example, we have critical data received from the server that we do not want to lose it at any cost while processing. In such a case, we should use std::move_if_noexcept which will move ownership of critical data only and only if move constructor is exception-safe. TL;DR\nMove critical object safely with std::move_if_noexcept\n7. Real Cost of C++ Exception Handling With Benchmark Despite many benefits, most people still do not prefer to use exceptions due to its overhead. So let\u0026rsquo;s clear it out of the way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void without_exception(benchmark::State \u0026amp;state){ for (auto _ : state){ std::vector\u0026lt;uint32_t\u0026gt; v(10000); for (uint32_t i = 0; i \u0026lt; 10000; i++) v.at(i) = i; } } BENCHMARK(without_exception);//---------------------------------------- static void with_exception(benchmark::State \u0026amp;state){ for (auto _ : state){ std::vector\u0026lt;uint32_t\u0026gt; v(10000); for (uint32_t i = 0; i \u0026lt; 10000; i++){ try{ v.at(i) = i; } catch (const std::out_of_range \u0026amp;oor){} } } } BENCHMARK(with_exception);//-------------------------------------------- static void throwing_exception(benchmark::State \u0026amp;state){ for (auto _ : state){ std::vector\u0026lt;uint32_t\u0026gt; v(10000); for (uint32_t i = 1; i \u0026lt; 10001; i++){ try{ v.at(i) = i; } catch (const std::out_of_range \u0026amp;oor){} } } } BENCHMARK(throwing_exception);//----------------------------------------- As you can see above, with_exception \u0026amp; without_exception has only a single difference i.e. exception syntax. But none of them throws any exceptions. While throwing_exception does the same task except it throws an exception of type std::out_of_range in the last iteration. As you can see in below bar graph, the last bar is slightly high as compared to the previous two which shows the cost of throwing an exception. But the cost of using exception is zero here, as the previous two bars are identical. I am not considering the optimization here which is the separate case as it trims some of the assembly instructions completely. Also, implementation of compiler \u0026amp; ABI plays a crucial role. But still, it is far better than losing time by setting up a guard(`if(error) strategy) and explicitly checking for the presence of error everywhere. While in case of exception, the compiler generates a side table that maps any point that may throw an exception (program counter) to the list of handlers. When an exception is thrown, this list consults to pick the right handler (if any) and the stack unwound. See this for in-depth knowledge. By the way, I am using a quick benchmark \u0026amp; which internally uses Google Benchmark, if you want to explore more. First and foremost, remember that using try and catch doesn\u0026rsquo;t actually decrease performance unless an exception is thrown. It\u0026rsquo;s \u0026ldquo;zero cost\u0026rdquo; exception handling; no instruction related to exception handling executes until one is thrown. But, at the same time, it contributes to the size of executable due to unwinding routines, which may be important to consider for embedded systems. TL;DR\nNo instruction related to exception handling is executed until one is thrown so using try / catch doesn\u0026rsquo;t actually decrease performance.\nBest Practices \u0026amp; Some C++ Core Guidelines on Exception Handling C++ Exception Handling Best Practices\nIdeally, you should not throw an exception from the destructor, move constructor or swap like functions.\nPrefer RAII idiom for the exception safety because in case of exception you might be left with\n- data in an invalid state, i.e. data that cannot be further read \u0026amp; used;\n- leaked resources such as memory, files, ids, or anything else that needs to be allocated and released;\n- corrupted memory;\n- broken invariants, e.g. size function returns more elements than actually held in a container.\nAvoid using raw new \u0026amp; delete. Use solutions from the standard library, e.g. std::unique_pointer, std::make_unique, std::fstream, std::lock_guard, etc.\nMoreover, it is useful to split your code into modifying and non-modifying parts, where only the non-modifying part can throw exceptions.\nNever throw exceptions while owing some resource.\nSome CPP Core Guidelines\nE.1: Develop an error-handling strategy early in a design E.3: Use exceptions for error handling only E.6: Use RAII to prevent leaks E.13: Never throw while being the direct owner of an object E.16: Destructors, deallocation, and swap must never fail E.17: Don’t try to catch every exception in every function E.18: Minimize the use of explicit try/catch 26: If you can’t throw exceptions, consider failing fast E.31: Properly order your catch-clauses ","permalink":"https://vishalchovatiya.github.io/posts/7-best-practices-for-exception-handling-in-cpp-with-example/","summary":"Exception handling in C++ is a well-unschooled topic if you observe initial stages of the learning curve. There are numerous tutorials available online on exception handling in C++. But few explains what you should not do \u0026amp; intricacies around it. So here I am to bridge the gap \u0026amp; show you some intricacies, from where \u0026amp; why you should not throw an exception and C++ exception handling best practices. Along with some newer features introduced for exception handling in Modern C++ with example.","title":"C++ Exception Handling Best Practices: 7 Things To Know"},{"content":"So, you came across the Modern C++ \u0026amp; overwhelmed by its features in terms of performance, convenience \u0026amp; code expressiveness. But in a dilemma that how you can spot where you can enforce Modern C++ features in your day to day coding job. No worries, here we will see 21 new features of Modern C++ you can use in your project.\nC++ community releasing new standards more frequently than iPhone releases. Due to this, C++ now becomes like an elephant and it is impossible to eat the whole elephant in one go. That is why I have written this post to kick start your Modern C++ journey. Here my intended audience is peeps who are moving from older(i.e. 98/03) C++ to Modern(i.e. 2011 onwards) C++.\nI have chosen some of the Modern C++ features \u0026amp; explained it with the minimalistic example to make you aware that how you can spot the places where you can employ new features.\nDigit separators 1 2 3 int no = 1\u0026#39;000\u0026#39;000; // separate units like, thousand, lac, million, etc. long addr = 0xA000\u0026#39;EFFF; // separate 32 bit address uint32_t binary = 0b0001\u0026#39;0010\u0026#39;0111\u0026#39;1111; // now, explanation is not needed i guess Earlier you have to count digits or zeros, but now not anymore from C++14. This will be useful while counting address in word, half-word or digit boundary or let say you have a credit card or social security number. By grouping digits, your code would become more expressive. Type aliases 1 2 3 4 5 template \u0026lt;typename T\u0026gt; using dyn_arr = std::vector\u0026lt;T\u0026gt;; dyn_arr\u0026lt;int\u0026gt; nums; // equivalent to std::vector\u0026lt;int\u0026gt; using func_ptr = int (*)(int); Semantically similar to using a typedef , however, type aliases are easier to read and are compatible with C++ templates types also. Thanks to C++11. User-defined literals 1 2 3 4 5 6 7 8 9 10 11 12 13 14 using ull = unsigned long long; constexpr ull operator\u0026#34;\u0026#34; _KB(ull no) { return no * 1024; } constexpr ull operator\u0026#34;\u0026#34; _MB(ull no) { return no * (1024_KB); } cout\u0026lt;\u0026lt;1_KB\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;5_MB\u0026lt;\u0026lt;endl; Most of the times you have to deal with real-world jargons like KB, MB, km, cm, rupees, dollars, euros, etc. rather defining functions which do the unit conversion on run-time, you can now treat it as user-defined literals as you do with other primitive types. Very convenient for units \u0026amp; measurement. Adding constexpr will serve zero cost run-time performance impact which we will see later in this article \u0026amp; I have written a more detailed article on when to use const vs constexpr in c++. Uniform initialization \u0026amp; Non-static member initialization Earlier, you have to initialize data members with its default values in the constructor or in the member initialization list. But from C++11, it’s possible to give normal class member variables (those that don’t use the static keyword) a default initialization value directly as shown below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class demo { private: uint32_t m_var_1 = 0; bool m_var_2 = false; string m_var_3 = \u0026#34;\u0026#34;; float m_var_4 = 0.0; public: demo(uint32_t var_1, bool var_2, string var_3, float var_4) : m_var_1(var_1), m_var_2(var_2), m_var_3(var_3), m_var_4(var_4) {} }; demo obj{123, true, \u0026#34;lol\u0026#34;, 1.1}; This is more useful when there are multiple sub-objects defined as data members as follows: 1 2 3 4 5 6 7 8 9 10 class computer { private: cpu_t m_cpu{2, 3.2_GHz}; ram_t m_ram{4_GB, RAM::TYPE::DDR4}; hard_disk_t m_ssd{1_TB, HDD::TYPE::SSD}; public: // ... }; In this case, you do not need to initialize it in initializer list, rather you can directly give default initialization at the time of declaration. 1 2 3 4 5 6 class X { const static int m_var = 0; }; // int X::m_var = 0; // not needed for constant static data members You can also provide initialization at the time of declaration if members are const \u0026amp; static as above. std::initializer_list 1 2 3 4 5 6 7 8 9 10 11 12 13 std::pair\u0026lt;int, int\u0026gt; p = {1, 2}; std::tuple\u0026lt;int, int\u0026gt; t = {1, 2}; std::vector\u0026lt;int\u0026gt; v = {1, 2, 3, 4, 5}; std::set\u0026lt;int\u0026gt; s = {1, 2, 3, 4, 5}; std::list\u0026lt;int\u0026gt; l = {1, 2, 3, 4, 5}; std::deque\u0026lt;int\u0026gt; d = {1, 2, 3, 4, 5}; std::array\u0026lt;int, 5\u0026gt; a = {1, 2, 3, 4, 5}; // Wont work for adapters // std::stack\u0026lt;int\u0026gt; s = {1, 2, 3, 4, 5}; // std::queue\u0026lt;int\u0026gt; q = {1, 2, 3, 4, 5}; // std::priority_queue\u0026lt;int\u0026gt; pq = {1, 2, 3, 4, 5}; Assign values to containers directly by initializer list as do with C-style arrays. This is also true for nested containers. Thanks to C++11. auto \u0026amp; decltype 1 2 3 4 5 auto a = 3.14; // double auto b = 1; // int auto\u0026amp; c = b; // int\u0026amp; auto g = new auto(123); // int* auto x; // error -- `x` requires initializer auto-typed variables are deduced by the compiler according to the type of their initializer. Extremely useful for readability, especially for complicated types: 1 2 3 4 5 // std::vector\u0026lt;int\u0026gt;::const_iterator cit = v.cbegin(); auto cit = v.cbegin(); // alternatively // std::shared_ptr\u0026lt;vector\u0026lt;uint32_t\u0026gt;\u0026gt; demo_ptr(new vector\u0026lt;uint32_t\u0026gt;(0); auto demo_ptr = make_shared\u0026lt;vector\u0026lt;uint32_t\u0026gt;\u0026gt;(0); // alternatively Functions can also deduce the return type using auto. In C++11, a return type must be specified either explicitly, or using decltype like: 1 2 3 4 5 6 7 8 template \u0026lt;typename X, typename Y\u0026gt; auto add(X x, Y y) -\u0026gt; decltype(x + y) { return x + y; } add(1, 2); // == 3 add(1, 2.0); // == 3.0 add(1.5, 1.5); // == 3.0 Defining return type as above called trailing return type i.e. -\u0026gt; return-type. Range-based for-loops Syntactic sugar for iterating over a container\u0026rsquo;s elements. 1 2 3 std::array\u0026lt;int, 5\u0026gt; a {1, 2, 3, 4, 5}; for (int\u0026amp; x : a) x *= 2; // a == { 2, 4, 6, 8, 10 } Note the difference when using int as opposed to int\u0026amp;: 1 2 3 std::array\u0026lt;int, 5\u0026gt; a {1, 2, 3, 4, 5}; for (int x : a) x *= 2; // a == { 1, 2, 3, 4, 5 } Smart pointers C++11 introduces new smart(er) pointers: std::unique_ptr, std::shared_ptr, std::weak_ptr. And std::auto_ptr now become deprecated and then eventually removed in C++17. 1 2 3 4 5 6 7 8 9 10 11 12 std::unique_ptr\u0026lt;int\u0026gt; i_ptr1{new int{5}}; // Not recommendate auto i_ptr2 = std::make_unique\u0026lt;int\u0026gt;(5); // More conviniently template \u0026lt;typename T\u0026gt; struct demo { T m_var; demo(T var) : m_var(var){}; }; auto i_ptr3 = std::make_shared\u0026lt;demo\u0026lt;uint32_t\u0026gt;\u0026gt;(4); ISO CPP guidelines suggest avoiding the call of new and delete explicitly by the rule of no naked new. I have already written an article on understanding unique_ptr with example in C++ here. nullptr C++11 introduces a new null pointer type designed to replace C\u0026rsquo;s NULL macro. nullptr itself is of type std::nullptr_t and can be implicitly converted into pointer types, and unlike NULL, not convertible to integral types except bool. 1 2 3 4 void foo(int); void foo(char*); foo(NULL); // error -- ambiguous foo(nullptr); // calls foo(char*) Strongly-typed enums 1 2 3 4 5 6 7 8 9 enum class STATUS_t : uint32_t { PASS = 0, FAIL, HUNG }; STATUS_t STATUS = STATUS_t::PASS; STATUS - 1; // not valid anymore from C++11 Type-safe enums that solve a variety of problems with C-style enums including implicit conversions, arithmetic operations, inability to specify the underlying type, scope pollution, etc. Typecasting C style casting only change the type without touching underlying data. While older C++ was a bit type-safe and has a feature of specifying type conversion operator/function. But it was implicit type conversion, from C++11, conversion functions can now be made explicit using the explicit specifier as follows. 1 2 3 4 5 6 7 8 9 struct demo { explicit operator bool() const { return true; } }; demo d; if (d); // OK calls demo::operator bool() bool b_d = d; // error: cannot convert \u0026#39;demo\u0026#39; to \u0026#39;bool\u0026#39; in initialization bool b_d = static_cast\u0026lt;bool\u0026gt;(d); // OK, explicit conversion, you know what you are doing If the above code looks alien to you, I have written a more detailed article on C++ typecasting here. Move semantics When an object is going to be destroyed or unused after expression execution, then it is more feasible to move resource rather than copying it. Copying includes unnecessary overheads like memory allocation, deallocation \u0026amp; copying memory content, etc. Consider the following swap function: 1 2 3 4 5 6 template \u0026lt;class T\u0026gt; swap(T\u0026amp; a, T\u0026amp; b) { T tmp(a); // we now have two copies of a a = b; // we now have two copies of b (+ discarded a copy of a) b = tmp; // we now have two copies of tmp (+ discarded a copy of b) } using move allows you to swap the resources instead of copying them around: 1 2 3 4 5 6 template \u0026lt;class T\u0026gt; swap(T\u0026amp; a, T\u0026amp; b) { T tmp(std::move(a)); a = std::move(b); b = std::move(tmp); } Think of what happens when T is, say, vector\u0026lt;int\u0026gt; of size n. And n is too big. In the first version, you read and write 3*n elements, in the second version you basically read and write just the 3 pointers to the vectors\u0026rsquo; buffers, plus the 3 buffers\u0026rsquo; sizes. Of course, class T needs to know how to do the moving; your class should have a move-assignment operator and a move-constructor for class T for this to work. This feature will give you a significant boost in the performance which is why people use C++ for(i.e. last 2-3 drops of speed). Forwarding references Also known (unofficially) as universal references. A forwarding reference is created with the syntax T\u0026amp;\u0026amp; where T is a template type parameter, or using auto\u0026amp;\u0026amp;. This enables two major features move semantics And perfect forwarding, the ability to pass arguments that are either lvalues or rvalues. Forwarding references allow a reference to binding to either an lvalue or rvalue depending on the type. Forwarding references follow the rules of reference collapsing:\nT\u0026amp; \u0026amp; becomes T\u0026amp; T\u0026amp; \u0026amp;\u0026amp; become T\u0026amp; T\u0026amp;\u0026amp; \u0026amp; becomes T\u0026amp; T\u0026amp;\u0026amp; \u0026amp;\u0026amp; becomes T\u0026amp;\u0026amp; Template type parameter deduction with lvalues and rvalues:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Since C++14 or later: void f(auto\u0026amp;\u0026amp; t) { // ... } // Since C++11 or later: template \u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; t) { // ... } int x = 0; f(0); // deduces as f(int\u0026amp;\u0026amp;) f(x); // deduces as f(int\u0026amp;) int\u0026amp; y = x; f(y); // deduces as f(int\u0026amp; \u0026amp;\u0026amp;) =\u0026gt; f(int\u0026amp;) int\u0026amp;\u0026amp; z = 0; // NOTE: `z` is an lvalue with type `int\u0026amp;\u0026amp;`. f(z); // deduces as f(int\u0026amp;\u0026amp; \u0026amp;) =\u0026gt; f(int\u0026amp;) f(std::move(z)); // deduces as f(int\u0026amp;\u0026amp; \u0026amp;\u0026amp;) =\u0026gt; f(int\u0026amp;\u0026amp;) If this seems complex \u0026amp; weird to you then read this first \u0026amp; then come back here. Variadic templates 1 2 3 4 5 6 7 8 9 10 void print() {} template \u0026lt;typename First, typename... Rest\u0026gt; void print(const First \u0026amp;first, Rest \u0026amp;\u0026amp;... args) { std::cout \u0026lt;\u0026lt; first \u0026lt;\u0026lt; std::endl; print(args...); } print(1, \u0026#34;lol\u0026#34;, 1.1); The ... syntax creates a parameter pack or expands one. A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A C++ template with at least one parameter pack is called a variadic template. constexpr 1 2 3 4 5 6 constexpr uint32_t fibonacci(uint32_t i) { return (i \u0026lt;= 1u) ? i : (fibonacci(i - 1) + fibonacci(i - 2)); } constexpr auto fib_5th_term = fibonacci(6); // equal to `auto fib_5th_term = 8` Constant expressions are expressions evaluated by the compiler at compile-time. In the above case, fibonacci the function is executed/evaluated by the compiler at the time of compilation \u0026amp; result will be substituted at calling the place. I have written a detailed article on when to use const vs constexpr in C++. Deleted \u0026amp; Defaulted functions 1 2 3 4 5 6 struct demo { demo() = default; }; demo d; Now you might be wondering that rather than writing 8+ letters(i.e. = default;), I could simply use {} i.e. empty constructor. That\u0026rsquo;s true! but think about copy constructor, copy assignment operator, etc. An empty copy constructor, for example, will not do the same as a defaulted copy constructor (which will perform a member-wise copy of its members). You can limit certain operation or way of object instantiation by simply deleting the respective method as follows\n1 2 3 4 5 6 7 8 9 10 11 12 13 class demo { int m_x; public: demo(int x) : m_x(x){}; demo(const demo \u0026amp;) = delete; demo \u0026amp;operator=(const demo \u0026amp;) = delete; }; demo obj1{123}; demo obj2 = obj1; // error -- call to deleted copy constructor obj2 = obj1; // error -- operator= deleted In older C++ you have to make it private. But now you have delete compiler directive.\nDelegating constructors 1 2 3 4 5 6 7 8 struct demo { int m_var; demo(int var) : m_var(var) {} demo() : demo(0) {} }; demo d; In older C++, you have to create common initialization member function \u0026amp; need to call it from all the constructor to achieve the common initialization. But from C++11, now constructors can call other constructors in the same class using an initializer list. Lambda expression 1 2 3 4 auto generator = [i = 0]() mutable { return ++i; }; cout \u0026lt;\u0026lt; generator() \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; generator() \u0026lt;\u0026lt; endl; // 2 cout \u0026lt;\u0026lt; generator() \u0026lt;\u0026lt; endl; // 3 I think this feature no need any introduction \u0026amp; hot favourite among other features. Now you can declare functions wherever you want. That too with zero cost performance impact. I wrote a separate article to learn lambda expression in C++ with example. Selection statements with initializer In earlier C++, the initializer is either declared before the statement and leaked into the ambient scope, or an explicit scope is used. With C++17, the new form of if/switch can be written more compactly, and the improved scope control makes some erstwhile error-prone constructions a bit more robust: 1 2 3 4 5 6 7 switch (auto STATUS = window.status()) // Declare the object right within selection statement { case PASS:// do this break; case FAIL:// do that break; } How it works 1 2 3 4 5 6 7 8 9 10 { auto STATUS = window.status(); switch (STATUS) { case PASS: // do this break; case FAIL: // do that break; } } std::tuple 1 2 3 4 auto employee = std::make_tuple(32, \u0026#34; Vishal Chovatiya\u0026#34;, \u0026#34;Bangalore\u0026#34;); cout \u0026lt;\u0026lt; std::get\u0026lt;0\u0026gt;(employee) \u0026lt;\u0026lt; endl; // 32 cout \u0026lt;\u0026lt; std::get\u0026lt;1\u0026gt;(employee) \u0026lt;\u0026lt; endl; // \u0026#34;Vishal Chovatiya\u0026#34; cout \u0026lt;\u0026lt; std::get\u0026lt;2\u0026gt;(employee) \u0026lt;\u0026lt; endl; // \u0026#34;Bangalore\u0026#34; Tuples are a fixed-size collection of heterogeneous values. Access the elements of a std::tuple by unpacking using std::tie, or using std::get. You can also catch arbitrary \u0026amp; heterogeneous return values as follows: 1 2 3 4 5 6 7 8 auto get_employee_detail() { // do something . . . return std::make_tuple(32, \u0026#34; Vishal Chovatiya\u0026#34;, \u0026#34;Bangalore\u0026#34;); } string name; std::tie(std::ignore, name, std::ignore) = get_employee_detail(); Use std::ignore as a placeholder for ignored values. In C++17, structured bindings should be used instead. Class template argument deduction 1 2 3 4 5 std::pair\u0026lt;std::string, int\u0026gt; user = {\u0026#34;M\u0026#34;, 25}; // previous std::pair user = {\u0026#34;M\u0026#34;, 25}; // C++17 std::tuple\u0026lt;std::string, std::string, int\u0026gt; user(\u0026#34;M\u0026#34;, \u0026#34;Chy\u0026#34;, 25); // previous std::tuple user2(\u0026#34;M\u0026#34;, \u0026#34;Chy\u0026#34;, 25); // deduction in action! Automatic template argument deduction much likes how it\u0026rsquo;s done for functions, but now including class constructors as well. Closing words Here, we have just scratched the surface in terms of new feature \u0026amp; the possibility of its application. There are many things to learn in Modern C++, but still, you can consider this as a good starting point. Modern C++ is not only expanding in terms of syntax but there is lot more other features are also added like unordered containers, threads, regex, Chrono, random number generator/distributor, exception handling and many new STL algos(like all_of(), any_of() and none_of(), etc).\nHappy Modern C++ Coding\u0026hellip;!\n","permalink":"https://vishalchovatiya.github.io/posts/21-new-features-of-modern-cpp-to-use-in-your-project/","summary":"So, you came across the Modern C++ \u0026amp; overwhelmed by its features in terms of performance, convenience \u0026amp; code expressiveness. But in a dilemma that how you can spot where you can enforce Modern C++ features in your day to day coding job. No worries, here we will see 21 new features of Modern C++ you can use in your project.\nC++ community releasing new standards more frequently than iPhone releases.","title":"21 New Features of Modern C++ to Use in Your Project"},{"content":"Lambda function is quite an intuitive \u0026amp; widely loved feature introduced in C++11. And, there are tons of articles \u0026amp; tutorials already available on the topic. But, there are very few or none of them touched upon things like IIFE, types of lambda and newer updates on lambda by subsequent standard releases. So, I got the opportunity to fill the blank. I will start this article with what is lambda function! And as we move along will show you how it works internally! \u0026amp; different variations of it. My focus here would be to give you a pragmatic overview. If you are in search of deep dive, I would suggest you read C++ Lambda Story by Bartłomiej Filipek.\nTitle of this article is a bit misleading. Because lambda doesn\u0026rsquo;t always synthesize to function pointer. It\u0026rsquo;s an expression (precisely unique closure). But I have kept it that way for simplicity. So from now on, I might use them interchangeably.\nWhat is lambda function? A lambda function is short snippets of code that\nnot worth naming(unnamed, anonymous, disposable, etc. whatever you can call it), and also not reused. In other words, it\u0026rsquo;s just syntactic sugar. lambda function syntax is defined as:\n1 2 3 4 [ capture list ] (parameters) -\u0026gt; return-type { method definition } Usually, compiler evaluates a return type of a lambda function itself. So we don\u0026rsquo;t need to specify a trailing return type explicitly i.e. -\u0026gt; return-type. But in some complex cases, the compiler unable to deduce the return type and we need to specify that. Why Should We Use a Lambda Function? C++ includes many useful generic functions like std::for_each, which can be handy. Unfortunately, they can also be quite cumbersome to use, particularly if the functor you would like to apply is unique to the particular function. Consider the following code for an example:\n1 2 3 4 5 6 7 8 9 10 11 struct print { void operator()(int element) { cout \u0026lt;\u0026lt; element \u0026lt;\u0026lt; endl; } }; int main(void) { vector\u0026lt;int\u0026gt; v = {1, 2, 3, 4, 5}; for_each(v.begin(), v.end(), print()); return EXIT_SUCCESS; } If you use print once, in that specific place, it seems overkill to be writing a whole class just to do something trivial and one-off. However, for this kind of situation inline code would be more suitable \u0026amp; appropriate which can be achieved by lambda function as follows: 1 for_each(v.begin(), v.end(), [](int element) { cout \u0026lt;\u0026lt; element \u0026lt;\u0026lt; endl; }); How Does Lambda Functions Works Internally? 1 2 3 4 5 6 7 8 9 10 11 [\u0026amp;i] ( ) { cout \u0026lt;\u0026lt; i; } // is equivalent to struct anonymous { int \u0026amp;m_i; anonymous(int \u0026amp;i) : m_i(i) {} inline auto operator()() const { cout \u0026lt;\u0026lt; m_i; } }; The compiler generates unique closure as above for each lambda function. Finally, the secret revealed. Unique closure is nothing but a class(or struct depending upon compiler developer). Capture list will become a constructor argument in closure, If you capture argument as value then corresponding type data member is created within the closure. Moreover, you can declare variable/object in the lambda function argument, which will become an argument to call operator i.e. `operator()`` Benefits of Using a Lambda Function Zero cost abstraction. Yes! you read it right. lambda doesn\u0026rsquo;t cost you performance \u0026amp; as fast as a normal function. In addition, code becomes compact, structured \u0026amp; expressive. Learning Lambda Expression Syntax Capture by Reference/Value 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int x = 100, y = 200; auto print = [\u0026amp;] { // Capturing everything by reference(not recommended though) cout \u0026lt;\u0026lt; __PRETTY_FUNCTION__ \u0026lt;\u0026lt; \u0026#34; : \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; , \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; }; print(); return EXIT_SUCCESS; } /* Output main()::\u0026lt;lambda()\u0026gt; : 100 , 200 */ In the above example, I have mentioned \u0026amp; in capture list. which captures variable x \u0026amp; y as reference. Similarly, = denotes captured by value, which will create data member of the same type within the closure and copy assignment will take place. In addition, the parameter list is optional, you can omit the empty parentheses if you do not pass arguments to the lambda expression. Lambda Capture List The following table shows different use cases for the same: Syntax Description [](){} no captures [=](){} captures everything by copy (not recommended) [\u0026amp;](){} captures everything by reference (not recommended) [x](){} captures x by copy [\u0026amp;x](){} captures x by reference [\u0026amp;, x](){} captures x by copy, everything else by reference [=, \u0026amp;x](){} captures x by reference, everything else by copy Passing Lambda as Parameter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template \u0026lt;typename Functor\u0026gt; void f(Functor functor) { cout \u0026lt;\u0026lt; __PRETTY_FUNCTION__ \u0026lt;\u0026lt; endl; } /* Or alternatively you can use this void f(function\u0026lt;int(int)\u0026gt; functor) { cout \u0026lt;\u0026lt; __PRETTY_FUNCTION__ \u0026lt;\u0026lt; endl; } */ int g() { static int i = 0; return i++; } int main() { auto lambda_func = [i = 0]() mutable { return i++; }; f(lambda_func); // Pass lambda f(g);\t// Pass function } /* Output Function Type : void f(Functor) [with Functor = main()::\u0026lt;lambda(int)\u0026gt;] Function Type : void f(Functor) [with Functor = int (*)(int)] */ As you can see, you can also pass lambda function as an argument to other function just like a normal function. So, if you see, here I have declared variable i in capture list which will become data member. As a result, every time you call lambda_func, it will be returned and incremented. Capture Member Variable in Lambda or This Pointer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Example { int m_var; public: Example() : m_var(10) {} void func() { [=]() { cout \u0026lt;\u0026lt; m_var \u0026lt;\u0026lt; endl; }(); // IIFE } }; int main() { Example e; e.func(); return EXIT_SUCCESS; } this pointer can also be captured using [this], [=] or [\u0026amp;]`. In any of these cases, class data members(including private) can be accessed as you do in a normal method. If you see the lambda expression line, I have used extra `() at the end of the lambda function declaration which used to calls it right thereafter declaration. It is called IIFE (Immediately Invoked Function Expression). Lambda Function Variations in Modern C++ Generic Lambda(C++14) 1 2 3 4 5 6 7 8 9 const auto l = [](auto a, auto b, auto c) {}; // is equivalent to struct anonymous { template \u0026lt;class T0, class T1, class T2\u0026gt; auto operator()(T0 a, T1 b, T2 c) const { } }; Generic lambda introduced in C++14 which can captures parameters with auto specifier. Variadic Generic Lambda(C++14) 1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename... Args\u0026gt; void print(Args \u0026amp;\u0026amp;... args) { (void(cout \u0026lt;\u0026lt; forward\u0026lt;Args\u0026gt;(args) \u0026lt;\u0026lt; endl), ...); } int main() { auto variadic_generic_lambda = [](auto \u0026amp;\u0026amp;... param) { print(forward\u0026lt;decltype(param)\u0026gt;(param)...); }; variadic_generic_lambda(1, \u0026#34;lol\u0026#34;, 1.1); return EXIT_SUCCESS; } Lambda with variadic template(C++11) will be useful in many scenarios like debugging, repeated operation with different data input, etc. Mutable Lambda Function(C++11) Typically, a lambda\u0026rsquo;s function call operator is const-by-value which means lambda requires mutable keyword if you are capturing anything by-value. 1 2 3 4 5 6 7 8 []() mutable {} // is equivalent to struct anonymous { auto operator()() { // call operator } }; We have already seen an example of this above. I hope you noticed it. Lambda as a Function Pointer(C++11) 1 2 auto funcPtr = +[] {}; static_assert(is_same\u0026lt;decltype(funcPtr), void (*)()\u0026gt;::value); You can force the compiler to generate lambda as a function pointer rather than closure by adding + in front of it as above. Higher-Order Returning Lambda Functions(C++11) 1 2 3 4 5 6 7 8 9 10 11 12 const auto less_than = [](auto x) { return [x](auto y) { return y \u0026lt; x; }; }; int main() { auto less_than_five = less_than(5); cout \u0026lt;\u0026lt; less_than_five(3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; less_than_five(10) \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } Going a bit further, lambda function can also return another lambda function. This will open the doors of endless possibility for customization, code expressiveness \u0026amp; compactibility(BTW, there is no word like this) of code. constexpr Lambda Expression(C++17) Since C++17, a lambda expression can be declared as constexpr.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 constexpr auto sum = [](const auto \u0026amp;a, const auto \u0026amp;b) { return a + b; }; /* is equivalent to constexpr struct anonymous { template \u0026lt;class T1, class T2\u0026gt; constexpr auto operator()(T1 a, T2 b) const { return a + b; } }; */ static_assert(sum(10, 10) == 20); Even if you don\u0026rsquo;t specify constexpr , the function call operator will be constexpr anyway, if it happens to satisfy all constexpr function requirements. Template Lambda Expression(C++20) As we saw above in generic lambda function, we can declare parameters as auto. That in turn templatized by compiler \u0026amp; deduce the appropriate template type. But there was no way to change this template parameter and use real C++ template arguments. For example: 1 2 3 4 template \u0026lt;typename T\u0026gt; void f(vector\u0026lt;T\u0026gt;\u0026amp;\tvec){ //. . . } How do you write the lambda for the above function which takes std::vector of type T? This was the limitation till C++17, but with C++20 it is possible as below: 1 2 3 4 5 6 auto f = []\u0026lt;typename T\u0026gt;(vector\u0026lt;T\u0026gt;\u0026amp; vec){ // . . . }; std::vector\u0026lt;int\u0026gt; v; f(v); There are other small changes as well regarding the same that you can read here. Parting Words I hope you enjoyed this article. I have tried to cover most of the fundamentals around lambda function with a couple of unsophisticate \u0026amp; small examples. You should use lambda wherever it strikes in your mind considering code expressiveness \u0026amp; easy maintainability. For example, you can use it in custom deleters for smart pointers, to avoid code repetition \u0026amp; with most of the STL algorithms.\n","permalink":"https://vishalchovatiya.github.io/posts/learn-lambda-function-in-cpp-with-example/","summary":"Lambda function is quite an intuitive \u0026amp; widely loved feature introduced in C++11. And, there are tons of articles \u0026amp; tutorials already available on the topic. But, there are very few or none of them touched upon things like IIFE, types of lambda and newer updates on lambda by subsequent standard releases. So, I got the opportunity to fill the blank. I will start this article with what is lambda function!","title":"All About Lambda Function in C++(From C++11 to C++20)"},{"content":"In an earlier article, we have seen C runtime: before starting main \u0026amp; How C program stored in RAM memory. Here we will see \u0026ldquo;How C program converts into assembly?\u0026rdquo; and different aspect of its working at the machine level.\nA Bit About Functions Stack Frames During function code execution, a new stack frame is created in stack memory to allow access to function parameters and local variables. The direction of stack frame growth totally depends on compiler ABI which is out of our scope for this article. The complete information on stack frame size, memory allocation, returning from stack frame is decided at compile time. Before diving into assembly code you should be aware of two things : CPU registers of x86 machine. x86 assembly instructions: As this is a very vast topic \u0026amp; updating quite frequently, we will only see the instructions needed for our examples. x86 CPU Registers General Purpose Registers: 32-bit SFR 64-bit SFR Name eax rax Accumulator uses for arithmetic ebx rbx Base uses for memory address calculations ecx rcx Counter uses to hold loop count edx rdx Double-word Accumulator or data register use for I/O port access Pointer Register: 32-bit SFR 64-bit SFR Name esp rsp Stack pointer ebp rbp Frame/base pointer points current stack frame eip rip Instruction pointer points to the next instruction to execute Segment Register: SFR Name cs Code segment ds Data segment ss Stack segment es Extra segment Index Registers: 32-bit SFR 64-bit SFR Name esi rsi Source Index uses to point index in sequential memory operations edi rdi Destination Index uses to point index in sequential memory operations Apart from all these, there are many other registers as well which even I don\u0026rsquo;t know about. But above-mentioned registers are sufficient to understand the subsequent topics.\nHow C Program Converts Into Assembly? We will consider the following example with its disassembly inlined to understand its different aspect of working at machine level :\nWe will focus on a stack frame of the function func() But before analysing stack frame of it, we will see how the calling of function happens:\nFunction calling Function calling is done by call instruction(see Line 15) which is subroutine instruction equivalent to :\n1 2 push rip + 1 ; return address is address of next instructions jmp func Here, call store the rip+1(not that +1 is just for simplicity, technically this will be substituted by the size of instruction) in the stack which is return address once call to func()ends.\nFunction Stack Frame A function stack frame is divided into three parts\nPrologue/Entry User code Epilogue/Exit 1. Prologue/Entry: As you can see instructions(line 2 to 4) generated against start bracket { is prologue which is setting up the stack frame for `func(), Line 2 is pushing the previous frame pointer into the stack \u0026amp; Line 3 is updating the current frame pointer with stack end which is going to be a new frame start.\npush is basically equivalent to :\n1 2 sub esp, 4 ; decrements ESP by 4 which is kind of space allocation mov [esp], X ; put new stack item value X in Parameter Passing Argument of func() is stored in edi register on Line 14 before calling call instruction. If there is more argument then it will be stored in a subsequent register or stack \u0026amp; address will be used. Line 4 in func()is reserving space by pulling frame pointer(pointed by rbp register) down by 4 bytes for the parameter arg as it is of type int. Then mov instruction will initialize it with value store inedi. This is how parameters are passed \u0026amp; stored in the current stack frame.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ---|-------------------------|--- main() | | | | | | |-------------------------| | main frame pointer | rbp \u0026amp; rsp ---|-------------------------|--- func() in func() | arg | |-------------------------| | a | |-------------------------| stack | + | | | + | | | + | | ---|-------------------------|--- \\|/ | | | | Allocating Space for Local Variables 2. User code: Line 5 is reserving space for a local variable a, again by pulling frame pointer further down by 4 bytes. mov instruction will initialize that memory with a value 5.\nAccessing Global \u0026amp; Local Static Variables As you can see above, g is addressed directly with its absolute addressing because its address is fixed which lies in the data segment. This is not the case all the time. Here we have compiled our code for x86 mode, that\u0026rsquo;s why it is accessing it with an absolute address. In the case of x64 mode, the address is resolved using rip register which meant that the assembler and linker should cooperate to compute the offset of g from the ultimate location of the current instruction which is pointed by rip register. The same statement stands true for the local static variables also. 3. Epilogue/Exit: After the user code execution, the previous frame pointer is retrieved from the stack by pop instruction which we have stored in Line 2. pop is equivalent to:\n1 2 mov X, [esp] ; put top stack item value into X add esp, 4 ; increments ESP by 4 which is kind of deallocation Return From Function ret instruction jumps back to the next instruction from where func()called by retrieving the jump address from stack stored by call instruction. ret is subroutine instruction which is equivalent to:\n1 2 pop rip ; jmp rip ; If any return value specified then it will be stored in eax register which you can see in Line 16.\nSo, this is it for \u0026ldquo;How C program converts into assembly?\u0026rdquo;. Although this kind of information is strictly coupled with compiler \u0026amp; ABI. But most of the compilers, ABI \u0026amp; instruction set architecture follows the same more or less. In case, you have not gone through my previous articles, here are simple FAQs helps you to understand better:\nFAQs Q. How do you determine the stack growth direction\nA. Simple\u0026hellip;! by comparing the address of two different function\u0026rsquo;s local variables.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int *main_ptr = NULL; int *func_ptr = NULL; void func() { int a; func_ptr = \u0026amp;a; } int main() { int a; main_ptr = \u0026amp;a; func(); (main_ptr \u0026gt; func_ptr) ? printf(\u0026#34;DOWN\\n\u0026#34;) : printf(\u0026#34;UP\\n\u0026#34;); return 0; } Q. How do you corrupt stack deliberately\nA. Corrupt the SFR values stored in the stack frame.\n1 2 3 4 5 6 7 8 9 10 11 void func() { int a; memset(\u0026amp;a, 0, 100); // Corrupt SFR values stored in stack frame } int main() { func(); return 0; } Q. How you can increase stack frame size\nA. alloca()is the answer. Google about it or see this. Although this is not recommended.\n","permalink":"https://vishalchovatiya.github.io/posts/how-c-program-convert-into-assembly/","summary":"In an earlier article, we have seen C runtime: before starting main \u0026amp; How C program stored in RAM memory. Here we will see \u0026ldquo;How C program converts into assembly?\u0026rdquo; and different aspect of its working at the machine level.\nA Bit About Functions Stack Frames During function code execution, a new stack frame is created in stack memory to allow access to function parameters and local variables. The direction of stack frame growth totally depends on compiler ABI which is out of our scope for this article.","title":"How C Program Converts Into Assembly!"},{"content":"When you run any C-program, its executable image loaded into RAM of computer in an organized manner which called process address space or memory layout of C program. Here I have tried to show you the same thing in two parts . In the 1st part i.e. \u0026ldquo;Overview\u0026rdquo;, we will see segment-wise overview \u0026amp; in 2nd part i.e. \u0026ldquo;Example\u0026rdquo;, we\u0026rsquo;ll see How C program stored in RAM memory? with example.\nThe memory layout of C program organized in the following fashion:\nText segment Data segment Heap segment Stack segment Note: It\u0026rsquo;s not just these 4 segments, there are a lot more but these 4 are the core to understanding the working of C program at the machine level.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 HIGHER ADDRESS +------------------------+ | Unmapped or reserved | Command-line argument \u0026amp; Environment variables |------------------------|------------------------ | Stack segment | | | | | | Stack frame | v | v | | | ^ | ^ | | | | Dynamic memory | Heap segment | | |------------------------|------------------------ | Uninitialized data | |------------------------| Data segment | Initialized data | |------------------------|------------------------ | | | Text segment | Executable code | | +------------------------+ LOWER ADDRESS Text segment Text segment contains executable instructions of your C program, its also called code segment also. This includes all functions making up the program(main()too), both user-defined and system. The text segment is sharable so that only a single copy needs to be in memory for different executing programs, such as text editors, shells, and so on. Usually, the text segment is read-only, to prevent a program from accidentally modifying its instructions. Data segment There are two subsections of this segment\nInitialized data It contains both static and global data that initialized with non-zero values. This segment can be further classified into the read-only area and read-write area. For example, The global string defined by char string[ ] = \u0026quot;hello world\u0026quot; and a statement like an int count=1 outside the main (i.e. global) would be stored in initialized read-write area. And a global statement like const int A=3; makes the variable A read-only and to be stored in initialized read-only area. Uninitialized data (BSS segment) An uninitialized data segment also called the BSS( \u0026lsquo;Block Started by Symbol\u0026rsquo; ) segment. Which contains all global and static variables that initialized to zero or do not have explicit initialization in source code. For example, The global variable declared as int A would be stored in the uninitialized data segment. A statement like static int X=0 will also be stored in this segment cause it initialized with zero. If you do not initialize a global variable, by default value is zero. This flushing memory content is usually done by program loader(i.e. /lib/ld-linux.so.2). Heap segment The heap segment is an area where dynamically allocated memory (allocated by malloc(), calloc(), realloc()and new for C++) resides. When we allocate memory through dynamic allocation techniques(in other words, run-time memory allocation), program acquire space from OS and process address space grows. We can free dynamically allocated memory space (by using free()or delete). Freed memory goes back to the heap but doesn’t have to be returned to OS (it doesn\u0026rsquo;t have to be returned at all), so unordered malloc/free eventually, cause heap fragmentation. You can learn more about how malloc works here. When we use dynamic allocation to acquire memory space we must keep track of allocated memory by using its address. Stack segment The stack segment is an area where local variables stored. By saying local variable means that all those variables which are declared in every function including main()in your C program. I have written a detailed article about the stack frame here. When we call any function, the stack frame created and when a function returns, the stack frame destroyed/rewind including all local variables of that particular function. A stack frame contains some data like return address, arguments passed to it, local variables, and any other information needed by the invoked function. A stack pointer(SP) which is a special function register of CPU keeps track of stack by each push \u0026amp; pop operation onto it, by adjusted stack pointer to next or previous address. The direction of the stack \u0026amp; heap growth completely depends on the compiler, ABI, OS and hardware. We have taken a simple example as above along with its memory layout.\nAs we discussed in the previous tab(i.e. Overview) how executable image of our program divided into the different segment and stored in memory(RAM). Now we understand those blocks by using our example code presented above.\nLoader A loader is not a segment but kind of program interpreter which reads a different segment from the binary \u0026amp; copy it in RAM in proper fashion. There is a binary utility command by which you can see different segments \u0026amp; path of the loader in binary as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 $ readelf --segments ./a.out Elf file type is EXEC (Executable file) Entry point 0x8048300 There are 9 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4 INTERP 0x000154 0x08048154 0x08048154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0x00608 0x00608 R E 0x1000 LOAD 0x000f08 0x08049f08 0x08049f08 0x00118 0x00124 RW 0x1000 DYNAMIC 0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 RW 0x4 NOTE 0x000168 0x08048168 0x08048168 0x00020 0x00020 R 0x4 GNU_EH_FRAME 0x0004c4 0x080484c4 0x080484c4 0x00044 0x00044 R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x000f08 0x08049f08 0x08049f08 0x000f8 0x000f8 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag 06 .eh_frame_hdr 07 08 .init_array .fini_array .jcr .dynamic .got As I have mentioned earlier, there is not only 4 segment as you can see above, but there are a lot of segments which usually depends on compiler \u0026amp; ABI. Above you can see, .data, .bss, .text, etc. segments are there. But a stack segment is not shown as its created at a run time \u0026amp; decided by OS(precisely loader \u0026amp; kernel). INTERP in the program header defines the name \u0026amp; path of loader which going to load the current binary image into the RAM by reading these segments. Here it is /lib/ld-linux.so.2. You can read more about binary file format ELF here. Text segment When you compile C code, you get executable image(which may be in any form like .bin, .exe, .hex, .out or no extension etc). This executable image contains text segment which you see by Binutils command $ objdump -d \u0026lt;binary_name\u0026gt; and it looks like follows:\n1 2 3 4 5 6 ..... 080483f1 \u0026lt;main\u0026gt;: 80483f1:\t8d 4c 24 04 lea 0x4(%esp),%ecx 80483f5:\t83 e4 f0 and $0xfffffff0,%esp 80483f8:\tff 71 fc pushl -0x4(%ecx) ..... This is executable instructions stored in the text segment as a read-only section and shared by the processes if requires. These instructions read by CPU using program counter and stack frame created in the stack at the time of execution. Program-counter points to the address of the instruction to executed which lies in the text segment.\nData segment Initialized Data segment A const int x = 1; stored in the read-only area. So you can not modify it accidentally. While a string char str[] = \u0026quot;Hi!\u0026quot;; \u0026amp; static int var = 0; stored in the read-write area because we don\u0026rsquo;t use a keyword like const which makes variable read-only. Uninitialized Data segment In our program, int i declared global goes to this area of storage because it is not initialized or initialized to zero by default. Heap segment When you compile your program, memory space allocated by you i.e. all locals, static \u0026amp; global variables fixed at compile-time. But when code needs memory at run-time, it approach OS by calling functions like malloc(), calloc(), etc. When OS provides dynamic memory to process it shrinks stack limit pointer which initially points to uninitialized data segment start(the technical word is \u0026ldquo;program break\u0026rdquo;, read about it here). As a result heap segment grows. That\u0026rsquo;s why there is no line between heap \u0026amp; stack segment. An arrow indicates its growth of direction. In the example code, we allocate 1-byte dynamic memory using malloc()function and stored its address in pointer ptr to keep track of that memory or to access it. This ptr is a local variable of main hence it\u0026rsquo;s in main\u0026rsquo;s stack frame, but memory pointed by it is in a heap which I have shown by *ptr. Stack segment The usual starting point(not entry point which is different) of any program is `main(), which is also a function hence, stack frame is created for it while execution. Although there are many functions called before main which I have discussed here. As you can see in image, stack frame of main() is created before function func()as we called it nested. As the func( ) execution overs its local variable a and its stack frame will destroy(rewind is a precise word here), same goes for main()function also. And this is how stack grows \u0026amp; shrinks. FAQs Q. How do you determine the stack growth direction\nA. Simple\u0026hellip;! by comparing the address of two different function\u0026rsquo;s local variables.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int *main_ptr = NULL; int *func_ptr = NULL; void func() { int a; func_ptr = \u0026amp;a; } int main() { int a; main_ptr = \u0026amp;a; func(); (main_ptr \u0026gt; func_ptr) ? printf(\u0026#34;DOWN\\n\u0026#34;) : printf(\u0026#34;UP\\n\u0026#34;); return 0; } Q. How do you corrupt stack deliberately\nA. Corrupt the SFR values stored in the stack frame.\n1 2 3 4 5 6 7 8 9 10 11 void func() { int a; memset(\u0026amp;a, 0, 100); // Corrupt SFR values stored in stack frame } int main() { func(); return 0; } Q. How you can increase stack frame size\nA. alloca()is the answer. Google about it or see this.\n","permalink":"https://vishalchovatiya.github.io/posts/how-c-program-stored-in-ram-memory/","summary":"When you run any C-program, its executable image loaded into RAM of computer in an organized manner which called process address space or memory layout of C program. Here I have tried to show you the same thing in two parts . In the 1st part i.e. \u0026ldquo;Overview\u0026rdquo;, we will see segment-wise overview \u0026amp; in 2nd part i.e. \u0026ldquo;Example\u0026rdquo;, we\u0026rsquo;ll see How C program stored in RAM memory? with example.","title":"How C Program Stored in Ram Memory!"},{"content":"Default Handlers in C: weak_alias function tells the linker that new is to be a weak alias for old. That is, this definition of new is a weak symbol. If there is no other definition of a symbol called new, this old definition stands.\nMight seems alien to you first, so go through a below example \u0026amp; read again.\nDefinition of weak_alias is as follows : 1 2 #define weak_alias(old, new) \\ extern __typeof(old) new __attribute__((weak, alias(#old))) If there is another (non-weak) definition of new then that non-weak(i.e. strong) definition stands and the weak definition is ignored. Let\u0026rsquo;s understand default handlers in C: weak_alias by example oldDef.c 1 2 3 4 5 6 7 8 9 10 #define weak_alias(old, new) \\ extern __typeof(old) new __attribute__((weak, alias(#old))) void DefaultHandler() { puts(\u0026#34;Default Handler\u0026#34;); } weak_alias( DefaultHandler, Feature1); weak.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; /* void Feature1() { puts(\u0026#34;Feature 1\u0026#34;); } */ int main() { Feature1(); DefaultHandler(); return 0; } Compilation 1 2 $ gcc weak.c oldDef.c -o weak $ ./weak If you run the above program as it is, it will print 1 2 Default Handler Default Handler But if you uncomment Feature1()then it will print 1 2 Default Handler Feature 1 Why so? It\u0026rsquo;s due to way linker understand symbols. When you first run without Feature1()function linker does not found strong Feature1()symbol so it links to DefaultHandler() And in the second case, when we introduce Feature1()linker finds a strong symbol \u0026amp; links it to Feature1() ","permalink":"https://vishalchovatiya.github.io/posts/default-handlers-in-c-weak_alias/","summary":"Default Handlers in C: weak_alias function tells the linker that new is to be a weak alias for old. That is, this definition of new is a weak symbol. If there is no other definition of a symbol called new, this old definition stands.\nMight seems alien to you first, so go through a below example \u0026amp; read again.\nDefinition of weak_alias is as follows : 1 2 #define weak_alias(old, new) \\ extern __typeof(old) new __attribute__((weak, alias(#old))) If there is another (non-weak) definition of new then that non-weak(i.","title":"Default Handlers in C: weak_alias"},{"content":"This article is just a simplification of the IEEE 754 standard. Here, we will see how floating-point no stored in memory, floating-point exceptions/rounding, etc. But if you will want to find more authoritative sources then go for\nWhat Every Computer Scientist Should Know About Floating-Point Arithmetic https://en.wikipedia.org/wiki/IEEE_754-1985 https://en.wikipedia.org/wiki/Floating_point. Floating-point numbers stored by encoding significand \u0026amp; the exponent (along with a sign bit)\nAbove line contains 2-3 abstract terms \u0026amp; I think you will unable to understand the above line until you read further. Floating Point Number Memory Layout 1 2 3 4 5 6 7 8 9 10 +-+--------+-----------------------+ | | | | +-+--------+-----------------------+ ^ ^ ^ | | | | | +-- significand(width- 23 bit) | | | +------------------- exponent(width- 8 bit) | +------------------------ sign bit(width- 1 bit) A typical single-precision 32-bit floating-point memory layout has the following fields :\nsign exponent significand(AKA mantissa) Sign The high-order bit indicates a sign. 0 indicates a positive value, 1 indicates negative. Exponent The next 8 bits are used for the exponent which can be positive or negative, but instead of reserving another sign bit, they\u0026rsquo;re encoded such that 1000 0000 represents 0, so 0000 0000 represents -128 and 1111 1111 represents 127. How does this encoding work? go to exponent bias or see it in next point practically. Significand The remaining 23-bits used for the significand(AKA mantissa). Each bit represents a negative power of 2 countings from the left, so: 1 2 3 01101 = 0 * 2^-1 + 1 * 2^-2 + 1 * 2^-3 + 0 * 2^-4 + 1 * 2^-5 = 0.25 + 0.125 + 0.03125 = 0.40625 OK! We are done with basics.\nLet\u0026rsquo;s Understand Practically So, we consider very famous float value 3.14(PI) example. Sign: Zero here, as PI is positive! Exponent calculation 3 is easy: 0011 in binary The rest, 0.14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0.14 x 2 = 0.28, 0 0.28 x 2 = 0.56, 00 0.56 x 2 = 1.12, 001 0.12 x 2 = 0.24, 0010 0.24 x 2 = 0.48, 00100 0.48 x 2 = 0.96, 001000 0.96 x 2 = 1.92, 0010001 0.92 x 2 = 1.84, 00100011 0.84 x 2 = 1.68, 001000111 And so on . . . So, 0.14 = 001000111...If you don\u0026rsquo;t know how to convert decimal no in binary then refer this float to binary. Add 3, `11.001000111\u0026hellip; with exp 0 (3.14 * 2^0) Now shift it (normalize it) and adjust the exponent accordingly `1.1001000111\u0026hellip; with exp +1 (1.57 * 2^1) Now you only have to add the bias of 127 to the exponent 1 and store it(i.e. 128 = 1000 0000) 0 1000 0000 1100 1000 111... Forget the top 1 of the mantissa (which is always supposed to be 1, except for some special values, so it is not stored), and you get: 0 1000 0000 1001 0001 111... So our value of 3.14 would be represented as something like: 1 2 3 4 5 6 7 8 0 10000000 10010001111010111000011 ^ ^ ^ | | | | | +--- significand = 0.7853975 | | | +------------------- exponent = 1 | +------------------------- sign = 0 (positive) The number of bits in the exponent determines the range (the minimum and maximum values you can represent). Summing up Significand If you add up all the bits in the significand, they don\u0026rsquo;t total 0.7853975(which should be, according to 7 digit precision). They come out to 0.78539747. There aren\u0026rsquo;t quite enough bits to store the value exactly. we can only store an approximation. The number of bits in the significand determines the precision. 23-bits gives us roughly 6 decimal digits of precision. 64-bit floating-point types give roughly 12 to 15 digits of precision. Strange! But Fact\nSome values cannot represent exactly no matter how many bits you use. Just as values like 1/3 cannot represent in a finite number of decimal digits, values like 1/10 cannot represent in a finite number of bits. Since values are approximate, calculations with them are also approximate, and rounding errors accumulate. Let\u0026rsquo;s See Things Working 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; /* Print binary stored in plain 32 bit block */ void intToBinary(unsigned int n) { int c, k; for (c = 31; c \u0026gt;= 0; c--) { k = n \u0026gt;\u0026gt; c; if (k \u0026amp; 1) printf(\u0026#34;1\u0026#34;); else printf(\u0026#34;0\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } int main(void) { unsigned int m; float f = 3.14; /* See hex representation */ printf(\u0026#34;f = %a\\n\u0026#34;, f); /* Copy memory representation of float to plain 32 bit block */ memcpy(\u0026amp;m, \u0026amp;f, sizeof (m)); intToBinary(m); return 0; } This C code will print binary representation of float on the console. 1 2 f = 0x3.23d70cp+0 01000000010010001111010111000011 Where the Decimal Point Is Stored? The decimal point not explicitly stored anywhere. As I wrote a line `Floating-point numbers stored by encoding significand \u0026amp; the exponent (along with a sign bit), but you don\u0026rsquo;t get it the first time. Don\u0026rsquo;t worry 99% people don\u0026rsquo;t get it first, including me. A Bit More About Representing Numbers According to IEEE 754-1985 worldwide standard, you can also store zero, negative/positive infinity and even `NaN`(Not a Number). Don\u0026rsquo;t worry if you don\u0026rsquo;t know what is NaN, I will explain shortly(But be worried, if you don\u0026rsquo;t know infinity). Zero Representation sign = 0 for positive zero, 1 for negative zero. exponent = 0. fraction = 0. Positive \u0026amp; Negative Infinity Representation sign = 0, for positive infinity, 1 for negative infinity. exponent = all 1 bits. fraction = all 0 bits. NaN Representation sign = either 0 or 1. exponent = all 1 bits. fraction = anything except all 0 bits (since all 0 bits represents infinity) Why Do We Need NaN ? Some operations of floating-point arithmetic are invalid, such as dividing by zero or taking the square root of a negative number. The act of reaching an invalid result called a floating-point exception(next point). An exceptional result is represented by a special code called a NaN, for \u0026ldquo;Not a Number\u0026rdquo;. Floating-Point Exceptions The IEEE 754-1985 standard defines five exceptions that can occur during a floating-point calculation named as Invalid Operation: occurs due to many causes like multiplication of infinite with zero or infinite, division of infinite by zero or infinite \u0026amp; vice-versa, square root of operand less than zero, etc. Division by Zero: occurs when \u0026ldquo;as its name sounds\u0026rdquo; Overflow: This exception raised whenever the result cannot represent a finite value in the precision format of the destination. Underflow: The underflow exception raised when an intermediate result is too small to calculate accurately, or if the operation’s result rounded to the destination precision too small to normalized Inexact: raised when a rounded result not exact. Rounding in Floating-Point As we saw floating-point numbers have a limited number of digits, they cannot represent all real numbers accurately: when there are more digits than the format allows, the leftover ones are omitted - the number is rounded. There are 4 rounding modes : 1. Round to Nearest: rounded to the nearest value with an even (zero) least significant bit, which occurs 50% of the time.\n2. Round toward 0 – simply truncate the extra digits.\n3. Round toward +∞ – rounding towards positive infinity.\n4. Round toward −∞ – rounding towards negative infinity.\nMisc points In older time, embedded system processors do not use floating-point numbers as they don\u0026rsquo;t have such hardware capabilities. So there is some alternative to a floating-point number, called Fixed Point Numbers. A fixed-point number is usually used in special-purpose applications on embedded processors that can only do integer arithmetic, but decimal fixed point(\u0026rsquo;.\u0026rsquo;) is manipulated by software library. But nowadays, the microcontroller has separate FPU\u0026rsquo;s too, like STM32F series. ","permalink":"https://vishalchovatiya.github.io/posts/how-floating-point-no-is-stored-memory/","summary":"This article is just a simplification of the IEEE 754 standard. Here, we will see how floating-point no stored in memory, floating-point exceptions/rounding, etc. But if you will want to find more authoritative sources then go for\nWhat Every Computer Scientist Should Know About Floating-Point Arithmetic https://en.wikipedia.org/wiki/IEEE_754-1985 https://en.wikipedia.org/wiki/Floating_point. Floating-point numbers stored by encoding significand \u0026amp; the exponent (along with a sign bit)\nAbove line contains 2-3 abstract terms \u0026amp; I think you will unable to understand the above line until you read further.","title":"How Floating-Point No Is Stored in Memory?"},{"content":"In the early days of my career, I used to work on Linux machines remotely. In those days, I was not knowing about SSH \u0026amp; all and people around me was using Putty as it was very easy \u0026amp; simple. Open source as well. You just have to enter IP \u0026amp; Port and you would get command-line access to remote machine. here, we will discuss \u0026ldquo;how to install and configure VNC server on Linux?\u0026rdquo;\nAs development/deployment of build complexity increase over the year \u0026amp; I have gained some experience, my necessity increased. Then, I have to work on 2-3 different machine simultaneously and sometimes have to execute command synchronously in different machine.\nThen I came across MobaXterm, which gives you screen split \u0026amp; command recording as macros made me astonish. It also support Window forwarding so you can also use GUI(not properly). This tool helped me a lot along the way of my professional journey.\nRecently I have used vncserver \u0026amp; felt, earlier whatever I was using is scrap you can access complete full-fledged remote system with minimal processing cost.\nThen I installed TigerVNC Viewer in my laptop which has windows 10 \u0026amp; vncserver in remote machine which has Ubuntu 17.\nHow to install and configure VNC server on Linux? Installing **vncserver** 1 2 sudo apt-get update sudo apt-get install xfce4 xfce4-goodies tightvncserver Configure Set password 1 $ vncpasswd you prompted with entry password \u0026amp; confirm password lines where you have to set password.\nRunning VNC Server 1 2 3 4 5 6 $ vncserver New \u0026#39;X\u0026#39; desktop is vishal-:1 Creating default startup script /home/vishal/.vnc/xstartup Starting applications specified in /home/vishal/.vnc/xstartup Log file is /home/vishal/.vnc/vishal-:1.log Now open TigerVNC Viewer(which may be on desktop or search using Windows Key). Enter: Like this \u0026amp; click on connect. You will prompted by password screen. You have to enter the password you set when running command vncpasswd.\nDebugging Error I have got grey screen nothing else. I have resolved that error following ways.\nVNC server grey screen problem solution Kill running server, there are two ways to do that\n1). vncserver -list gives you a list of running vncserver.\n2). ps -ef | grep vnc will give you a list of running vnc servers \u0026amp; their display number. 1 $ vncserver -kill :1 I have given :1 as my display no is 1\nOpen xstartup file 1 $ vim ~/.vnc/xstartup Add following lines\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/sh def export XKLXMODMAPDISABLE=1 unset SESSIONMANAGER unset DBUSSESSIONBUSADDRESS gnome-panel \u0026amp; gnome-settings-daemon \u0026amp; metacity \u0026amp; nautilus \u0026amp; gnome-terminal \u0026amp; Save \u0026amp; close it. Then run\n1 $ sudo apt-get install ubuntu-gnome-desktop -y Will take some time. Restart/configure vncserver by. Your problem should be resolved.\nVNC server related utilities Copy-paste between host \u0026amp; TigerVNC viewer 1 $ vncconfig --nowin \u0026amp; ","permalink":"https://vishalchovatiya.github.io/posts/how-to-install-configure-vncserver-linux-2/","summary":"In the early days of my career, I used to work on Linux machines remotely. In those days, I was not knowing about SSH \u0026amp; all and people around me was using Putty as it was very easy \u0026amp; simple. Open source as well. You just have to enter IP \u0026amp; Port and you would get command-line access to remote machine. here, we will discuss \u0026ldquo;how to install and configure VNC server on Linux?","title":"How to Install and Configure VNC Server on Linux!"},{"content":"This topic might be a piece of cake for every experienced C++ veteran. But I remember back in the days when I was a novice \u0026amp; introducing myself with Modern C++, I was really irritated by C++ compiler messages saying this is lvalue \u0026amp; that is rvalue kind of jargons. And even if you are not using C++, you may have faced compiler error in C language saying \u0026ldquo;lvalue required as left operand of assignment\u0026rdquo;.\nSo I was getting difficulties in understanding this un-schooled topic \u0026ldquo;lvalue rvalue and their references with example in C++\u0026rdquo; until I have googled a bit for the same. This is my habit to preserve knowledge in term of an article. So here is a bit about things I had learned so far. I always start with \u0026ldquo;Why do we need that?\u0026rdquo; So let\u0026rsquo;s start from there.\nWhy Do We Need Lvalue \u0026amp; Rvalue Kind of Jargons? If you are using C++ prior to C++11 then you don\u0026rsquo;t need these jargons to write code. But yes it is still useful to understand compilation errors. The compiler sees things by expression \u0026amp; to evaluate expression it identify operand \u0026amp; operation. Let\u0026rsquo;s understand this by example: 1 uint32_t a = 5; Here compiler identifies a \u0026amp; 5 as operand and =(assignment) as operation. Furthermore, compiler divides operand in subcategory named as rvalues, lvalues, xvalues, glvalues, and prvalues to distinguish between them(see heading image for hierarchy). This different value type tells the compiler about the source, destination, the scope of information, etc. In the above expression a is lvalue as it indicates destination memory where rvalue i.e. 5 will be stored. When you compile \u0026amp; see above statement in assembly, it would probably look like : 1 2 3 ... movl $5, -4(%ebp) ... Here, (%ebp) is current frame pointer which pulls down by 4 bytes which indicate [space allocated by the compiler for a variable in a stack](/posts/how-c-program-convert-into-assembly/). And movlinstruction store5` to that memory location directly. This is straight forward as long as we are using primitive data types like int, double, char, etc. So compiler will store raw value directly in instruction code itself like in our case its $5. After the execution of that instruction, $5 is not used, so it has an expression scope, in other words, it is temporary. But when we use class \u0026amp; struct which are the user-defined type, things get bit complex \u0026amp; compiler introduce temporary object instead of directly storing the value in instruction code itself. TL;DR\nWe need this kind of jargons to understand compilation error \u0026amp; to see things from a compilers perspective. And yes! if you are using C++11 or above, you need to understand these jargons to write robust, fast \u0026amp; optimize code.\nLvalue Rvalue and Their References With Example What Are Lvalue \u0026amp; Rvalue? lvalue \u0026amp; rvalue is compiler identifiers to evaluate the expression. Any compiler identifier which represents memory location is an lvalue. Any compiler identifier which represents data value on the right-hand side of an assignment operator(=) is rvalue. Examples of Lvalue There are two types of lvalue modifiable \u0026amp; non-modifiable(which are const). Modifiable lvalue: Expression Explanation a = 1; a is lvalue as it represents memory int b = a; b \u0026amp; a is an lvalue, when a is assigned to b. It becomes an implicit rvalue because a copy of a is stored in b, not a itself struct S* ptr = \u0026amp;obj; ptr is lvalue arr[20] = 5; location index 20 in arr is lvalue int *pi = \u0026amp;i; *pi = 10; i is lvalue as it is addressable. *pi is lvalue as it points to i class MyClass {}; MyClass X; X is lvalue as it represents the memory of user-defined type Non-modifiable lvalue: Expression Explanation const int a=1; a is non-modifiable lvalue const int *p=\u0026amp;a; p is non-modifiable lvalue Examples of Rvalue Expression Explanation int a = 1; 1 is rvalue int b = a; a is implicit rvalue in this case (as discussed in the 2nd point of \u0026ldquo;Examples of lvalue\u0026rdquo;) q = p + 5; p + 5 is an rvalue int result = getInteger(); The value returned by getInteger() is rvalue class cat {}; c = cat(); cat() is an rvalue rvalue could be a function on the right-hand side of = assignment operator which eventually evaluate to object(primitive or user-defined). rvalues are typically evaluated for their values, have expression scope (they die at the end of the expression they are in) most of the time, and cannot be assigned to. For example: 1 2 5 = a; // invalid getInt() = 2; // invalid Lvalue Rvalue References With Example lvalue reference\nAn lvalue reference is a reference that binds to an lvalue. lvalue references are marked with one ampersand \u0026amp;. 1 2 int x = 5; int \u0026amp;lref = x; // lvalue reference initialized with lvalue x Prior to C++11, only one type of reference existed in C++, and so it was just called a “reference”. However, in C++11, it’s sometimes called an lvalue reference. lvalue references can only be initialized with modifiable lvalues. 1 2 const int a = 5; int \u0026amp;ref = a; // Invalid \u0026amp; error will be thrown by compiler Exception\nWe cannot bind lvalue reference to an rvalue 1 int \u0026amp;a = 5; // error: lvalue cannot be bound to rvalue 5 However, we can bind an rvalue to a const lvalue reference (const reference):\n1 const int \u0026amp;a = 5; // Valid In this case, the compiler converts 5 into lvalue first \u0026amp; then it assigns memory location to a const reference. rvalue reference\nThis is by far the most useful \u0026amp; bit complex thing you will learn. An rvalue reference is a reference that binds to an rvalue. rvalue references are marked with two ampersand \u0026amp;\u0026amp;. 1 int \u0026amp;\u0026amp;rref = 5; // rvalue reference initialized with rvalue 5 rvalues references cannot be initialized with lvalues i.e. 1 2 int a = 5; int \u0026amp;\u0026amp;ref = a; // Invalid \u0026amp; error will be thrown by compiler rvalue references are more often used as function parameters. This is most useful for function overloads when you want to have different behaviour for lvalue and rvalue arguments. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void fun(const int \u0026amp;lref) // lvalue arguments will select this function { std::cout \u0026lt;\u0026lt; \u0026#34;lvalue reference to const\\n\u0026#34;; } void fun(int \u0026amp;\u0026amp;rref) // rvalue arguments will select this function { std::cout \u0026lt;\u0026lt; \u0026#34;rvalue reference\\n\u0026#34;; } int main() { int x = 5; fun(x); // lvalue argument calls lvalue version of function fun(5); // rvalue argument calls rvalue version of function return 0; } Why Do We Need Rvalue References? If you observe the copy constructor \u0026amp; copy assignment operator prototype, it always takes const reference object as an argument. Because their primary work is to copy the object. And while copying we don\u0026rsquo;t want to modify the object we have provided on the right-hand side of the expression. But there are some scenarios where we don\u0026rsquo;t care about the right-hand side object we have provided to copy from. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class IntArray{ int *m_arr; int m_len; public: IntArray(int len) : m_len(len), m_arr(new int[len]){} ~IntArray(){delete [] m_arr;} // Copy Constructor IntArray(const IntArray\u0026amp; rhs){ m_arr = new int[rhs.m_len]; m_len = rhs.m_len; for(int i=0;i\u0026lt;m_len;i++) m_arr[i] = rhs.m_arr[i]; } }; IntArray func() { IntArray obj(5); // process obj return obj; } int main() { IntArray arr = func(); return 0; } // Note: use \u0026#34;-fno-elide-constructors\u0026#34; option while compiling otherwise it will create copy elision By observing this code we conclude that obj is not useful after the return of func() function. But when you return an [object](/posts/inside-the-cpp-object-model/) by the value it will invoke copy constructor \u0026amp; which will copy all the content from objtoarr(declared in main()by allocating new resource forarr. And when obj` goes out of scope it will deallocate its resources. Rather than allocating new resources \u0026amp; copying data into it why don\u0026rsquo;t we simply use those existing obj\u0026rsquo;s resources? Let\u0026rsquo;s do that: Move Constructor 1 2 3 4 5 6 IntArray(IntArray\u0026amp;\u0026amp; rhs){ m_arr = rhs.m_arr; m_len = rhs.m_len; rhs.m_arr = nullptr; // To prevent code crashing } I have just modified copy constructor code as above which accept rvalue reference as an argument rather than lvalue so that our overloaded copy constructor will only be called when there is an rvalue is used on the right-hand side. Which simply means this constructor will only be called when right-hand side object is temporary or programmer is no longer care about that object. The implementation simply took ownership of resources from obj to arr and set right-hand side object\u0026rsquo;s pointer to NULL so that its destructor won\u0026rsquo;t deallocate resource which it is no longer owning. In fact, this is move constructor, not a copy constructor. Whose primary task is to take/move ownership of resources. Consider following move constructor prototype for more solid understanding: Catching Rvalue Reference 1 2 3 4 IntArray(IntArray\u0026amp;\u0026amp; rhs) { ... } The message of this code is this: \u0026ldquo;The object that rhs binds to is YOURS. Do whatever you like with it, no one will care anyway.\u0026rdquo; It\u0026rsquo;s a bit like giving a copy to IntArray but without making a copy. Why do we need move constructor?\nThis can be interesting for two purposes:\nimproving performance (as we are not allocating new resources \u0026amp; transferring content).\ntaking over ownership (since the object the reference binds to has been abandoned by the caller).\nI know you might be thinking that why just we don\u0026rsquo;t modify copy constructor by removing const keyword from it. Let\u0026rsquo;s do that as well\n1 2 IntArray(IntArray\u0026amp; rhs){ } Compilation error 1 2 3 4 5 6 7 8 exit status 1 error: no matching constructor for initialization of \u0026#39;IntArray\u0026#39; IntArray arr = func(); ^ ~~~~~~ note: candidate constructor not viable: expects an lvalue for 1st argument IntArray(IntArray\u0026amp; rhs){ ^ 1 error generated. If you see the note above, our overloaded copy constructor asking for lvalue. What we are doing is providing rvalue. As when we return an object by value, temporary(which falls under rvalue category) object will be created and supplied to our copy constructor. And as we have already seen above lvalue reference cannot bind to rvalue object. Don\u0026rsquo;t think about changing your copy constructor\u0026rsquo;s argument as const lvalue reference, I know we have seen that its exception \u0026amp; we can bind const lvalue reference to rvalue/temporary object. But in that case, you can not move/transfer resource as it is const. So, this is it for \u0026ldquo;lvalue rvalue and their references with example\u0026rdquo;, in the next article we will design smart pointer using rvalue reference \u0026amp; other concepts gained here.\n","permalink":"https://vishalchovatiya.github.io/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/","summary":"This topic might be a piece of cake for every experienced C++ veteran. But I remember back in the days when I was a novice \u0026amp; introducing myself with Modern C++, I was really irritated by C++ compiler messages saying this is lvalue \u0026amp; that is rvalue kind of jargons. And even if you are not using C++, you may have faced compiler error in C language saying \u0026ldquo;lvalue required as left operand of assignment\u0026rdquo;.","title":"Lvalue Rvalue and Their References With Example in C++"},{"content":"In an earlier article, we have seen how move constructor \u0026amp; move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor \u0026amp; assignment operator to implement unsophisticated shared_ptr.\nImplementing Our shared_ptr with Move Constructor \u0026amp; Assignment Operator In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time. And when the reference count goes to zero which means nobody is using that resource, we will deallocate that resource. Unlike std::unique_ptr, which is designed to singly own and manage a resource, std::shared_ptr is meant to solve the case where you need multiple smart pointers co-owning a resource. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 template\u0026lt;class T\u0026gt; class smart_ptr { T* m_ptr; uint32_t *m_refCount; public: smart_ptr(T* ptr = nullptr):m_ptr(ptr) { if(m_ptr) m_refCount = new uint32_t(1); else m_refCount = nullptr; } ~smart_ptr() { if(m_refCount != nullptr){ (*m_refCount)--; if((*m_refCount) == 0){ delete m_ptr; delete m_refCount; } } } // Copy constructor smart_ptr(const smart_ptr\u0026amp; a) { m_ptr = a.m_ptr; m_refCount = a.m_refCount; (*m_refCount)++; } // Move constructor smart_ptr(smart_ptr\u0026amp;\u0026amp; a): m_ptr(a.m_ptr), m_refCount(a.m_refCount) { a.m_ptr = nullptr; a.m_refCount = nullptr; } // Copy assignment smart_ptr\u0026amp; operator=(const smart_ptr\u0026amp; a) { m_ptr = a.m_ptr; m_refCount = a.m_refCount; (*m_refCount)++; return *this; } // Move assignment smart_ptr\u0026amp; operator=(smart_ptr\u0026amp;\u0026amp; a) { if (\u0026amp;a == this) return *this; delete m_ptr; delete m_refCount; m_ptr = a.m_ptr; a.m_ptr = nullptr; m_refCount = a.m_refCount; a.m_refCount = nullptr; return *this; } T\u0026amp; operator*() const { return *m_ptr; } T* operator-\u0026gt;() const { return m_ptr; } }; class Resource { public: Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource acquired\\n\u0026#34;; } ~Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource destroyed\\n\u0026#34;; } }; smart_ptr\u0026lt;Resource\u0026gt; func(smart_ptr\u0026lt;Resource\u0026gt; temp) { // Do something return temp; } int main() { Resource *res = new Resource; smart_ptr\u0026lt;Resource\u0026gt; ptr1(res); { smart_ptr\u0026lt;Resource\u0026gt; ptr2(ptr1); auto ptr3 = func(ptr1); std::cout \u0026lt;\u0026lt; \u0026#34;Killing one shared pointer\\n\u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;Killing another shared pointer\\n\u0026#34;; return 0; } Unlike std::unique_ptr, which uses a single pointer internally, std::shared_ptr uses two pointers internally. One pointer points at the managed resource. The other points at a \u0026ldquo;control block\u0026rdquo;, which is a dynamically allocated object that tracks of a bunch of stuff, including how many std::shared_ptr are pointing at the resource. Here I have only used a single variable to keep track of references pointing to resource for simplicity. The actual implementation is a bit bulky for more feature \u0026amp; security purpose. A bit about move constructor \u0026amp; move assignment operator When does the move constructor \u0026amp; move assignment operator get called?\nThe move constructor and move assignment are called when those functions have been defined, and the argument for construction or assignment is an r-value. Most typically, this r-value will be a literal or temporary value.\nIn most cases, a move constructor and move assignment operator will not be provided by default, unless the class does not have any defined copy constructors, copy assignment, move assignment, or destructors. However, the default move constructor and move assignment do the same thing as the default copy constructor and copy assignment (make copies, not do moves). l-value reference \u0026amp; r-value reference I have already written a separate article for that. std::move In C++11, std::move is a standard library function that serves a single purpose \u0026ndash; to convert its argument into an r-value. Once you start using move semantics more regularly, you\u0026rsquo;ll start to find cases where you want to invoke move semantics, but the objects you have to work with are l-values, not r-values. Use case or benefit of std::move Consider the following swap()function as an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;class T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T tmp { a }; // invokes copy constructor a = b; // invokes copy assignment b = tmp; // invokes copy assignment } int main() { std::string x{ \u0026#34;abc\u0026#34; }; std::string y{ \u0026#34;de\u0026#34; }; swap(x, y); return 0; } Above swap()function makes 3 copies. That leads to a lot of excessive string creation and destruction, which is slow. However, doing copies isn\u0026rsquo;t necessary here. All we\u0026rsquo;re really trying to do is swap the values of a and b, which can be accomplished just as well using 3 moves instead! So if we switch from copy semantics to move semantics, we can make our code more performant. 1 2 3 4 5 6 7 template\u0026lt;class T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T tmp { std::move(a) }; // invokes move constructor a = std::move(b); // invokes move assignment b = std::move(tmp); // invokes move assignment } std::move can also be useful when sorting an array of elements. Many sorting algorithms (such as selection sort and bubble sort) work by swapping pairs of elements. Here we can use move semantics, which is more efficient. ","permalink":"https://vishalchovatiya.github.io/posts/move-constructor-assignment-operator-with-shared-ptr/","summary":"In an earlier article, we have seen how move constructor \u0026amp; move assignment operators helped us in creating our own unique_ptr. Here we will use move constructor \u0026amp; assignment operator to implement unsophisticated shared_ptr.\nImplementing Our shared_ptr with Move Constructor \u0026amp; Assignment Operator In some cases, we have a requirement where a single resource is represented by multiple pointers. We can not accomplish this by std::unique_ptr. To accomplish this, we can add a new variable to our smart pointer class which keeps track of reference count at the real-time.","title":"Move Constructor \u0026 Assignment Operator With std::shared_ptr"},{"content":"The smart pointers are a really good mechanism to manage dynamically allocated resources. In this article, we will see unique_ptr with example in C++11. But we don\u0026rsquo;t discuss standard smart pointers from a library. Rather, we implement our own smart pointer equivalent to it. This will give us an idea of inside working of smart pointers.\nBrief Prior to C++11, the standard provided std::auto_ptr. Which had some limitations. But from C++11, standard provided many smart pointers classes. Understanding unique_ptr with example in C++ requires an understanding of move semantics which I have discussed here \u0026amp; here.\nBut before all these nuisances, we will see \u0026ldquo;Why do we need smart pointer in 1st place?\u0026rdquo;:\nWhy do we need smart pointers? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void func() { Resource *ptr = new Resource; int x; std::cout \u0026lt;\u0026lt; \u0026#34;Enter an integer: \u0026#34;; std::cin \u0026gt;\u0026gt; x; if (x == 0) throw 0; // the function returns early, and ptr won\u0026#39;t be deleted! if (x \u0026lt; 0) return; // the function returns early, and ptr won\u0026#39;t be deleted! // do stuff with ptr here delete ptr; } In the above code, the early return or throw statement, causing the function to terminate without variable ptr being deleted. Consequently, the memory allocated for variable ptr is now leaked (and leaked again every time this function is called and returns early). These kinds of issues occur because pointer variables have no inherent mechanism to clean up after themselves. Following class cleans-up automatically when sources are no longer in use: smart_ptr aka std::auto_ptr from C++98 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class T\u0026gt; class smart_ptr { T* m_ptr; public: smart_ptr(T* ptr=nullptr):m_ptr(ptr){} ~smart_ptr() { delete m_ptr; } T\u0026amp; operator*() const { return *m_ptr; } T* operator-\u0026gt;() const { return m_ptr; } }; Now, let\u0026rsquo;s go back to our func()example above, and show how a smart pointer class can solve our challenge: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Resource { public: Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource acquired\\n\u0026#34;; } ~Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource destroyed\\n\u0026#34;; } }; void func() { smart_ptr\u0026lt;Resource\u0026gt; ptr(new Resource); // ptr now owns the Resource int x; std::cout \u0026lt;\u0026lt; \u0026#34;Enter an integer: \u0026#34;; std::cin \u0026gt;\u0026gt; x; if (x == 0) throw 0; if (x \u0026lt; 0) return; // do stuff with ptr here // dont care about deallocation } int main() { try{ func(); } catch(int val){} return 0; } Output 1 2 3 Resource acquired Hi! Resource destroyed Note that even in the case where the user enters zero and the function terminates early, the Resource is still properly deallocated. Because of the ptr variable is a local variable. ptr destroys when the function terminates (regardless of how it terminates). And because of the smart_ptr destructor will clean up the Resource, we are assured that the Resource will be properly cleaned up. There is still some problem with our code. Like: 1 2 3 4 5 6 7 int main() { smart_ptr\u0026lt;Resource\u0026gt; res1(new Resource); smart_ptr\u0026lt;Resource\u0026gt; res2(res1); // Alternatively, don\u0026#39;t initialize res2 and then assign res2 = res1; return 0; } Output 1 2 3 Resource acquired Resource destroyed Resource destroyed In this case destructor of our Resource object will be called twice which can crash the program. What if, instead of having our copy constructor and assignment operator copy the pointer (\u0026ldquo;copy semantics\u0026rdquo;), we instead transfer/move ownership of the pointer from the source to the destination object? This is the core idea behind move semantics. Move semantics means the class will transfer ownership of the object rather than making a copy. Let\u0026rsquo;s update our smart_ptr class to show how this can be done: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 template\u0026lt;class T\u0026gt; class smart_ptr { T* m_ptr; public: smart_ptr(T* ptr=nullptr) :m_ptr(ptr) {} ~smart_ptr() { delete m_ptr; } // copy constructor that implements move semantics smart_ptr(smart_ptr\u0026amp; a) // note: not const { m_ptr = a.m_ptr; // transfer our dumb pointer from the source to our local object a.m_ptr = nullptr; // make sure the source no longer owns the pointer } // assignment operator that implements move semantics smart_ptr\u0026amp; operator=(smart_ptr\u0026amp; a) // note: not const { if (\u0026amp;a == this) return *this; delete m_ptr; // make sure we deallocate any pointer the destination is already holding first m_ptr = a.m_ptr; // then transfer our dumb pointer from the source to the local object a.m_ptr = nullptr; // make sure the source no longer owns the pointer return *this; } T\u0026amp; operator*() const { return *m_ptr; } T* operator-\u0026gt;() const { return m_ptr; } }; class Resource { public: Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource acquired\\n\u0026#34;; } ~Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource destroyed\\n\u0026#34;; } }; int main() { smart_ptr\u0026lt;Resource\u0026gt; res1(new Resource); smart_ptr\u0026lt;Resource\u0026gt; res2(res1); return 0; } Output 1 2 Resource acquired Resource destroyed std::auto_ptr, and why to avoid it What we have seen above as smart_ptr is basically an std::auto_ptr which was introduced in C++98, was C++\u0026rsquo;s first attempt at a standardized smart pointer. However, std::auto_ptr (and our smart_ptr class) has a number of problems that make using it dangerous. Because std::auto_ptr implements move semantics through the copy constructor and assignment operator, passing an std::auto_ptr by value to a function will cause your resource to get moved to the function parameter (and be destroyed at the end of the function when the function parameters go out of scope). Then when you go to access your std::auto_ptr argument from the caller (not realizing it was transferred and deleted), you\u0026rsquo;re suddenly dereferencing a null pointer. Crash! std::auto_ptr always deletes its contents using non-array delete. This means std::auto_ptr won\u0026rsquo;t work correctly with dynamically allocated arrays, because it uses the wrong kind of deallocation. Worse, it won\u0026rsquo;t prevent you from passing it a dynamic array, which it will then mismanage, leading to memory leaks. Because of the above-mentioned shortcomings, std::auto_ptr has been deprecated in C++11, and it should not used. In fact, std::auto_ptr slated for complete removal from the standard library as part of C++17! Overriding the copy semantics to implement move semantics leads to weird edge cases and inadvertent bugs. Because of this, in C++11, the concept of \u0026ldquo;move\u0026rdquo; formally defined. And \u0026ldquo;move semantics\u0026rdquo; added to the language to properly differentiate copying from moving. In C++11, std::auto_ptr has been replaced by a bunch of other types of \u0026ldquo;move-aware\u0026rdquo; smart pointers: std::scoped_ptr, std::unique_ptr, std::weak_ptr, and std::shared_ptr. We\u0026rsquo;ll also explore the two most popular of these: std::unique_ptr (which is a direct replacement for std::auto_ptr) and std::shared_ptr. std::unique_ptr with example in C++11 std::unique_ptr is the C++11 replacement for std::auto_ptr. It is used to manage use to manage any dynamically allocated object not shared by multiple objects. That is, std::unique_ptr should completely own the object it manages, not share that ownership with other classes. We can convert our smart_ptr we designed above into std::unique_ptr. And for that one thing, we can do is delete the copy constructor \u0026amp; assignment operator so that no one can copy smart pointer. As we are not allowing a copy of smart pointer we can\u0026rsquo;t pass our smart pointer to any function by value or return by value. And this is not good design. To pass or return by value, we can add move constructor \u0026amp; move assignment operator, so that while passing or returning by value, we would have to transfer ownership through move semantics. This way we can also ensure single ownership throughout the lifetime of the object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 template\u0026lt;class T\u0026gt; class smart_ptr { T* m_ptr; public: smart_ptr(T* ptr = nullptr) : m_ptr(ptr){} ~smart_ptr() { delete m_ptr; } // Copy constructor smart_ptr(const smart_ptr\u0026amp; a) = delete; // Move constructor smart_ptr(smart_ptr\u0026amp;\u0026amp; a) : m_ptr(a.m_ptr) { a.m_ptr = nullptr; } // Copy assignment smart_ptr\u0026amp; operator=(const smart_ptr\u0026amp; a) = delete; // Move assignment smart_ptr\u0026amp; operator=(smart_ptr\u0026amp;\u0026amp; a) { if (\u0026amp;a == this) return *this; delete m_ptr; m_ptr = a.m_ptr; a.m_ptr = nullptr; return *this; } T\u0026amp; operator*() const { return *m_ptr; } T* operator-\u0026gt;() const { return m_ptr; } }; class Resource { public: Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource acquired\\n\u0026#34;; } ~Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource destroyed\\n\u0026#34;; } }; smart_ptr\u0026lt;Resource\u0026gt; func(smart_ptr\u0026lt;Resource\u0026gt; temp) { // Do something return temp; } int main() { smart_ptr\u0026lt;Resource\u0026gt; res1(new Resource); // smart_ptr\u0026lt;Resource\u0026gt; res3 = res1; // Won\u0026#39;t compile, as copy contructor is deleted smart_ptr\u0026lt;Resource\u0026gt; res3 = func(std::move(res1)); // calls move semantics return 0; } Output 1 2 Resource acquired Resource destroyed This is not the exact implementation of std::unique_ptr as there is deleter, implicit cast to bool \u0026amp; other security features included in an actual implementation, but this gives you a bigger picture of how std::unique_ptr is implemented. References https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/ https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=vs-2017 ","permalink":"https://vishalchovatiya.github.io/posts/unique_ptr-with-example-in-c/","summary":"The smart pointers are a really good mechanism to manage dynamically allocated resources. In this article, we will see unique_ptr with example in C++11. But we don\u0026rsquo;t discuss standard smart pointers from a library. Rather, we implement our own smart pointer equivalent to it. This will give us an idea of inside working of smart pointers.\nBrief Prior to C++11, the standard provided std::auto_ptr. Which had some limitations. But from C++11, standard provided many smart pointers classes.","title":"Understanding unique_ptr with Example in C++11"},{"content":"The typecasting is the feature which makes C++ more type-safe, robust \u0026amp; may convince you to use it over C. But this is also a more underrated topic when you are a newbie or moving from C background. Hence, I come up with an article on it. Here, we will not only see the C++ type casting with example but we will also cover Why do we need typecasting? \u0026amp; C++ type casting cheat codes for C developers to remember \u0026amp; employ it easily. Although I am not an expert but this is what I have learned so far from various sources \u0026amp; 5+ yrs of industry experience.\nIn C++, there are 5 different types of casts: C-style casts, static_cast, const_cast, dynamic_cast, and reinterpret_cast.\nI usually start with \u0026ldquo;Why do we need it?\u0026rdquo;, but this time first we quickly go through some jargons \u0026amp; I will end this article with some of CPP core guidelines on typecasting.\nJargons You Need to Face Implicit conversion: where the compiler automatically typecast. Like float f = 3;, here compiler will not complain but directly transform 3 which is of type integer into float \u0026amp; assign to f. Explicit conversions: where the developer uses a casting operator to direct the conversion. All types of manual casting fall under the explicit type conversions category. Like int * p = (int*)std::malloc(10);, here we explicitly casting void* to int*. l-value: an identifier which represents memory location. For example, variable name, *ptr where ptr points to a memory location, etc. r-value: a value which is not l-value, r-value appear on the right-hand side of the assignment(=) operator. Like 1 2 int a = 5; // 5 = r-value, q = p + 5; // p + 5 is r-value Note: Although there are some exceptions \u0026amp; more to learn on lvalue, rvalue and their references in C++.\nWhy Do We Need Typecasting? Data is a representation of the bits(0s \u0026amp; 1s) in memory. Data-type is compiler directive which tells the compiler how to store \u0026amp; process particular data. uint32_t a = 5; by this statement you can presume that 4 bytes will be reserved in your memory \u0026amp; upon execution, it will store 0000 0000 0000 0000 0000 0000 0000 0101 data bits in that memory location. This was plain \u0026amp; simple. Let\u0026rsquo;s go a bit further, float f = 3.0; this statement will also reserve 4 bytes in memory \u0026amp; store data bits in the form of 1). the sign bit, 2). exponent \u0026amp; 3). mantissa. Recall how floating-point numbers are stored in memory. But when you write like float f = 3;, the compiler will be confused that how to store an integer value in float type of memory. So it will automatically presume(Implicit conversion here) that you want to store 3.0 rather than 3 which is technically same from the human point of view but it\u0026rsquo;s different when you think from computer memory perspective cause they stored differently. There are many such scenarios where you provide data to store in memory which used to represent different data type. For example, in the following example, you are trying to assign an object of type B into an object of type A 1 2 3 4 5 6 7 8 9 class A{}; class B{}; int main () { B b; A a = b; return 0; } In such scenario compiler can not presume anything \u0026amp; simply throws a compilation error: 1 2 3 4 5 6 7 8 9 10 11 exit status 1 error: no viable conversion from \u0026#39;B\u0026#39; to \u0026#39;A\u0026#39; A a = b; ^ ~ note: candidate constructor (the implicit copy constructor) not viable: no known conversion from \u0026#39;B\u0026#39; to \u0026#39;const A \u0026amp;\u0026#39; for 1st argument class A{}; ^ note: candidate constructor (the implicit move constructor) not viable: no known conversion from \u0026#39;B\u0026#39; to \u0026#39;A \u0026amp;\u0026amp;\u0026#39; for 1st argument class A{}; ^ 1 error generated. But when you define a conversion operator as follows: 1 2 3 4 5 6 7 class B { public: operator A(){ cout\u0026lt;\u0026lt;\u0026#34;CONVERSION OPERATOR\\n\u0026#34;; return A(); } }; The compiler will simply call this member function \u0026amp; won\u0026rsquo;t throw any error because programmer explicitly mentioning that this is how he/she wants to convert. C++ Type Casting With Example for C Developers C-style casts 1 2 3 4 5 int main() { float res = 10 / 4; cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } When you will try to run the above code, you will get 2 as output which we didn\u0026rsquo;t expect. To initialize res variable correctly we need to typecast using float as follows: 1 float res = (float)10 / 4; Now your answer will be 2.5. This type of casting is very simple \u0026amp; straight forward as it appears. You can also write above casting in C++ as: 1 float res = float(10) / 4; C-style casts can change a data type without changing the underlying memory representation which may lead to garbage results. static_cast If you are C developer like me, then this will be your best goto C++ cast which fits in most of the example like: 1 int * p = std::malloc(10); When you try to compile above code using C compiler it works fine. But C++ compiler is not kind enough. It will throw an error as follows : 1 2 3 4 5 exit status 1 error: cannot initialize a variable of type \u0026#39;int *\u0026#39; with an rvalue of type \u0026#39;void *\u0026#39; int * p = std::malloc(10); ^ ~~~~~~~~~~ 1 error generated. The first thing that comes to your mind is the C-style cast: 1 int * p = (int*)std::malloc(10); This will work, but C-style cast is not recommended in C++. static_cast handles implicit conversions like this. We will primarily use it for converting in places where implicit conversions fail, such as std::malloc. 1 int * p = static_cast\u0026lt;int*\u0026gt;(std::malloc(10)); The main advantage of static_cast is that it provides compile-time type checking, making it harder to make an inadvertent error. Let\u0026rsquo;s understand this with C++ example: 1 2 3 4 5 6 7 8 9 10 11 class B {}; class D : public B {}; class X {}; int main() { D* d = new D; B* b = static_cast\u0026lt;B*\u0026gt;(d); // this works X* x = static_cast\u0026lt;X*\u0026gt;(d); // ERROR - Won\u0026#39;t compile return 0; } As you can see, there is no easy way to distinguish between the two situations without knowing a lot about all the classes involved. Another problem with the C-style casts is that it is too hard to locate. In complex expressions, it can be very hard to see C-style casts e.g. T(something) syntax is equivalent to (T)something. const_cast Now we will directly jump to example. No theory can explain this better than example. 1. Ignore constness\n1 2 3 4 5 6 7 int i = 0; const int\u0026amp; ref = i; const int* ptr = \u0026amp;i; *ptr = 3; // Not OK const_cast\u0026lt;int\u0026amp;\u0026gt;(ref) = 3; //OK *const_cast\u0026lt;int*\u0026gt;(ptr) = 3; //OK You are allowed to modify i, because of the object(i here) being assigned to, is not const. If you add const qualifier to i, code will compile, but its behaviour will be undefined (which can mean anything from \u0026ldquo;it works just fine\u0026rdquo; to \u0026ldquo;the program will crash\u0026rdquo;.) 2. Modifying data member using const this pointer\nconst_cast can be used to change non-const class members by a method in which this pointer declared as const. - This can also be useful when overloading member functions based on const, for instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class X { public: int var; void changeAndPrint(int temp) const { this-\u0026gt;var = temp; // Throw compilation error (const_cast\u0026lt;X *\u0026gt;(this))-\u0026gt;var = temp; // Works fine } void changeAndPrint(int *temp) { // Do some stuff } }; int main() { int a = 4; X x; x.changeAndPrint(\u0026amp;a); x.changeAndPrint(5); cout \u0026lt;\u0026lt; x.var \u0026lt;\u0026lt; endl; return 0; } 3. Pass const argument to a function which accepts only non-const argument\nconst_cast can also be used to pass const data to a function that doesn’t receive const argument. See the following code: 1 2 3 4 5 6 7 8 9 10 11 int fun(int* ptr) { return (*ptr + 10); } int main(void) { const int val = 10; cout \u0026lt;\u0026lt; fun(const_cast \u0026lt;int *\u0026gt;(\u0026amp;val)); return 0; } 4. Castaway volatile attribute\nconst_cast can also be used to cast away volatile attribute. Whatever we discussed above in const_cast is also valid for volatile keyword. dynamic_cast dynamic_cast uses the type checking at runtime in contrary to static_cast which does it at compile time. dynamic_cast is more useful when you don\u0026rsquo;t know the type of input which it represents. Let assume: 1 2 3 4 5 6 7 8 9 Base* CreateRandom() { if( (rand()%2) == 0 ) return new Derived1; else return new Derived2; } Base* base = CreateRandom(); As you can see, we don\u0026rsquo;t know which object will be returned by CreateRandom() at run time but you want to execute Method1()of Derived1if it returnsDerived1. So in this scenario, you can use dynamic_cast` as follows 1 2 3 4 Derived1 *pD1 = dynamic_cast\u0026lt;Derived1 *\u0026gt;(base); if (pD1){ pD1-\u0026gt;Method1(); } In case, if the input of dynamic_cast does not point to valid data, it will return nullptr for pointers or throw a std::bad_cast exception for references. In order to work with dynamic_cast, your classes must be polymorphic type i.e. must include at least one virtual methods. dynamic_cast take advantage of RTTI(Run Time Type Identification) mechanism. reinterpret_cast reinterpret_cast converts between types by reinterpreting the underlying bit pattern. You can use reinterpret_cast to cast any pointer or integral type to any other pointer or integral type. This can lead to dangerous situations: nothing will stop you from converting an int to an std::string*. You will use reinterpret_cast in your embedded systems. A common scenario where reinterpret_cast applies is converting between uintptr_t and an actual pointer or between: 1 2 3 4 5 error: static_cast from \u0026#39;int *\u0026#39; to \u0026#39;uintptr_t\u0026#39; (aka \u0026#39;unsigned long\u0026#39;) is not allowed uintptr_t ptr = static_cast\u0026lt;uintptr_t\u0026gt;(p); ^~~~~~~~~~~~~~~~~~~~~~~~~ 1 error generated. Instead, use this: 1 uintptr_t ptr = reinterpret_cast\u0026lt;uintptr_t\u0026gt;(p); I have tried to cover most of the intricacies to clear the main concept behind different typecasting, but still, there might be a chance that I may miss some. So, this is it for C++ type casting with example for C developers. Let\u0026rsquo;s quickly recap:\nCheat Code for C Developers Moving to C++ on Type Casting After reading all this you may confuse on what to use \u0026amp; when! That\u0026rsquo;s why I have created this cheat code\nAvoid C-style casts. Be sure about what you want while casting. Use static_cast wherever you were using C-style cast. Use dynamic_cast with polymorphic classes. Keep in mind that only use dynamic_cast on classes with at least one virtual member in the inheritance hierarchy. Use const_cast when you need to remove const or volatile qualifiers. Use reinterpret_cast when you have no options. Note: const_cast and reinterpret_cast should generally be avoided because they can be harmful if used incorrectly. Don\u0026rsquo;t use it unless you have a very good reason to use them.\nSome of the C++ Core Guidelines on Typecasting P.4: Ideally, a program should be statically (compile-time) type safe ES.48: Avoid casts ES.49: If you must use a cast, use a named cast ES.50: Don’t cast away const C.146: Use dynamic_cast where class hierarchy navigation is unavoidable C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative ","permalink":"https://vishalchovatiya.github.io/posts/cpp-type-casting-with-example-for-c-developers/","summary":"The typecasting is the feature which makes C++ more type-safe, robust \u0026amp; may convince you to use it over C. But this is also a more underrated topic when you are a newbie or moving from C background. Hence, I come up with an article on it. Here, we will not only see the C++ type casting with example but we will also cover Why do we need typecasting? \u0026amp; C++ type casting cheat codes for C developers to remember \u0026amp; employ it easily.","title":"C++ Type Casting With Example for C Developers"},{"content":"In the previous article about How Does Virtual Base Class Works Internally? we have seen address resolution of virtual base class \u0026amp; why it\u0026rsquo;s needed. But I have not discussed Complications of Using the Virtual Base Class. Which we will see in this article. This is going to be a bit complex \u0026amp; clumsy then learning the internal working of the virtual base class. But if you are not tired, then read forward.\nI am re-posting the previous example here to refresh some memory:\n1 2 3 4 class Top { public: int t; }; class Left : virtual public Top { public: int l; }; class Right : virtual public Top { public: int r; }; class Bottom : public Left, public Right { public: int b; }; Class diagram 1 2 3 4 5 Top / \\ Left Right \\ / Bottom Complications of Downcasting While Using the Virtual Base Class As we have seen, casting of the object Bottom to Right(in other words, upcasting) requires adding offset to a pointer. One might be tempted to think that downcasting can then simply be implemented by subtracting the same offset. This process is not easy for the compiler as it seems. To understand this, let us go through an example. 1 2 3 4 5 6 class AnotherBottom : public Left, public Right { public: int ab1; int ab2; }; Bottom \u0026amp; AnotherBottom have the same inheritance hierarchy except for their own data members. Now consider the following code. 1 2 3 4 5 Bottom* bottom1 = new Bottom(); AnotherBottom* bottom2 = new AnotherBottom(); Top* top1 = bottom1; Top* top2 = bottom2; Left* left = static_cast\u0026lt;Left*\u0026gt;(top1); Following is memory layout for Bottom \u0026amp; AnotherBottom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 | | | | |------------------------|\u0026lt;---- Bottom |------------------------|\u0026lt;---- AnotherBottom | Left::l | | Left::l | |------------------------| |------------------------| | Left::_vptr_Left | | Left::_vptr_Left | |------------------------| |------------------------| | Right::r | | Right::r | |------------------------| |------------------------| | Right::_vptr_Right | | Right::_vptr_Right | |------------------------| |------------------------| | Bottom::b | | AnotherBottom::ab1 | top1--\u0026gt;|------------------------| |------------------------| | Top::t | | AnotherBottom::ab2 | |------------------------| top2-----\u0026gt;|------------------------| | | | Top::t | |------------------------| | | Now consider how to implement the static_cast from top1 to left, while taking into account that we do not know whether top1 is pointing to an object of type Bottom or an object of type AnotherBottom. It can\u0026rsquo;t be done! The necessary offset depends on the runtime type of top1 (20 for Bottom and 24 for AnotherBottom). The compiler will complain: 1 error: cannot convert from a pointer to base class \u0026#39;Top\u0026#39; to a pointer to derived class \u0026#39;Left\u0026#39; because the base is virtual Since we need runtime information, we need to use a dynamic_cast instead: 1 Left* left = dynamic_cast\u0026lt;Left*\u0026gt;(top1); However, the compiler is still unhappy: 1 error: cannot dynamic_cast \u0026#39;top1\u0026#39; (of type \u0026#39;class Top*\u0026#39;)to type \u0026#39;class Left*\u0026#39; (source type is not polymorphic) The problem is that a dynamic_cast (as well as the use of typeid) needs runtime type information about the object pointed to by top1. The compiler did not include that because it did not think that was necessary. To force the compiler to include that, we can add a virtual destructor to Top: 1 2 3 4 5 6 class Top { public: virtual ~Top() {} // This line creates magic for us int t; }; Thus, for a downcasting object having virtual base class we need to have at least one virtual function in the virtual base class. Double Pointer Hack For below code: 1 2 Bottom* b = new Bottom(); Right* r = b; We already know that the value of b gets adjusted by 8 bytes before it is assigned to r so that it points to the Right section of the Bottom object). Thus, we can legally assign a Bottom* to a Right*. What about Bottom** and Right**? 1 2 Bottom** bb = \u0026amp;b; Right** rr = bb; Should the compiler accept this? A quick test will show that the compiler will complain: 1 error: invalid conversion from `Bottom**\u0026#39; to `Right**\u0026#39; Why? Suppose the compiler would accept the assignment of bb to rr. We can visualise the result as: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 |----------| --------\u0026gt; |---------| | | | bb | | b | ------\u0026gt; |------------------------|\u0026lt;---- Bottom |----------| /----\u0026gt; |---------| | Left::l | / |------------------------| / | Left::_vptr_Left | |----------| / |---------| ------\u0026gt; |------------------------| | rr | | r | | Right::r | |----------| |---------| |------------------------| | Right::_vptr_Right | |------------------------| | Bottom::b | |------------------------| | Top::t | |------------------------| | | So, bb and rr both point to b, and b and r point to the appropriate sections of the Bottom object. Now consider what happens when we assign to *rr (note that the type of *rr is Right*, so this assignment is valid): 1 *rr = b; This is essentially the same assignment as the assignment to r above. Thus, the compiler will implement it the same way! In particular, it will adjust the value of b by 8 bytes before it assigns it to *rr. But *rr pointed to b! If we visualise the result again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 |----------| --------\u0026gt; |-----------| | | | bb | | b | |------------------------|\u0026lt;---- Bottom |----------| /----\u0026gt; |-----------|\\ | Left::l | / \\ |------------------------| / \\ | Left::_vptr_Left | |----------| / |-----------|---\\-----\u0026gt; |------------------------| | rr | | r | | Right::r | |----------| |-----------| |------------------------| | Right::_vptr_Right | |------------------------| | Bottom::b | |------------------------| | Top::t | |------------------------| | | This is correct as long as we access the Bottom object through *rr, but as soon as we access it through b itself, all memory references will be off by 8 bytes — obviously a very undesirable situation. So, in summary, even if *a and *b are related by some subtyping relation, **a and **b are not. Constructors of Virtual Bases The compiler must guarantees that the constructor for all virtual bases of a class gets invoked, and get invoked only once. If you don\u0026rsquo;t explicitly call the constructors of your virtual base class (independent of how far up the tree they are), the compiler will automatically insert a call to their default constructors. This can lead to some unexpected results. Consider the same class hierarchy again we have been considering so far, extended with constructors: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Top { public: Top() { a = -1; } Top(int _a) { a = _a; } int a; }; class Left : virtual public Top { public: Left() { b = -2; } Left(int _a, int _b) : Top(_a) { b = _b; } int b; }; class Right : virtual public Top { public: Right() { c = -3; } Right(int _a, int _c) : Top(_a) { c = _c; } int c; }; class Bottom : public Left, public Right { public: Bottom() { d = -4; } Bottom(int _a, int _b, int _c, int _d) : Left(_a, _b), Right(_a, _c) { d = _d; } int d; }; What would you expect this to output: 1 2 Bottom bottom(1,2,3,4); printf(\u0026#34;%d %d %d %d %d\\n\u0026#34;, bottom.Left::a, bottom.Right::a, bottom.b, bottom.c, bottom.d); You would probably get 1 -1 -1 2 3 4 I know you were expecting different. But if you trace the execution of the constructors, you will find 1 2 3 4 Top::Top() Left::Left(1,2) Right::Right(1,3) Bottom::Bottom(1,2,3,4) As explained above, the compiler has inserted a call to the default constructor in Bottom, before the execution of the other constructors. Then when Left tries to call its base class constructor(Top), we find that Top has already been initialised and the constructor does not get invoked. To avoid this situation, you should explicitly call the constructor of your virtual base(s): 1 2 3 4 Bottom(int _a, int _b, int _c, int _d): Top(_a), Left(_a,_b), Right(_a,_c) { d = _d; } Pointer Equivalence\nOnce again assuming the same (virtual) class hierarchy, would you expect this to print “Equal”? 1 2 3 4 5 Bottom* b = new Bottom(); Right* r = b; if(r == b) printf(\u0026#34;Equal!\\n\u0026#34;); Bear in mind that the two addresses are not actually equal (r is off by 8 bytes). However, that should be completely transparent to the user; so, the compiler actually subtracts the 8 bytes from r before comparing it to b; thus, the two addresses are considered equal. Although, this also stands true for the following code. 1 2 3 4 5 6 7 8 9 class base1{}; class base2{}; class derived : public base1, public base2{}; derived *d = new derived(); base2 *b2 = d; if(b2 == d) printf(\u0026#34;Equal!\\n\u0026#34;); Reference http://www.avabodh.com/cxxin/virtualbase.html https://stackoverflow.com/questions/21558/in-c-what-is-a-virtual-base-class https://web.archive.org/web/20160413064252/http://www.phpcompiler.org/articles/virtualinheritance.html Book: Inside C++ Object Model By Lippman ","permalink":"https://vishalchovatiya.github.io/posts/complications-of-using-the-virtual-base-class/","summary":"In the previous article about How Does Virtual Base Class Works Internally? we have seen address resolution of virtual base class \u0026amp; why it\u0026rsquo;s needed. But I have not discussed Complications of Using the Virtual Base Class. Which we will see in this article. This is going to be a bit complex \u0026amp; clumsy then learning the internal working of the virtual base class. But if you are not tired, then read forward.","title":"Complications of Using the Virtual Base Class"},{"content":"Finally, we are in the 3rd \u0026amp; last part of this series. We have already discussed how virtual function \u0026amp; virtual class/inheritance works internally in previous parts. We left one topic i.e. \u0026ldquo;How Does Virtual Destructor Works?\u0026rdquo; which we will see now. As usual, before learning anything new I usually start with “Why Do We Need It in the First Place?”\nWhy Do We Need a Virtual Destructor? We will understand this with our earlier example(slightly twisted): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class protocol_t { private: uint8_t *_type; // storage ... public: protocol_t() { _type = new uint8_t; } ~protocol_t() { cout\u0026lt;\u0026lt;\u0026#34;~protocol_t\u0026#34;; delete _type; } virtual void authenticate(){}; virtual void connect(){}; // operations ... }; class wifi_t : public protocol_t { private: char *_pass; // storage ... public: wifi_t() { _pass = new char[15]; } ~wifi_t() { cout\u0026lt;\u0026lt;\u0026#34;~wifi_t\u0026#34;; delete _pass; } virtual void authenticate(){}; virtual void connect(){}; // operations ... }; class bluetooth_t : public protocol_t { private: char *_pass; // storage ... public: bluetooth_t() { _pass = new char[15]; } ~bluetooth_t(){ cout\u0026lt;\u0026lt;\u0026#34;~bluetooth_t\u0026#34;; delete _pass; } virtual void authenticate(){}; virtual void connect(){}; // operations ... }; void makeConnection(protocol_t *protocol) { protocol-\u0026gt;authenticate(); protocol-\u0026gt;connect(); // Do some tx \u0026amp; rx delete protocol; } int main() { int prot_type = rand() % 2; makeConnection( (prot_type) ? new wifi_t : new bluetooth_t); return 0; } So, we have created wifi_t \u0026amp; bluetooth_t objects dynamically in main() and passed it to function makeConnection()` An objects of wifi_t, bluetooth_t \u0026amp; protocol_t also uses heap memory at construction \u0026amp; destruction time. Well, this code compiles \u0026amp; runs fine without any error. But when you run above code, at the time of delete protocol line it always calls the destructor of protocol_t which you can verify by ~protocol_t print on console. We are freeing only sub-object resources which is protocol_t in call of ~protocol_t() destructor. This means that there is a memory leak as we are not freeing heap memory resource of an object pointed by the pointer protocol_tin functionmakeConnection()` We even don\u0026rsquo;t know the type of object protocol_t pointer pointed to at the run time. Virtual destructors are there to solve this problem. What we have to do is that 1 2 3 //... virtual ~protocol_t() { cout\u0026lt;\u0026lt;\u0026#34;~protocol_t\u0026#34;; delete _type; } //... Put keyword virtual in front of destructor ~protocol_t() Now delete protocol line will not directly call the destructor of protocol, rather it calls destructor indirectly i.e. using virtual table mechanism(in other words, dynamic dispatch). This way it calls the destructor of the object pointed i.e. either ~wifi_t() or ~bluetooth_t() by pointer protocol \u0026amp; then call the destructor of its base class i.e. ~protocol_t() Hence, virtual destructor uses to delete the object pointed by base class pointer/reference. How Does Virtual Destructor Works? The question is how our destructor of a derived class called. The answer is simple it calls the destructor indirectly i.e. using virtual table pointer(_vptr). Let\u0026rsquo;s understand it with the assumption that our pointer protocol points to an object of type wifi_t. 1 2 protocol_t *protocol = new wifi_t; delete protocol; Here is the memory layout of the object wifi_t 1 2 3 4 5 6 7 8 9 10 11 12 13 14 | | |--------------------------------| \u0026lt;------ wifi_t class object memory layout | protocol_t::_type | |--------------------------------| | protocol_t::_vptr_protocol_t |----------| |--------------------------------| |----------|-------------------------| | wifi_t::_pass | | type_info wifi_t | |--------------------------------| |-------------------------| | | | wifi_t::authenticate | | | |-------------------------| | | | wifi_t::connect | | | |-------------------------| | | | wifi_t::~wifi_t | | | |-------------------------| Now, the statement delete protocol; will probably be transformed by a compiler into 1 2 3 //... (*protocol-\u0026gt;vptr[3])(protocol); // Equivalent to `delete protocol;` //... Till here it was simple for us to understand how things are working. Because this is similar to a virtual function mechanism which we have seen in earlier articles. But the real magic comes when the destructor of a base class i.e. protocol_t will be called. Which is again done with augmented code by the compiler in derived class destructor \u0026amp; probably be: 1 2 3 4 5 6 7 8 9 10 11 12 ~wifi_t() { cout\u0026lt;\u0026lt;\u0026#34;~wifi_t\u0026#34;; delete this-\u0026gt;_pass; // Compiler augmented code ---------------------------------------------------- // Rewire virtual table this-\u0026gt;vptr = vtable_protocol_t; // vtable_protocol_t = address of static virtual table // Call to base class destructor protocol_t::~protocol_t(this); // ---------------------------------------------------------------------------- } The process of destructing an object takes more operations than those you write inside the body of the destructor. When the compiler generates the code for the destructor, it adds extra code both before and after the user-defined code. Here we have only taken after code for the sake of understanding. The same process will happen no matter how long tree up there is. Verifying Compiler Augmented Code in Case of the Virtual Destructor Although you can not see compiler augmented code(unless if you disassemble it), we can use one hack that will prove that compiler insert the call of base class destructor in a derived class destructor when we use a virtual destructor. For the same, consider the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class base { public: virtual ~base()=0; }; class derived : public base{ public: ~derived(){} }; int main(){ base *pbase = new derived; delete pbase; return 0; } When we use pure virtual destructor, the compiler will throw the following error at the time of linking: 1 2 3 4 exit status 1 /tmp/main-06bc44.o: In function `derived::~derived()`: main.cpp:(.text._ZN7derivedD2Ev[_ZN7derivedD2Ev]+0x11): undefined reference to `base::~base()` clang: error: linker command failed with exit code 1 (use -v to see invocation) Hence, compiler tried to add the code for base class destructor call in the derived class destructor. But due to unavailability of base class destructor definition linker exited with an error. Tricky Example: Guess the Output Following example stolen from stackoverflow: 1 2 3 4 5 6 7 8 9 10 11 struct base { virtual ~base() { f(); } virtual void f() { std::cout \u0026lt;\u0026lt; \u0026#34;base\u0026#34;; } }; struct derived : base { void f() { std::cout \u0026lt;\u0026lt; \u0026#34;derived\u0026#34;; } }; int main() { base * p = new derived; delete p; } I would recommend you to guess the output first \u0026amp; run it. If you get goosebump, try to interpret below line. Standard mandates that the runtime type of the object is that of the class being constructed/destructed at this time, even if the original object that is being constructed/destructed is of a derived type. Hence, it prints the output base. Summary Virtual destructor uses to delete the object pointed by base class pointer/reference Call to virtual destructor is done using dynamic dispatch Compiler augments the derived class destructor code by inserting a call to the base class destructor The runtime type of the object is that of the class being constructed/destructed at this time, even if the original object that is being constructed/destructed is of a derived type ","permalink":"https://vishalchovatiya.github.io/posts/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/","summary":"Finally, we are in the 3rd \u0026amp; last part of this series. We have already discussed how virtual function \u0026amp; virtual class/inheritance works internally in previous parts. We left one topic i.e. \u0026ldquo;How Does Virtual Destructor Works?\u0026rdquo; which we will see now. As usual, before learning anything new I usually start with “Why Do We Need It in the First Place?”\nWhy Do We Need a Virtual Destructor? We will understand this with our earlier example(slightly twisted): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class protocol_t { private: uint8_t *_type; // storage .","title":"Part 3: All About Virtual Keyword in C++: How Does Virtual Destructor Works?"},{"content":"While introducing myself to Modern C++ \u0026amp; its new features introduced in C++11 \u0026amp; C++14, I have completely neglected this keyword constexpr. Initially, I was confused about when to use const vs constexpr in C++ \u0026amp; how this constexpr works \u0026amp; differ with const. So, I have studied this from different sources \u0026amp; here is the consolidation of it:\nPrimitive constexpr Variables 1 2 3 int varA = 3; const int varB = 5; constexpr int varC = 7; All of the above variable having a value which is known at compile time. varA is a normal scenario while varB \u0026amp; varC will not take further value or assignment. varB \u0026amp; varC are fixed at compile time if we have defined them like above. But, varB is not the right way(in some situation) of declaring the constant value at compile time. For example, if I declare them as follows: 1 2 3 4 5 6 7 8 9 10 11 12 int getRandomNo() { return rand() % 10; } int main() { const int varB = getRandomNo(); // OK constexpr int varC = getRandomNo(); // not OK! compilation error return 0; } Value of varB would not anymore compile time. While statement with varC will throw compilation error. The reason is constexpr will always accept a strictly compile-time value. constexpr Functions 1 2 3 4 5 6 7 8 9 10 11 constexpr int sum(int x, int y) { return x + y; } int main() { const int result = sum(10, 20); // Here, you can use constexpr as well cout \u0026lt;\u0026lt; result; return 0; } constexpr specifies that the value of an object, variable and a function can be evaluated strictly at compile-time. And an expression can use in other constant expressions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 +--------------------------------+-----------------------------------+ | int result = sum(10, 20); | const int result = sum(10, 20); | +--------------------------------+-----------------------------------+ | main: | main: | | .... | .... | | .... | .... | | .... | .... | | subl $20, %esp | subl $20, %esp | | subl $8, %esp | movl $30, -12(%ebp) | \u0026lt;-- Direct | pushl $20 | subl $8, %esp | result | pushl $10 | pushl $30 | substitution | call _Z3sumii | pushl $_ZSt4cout | | addl $16, %esp | call _ZNSolsEi | | movl %eax, -12(%ebp) | .... | | subl $8, %esp | .... | | pushl -12(%ebp) | .... | | pushl $_ZSt4cout | | | call _ZNSolsEi | | | .... | | | .... | | | .... | | +--------------------------------+-----------------------------------+ If you observe above code, you can see that when you catch result as const or constexpr, call to the function sum is not there in assembly rather compiler will execute that function by itself at compile time \u0026amp; substitute the result with function. By specifying constexpr, we suggest compiler to evaluate the function sum at compile time. constexpr Constructors 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class INT { int _no; public: constexpr INT(int no) : _no(no) {} constexpr int getInt() const { return _no; } }; int main() { constexpr INT obj(INT(5).getInt()); cout \u0026lt;\u0026lt; obj.getInt(); return 0; } Above code is simple \u0026amp; self-explanatory. If it isn\u0026rsquo;t to you, then play with it here. const vs constexpr in C++ They serve different purposes. constexpr is mainly for optimization while const is for practically const objects like the value of Pi. const \u0026amp; constexpr both can be applied to member methods. Member methods are made const to make sure that there are no accidental changes by the method. On the other hand, the idea of using constexpr is to compute expressions at compile time so that time can be saved when the code is running. const can only be used with non-static member function whereas constexpr can be used with member and non-member functions, even with constructors but with condition that argument and return type must be of literal types. You read about more limitations here. Where to Use What? Where you need a value not often \u0026amp; calculating it would be a bit complex, then that is the place you need constexpr. Otherwise, things are fine with an older buddy const. For example, Fibonacci number, factorial, etc. 1 2 3 4 5 6 constexpr unsigned int factorial(unsigned int n) { return (n \u0026lt;= 1) ? 1 : (n * factorial(n - 1)); } static constexpr auto magic_value = factorial(5); Often programmer would suggest using constexpr instead of a macro. Sometimes you have an expression, that evaluated down to a constant, while maintaining good readability and allowing slightly more complex processing than just setting a constant to a number. For example: 1 2 3 4 5 template\u0026lt; typename Type \u0026gt; constexpr Type max( Type a, Type b ) { return a \u0026lt; b ? b : a; } Its a pretty simple choice there but it does mean that if you call max with constant values, it is explicitly calculated at compile time and not at runtime.\nAnother good example is converting units like 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 using ull = unsigned long long; constexpr ull operator\u0026#34;\u0026#34; _KB(ull no) { return no * 1024; } constexpr ull operator\u0026#34;\u0026#34; _MB(ull no) { return no * (1024_KB); } int main() { cout \u0026lt;\u0026lt; 1_KB \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; 1_MB \u0026lt;\u0026lt; endl; } Here you can use constexpr.\n","permalink":"https://vishalchovatiya.github.io/posts/when-to-use-const-vs-constexpr-in-cpp/","summary":"While introducing myself to Modern C++ \u0026amp; its new features introduced in C++11 \u0026amp; C++14, I have completely neglected this keyword constexpr. Initially, I was confused about when to use const vs constexpr in C++ \u0026amp; how this constexpr works \u0026amp; differ with const. So, I have studied this from different sources \u0026amp; here is the consolidation of it:\nPrimitive constexpr Variables 1 2 3 int varA = 3; const int varB = 5; constexpr int varC = 7; All of the above variable having a value which is known at compile time.","title":"When to Use const vs constexpr in C++"},{"content":"While I was introducing myself to C++, I was confused about the syntax of the copy assignment operator in C++ \u0026amp; some of its use-cases. I have learned those lessons the hard way. And so I have decided to write this article, where we see 2 wrong way to learn copy assignment operator in C++ with example. And we also see why we need it \u0026amp; why its syntax like that only. Although I am not an expert or pro but this what I have learned so far from various sources.\nWhy Do We Need Copy Assignment Operator in C++? The simple answer is just to assign data. As we do an assignment in primitive data types like int a; a = 5. Sometimes we also need to do this in our user-defined data type i.e. class/struct. The answer would be the same as copy constructor which I have given here. A class could be a complex entity so that we need a special function which does this task. Although compiler provides a default one. But in some cases, you have to define your own copy assignment operation such as: Write your own assignment operator that does the deep copy if you are using dynamic memory. Do not allow the assignment of one object to another object or sub-object(object slicing). We can create our own dummy assignment operator and make it private or simply delete it. Why Do We Need to Return Something From the Copy Assignment Operator? While I was learning about the copy assignment operator, I always had a doubt that why do we need to return value from the copy assignment operator function. Let\u0026rsquo;s consider following example: Copy Assignment Operator in C++ With Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class X { public: int var; X(int x) { this-\u0026gt;var = x; } X \u0026amp;operator=(const X \u0026amp;rhs) { this-\u0026gt;var = rhs.var; return *this; } }; X x1(1), x2(2); x2 = x1; // Compiler augments into X::x2.operator=(x1); Actually, we don\u0026rsquo;t need to, if you look at the above code we are already assigning to a current object i.e. x2 using this pointer who called copy assignment operator function. I can understand the need for const in the argument of the copy assignment operator function. But the return value was not justifiable to me until I saw the following code: 1 2 X x1(1), x2(2), x3(3); x3 = x2 = x1; If you make return type of copy assignment operator function as void, the compiler won\u0026rsquo;t throw error till you are using x2 = x1;. But when assignment chain will be created like x3 = x2 = x1; you have to return something so that it can be an argument on further call to copy assignment operator. So we have to return something from the copy assignment operator to support assignment chaining feature. But what should be the appropriate return type? This will lead us to our next point. What Should Be the Appropriate Return Type? I know, you will say we have to return a reference to the current object. Yeh! that\u0026rsquo;s correct also but why not return by value or pointer? Ok, then, let\u0026rsquo;s see 2 wrong way to learn copy assignment operator in C++\nNo. 1: Let\u0026rsquo;s try return by value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class X { public: int var; X(int x) { this-\u0026gt;var = x; } X operator=(X \u0026amp;rhs) { this-\u0026gt;var = rhs.var; return *this; } }; int main() { X x1(1), x2(2), x3(3); x2 = x1; // Statement 1: Works fine (x3 = x2) = x1; // Statement 2: Correct, but meaning less statement x3 = (x2 = x1); // Statement 3: Meaningful but compiler won\u0026#39;t alllow us x3 = x2 = x1; // Statement 4: Meaningful but compiler won\u0026#39;t alllow us cout \u0026lt;\u0026lt; x1.var \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; x2.var \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; x3.var \u0026lt;\u0026lt; endl; return 0; } Note that I have not taken an argument as const in copy assignment operator.\nWhen you will compile the above code, GCC will throw an error as follows: 1 2 3 4 5 6 error: no viable overloaded \u0026#39;=\u0026#39; x3 = (x2 = x1); // Statement 3: Meaningful but compiler won\u0026#39;t alllow us ~~ ^ ~~~~~~~~~ note: candidate function not viable: expects an l-value for 1st argument X operator = (X \u0026amp;rhs){ ^ Let\u0026rsquo;s understand all these statements one-by-one 1 x2 = x1; // Statement 1: Works fine Above statement is correct \u0026amp; works fine as we are not utilising return value provided by the copy assignment operator. 1 (x3 = x2) = x1; // Statement 2: Correct, but meaningless statement This statements is perfectly fine \u0026amp; have no problem in a compilation. But Statement 2 is meaningless as we are first assigning x2 into x3 which returns a temporary(AKA anonymous) object which again calls a copy assignment operator with x1 as an argument. This works fine but at the end call of the copy assignment operator, we are assigning the value of x1 to a temporary object which is meaningless. Probable transformation of Statement 2 by the compiler would be 1 (X::x3.operator=(x2)).operator=(x1); With more simplicity 1 2 X temp = X::x3.operator=(x2); X::temp.operator=(x1); As you can see I have taken temp object which usually created by the compiler as we are returning an object by value. So this way output would be 1 2 2 which is not correct. Now we will observe Statement 3 1 x3 = (x2 = x1); // Statement 3: Meaningful but compiler won\u0026#39;t allow us Probable transformation of Statement 3 by the compiler would be 1 (X::x3.operator=((x2 = x1)); Code till operation x2 = x1 is fine we have seen it earlier but when the result of that operation becomes an argument to another copy assignment operator function, it will again create the problem of temporary object binding to a non-const reference. If you don\u0026rsquo;t know about \u0026ldquo;temporary object binding to non-const reference\u0026rdquo; then you should find out the reason behind why the following program is not working, you will understand everything you wanted to know for Statement 3. 1 2 3 4 5 6 int main() { const string \u0026amp;val1 = string(\u0026#34;123\u0026#34;); // Works fine string \u0026amp;val2 = string(\u0026#34;123\u0026#34;); // Will throw error return 0; } Error: 1 2 3 4 5 6 clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final) exit status 1 error: non-const lvalue reference to type \u0026#39;basic_string\u0026lt;...\u0026gt;\u0026#39; cannot bind to a temporary of type \u0026#39;basic_string\u0026lt;...\u0026gt;\u0026#39; string\u0026amp; val2 = string(\u0026#34;123\u0026#34;); ^ ~~~~~~~~~~~~~ 1 error generated. Note that the above code will work in some of the old compilers like VC2012, etc. Now we will move to Statement 4 1 x3 = x2 = x1; // Statement 4: Meaningful but compiler won\u0026#39;t allow us This will also throw the same error as Statement 3 because conceptually both are same. Although Statement 3 \u0026amp; Statement 4 can also be valid if you modify argument of copy assignment operator from pass by reference to pass by value which we know adds the unnecessary overhead of calling copy constructor which also stands true for the return type. No. 2: Let\u0026rsquo;s try return by pointer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class X { public: int var; X(int x) { this-\u0026gt;var = x; } X *operator=(X \u0026amp;rhs) { this-\u0026gt;var = rhs.var; return this; } }; int main() { X x1(1), x2(2), x3(3); x2 = x1; // Statement 1: Works fine x3 = x2 = x1; // Statement 4: Meaningful but compiler won\u0026#39;t alllow us cout \u0026lt;\u0026lt; x1.var \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; x2.var \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; x3.var \u0026lt;\u0026lt; endl; return 0; } This time we will not observe all four statements rather will go for 2 basic statement which is also valid for primitive data types. Statement 1 is not correct but still works fine. While Statement 4 throws an error 1 2 3 4 5 6 7 8 9 clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final) exit status 1 error: no viable overloaded \u0026#39;=\u0026#39; x3 = x2 = x1; // Statement 4: Meaningful but compiler wont alllow us ~~ ^ ~~~~~~~ note: candidate function not viable: no known conversion from \u0026#39;X *\u0026#39; to \u0026#39;X \u0026amp;\u0026#39; for 1st argument; dereference the argument with * X* operator = (X \u0026amp;rhs){ ^ 1 error generated. Probable transformation of Statement 4 by the compiler would be 1 (X::x3.operator=( ( x2 = x1 ) ); This will not work simply because of the result of an operation `( x2 = x1 ) is pointer \u0026amp; copy assignment operator function wants a reference as an argument. Now you will say that why we just not change argument with pointer rather than accepting it as a reference. Nice idea! I would say 1 2 3 4 5 6 X *operator=(X *rhs) { cout \u0026lt;\u0026lt; \u0026#34;THIS\\n\u0026#34;; this-\u0026gt;var = rhs-\u0026gt;var; return this; } Now to call above copy assignment operator you need to use the following operation 1 x2 = \u0026amp;x1; Because we are expecting pointer as an argument in copy assignment operator. x1 = x2 or x3 = x2 = x1 won\u0026rsquo;t work anymore. If you are still getting the correct answer as 1 1 1 in your output window then just consider print from cout. You are getting the correct answer 1 1 1 because default copy constructor provided by the compiler is getting called every time. Technically, we have just overloaded copy constructor by changing its return type \u0026amp; argument as a pointer. Conclusion Above are the reason why it is not feasible to use pass by value or pointer an argument or return type of copy assignment operator. Compiler designer have designed standard in such a way that your class object operation should also work same as primitive type operations like 1 2 3 4 5 6 7 // Primitive type \u0026amp; operations int a = 5, b, c; a = b = c; // User defined type \u0026amp; operations X x1(5), x2, x3; x3 = x2 = x1; ","permalink":"https://vishalchovatiya.github.io/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/","summary":"While I was introducing myself to C++, I was confused about the syntax of the copy assignment operator in C++ \u0026amp; some of its use-cases. I have learned those lessons the hard way. And so I have decided to write this article, where we see 2 wrong way to learn copy assignment operator in C++ with example. And we also see why we need it \u0026amp; why its syntax like that only.","title":"2 Wrong Way to Learn Copy Assignment Operator in C++ With Example"},{"content":"Do not carry away with the title \u0026ldquo;All about copy constructor in C++ with example\u0026rdquo;. In this article, I am not going to describe what copy constructor in C++ is. There is plenty of material available for that over the internet. Rather we will discuss why, where \u0026amp; how it used, how compiler synthesizes it for you and in what scenarios it called or not synthesized.\nWhy: Copy Constructor The simple answer is to copy the data within the same data types, but if you want more concrete idea then see below image:\nNote: Color represents assembly generated by the compiler for a corresponding C expression\nAs you can see, for creating a copy within the same primitive data types like char, int, float, long double, etc. compiler has special instructions. But when you declare user-defined data type i.e. class/struct. The compiler does not have instruction for that because you are the owner of your type, so you have to define the copy operation in special member function called copy constructor suggesting compiler the way you want to copy. Whenever the situation of copy occurs compiler will simply substitute that expression with your copy constructor method. Where: Copy Constructor Object initialization by another object of the same class/type. 1 2 3 4 5 class X { ... }; X x; // Copy constructor will be called X xx = x; When an object passed as an argument to a function 1 2 3 4 5 6 7 8 9 10 extern void foo( X x ); void bar() { X xx; // Copy constructor will be called foo( xx ); // ... } When a function returns a class object 1 2 3 4 5 6 7 8 X foo_bar() { X xx; // ...; // Copy constructor will be called return xx; } Not: Copy Constructor The compiler will not synthesize copy constructor if class having a base class or sub-object with the deleted copy constructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 struct base { base() = default; base(const base\u0026amp;) = delete; }; struct derived : public base{ }; int main() { derived d1; derived d2(d1); return 0; } In this case, derived class copy constructor will be deleted implicitly. See below error for reference: 1 2 3 4 5 6 7 8 9 10 11 12 13 error: call to implicitly-deleted copy constructor of \u0026#39;derived\u0026#39; derived d2(d1); ^ ~~ note: copy constructor of \u0026#39;derived\u0026#39; is implicitly deleted because base class \u0026#39;base\u0026#39; has a deleted copy constructor struct derived : public base{ }; ^ note: \u0026#39;base\u0026#39; has been explicitly marked deleted here base(const base\u0026amp;) = delete; ^ 1 error generated. compiler exit status 1 Same stands true for move constructor \u0026amp; copy/move assignment operator. How: Bitwise Copy \u0026amp; Memberwise Copy 1 2 3 4 5 6 7 8 9 #include \u0026#34;Word.h\u0026#34; Word noun( \u0026#34;block\u0026#34; ); void foo() { Word verb = noun; // ... } If class word defined as follows, then it exhibits bitwise copy constructor as the initialization of verb need not result in a function call. 1 2 3 4 5 6 7 8 9 class Word { public: Word( const char* ); ~Word() { delete [] str; } // ... private: int cnt; char *str; }; But, if the class word defined as follows, then it exhibits memberwise copy constructor \u0026amp; result in a function call because string declares explicit copy constructor. 1 2 3 4 5 6 7 8 9 class Word { public: Word( const string\u0026amp; ); ~Word(); // ... private: int cnt; string str; }; In this case, the compiler needs to synthesize a copy constructor as follows in order to invoke the copy constructor of the member class string object: 1 2 3 4 5 6 // A synthesized copy constructor inline Word::Word( const Word\u0026amp; wd ) { str.string::string( wd.str ); cnt = wd.cnt; } Not: Bitwise Copy Semantics..! When bitwise copy semantics not exhibited by a class? There are four instances:\nWhen the class contains a member object of a class for which a copy constructor exists (either explicitly declared by the class designer, as in the case of the previous string class, or synthesized by\nthe compiler, as in the case of class Word) When the class derived from a base class for which a copy constructor exists (again, either explicitly\ndeclared or synthesized) When the class declares one or more virtual functions When the class derived from an inheritance chain in which one or more virtual base classes exist In instances 1 \u0026amp; 2, the implementation needs to insert invocations of the member or base class copy constructors inside the synthesized copy constructor.\nOther Ways: Can Copy Constructor Be Invoked 1 2 3 4 5 X x0; X x1( x0 ); X x2 = x0; X x3 = x( x0 ); // ... All these statements transform into the invocation of the copy constructor. 1 2 3 4 5 6 7 8 9 10 X x0; X x1; X x2; X x3; // compiler inserted invocations // of copy constructor for X x1.X::X( x0 ); x2.X::X( x0 ); x3.X::X( x0 ); // ... ","permalink":"https://vishalchovatiya.github.io/posts/all-about-copy-constructor-in-cpp-with-example/","summary":"Do not carry away with the title \u0026ldquo;All about copy constructor in C++ with example\u0026rdquo;. In this article, I am not going to describe what copy constructor in C++ is. There is plenty of material available for that over the internet. Rather we will discuss why, where \u0026amp; how it used, how compiler synthesizes it for you and in what scenarios it called or not synthesized.\nWhy: Copy Constructor The simple answer is to copy the data within the same data types, but if you want more concrete idea then see below image:","title":"All About Copy Constructor in C++ With Example"},{"content":"This article is the collection of concept I have acquired while introducing myself to C++ by googling here \u0026amp; there. This material is also not in order. I have just collected the answer to my quick question. And write it down here. But one thing I can assure you is that once you go through this article. You can connect many broken thought of understanding on what runs \u0026ldquo;Inside the C++ object model\u0026rdquo;. And why people call it as it runs C internally.\nNote: In addition, here I have not considered name mangling \u0026amp; other compiler attributes for simplicity. Also not shown how object memory layout created. So, I have discussed it here. Code augmentation depends on compiler implementation, there is no such standard define.\nDefault Member-Functions Created by the Compiler Inside the C++ Object Model Suppose you have declared class like:\n1 class Thing {}; The compiler will probably synthesize this class as: 1 2 3 4 5 6 7 8 9 10 class Thing { public: Thing(); // default constructor Thing(const Thing\u0026amp;); // copy c\u0026#39;tor Thing\u0026amp; operator=(const Thing\u0026amp;); // copy-assign ~Thing(); // d\u0026#39;tor // C++11: Thing(Thing\u0026amp;\u0026amp;); // move c\u0026#39;tor Thing\u0026amp; operator=(Thing\u0026amp;\u0026amp;); // move-assign }; So by default compiler will generate: default constructor copy constructor copy-assign operator destructor move constructor move-assign operator Note: This stands true till C++ 14.\nThe compiler creates all default/implicitly-declared member-functions when it needed. A compiler cannot create default member-functions when it\u0026rsquo;s no use. How C++ Object Model Used in Function? Given the following function, where class X defines a copy constructor, virtual destructor, and virtual function foo() 1 2 3 4 5 6 7 8 9 10 11 12 X foobar() { X xx; X *px = new X; // foo() is virtual function xx.foo(); px-\u0026gt;foo(); delete px; return xx; }; The probable compiler transformation would be: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void foobar(X \u0026amp;result) { X::X(\u0026amp;result);\t// Constructor call, NRVO px = _new(sizeof(X)); // expand X *px = new X; if (px != 0) px-\u0026gt;X::X(); foo(\u0026amp;result);\t// xx.foo(): replaced xx with result (*px-\u0026gt;_vtbl[2])(px); // px-\u0026gt;foo(): using dynamic dispatch // Expand delete px; if (px != 0) { (*px-\u0026gt;_vtbl[1])(px); // Virtual destructor _delete(px); } // replace named return statement // no need to destroy local object xx return; }; This is how the object-oriented paradigm converted into the procedure-oriented paradigm. How Class/Object-Oriented Code Transformed Into Sequential Code? Let\u0026rsquo;s take the following example to understand it: 1 2 3 4 5 6 7 8 9 10 struct foo { int m_var; public: void print() { cout \u0026lt;\u0026lt; m_var \u0026lt;\u0026lt; endl; } }; The compiler treats this as : 1 2 3 4 5 6 7 8 9 struct foo { int m_var; }; void foo::print(foo *this) { std::cout.operator\u0026lt;\u0026lt;(this-\u0026gt;m_var).operator\u0026lt;\u0026lt;(std::endl); } As you can see above, objects \u0026amp; methods are a separate entity. An object only represents data members. Therefore, all the methods in class/struct contain implicit this pointer as the first argument using which all non-static data members are accessed. Static data members are not part of class/struct. Because it usually resides in a data segment of memory layout. So it accesses directly(or using segment registers). So this is the reason if you print the size of the above class. Hence, It prints 4 because all methods are a separate entity which operates on the object by using implicit this pointer. How \u0026amp; Where Constructor Code Transform/Synthesize With Inheritance \u0026amp; Composition Class? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Foo { public: Foo(){cout\u0026lt;\u0026lt;\u0026#34;Foo\u0026#34;\u0026lt;\u0026lt;endl;} ~Foo(){cout\u0026lt;\u0026lt;\u0026#34;~Foo\u0026#34;\u0026lt;\u0026lt;endl;} }; class base { public: base(){cout\u0026lt;\u0026lt;\u0026#34;base\u0026#34;\u0026lt;\u0026lt;endl;} ~base(){cout\u0026lt;\u0026lt;\u0026#34;~base\u0026#34;\u0026lt;\u0026lt;endl;} }; class Bar /* : public base */ { Foo foo; char *str; public: Bar() { cout\u0026lt;\u0026lt;\u0026#34;Bar\u0026#34;\u0026lt;\u0026lt;endl; str = 0; } ~Bar(){cout\u0026lt;\u0026lt;\u0026#34;~Bar\u0026#34;\u0026lt;\u0026lt;endl;} }; Compiler augmented Bar constructor would look like: 1 2 3 4 5 6 7 Bar::Bar() { foo.Foo::Foo(); // augmented compiler code cout\u0026lt;\u0026lt;\u0026#34;Bar\u0026#34;\u0026lt;\u0026lt;endl; // explicit user code str = 0; // explicit user code } Similarly, multiple class member objects require a constructor initialization. The language specifies that the constructors would be invoked in the order of member declaration within the class. This is accomplished by the compiler. But, if an object member does not define a default constructor, a non-trivial default constructor synthesizes by a compiler for respective classes. Moreover, in the case of inheritance, the constructor calling sequence starts from base(top-down) to derived manner. Constructor synthesis \u0026amp; augmentation remain same as above. So in the above case, if you derive Bar from Base then constructor calling sequence would be Base -\u0026gt; Foo -\u0026gt; Bar. How \u0026amp; Where Destructor Code Transform/Synthesize With Inheritance \u0026amp; Composition Class? In case of the destructor, calling sequence is exactly the reverse that of a constructor. Like in the above case it would be Bar -\u0026gt; Foo -\u0026gt; Base. Synthesis \u0026amp; augmentation remain same as above. Access and all other things remain the same. How \u0026amp; Where Virtual Table Code Will Be Inserted? The virtual table code will be inserted by the compiler before \u0026amp; after the user-written code in constructor \u0026amp; destructor. That too on demand of user implementation. Additionally, for the question \u0026ldquo;How virtual table code will be inserted\u0026rdquo;, my answer is \u0026ldquo;this is purely compiler dependent\u0026rdquo;. C++ standard only mandates behaviour. Although this would not be complex. It probably would look like: 1 this-\u0026gt;_vptr[0] = type_info(\u0026#34;class_name\u0026#34;); By the way, I have written a more detailed article on virtual keyword here. Reference https://stackoverflow.com/questions/3734247/what-are-all-the-member-functions-created-by-compiler-for-a-class-does-that-hap Book: Inside C++ Object Model By Lippman ","permalink":"https://vishalchovatiya.github.io/posts/inside-the-cpp-object-model/","summary":"This article is the collection of concept I have acquired while introducing myself to C++ by googling here \u0026amp; there. This material is also not in order. I have just collected the answer to my quick question. And write it down here. But one thing I can assure you is that once you go through this article. You can connect many broken thought of understanding on what runs \u0026ldquo;Inside the C++ object model\u0026rdquo;.","title":"Inside the C++ Object Model"},{"content":"In this article, we will see the memory layout of different C++ Object. And how different storage \u0026amp; access specifiers affect this memory footprint. I am not going to discuss compiler augmented code, name mangling \u0026amp; working of any C++ mechanism related to memory as it is compiler \u0026amp; architecture-dependent. To keep this further simple, I have considered the standard stack growth direction i.e. downwards. And with the same, data members are represented inverted in memory(thanks to Thomas Vermeilh for pointing that out), that too I have ignored for simplicity. Although if you want to play around with the same, you can refer to this link.\nSo, in nutshell, it\u0026rsquo;s just all about \u0026ldquo;How different objects are laid out in memory?\u0026rdquo;\nMemory Layout of Simple \u0026amp; Non-Polymorphic Object in C++ 1 2 3 4 5 6 7 8 9 10 11 class X { int x; float xx; public: X() {} ~X() {} void printInt() {} void printFloat() {} }; Memory layout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 | | |------------------------| \u0026lt;------ X class object memory layout | int X::x | |------------------------| stack segment | float X::xx | | |------------------------| | | | \\|/ | | | | ------|------------------------|---------------- | X::X() | |------------------------| | | X::~X() | | |------------------------| \\|/ | X::printInt() | text segment |------------------------| | X::printFloat() | |------------------------| | | In conclusion of the above example, only data members got the space in the stack. That too as the same order of their declarations. Because this is guaranteed by most of the compilers, apparently. In addition, all other methods, constructor, destructor \u0026amp; compiler augmented code goes into the text segment. These methods are then called \u0026amp; passed this pointer implicitly of calling object in its 1st argument which we have already discussed in Inside The C++ Object Model. Layout of an Object With Virtual Function \u0026amp; Static Data Member 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class X { int x; float xx; static int count; public: X() {} virtual ~X() {} virtual void printAll() {} void printInt() {} void printFloat() {} static void printCount() {} }; Memory layout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 | | |------------------------| \u0026lt;------ X class object memory layout | int X::x | stack |------------------------| | | float X::xx | | |------------------------| |-------|--------------------------| | | X::_vptr |------| | type_info X | \\|/ |------------------------| |--------------------------| | o | | address of X::~X() | | o | |--------------------------| | o | | address of X::printAll() | | | |--------------------------| | | ------|------------------------|------------ | static int X::count | /|\\ |------------------------| | | o | data segment | o | | | | \\|/ ------|------------------------|------------ | X::X() | |------------------------| | | X::~X() | | |------------------------| | | X::printAll() | \\|/ |------------------------| text segment | X::printInt() | |------------------------| | X::printFloat() | |------------------------| | static X::printCount() | |------------------------| | | As you can see above, all non-static data members got the space into the stack with the same order of their declaration which we have already seen in the previous example. And static data member got the space into the data segment of memory. Which access with scope resolution operator(i.e. ::). But after compilation, there is nothing like scope \u0026amp; namespace. Because, its just name mangling performed by the compiler, everything referred by its absolute or relative address. You can read more about name mangling in C++ here. Moreover, static methods go into the text segment and called with the scope resolution operator. Except for this pointer which is not passed in its argument. For virtual keyword, the compiler automatically inserts pointer(_vptr) to a virtual table into the object memory representation. So it transforms direct function calling in an indirect call(i.e. dynamic dispatch which I have discussed in How Does Virtual Function Works Internally?). Usually, virtual table created statically per class in the data segment, but it also depends on compiler implementation. In a virtual table, 1st entry points to a type_info object which contains information related to current class \u0026amp; DAG(Directed Acyclic Graph) of other base classes if it is derived from them. I have not mentioned the data type of _vptr because the standard does not mention(even I don\u0026rsquo;t know that). Layout of C++ Object With Inheritance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class X { int x; string str; public: X() {} virtual ~X() {} virtual void printAll() {} }; class Y : public X { int y; public: Y() {} ~Y() {} void printAll() {} }; Memory layout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 | | |------------------------------| \u0026lt;------ Y class object memory layout | int X::x | stack |------------------------------| | | int string::len | | |string X::str ----------------| | | char* string::str | \\|/ |------------------------------| |-------|--------------------------| | X::_vptr |------| | type_info Y | |------------------------------| |--------------------------| | int Y::y | | address of Y::~Y() | |------------------------------| |--------------------------| | o | | address of Y::printAll() | | o | |--------------------------| | o | ------|------------------------------|-------- | X::X() | |------------------------------| | | X::~X() | | |------------------------------| | | X::printAll() | \\|/ |------------------------------| text segment | Y::Y() | |------------------------------| | Y::~Y() | |------------------------------| | Y::printAll() | |------------------------------| | string::string() | |------------------------------| | string::~string() | |------------------------------| | string::length() | |------------------------------| | o | | o | | o | | | In the inheritance model, a base class \u0026amp; data member classes are a subobject of a derived class. So, a resultant memory map looks like the above diagram. Virtual table with all overridden virtual functions and code to assign _vptr with the virtual table is generated in the constructor of the class by the compiler. I have written more on this topic in the virtual function series. Memory Layout of an Object With Multiple Inheritances \u0026amp; Virtual Function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class X { public: int x; virtual ~X() {} virtual void printX() {} }; class Y { public: int y; virtual ~Y() {} virtual void printY() {} }; class Z : public X, public Y { public: int z; ~Z() {} void printX() {} void printY() {} void printZ() {} }; Memory layout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 | | |------------------------------| \u0026lt;------ Z class object memory layout stack | int X::x | | |------------------------------| |--------------------------| | | X:: _vptr |-----------------\u0026gt;| type_info Z | | |------------------------------| |--------------------------| \\|/ | int Y::y | | address of Z::~Z() | |------------------------------| |--------------------------| | Y:: _vptr |------| | address of Z::printX() | |------------------------------| | |--------------------------| | int Z::z | | |--------GUARD_AREA--------| |------------------------------| | |--------------------------| | o | |----------\u0026gt;| type_info Z | | o | |--------------------------| | o | | address of Z::~Z() | | | |--------------------------| ------|------------------------------|--------- | address of Z::printY() | | X::~X() | | |--------------------------| |------------------------------| | | X::printX() | | |------------------------------| | | Y::~Y() | \\|/ |------------------------------| text segment | Y::printY() | |------------------------------| | Z::~Z() | |------------------------------| | Z::printX() | |------------------------------| | Z::printY() | |------------------------------| | Z::printZ() | |------------------------------| | o | | o | | | In multiple inheritance hierarchy, an exact number of the virtual table pointer(_vptr) created will be N-1, where N represents the number of classes. Now, the rest of the things will be easy to understand for you, I guess so. If you try to call a method of class Z using any base class pointer, then it will call using the respective virtual table. As an example: 1 2 3 Y *y_ptr = new Z; y_ptr-\u0026gt;printY(); // OK y_ptr-\u0026gt;printZ(); // Not OK, as virtual table of class Y doesn\u0026#39;t have address of printZ() method In the above code, y_ptr will point to subobject of class Y within the complete Z object. As a result, call to any method for say y_ptr-\u0026gt;printY(); using y_ptr will be resolved like: 1 ( *y_ptr-\u0026gt;_vtbl[ 2 ] )( y_ptr ) You must be wondering why I have passed y_ptr as an argument here. It\u0026rsquo;s because of an implicit this pointer, you can learn about it here. Layout of Object Having Virtual Inheritance 1 2 3 4 class X { int x; }; class Y : public virtual X { int y; }; class Z : public virtual X { int z; }; class A : public Y, public Z { int a; }; Memory layout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 | | Y class ------\u0026gt; |----------------| \u0026lt;------ A class object memory layout sub-object | Y::y | |----------------| |------------------| | Y::_vptr_Y |------| | offset of X | // offset(20) starts from Y Z class ------\u0026gt; |----------------| |----\u0026gt; |------------------| sub-object | Z::z | | ..... | |----------------| |------------------| | Z::_vptr_Z |------| |----------------| | A sub-object --\u0026gt; | A::a | | |------------------| |----------------| | | offset of X | // offset(12) starts from Z X class -------\u0026gt; | X::x | |----\u0026gt; |------------------| shared |----------------| | ..... | sub-object | | |------------------| Memory representation of derived class having one or more virtual base class divides into two regions: an invariant region a shared region Data within the invariant region remains at a fixed offset from the start of the object regardless of subsequent derivations. However, shared region contains a virtual base class and it fluctuates with subsequent derivation \u0026amp; order of derivation. I have discussed more on this in How Does Virtual Inheritance Works?. ","permalink":"https://vishalchovatiya.github.io/posts/memory-layout-of-cpp-object/","summary":"In this article, we will see the memory layout of different C++ Object. And how different storage \u0026amp; access specifiers affect this memory footprint. I am not going to discuss compiler augmented code, name mangling \u0026amp; working of any C++ mechanism related to memory as it is compiler \u0026amp; architecture-dependent. To keep this further simple, I have considered the standard stack growth direction i.e. downwards. And with the same, data members are represented inverted in memory(thanks to Thomas Vermeilh for pointing that out), that too I have ignored for simplicity.","title":"Memory Layout of C++ Object in Different Scenarios"},{"content":"\u0026ldquo;All About Virtual Keyword in C++\u0026rdquo; is a series of articles(total of three, PART 1, PART 2, PART 3) describe working of the virtual keyword in different scenarios. This article mostly focuses on \u0026ldquo;How Does Virtual Function Works Internally?\u0026rdquo;. In other words, How dynamic dispatch done in C++! Although I am not a compiler writer, but this is what I have learned so far from various sources, courses, books \u0026amp; disassembly of C++ program.\nBefore diving into the How virtual function works internally!, I would like to clarify two things\nImplementation of dynamic dispatch(i.e. virtual function) is purely compiler dependent. C++ standard does not define the implementation. It only states the behaviour. I always ask my self before learning anything new \u0026ldquo;Why do we need it in the first place?\u0026rdquo;. So, let\u0026rsquo;s start there:\nWhy Do We Need a Virtual Function? Let\u0026rsquo;s understand it with an example. Suppose you want to connect to the network or to other mobile using your smartphone. So, you have two choices Bluetooth or Wifi. Although these two are completely different technologies, still some things are common in them at an abstract/behavioural level like both are communication protocol, both need authentication, etc. For example, we have a class of them as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class wifi_t{ private: char _pass[15]; // storage ... public: void authenticate(); void connect(); // operations ... }; class bluetooth_t{ private: char _pass[15]; // storage ... public: void authenticate(); void connect(); // operations ... }; Now, below is the main application in which you want to connect your device to others. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { wifi_t *wifi = new wifi_t; bluetooth_t *bluetooth = new bluetooth_t; int pt = selectProtocol(); if(pt == BLUETOOTH){ bluetooth-\u0026gt;authenticate(); bluetooth-\u0026gt;connect(); } else if(pt == WIFI){ wifi-\u0026gt;authenticate(); wifi-\u0026gt;connect(); } return 0; } If you observe above code then you will find that despite selecting any protocol some steps are the same. In such case, you can leverage virtual functions of C++ as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class protocol_t { private: uint8_t _type; // storage ... public: virtual void authenticate(){}; virtual void connect(){}; // operations ... }; class wifi_t : public protocol_t { private: char _pass[15]; // storage ... public: void authenticate(){}; void connect(){}; // operations ... }; class bluetooth_t : public protocol_t { private: char _pass[15]; // storage ... public: void authenticate(){}; void connect(){}; // operations ... }; void makeConnection(protocol_t *protocol) { protocol-\u0026gt;authenticate(); protocol-\u0026gt;connect(); } int main() { int pt = selectProtocol(); // You can not compile this line, but i have kept it that way for simplicity makeConnection( (pt == WIFI) ? new wifi_t : new bluetooth_t); return 0; } Following are the benefits we have achieved through virtual keywords:\nRun time polymorphism: Behavioural functions identified automatically at runtime \u0026amp; would called by their type like if protocol is wifi then execute wifi_t::authenticate() \u0026amp; wifi_t::connect()` Reusability of code: Observe makeConnection function there is an only single call to behavioural functions we have removed the redundant code from main. Code would be compact: Observe earlier main function \u0026amp; newer one. How Does Virtual Function Works Internally? When you declare any function virtual, the compiler will transform(augment is the precise word here) some of your code at compile time. For instance, in our case class protocol_t the class object will be augmented by a pointer called _vptr which points to the virtual table. In other words, this is nothing but a pointer(_vptr) which points to an array of a function pointer. That includes offset/address of your virtual functions. So that it can call your function through that table rather than calling it directly. So if you call the function authenticate()using a pointer of type protocol_t as below:\n1 2 3 4 protocol_t *protocol; // .... assignment to `protocol` protocol-\u0026gt;authenticate(); then it would probably augmented by a compiler like this\n1 (*protocol-\u0026gt;vptr[ 1 ])( protocol ); Where the following holds:\n_vptr represents the internally generated virtual table pointer inserted within each object whose class\ndeclares or inherits one or more virtual functions. In practice, its name mangled. There may be multiple _vptrs within a complex class derivation. 1 in _vptr[ 1 ] is the index into the virtual table slot associated with authenticate() This index is decided by compiler \u0026amp; fixed throughout the inheritance tree. protocol in its second occurrence(i.e. in the argument) represents the this pointer. When we inherit wifi_t class from protocol_t class, a new virtual table will be created by the compiler with overridden polymorphic function slot. Each virtual function has a fixed index in the virtual table, no matter how long the inheritance hierarchy is.\nIf derived class introduce a new virtual function not present in the base class, the virtual table will be grown by a slot and the address of the function is placed within that slot.\nIf you want to summarize virtual keyword functionality in two words then its indirect calling of a polymorphic function. And to visualize virtual function footprint you can take a look at my earlier article memory layout of a C++ object.\nLet\u0026rsquo;s Address Some of the FAQs Around Virtual Function \u0026amp; Virtual Table Q. Is virtual table per object or per class?\nThis usually depends on compiler implementation. But Generally, a virtual table is per class and the virtual table pointers(_vptr) is to object. There might be more than one virtual table pointers too depending upon type of inheritance. Q. Where \u0026amp; how does virtual table/pointer code augments by the compiler?\nThe code necessary to fill/override virtual table slot generated by the compiler at the time of compilation. To reiterate it in short, the virtual table is generated statically at the compile time by the compiler.\nin constructors right before user-written code. Virtual table pointer(i.e. _vptr) has fixed offset. And the code to override _**_vptr**_ is generated at the time of object construction by the compiler. This is the reason that you should not call the virtual function in constructor. Read more about it here. Q. How do we know at runtime that pointer protocol will execute a right function(of the object pointed to)?\nIn general, we don\u0026rsquo;t know the exact type of the object protocol addresses at each invocation of authenticate() However, we do know the virtual table pointer(_vptr) offset(which is fixed) associated with the object\u0026rsquo;s class. And using this _vptr, we can access the virtual table of the object pointed by protocol pointer. Again the index of function authenticate() in a virtual table fixed throughout the inheritance hierarchy. This way right authenticate()`function execution guaranteed. How `Pure` Virtual Function Works? When you declare any function as pure virtual, the compiler automatically fills the slot of that pure virtual function with dummy function or so-called place holder pure_virtual_called()library instance. And the run-time exception placed if somehow this place holder called. In addition, rest of calling \u0026amp; virtual table slot mechanism would be the same as a normal virtual function. Virtual Function Support Under Multiple Inheritances Now with multiple inheritance things will get a little bit tricky. To understand this behaviour let us take another simplified example as follow : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct base1 { int base1_var; virtual void base1_func() { } virtual void print() { } }; struct base2 { int base2_var; virtual void base2_func() { } virtual void print() { } }; struct derived : base1, base2 { int derived_var; void print() { } }; Here we have derived class with two base classes. In such a case, when we declare an object of the derived class, two virtual table pointers(_vptr) created in the derived class object. One for base1 \u0026amp; other for base2, which are overridden with the address of derived class virtual table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 | | |------------------------| \u0026lt;------ derived object memory layout | base1::base1_var | |------------------------| |---------\u0026gt;|----------------------| | base1::_vptr_base1 |----------| | type_info derived | |------------------------| |----------------------| | base2::base2_var | | base1::base1_func | |------------------------| |----------------------| | base2::_vptr_base2 |----------| | derived:::print | |------------------------| | |----------------------| | derived::derived_var | | |------GUARD_AREA------| |------------------------| |---------\u0026gt;|----------------------| | | | type_info derived | | | |----------------------| | | | base2::base2_func | | | |----------------------| | derived::print | |----------------------| To understand that, first, let\u0026rsquo;s assign a base2 pointer with the address of a derived class object allocated on the heap: 1 base2 *pb = new derived; The address of the new derived object must be adjusted to address its base2 subobject. The code augmentation done by compiler would look like: 1 2 3 base2* pb = static_cast\u0026lt;base2 *\u0026gt;(new derived()); // Equivalent to \u0026#34;address of derived object + sizeof(base1)\u0026#34; Visualizing memory object of above adjustment. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 | | |------------------------| \u0026lt;------ derived object memory layout | base1::base1_var | |------------------------| |---------\u0026gt;|----------------------| | base1::_vptr_base1 |----------| | type_info derived | pb ---\u0026gt; |------------------------| |----------------------| | base2::base2_var | | base1::base1_func | |------------------------| |----------------------| | base2::_vptr_base2 |----------| | derived:::print | |------------------------| | |----------------------| | derived::derived_var | | |------GUARD_AREA------| |------------------------| |---------\u0026gt;|----------------------| | | | type_info derived | | | |----------------------| | | | base2::base2_func | | | |----------------------| | derived:::print | |----------------------| Without this adjustment, any nonpolymorphic use of the pointer would fail, such as 1 pb-\u0026gt;base2_var = 5; And the call to the polymorphic function `print() 1 pb-\u0026gt;print(); would probably transforms into\n1 ( * pb-\u0026gt;_vptr_base2[ 2 ])( pb ); Summary I hope you liked this material \u0026amp; helps you to clarify many doubt around virtual function. There is one extraordinary case of virtual destructor which we will see in-depth in PART-3 of this series. Followings are the points which sum up this article in concise way:\nC++ standard does not define implementation \u0026amp; it only states the behaviour of the dynamic dispatch(i.e. virtual function) virtual table pointers(_vptr) is to object virtual table pointer(_vptr) has fixed offset code to override _vptr is generated at the time of object construction virtual table is per class virtual table is generated statically at the compile time ","permalink":"https://vishalchovatiya.github.io/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/","summary":"\u0026ldquo;All About Virtual Keyword in C++\u0026rdquo; is a series of articles(total of three, PART 1, PART 2, PART 3) describe working of the virtual keyword in different scenarios. This article mostly focuses on \u0026ldquo;How Does Virtual Function Works Internally?\u0026rdquo;. In other words, How dynamic dispatch done in C++! Although I am not a compiler writer, but this is what I have learned so far from various sources, courses, books \u0026amp; disassembly of C++ program.","title":"Part 1: All About Virtual Keyword in C++: How Does Virtual Function Works Internally?"},{"content":"In PART 1 of \u0026ldquo;All About Virtual Keyword in C++\u0026rdquo; series, we have discussed \u0026ldquo;How Does Virtual Function Works Internally?\u0026rdquo;. So, in this article, I will discuss \u0026ldquo;How Does Virtual Base Class Works Internally?\u0026rdquo;. I am iterating the same thing which I have mentioned in the earlier article as well that implementation of a virtual mechanism is purely compiler dependent. So, there is no C++ standard is defined for such dynamic dispatch. Hence, here I am discussing the general approach.\nAs usual, before learning anything new I usually start with “Why do we need it in the first place?”\nWhy Do We Need a Virtual Class/Inheritance? When we use inheritance, we basically extending a derived class with base class functionality. In other words, the base class object would be treated as sub-object in the derived class. As a result, this would create a problem in multiple inheritances if base class sharing the same mutual class as sub-object in the top-level hierarchy and you want to access its property. Problem I know above statement is a bit complex. So, let see an example. 1 2 3 4 class Top { public: int t; }; class Left : public Top { public: int l; }; class Right : public Top { public: int r; }; class Bottom : public Left, public Right { public: int b; }; The above class hierarchy/inheritance results in the \u0026ldquo;diamond\u0026rdquo; which looks like below: 1 2 3 4 5 Top / \\ Left Right \\ / Bottom An instance of Bottom will be made up of Left, which includes Top, and Right which also includes Top. So, we have two sub-object of Top. This will create ambiguity as follows: 1 2 Bottom *bot = new Bottom; bot-\u0026gt;t = 5; // is this Left\u0026#39;s `t` or Right\u0026#39;s `t` data member ?? This was by far the simplest reason for the need of the virtual base class. And consider the following scenarios as an example: 1 2 Top *t_ptr1 = new Left; Top *t_ptr2 = new Right; These both will work fine as Left or Right object memory layout has Top subobject. You can see the memory layout of the Bottom object below for clear understanding. 1 2 3 4 5 6 7 8 9 10 11 12 13 | | |----------------------| \u0026lt;------ Bottom bot; // Bottom object | Left::Top::t | |----------------------| | Left::l | |----------------------| | Right::Top::t | |----------------------| | Right::r | |----------------------| | Bottom::b | |----------------------| | | Now, what happens when we upcast a Bottom pointer? 1 Left *left = new Bottom; This will work fine as Bottom object memory layout starts with Left subobject. However, what happens when we upcast to Right? 1 Right *right = new Bottom; For this to work, we have to adjust the right pointer value to make it point to the corresponding section of the Bottom layout: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 | | |----------------------| | Left::Top::t | |----------------------| | Left::l | |----------------------| \u0026lt;------ right; | Right::Top::t | |----------------------| | Right::r | |----------------------| | Bottom::b | |----------------------| | | | | After this adjustment, we can access the Bottom through the right pointer as a normal Right object. But, what would happen if we do 1 Top* Top = new Bottom; This statement is ambiguous: the compiler will complain 1 error: `Top\u0026#39; is an ambiguous base of `Bottom\u0026#39; Although you can use force typecasting/C-style-cast as follows: 1 2 Top* topL = (Left*) Bottom; Top* topR = (Right*) Bottom; Solution Virtual inheritance uses to solve such kind of diamond problems. When you specify virtual while inheriting your classes, you\u0026rsquo;re telling the compiler that you only want a single instance. 1 2 3 4 class Top { public: int t; }; class Left : virtual public Top { public: int l; }; class Right : virtual public Top { public: int r; }; class Bottom : public Left, public Right { public: int b; }; This means that there is only one \u0026ldquo;instance\u0026rdquo; of Top included in the hierarchy. Hence 1 2 Bottom *bot = new Bottom; bot-\u0026gt;t = 5; // no longer ambiguous So, this may seem more obvious and simpler from a programmer\u0026rsquo;s point of view. But from the compiler\u0026rsquo;s point of view, this is vastly more complicated. But an interesting question is how this bot-\u0026gt;t will be addressed \u0026amp; handle by the compiler? Ok, this is the time to move on to next point. How Does Virtual Base Class Addressing Works Internally? A class containing one or more virtual base class as a subobject, such as Bottom, is divided into two regions: Invariant region Shared region Data within the invariant region remains at a fixed offset(which decided in compilation step) from the start of the object regardless of subsequent derivations. So members within the invariant region can access directly. In our case, its Left \u0026amp; Right \u0026amp; Bottom. Additionally, the shared region represents the virtual base class subobjects whose location within the shared region fluctuates with an order of derivation \u0026amp; subsequent derivation. So members within the shared region need to accessed indirectly. As the name suggests, an invariant region placed at the start of objects memory layout and the shared region placed at the end. The offset of the shared region updated in the virtual table. The code necessary for this augmented by the compiler at the time of object construction. See below image for reference. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 | | |------------------------| \u0026lt;------ Bottom bot; // Bottom object | Left::l | |------------------------| |------------------| | Left::_vptr_Left |-------| | offset of Top | // offset starts |------------------------| |-------|------------------| // from left subobject = 20 | Right::r | | ... | |------------------------| |------------------| | Right::_vptr_Right |-------| |------------------------| | |------------------| | Bottom::b | | | offset of Top | // offset starts |------------------------| |-------|------------------| // from right subobject = 12 | Top::t | | ... | |------------------------| |------------------| | | Now coming back to our interesting question i.e. \u0026ldquo;How this bot-\u0026gt;t will be addressed?\u0026rdquo; 1 2 Bottom *bot = new Bottom; bot-\u0026gt;t = 5; Above code will probably be transformed into 1 2 Bottom *bot = new Bottom; (bot + _vptr_Left[-1])-\u0026gt;t = 5; // If you haven\u0026#39;t got this, then consider the above memory map So, as you can see addressing of virtual base class is done through the offset(of the base class) stored in the virtual table. Handling of Virtual Functions in the Virtual Base Class Handling of the virtual functions in the virtual base class is the same as we have discussed in our previous article with multiple inheritances. There is nothing special about it. Summary As I mentioned earlier this seems straight forward from the programmer\u0026rsquo;s point of view. But from the compiler’s point of view, it is complicated. And, there are many other Complications of Using the Virtual Base Class which I have discussed in a separate article. Let\u0026rsquo;s summaries few take away points:\nThere is no C++ standard on dynamic dispatch implementation \u0026amp; it only states behaviour The virtual class needed to avoid the diamond problem The object having virtual base class as subobject has memory layout divided in two regions: Invariant region: non-virtual classes Shared region: virtual classes Shared region i.e. virtual base class subobject placed at the end of memory layout. The addresses of the data members in the virtual base class resolved using offset(of virtual base class) store in the virtual table. ","permalink":"https://vishalchovatiya.github.io/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/","summary":"In PART 1 of \u0026ldquo;All About Virtual Keyword in C++\u0026rdquo; series, we have discussed \u0026ldquo;How Does Virtual Function Works Internally?\u0026rdquo;. So, in this article, I will discuss \u0026ldquo;How Does Virtual Base Class Works Internally?\u0026rdquo;. I am iterating the same thing which I have mentioned in the earlier article as well that implementation of a virtual mechanism is purely compiler dependent. So, there is no C++ standard is defined for such dynamic dispatch.","title":"Part 2: All About Virtual Keyword in C++: How Does Virtual Base Class Works Internally?"},{"content":"Have you ever wondered , How game of size 8 GB is running on a computer has 4 GB of RAM only? or You can play multiple movies simultaneously combined size more than RAM size? If you are a software developer, you may come across a word like multi-tasking or multiprocessing which is key concept behind this. In other words, it creates virtual memory which is a memory management technique. Here we will see how it works\nHow Does Virtual Memory Work? Let’s say that an OS needs 120 MB of memory in order to hold all the running programs. But there’s currently only 50 MB of available physical memory stored on the RAM chips. The OS will then set up 120 MB of virtual memory \u0026amp; will use a program called the virtual memory manager(VMM) to manage that 120 MB. The VMM will create a file on the hard disk that is 70 MB (120 – 50) in size to account for the extra memory that’s needed. The OS will now proceed to address memory as if there were actually 120 MB of real memory stored in the RAM, even though there’s really only 50 MB. It is the responsibility of the VMM to deal with the fact that there is only 50 MB of real memory. /!\\: If you want to know in-depth of virtual memory implementation, you are at the wrong place. This article will only clear your concept of \u0026ldquo;How does virtual memory work\u0026rdquo;!\nJargons Term Definition Physical Memory or Main Memory RAM Secondary Memory HDD or SSD Virtual Memory Illusion created by OS for optimization (You can say this definition too) VMM Virtual Memory Manager Process Address Space Set of logical addresses that a process references in its code (provided by VMM) OS Operating system (I think this is not needed) AKA Also known as How Does VMM Work? VMM creates a file on the hard disk that holds the extra memory which needed by the OS, which in our case is 70 MB in size. This file called a paging file (AKA swap-file/page-frames) \u0026amp; plays an important role in virtual memory(i.e. How does virtual memory work). The paging file combined with the RAM accounts for all of the memory. Whenever the OS needs a ‘block’ of memory that’s not in the main(RAM) memory, the VMM takes a block from the real memory that hasn’t used recently, writes it to the paging file \u0026amp; then reads the block of memory that the OS needs from the paging file. The VMM then takes the block of memory from the paging file(which needed currently) \u0026amp; moves it into the main memory – in place of the old block. This process is called swapping (also known as paging) \u0026amp; the blocks of memory that are swapped, called pages. There are several algorithms for this process, called Page Replacement Algorithms. The group of pages that currently exist in RAM \u0026amp; that is dedicated to a specific process, is known as the working set for that process. Why Virtual Memory Used? There are two reasons why one would want this: To allow the use of programs that are too big to physically fit in memory. The other reason is to allow for multitasking. Before virtual memory existed, a word processor, e-mail program, \u0026amp; browser couldn’t be run at the same time unless there was enough memory to hold all three programs at once. This would mean that one would have to close one program in order to run the other, but now with virtual memory, multitasking is possible even when there is not enough memory to hold all executing programs at once. Which OS Implemented Virtual Memory? Some of the most popular OSs like Windows, Mac OSX, \u0026amp; Linux implemented VMM. Virtual Memory Can Slow Down Performance(Thrashing)! If the size of virtual memory is quite large in comparison to the main memory, then more swapping to \u0026amp; from the hard disk will occur as a result. Accessing the hard disk is far slower than using the main memory(RAM). Using too many programs at once in a system with an insufficient amount of RAM results in constant disk swapping – also called thrashing, which can really slow down a system’s performance. Terms Associated With Virtual Memory Page In the Paging Scheme, the OS retrieves data from Hard Disk in same-size blocks called pages. Paging It is a VMM scheme by which computer stores \u0026amp; retrieves data from secondary storage(Hard Disk\u0026ndash;Nowadays SSD) for use in real memory(RAM). Paging let programs exceed the size of available physical memory \u0026amp; form virtual memory. Page Fault A page fault occurs when a program tries to access a page that is mapped in address space but not loaded in the physical memory(RAM). Which means that the program would have to access the paging file (which resides on the hard disk) to retrieve the desired page. Combining Page, Paging \u0026amp; Page Fault Terms When OS create virtual memory it will use paging scheme through which some block of memory is loaded in RAM \u0026amp; rest is stored as a paging file in HDD(SSD in some cases) When our program(application) look for something which is not in RAM but stored as paging file, page fault occur. There are many sophisticated algorithms to decrease page fault rate, like LRU, MFU, FIFO, NRU, etc ","permalink":"https://vishalchovatiya.github.io/posts/how-does-virtual-memory-work/","summary":"Have you ever wondered , How game of size 8 GB is running on a computer has 4 GB of RAM only? or You can play multiple movies simultaneously combined size more than RAM size? If you are a software developer, you may come across a word like multi-tasking or multiprocessing which is key concept behind this. In other words, it creates virtual memory which is a memory management technique. Here we will see how it works","title":"How Does Virtual Memory Work?"},{"content":" Hi, I\u0026rsquo;m Vishal — Experienced Enthusiast For: C++, System Software, Firmware, SoC Modeling \u0026amp; Leadership.\nI am a techie who writes software in Assembly/C/C++(11/14/17)/SystemC/Python along with any other technologies that are needed to get things done. I also dabble in blogging, leadership, technical writing \u0026amp; application programming when time permits.\nAt present, leading a team on a technical front along with non-technical nuisances, to create a high impact on individual team member’s career growth while considering corporate accountability also. And that’s where I am losing most of my valuable time these days.\nApart from technical things, I find myself excellent in technical recruitment, competency-based interviewing, leadership \u0026amp; project ownership.\nSome of the words that describe me the best: Software Developer⌨, Tech-Lead?‍✈️, Product Owner?, Fitness Freak?, Geek?, Hipster?, Blogger?‍?, Productivity Hacker⌚, Technical Writer✍️, Tech talker?‍?, Leader?‍?, Manager?, Mentor??‍?, Always a Student?‍?, Incomplete? \u0026amp; Learning Junkie?.\nLanguages Hindi, English, Gujarati\nDate Of Birth 15th March\nHobbies Coding, Music, Workout, Foosball, Cricket\n[/su_tab] [su_tab title=\u0026ldquo;Professional\u0026rdquo; disabled=\u0026ldquo;no\u0026rdquo; anchor=\u0026quot;\u0026quot; url=\u0026quot;\u0026quot; target=\u0026ldquo;blank\u0026rdquo; class=\u0026quot;\u0026quot;]\n7+ Yrs of acquaintance with writing Firmwares, Embedded Systems, Application Softwares, Low-level system development \u0026amp; SoC modelling.\n**Infineon Technologies 9/2020 - Present**\nCurrently, accepting whatever comes in a way. **CircuitSutra Technologies Pvt Ltd 7/2017 - 8/2020**\nWorked with heterogeneous peoples to build a virtual prototype for electronic systems, computing platforms \u0026amp; SoCs to reduce time to market, pre-silicon functional verification, architecture exploration \u0026amp; early software development. Day to day work involves different IP programming using SystemC(kind of C++) like a timer, watch-dog, communication protocols (SPI, I2C, etc), integration of different IP to create SoC, writing multicore firmware \u0026amp; software to verify Virtual Prototype. The typical languages used are Assembly, C/C++(11/14), SystemC, Python and someday hack of shell/batch \u0026amp; TCL scripting. **HCL Technologies Pvt Ltd 6/2016 - 6/2017 : 1 Year**\nWorked with some really weird people to develop a proprietary OS for the supercomputer. My work was to handle/port/analyse/debug core C library upon which we were building OS functionalities. Most of the time I had to deal with a typical C \u0026amp; Assembly code which is written by some experienced psychic. **Skilrock Technologies Pvt Ltd 5/2015 - 5/2016 : 1 Year**\nDeveloped payment gateway applications which you may not hear(like Ingenico, TPS, Spectra) but come across daily at malls, petrol pumps \u0026amp; supermarket stores for billing. Provide end to end solution to customers with the single hand-coded application. Resolved bugs and errors in old projects in co-operation with java developer and testing team. **Satyam Software Solutions Pvt Ltd 4/2014 - 4/2015 : 1 Year**\nWrote firmware for microcontrollers like 8051, ARM Cortex-M4. Wrote embedded software in C/C++ with Linux system programming. Prepared design document –SRS(software requirement specification), the datasheet of finalized \u0026amp; tested products. Also done reverse engineering in co-operation with hardware board design team to design (copy in a real sense) product. Maintenance of old projects in Delhi metro. [/su_tab] [su_tab title=\u0026ldquo;Projects\u0026rdquo; disabled=\u0026ldquo;no\u0026rdquo; anchor=\u0026quot;\u0026quot; url=\u0026quot;\u0026quot; target=\u0026ldquo;blank\u0026rdquo; class=\u0026quot;\u0026quot;]\nAchieved experience on most of the computer engineering layers, starting from digital hardware design, bare-metal softwares, firmware, linux kernels to application softwares.\nCircuitSutra Technologies Pvt Ltd Automotive SoC Technology: Assembly/C/SystemC/C++ \u0026amp; Python Specification: Wrote bare-metal software to verify the functionality of the developed virtual prototype of multicore(10+ cores) SoC having multiple integrated peripherals including ARM’s GIC(Generic Interrupt Controller), ARM’s DMA330, SPI, I2C, multicore timers, WDT, clock management unit, windowed WDT, mailbox(inter-processor communication), etc. Also validated \u0026amp; debugged Linux device drivers to provide support to BSP bring-up team. About Automotive SoC: This automotive SoC is a hard real-time system for driver assistant so it contains 8 application-specific core of ARM(i.e. A76, ARMv8A), 2 real-time core (i.e. CR52, ARMv8R), 4 Cadence Tensilica HiFi 4 DSP core for audio/speech processing \u0026amp; bunch of supporting peripherals. F1M/F1H: Automotive Single \u0026amp; Multi-Core Microcontroller Technology: SystemC/C++ \u0026amp; Python Specification: Developed virtual IP for SoC \u0026amp; wrote bare-metal software to validate VP. Enhanced already modelled IP blocks of stand-by-controller, timer and interrupt controllers. Prepared firmware to test complete SoC using python callback to measure clocks \u0026amp; frequency input of different integrated models. About F1M/H: Renesas’s automotive series real-time microcontrollers for AUTOSAR. SAFETY-BY-SOFTWARE: Specific IP Block For Main Computing Machine Safety Technology: SystemC/C++ \u0026amp; Python Specification: Advanced form of watchdog timer running on a separate core(ARM Cortex-M3) which is not only used to monitor the main computing machine by timer/time-out but also keeps track of the state of the main application to provide hard real-time performance. About SAFETY-BY-SOFTWARE: It just not run a timer to measure the work done of the main system but also take care of state machine of main computing machine’s software in a separate core to prevent malfunction and provide hard real-time functionality. HCL Technologies Pvt Ltd Proprietary Operating System Technology: C, Assembly, Python Specification: Develop \u0026amp; maintain support for system calls \u0026amp; core c library functions. About OS: Participated in developing a new proprietary operating system for proprietary hardware of supercomputer on Linux kernel \u0026amp; bases on Eeebuntu. Skilrock Technologies Pvt Ltd Lottery Management System(LMS) Technology: C/C++ Specification: Develop application on Payment Gateway Terminals to maintain Casino’s Lottery and Game services. About LMS: it is a complete system build by Java application server, C/C++, Android and other technology to maintain Casino’s Lottery and Game services. Satyam Software Solution Pvt Ltd Token Capture Unit(TCU) Technology: Embedded C, Windows serial port driver, Reverse engineered UART Protocol. Specification: Microcontroller P89V51RD2 controls IR sensors \u0026amp; solenoids to trace \u0026amp; validate RFID tokens by continues communication using RS232 with Gate Control Unit (GCU). About TCU: it is a mechanism used to capture token inserted by passengers to travel in a metro train. Add Value Machine or Ticket Reader (AVM/TR) Technology: C/C++, Linux Shell Scripting. Specification: Developed two separate application one for reading RFID cards \u0026amp; second is GUI using DirectFB in Linux. Connected those with message queues, signalling and cross-compiled to run on ARM-based architecture along with high-resolution touch screen display. About TR/AVM: Used to read \u0026amp; add balance in smart card used in Delhi Metro Rail Corporation (DMRC). Automatic Feeding Machine \u0026amp; Passage Control Module(AFM \u0026amp; PCM) Specification AFM: P89V51RD2 control motors along with some mechanical parts by a TV remote and DMRC’s application interface using the UART standard. About AFM: Automatic Feeding Machine feeds RFID tokens to Passenger according to the amount received by the machine. Specification PCM: Hydraulic motors, relays, optocouplers and high power management ICs controlled by a microcontroller. About PCM: Passage Control Module controls the AFC gate’s barrier. I have done the only maintenance of these projects. [/su_tab] [su_tab title=\u0026ldquo;Certifications\u0026rdquo; disabled=\u0026ldquo;no\u0026rdquo; anchor=\u0026quot;\u0026quot; url=\u0026quot;\u0026quot; target=\u0026ldquo;blank\u0026rdquo; class=\u0026quot;\u0026quot;]\n15. Learning to Be Assertive LinkedIn Learning Learned to be assertive. And various communication techniques like an onion peeling, questioning to persuade, broken-record techniques, getting correct feedback, etc. 14. Regular Expressions LinkedIn Learning ECMAScript flavoured regex syntax. Various application of regex from a simple search, search + replace to input validation using C++ APIs. Learned usage of various online tools to craft perfect \u0026amp; optimal regex. 13. Modern C++ Concurrency in Depth Udemy Threads \u0026amp; Jthreads with threads management Sharing data between threads with a synchronization mechanism C++ Memory Model Lock based \u0026amp; lock-free data structure programming 12. Functional Programming using C++ Udemy Functional programming terminologies like type annotation, currying, high-level expressive code, functional composition, etc. Thinking functionally like memoization, monoids, monads, functors, etc. 11. Design Patterns in Modern C++ Udemy Learned about newer features of Modern C++. Got to know about SOLID design principles \u0026amp; how it helps in agile \u0026amp; adaptive software development. Implemented all the Creational, Structural \u0026amp; Behavioural Design Pattern using Modern C++. 10. C++ in detail: Common Idioms Udemy Learned about advanced C++ concepts like SFINAE, CRTP, RTR, Proxy, Type Erasure, etc. 9. C++ in detail: Exceptions Udemy Learned about exception handling strategies \u0026amp; nested exceptions. Also seen the Modern C++ features related to C++. Extracted the real cost of using exception handling by google benchmark. 8. Mastering C++ Standard Library Features Udemy Learned Modern C++(11/14/17). Grabbed value semantics, created movable classes, used Lambdas and got an introduction on compile-time programming. 7. C++ For C Programmers, Part A Coursera A refreshed basic aspect of C++ along with graph algorithms. 6. C++ For C Programmers, Part B Coursera Learned advanced C++ concepts like move semantics \u0026amp; smart pointers by using it in basic game development. 5. Learning How to Learn Coursera Learned different techniques, tricks \u0026amp; psychology related to learning new things. Concepts on memory \u0026amp; neurons. 4. Design Analysis Of Algorithm IIT Madras Got a view on algorithmic techniques like Divide \u0026amp; Conquer, Greedy, Dynamic Programming, Sorting \u0026amp; Searching techniques along with Time \u0026amp; Space Complexity Analysis of Algorithm. 3. Programming Data Structure \u0026amp; Algorithm IIT Madras Learnt Data structures like Stack, Queue, Heaps, LinkList, HashMap, Advance Trees like AVL, RedBlack, Trie, BST, Binary, Treap Also coded Graph DS \u0026amp; Algo. 2. Python IIT Madras Got an overview on inbuilt data structure like a list, dictionary, tuple, string manipulation, threading, file handling. Also done execution of Linux commands \u0026amp; automation test scripts mini project. 1. Embedded System Design Cetpa Infotech Pvt Ltd Industrial training after graduation on Embedded C with microcontrollers like 8051, AVR, ARM, Linux-RTOS concepts. [/su_tab] [su_tab title=\u0026ldquo;Skills\u0026rdquo; disabled=\u0026ldquo;no\u0026rdquo; anchor=\u0026quot;\u0026quot; url=\u0026quot;\u0026quot; target=\u0026ldquo;blank\u0026rdquo; class=\u0026quot;\u0026quot;]\nProgramming Languages Assembly (Very Good) C (In \u0026amp; Out) Embedded C (Good) C++11/14/17, STL, Design Patterns (Excellent) Python(Good) SystemC(Good) Linux Shell Scripting (Moderate) AutoHotkey(Moderate) Microcontrollers ARM7 (LPC21xx series) AVR (ATmega series) MCS-51 series ARM Cortex-M4 (STM32F407-discovery board) Technical Tools Proteus Hardware Design Suit, Synopsys Virtualizer MobaXterm, Putty, TigerVNC, mRemoteNG Vim, Sublime Text, VSCode Synopsys Virtualizer, TLM creator Beyond Compare, DiffPDF Trace32, gdb Github, Perforce, Beyond Compare Regex Productivity \u0026amp; Management Tools OneNote, Google Keep, Google Calendar Wekan, Trello boards MS Office Textik, Windows Ink Workspace, Clover Soft \u0026amp; Other Misc Skills Excellent with automation by Python \u0026amp; AutoHotKey for the repeated task. Good in technical-recruitment, competency-based interviewing, leadership \u0026amp; project management. Writing clean, efficient, scalable, maintainable \u0026amp; expressive code is my speciality. Technical Writing, Blogging, Branding, SEO. Other Protocols - UART, SPI, I2C Encryption – AES \u0026amp; DES CBC MAC through OpenSSL RFID Technology – Sony Felica, NXP’s Mifare DESfire, etc Reverse engineering of UART Protocol Knowledge of AFC(Automatic fair collection) domain of Delhi Metro Rail Corporation Productive \u0026amp; Efficient user of Vim, VSCode, Sublime Text Payment Terminals - TPS, Ingenico, Spectra Tech Talk on Demystifying C++ @CppIndia Tech Talk on Regex with Modern C++ @CppIndia [/su_tab] [su_tab title=\u0026ldquo;Education\u0026rdquo; disabled=\u0026ldquo;no\u0026rdquo; anchor=\u0026quot;\u0026quot; url=\u0026quot;\u0026quot; target=\u0026ldquo;blank\u0026rdquo; class=\u0026quot;\u0026quot;]\nB.Tech In Electronics \u0026amp; Telecommunication 06/2010 \u0026ndash; 06/2013 Aggregate with 81.6% Major: Communication Diploma In Electronics \u0026amp; Telecommunication 06/2007 \u0026ndash; 06/2010 Aggregate with 60% Major: Digital Electronics Matriculation(10th Standard) 06/2006 \u0026ndash; 06/2007 Aggregate with 70% Major: Science, Maths, Sanskrit. [/su_tab] [su_tab title=\u0026ldquo;Contact\u0026rdquo; disabled=\u0026ldquo;no\u0026rdquo; anchor=\u0026quot;\u0026quot; url=\u0026quot;\u0026quot; target=\u0026ldquo;blank\u0026rdquo; class=\u0026quot;\u0026quot;]\nLet\u0026rsquo;s talk \u0026ndash; +91 95555 35096\nConnect with me on -- Facebook, Linkedin, GitHub, Quora\nSay hi \u0026ndash; by email: vishalchovatiya@ymail.com\n[/su_tab][/su_tabs]\n","permalink":"https://vishalchovatiya.github.io/pages/curriculum-vitae/","summary":"Hi, I\u0026rsquo;m Vishal — Experienced Enthusiast For: C++, System Software, Firmware, SoC Modeling \u0026amp; Leadership.\nI am a techie who writes software in Assembly/C/C++(11/14/17)/SystemC/Python along with any other technologies that are needed to get things done. I also dabble in blogging, leadership, technical writing \u0026amp; application programming when time permits.\nAt present, leading a team on a technical front along with non-technical nuisances, to create a high impact on individual team member’s career growth while considering corporate accountability also.","title":"Curriculum Vitae"},{"content":"As we know, the process can allocate \u0026amp; deallocate memory using malloc \u0026amp; free in C language. But do you ever consider what happens behind the scene ? or How do malloc \u0026amp; free work? Let see\nAllocating Memory on the Heap A process can allocate memory by increasing the size of the heap.\nHeap is a variable-size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows \u0026amp; shrinks as memory allocated and freed.\nThe current limit of the heap referred to as the program break which is just at the end of the uninitialized data segment in process address space.\nResizing the heap (i.e., allocating or de-allocating memory) is as simple as telling the kernel to adjust its idea of where the process’s program break is.\nTo allocate memory, C programs normally use the malloc family of functions, which we describe shortly. However, we begin with a description of brk()\u0026amp; `sbrk(), upon which the malloc functions are based.\nPre-requisites: Memory layout of C program OR Understanding of process address space\nbrk()\u0026amp; `sbrk() 1 2 3 4 5 #include \u0026lt;unistd.h\u0026gt; int brk(void end_data_segment); void *sbrk(intptr_t increment); The brk()is a system call which sets the program break to the location specified by end_data_segment. Since virtual memory is located in units of pages, end_data_segment is effectively rounded up to the next page boundary. A call to sbrk() adjusts the program break by adding an increment to it. On Linux, sbrk() is a library function implemented on top of brk(). On success, sbrk()returns the previous address of the program break. In other words, if we have increased the program break, then the return value is a pointer to the start of the newly allocated block of memory. The call sbrk(0) returns the current setting of the program break without changing it. This can be useful if we want to track the size of the heap, perhaps to monitor the behaviour of a memory allocation package. After the program break increased, the program may access any address in the newly allocated area, but no physical memory pages allocated yet. The kernel automatically allocates new physical pages on the first attempt by the process to access addresses in those pages. How Does malloc \u0026amp; free Work? malloc When you malloc a block, it first checks how much memory you requested. There are 2 ways to get memory from the system: 1. mmap(), 2. brk() When you request some byte to be allocated by malloc it checks for MMAP_THRESHOLD limit(this also depends upon library implementations). If you request more than that limit, then mmap()system call used to obtain the requested memory. Else it uses brk()syscall, increments the program break size \u0026amp; gives you a pointer to start of newly allocate contiguous block. Whichever procedure it follows, it allocates a bit more memory than you asked for. This extra memory(also known as meta-data) used to store information such as the size of the allocated block. And a link to the next free/used a block in a chain of blocks, and sometimes some guard data(that helps the system to detect if you write past the end of your allocated block). Also, most allocators will round-up the total size and/or the start of your part of the memory to a multiple of bytes (e.g. on a 64-bit system may align the data to a multiple of 64 bits (8 bytes) as accessing data from non-aligned addresses can be more difficult and inefficient for the processor/bus), so you may also end up with some \u0026ldquo;padding\u0026rdquo; (unused bytes). free As we know so far that we allocate the memory just by increasing the program\u0026rsquo;s break. And upon your intellect, you must be thinking that free will lower this program break. But it\u0026rsquo;s not, free simply adds the block of memory to list of free blocks that are recycled by future calls to malloc() But why? Well, the block of memory being freed is typically somewhere in the middle of the heap, rather than at the end, so that lowering the program break is not possible. Will malloc Allocates Contiguously in Memory or It Scattered? Yes \u0026amp; no both, Here is why! In a typical OS, there exists the concepts of virtual memory and physical memory. Each process has its virtual memory range which is contiguous. When you allocate memory through malloc, the program break increased with respect to virtual memory. So your allocated byte is contiguous. But the OS, behind the scenes, is busy mapping virtual memory allocations onto real blocks of physical memory which do not be contiguous because this is how VMM(Virtual Memory Manager) works. You can read more about it here. How Does free Know How Much to Free? If you still can not figure out the answer to this question, you may read the above topics again. Anyway. When you call `malloc(), you specify the amount of memory to allocate. The amount of memory used is slightly more than this and includes extra information that records (at least) how big the block is. You can\u0026rsquo;t (reliably) access that other information - and nor should you. When you call `free(), it simply looks at the extra information to find out how big the block is. ","permalink":"https://vishalchovatiya.github.io/posts/how-do-malloc-free-work-in-c/","summary":"As we know, the process can allocate \u0026amp; deallocate memory using malloc \u0026amp; free in C language. But do you ever consider what happens behind the scene ? or How do malloc \u0026amp; free work? Let see\nAllocating Memory on the Heap A process can allocate memory by increasing the size of the heap.\nHeap is a variable-size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows \u0026amp; shrinks as memory allocated and freed.","title":"How Do malloc \u0026 free Work in C!"},{"content":"Following example covers API like dladdr, dlclose, dlerror, dlopen, dlsym and flags like RTLD_LAZY, RTLD_NOW, RTLD_GLOBAL, `RTLD_LOCAL, `RTLD_NODELETE`, `RTLD_NOLOAD`, RTLD_NEXT, RTLD_DEFAULT, etc.\nAt First Sight, This Might Look Lengthy \u0026amp; Alien, But If You Spend 5 Min, You Might Get What You Looking For. I Struggle With Finding Dynamic Linking Example On Net When I Came Across Dynamic Linking Related Development. So I Wrote One Helping Post. flags.c We will create binary flags out of flags.c \u0026amp; load both shared library libgetsum.so \u0026amp; `libsum.so` through dlopen with different configuration flags 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 /* * Test Procedure : * * i. Create \u0026#34;libsum.so\u0026#34; from sum.c (kept in same folder). * * gcc -o libgetsum.so -shared -fPIC getsum.c -D_GNU_SOURCE * * ii. Create \u0026#34;libgetsum.so\u0026#34; from sum.c (kept in same folder). * * gcc -o libsum.so -shared -fPIC sum.c -D_GNU_SOURCE * * iii. Create \u0026#34;flags\u0026#34; binary from flags.c file * * gcc -o flags flags.c -ldl -D_GNU_SOURCE * */ /* * Verification Method: * * [libsum.so] : Loaded successfully * [dlsym()] : Executed successfully * sum(0,0) : 1 * Error relocating /home/vishal/libgetsum.so: sum: symbol not found * [libsum.so] : Closed successfully * [libsum.so] : Loaded again successfully * [libgetsum.so] : Loaded again successfully * [dlsym()] : Executed successfully * getsum(4, 5) : 11 * [dlsym()] : Executed successfully * func() : Executed Successfully From [libgetsum.so] * [dladdr()] : Executed successfully * Function : funcXYZ * Shared Lib : /home/vishal/libgetsum.so * */ #include #include #include #include /*Please Provide Absolute Path Of Both Libs */ #define LIB_1 \u0026#34;Absolute_path_to_libsum.so\u0026#34; #define LIB_2 \u0026#34;Absolute_path_to_libgetsum.so\u0026#34; int main(int argc, char **argv) { /*------------------- PASS 1 : Loading Shared Lib 1 -----------------*/ void *lib1 = dlopen(LIB_1, RTLD_LAZY | RTLD_LOCAL | RTLD_NODELETE ); if (!lib1) { dprintf(1, \u0026#34;[libsum.so] : Error in finding the library : PASS 1\\n\u0026#34;); fputs(dlerror(), stderr); exit(1); } else{ dprintf(1, \u0026#34;[libsum.so] : Loaded successfully \\n\u0026#34;); } /*---------------------------------------------------------------------*/ /*------------------ PASS 2 : Finding Symbol \u0026amp; Execute it--------------*/ int (*sum)(int , int) = (int (*)(int , int))dlsym(lib1, \u0026#34;sum\u0026#34;); char *error = dlerror(); if (error != NULL) { dprintf(1, \u0026#34;[dlsym()] : Error : PASS 2\\n\u0026#34;); fputs(error, stderr); exit(1); } else{ dprintf(1,\u0026#34;[dlsym()] : Executed successfully\\n\u0026#34;); printf(\u0026#34;sum(0,0) : %d \\n\u0026#34;, (*sum)(0, 0)); } /*---------------------------------------------------------------------*/ /*------------------ PASS 3 : Loading Shared Lib 2 -------------------*/ void *lib2 = dlopen(LIB_2, RTLD_NOW); if (!lib2) { fputs(dlerror(), stderr); if( dlclose(lib1) == 0 ){ /* Closing Shared Lib 1 */ dprintf(1, \u0026#34;\\n[libsum.so] : Closed successfully \\n\u0026#34;); } else{ dprintf(1, \u0026#34;\\n[libsum.so] : Error in closing : PASS 3 \\n\u0026#34;); } } else{ dprintf(1, \u0026#34;[libgetsum.so] : Loaded successfully \\n\u0026#34;); } /*---------------------------------------------------------------------*/ /*----------------- PASS 4 : Loading Shared Lib 1 Again ---------------*/ lib1 = dlopen(LIB_1, RTLD_NOW | RTLD_NOLOAD | RTLD_GLOBAL ); if (!lib1) { dprintf(1, \u0026#34;[libsum.so] : Error in finding the library : PASS 4\\n\u0026#34;); fputs(dlerror(), stderr); exit(1); } else{ dprintf(1, \u0026#34;[libsum.so] : Loaded again successfully \\n\u0026#34;); } /*---------------------------------------------------------------------*/ /*----------------- PASS 5 : Loading Shared Lib 2 Again ---------------*/ lib2 = dlopen(LIB_2, RTLD_NOW | RTLD_GLOBAL ); if (!lib2) { dprintf(1, \u0026#34;[libgetsum.so] : Error in finding the library : PASS 5\\n\u0026#34;); fputs(dlerror(), stderr); exit(1); } else{ dprintf(1, \u0026#34;[libgetsum.so] : Loaded again successfully \\n\u0026#34;); } /*---------------------------------------------------------------------*/ /*------------------ PASS 6 : Finding Symbol \u0026amp; Execute it--------------*/ int (*getsum)(int , int) = (int (*)(int , int))dlsym(RTLD_DEFAULT, \u0026#34;getsum\u0026#34;); error = dlerror(); if (error != NULL) { dprintf(1, \u0026#34;[dlsym()] : Error : PASS 6\\n\u0026#34;); fputs(error, stderr); exit(1); } else{ dprintf(1,\u0026#34;[dlsym()] : Executed successfully\\n\u0026#34;); printf(\u0026#34;getsum(4, 5) : %d\\n\u0026#34;, (*getsum)(4, 5)); } /*---------------------------------------------------------------------*/ /*------------------ PASS 7 : Finding Symbol \u0026amp; Execute it--------------*/ void (*func)(void) = (void (*)(void))dlsym( lib2, \u0026#34;funcXYZ\u0026#34;); error = dlerror(); if (error != NULL) { dprintf(1, \u0026#34;[dlsym()] : Error : PASS 7\\n\u0026#34;); fputs(error, stderr); exit(1); } else{ dprintf(1,\u0026#34;[dlsym()] : Executed successfully\\n\u0026#34;); printf(\u0026#34;func() : \u0026#34;); (*func)(); } /*---------------------------------------------------------------------*/ /*------------- PASS 8 : Resolving Function Name By Address -----------*/ Dl_info DlInfo; if( dladdr(func, \u0026amp;DlInfo) != 0 ){ dprintf(1, \u0026#34;[dladdr()] : Executed successfully \\n\u0026#34;); dprintf(1, \u0026#34;Function : %s \\n\u0026#34;, DlInfo.dli_sname); dprintf(1, \u0026#34;Shared Lib : %s \\n\u0026#34;, DlInfo.dli_fname); } else{ dprintf(1, \u0026#34;[dladdr()] : Error : PASS 8\\n\u0026#34;); exit(1); } /*---------------------------------------------------------------------*/ dlclose(lib1); dlclose(lib2); return 0; } sum.c We will generate libsum.so out of this file \u0026amp; load libsum.so from flags.c through dlopen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include #include int sum(int a, int b) { static int i=0; i++; return a + b + i; } void funcXYZ() { static void (*fptr)(void) = NULL; /* Come here only first time */ if (fptr == NULL) { fptr = (void (*)(void))dlsym(RTLD_NEXT, \u0026#34;funcXYZ\u0026#34;); if (fptr == NULL) { printf(\u0026#34;dlsym: %s\\n\u0026#34;, dlerror()); return ; } } (*fptr)(); } getsum.c We will generate libgetsum.so out of this file \u0026amp; load libgetsum.so from flags.c through dlopen 1 2 3 4 5 6 7 8 9 10 11 12 13 #include extern int sum(int,int); int getsum(int a, int b) { return sum(a,b); } void funcXYZ() { printf(\u0026#34;Executed Successfully From [libgetsum.so]\\n\u0026#34;); } ","permalink":"https://vishalchovatiya.github.io/posts/dynamic-linking-example/","summary":"Following example covers API like dladdr, dlclose, dlerror, dlopen, dlsym and flags like RTLD_LAZY, RTLD_NOW, RTLD_GLOBAL, `RTLD_LOCAL, `RTLD_NODELETE`, `RTLD_NOLOAD`, RTLD_NEXT, RTLD_DEFAULT, etc.\nAt First Sight, This Might Look Lengthy \u0026amp; Alien, But If You Spend 5 Min, You Might Get What You Looking For. I Struggle With Finding Dynamic Linking Example On Net When I Came Across Dynamic Linking Related Development. So I Wrote One Helping Post. flags.c We will create binary flags out of flags.","title":"Dynamic Linking Example"},{"content":"Brief GNU Build System: Automake, Autoconf, Libtool are a suite of programming tools used to make source code packages portable to many Unix-like systems. Why We Need Autotools: Autoconf: automatically generates configure script by scans of existing tree to find its dependencies, that are supposed to work on all kinds of platforms. configure generates a config.h file (from a template) which programs can include to work around portability issues. For example, if HAVE_LIBPTHREAD is not defined, use forks instead. Automake: No need to write lengthy \u0026amp; complex makefiles. just define target, dependencies, flags, etc. Libtool: simplifying the building and installation of shared libraries on any Unix-like system. Autotools can handle cross-platform development smoothly. Above statements may seem like alien right now. But just go through below example \u0026amp; then read again. You will get what I just said\nCompiling Hello World With Autotools Creating following files in empty directory configure.ac 1 2 3 4 5 6 AC_INIT([PackageName], [1.0], [bug-report@address]) # Initialize `Autoconf`. Specify package\u0026#39;s name, version \u0026amp; bug-report address. AM_INIT_AUTOMAKE # Initialize Automake AC_PROG_CC # Check for a C compiler AC_CONFIG_HEADERS([config.h]) # Declare config.h as output header AC_CONFIG_FILES([Makefile src/Makefile]) # Declare Makefile \u0026amp; src/Makefile as output files AC_OUTPUT # Output all declared files Makefile.am 1 SUBDIRS = src # Build recursively in src directory src/Makefile.am 1 2 bin_PROGRAMS = hello # \u0026#34;hello\u0026#34; is target \u0026amp; will be installed in bindir (as specify \u0026#34;bin_\u0026#34;) hello_SOURCES = main.c # Dependencies of target hello is main.c src/main.c 1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { puts(\u0026#34;Hello World !\u0026#34;); return 0; } Directory Structure 1 2 3 4 5 6 $ ls -R .: configure.ac Makefile.am src ./src: main.c Makefile.am Build Package 1 2 3 4 5 6 $ autoreconf --install $ ./configure --prefix=$(pwd) $ make $ bin/hello Hello World ! $ At this stage, there are a lot of other files are generated as follows :\nMakefile.in, config.h.in, config* : expected configuration templates. aclocal.m4: definitions for third-party macros used in configure.ac. depcomp, install-sh, missing: auxiliary tools used during the build. autom4te.cache/: Autotools cache files. How Autotool Works Understand Build Package Procedure Step 1: autoreconf --install autoreconf is a helper that knows how to call autoconf, autoheader, aclocal, automake, libtoolize, autopoint, etc tools in the right order. Behind autoreconf\naclocal: Scan configure.ac for uses of third-party macros, and gather definitions in aclocal.m4. autoconf: Create configure from configure.ac \u0026amp; aclocal.m4. autoheader : Create config.h.in from configure.ac. automake --add-missing: Create Makefile.in s from Makefile.am s, configure.ac \u0026amp; aclocal.m4. --add-missing option will add required file(like config.guess, config.sub, missing, depcomp, install-sh, etc) to carry out build process. Note: Run libtoolize, If you use LT_INIT to create a shared library with libtool in configure.ac, otherwise you will get error as configure.ac:[LINE]: error: required file './ltmain.sh' not found.\nStep 2 : `./configure \u0026ndash;prefix=$(pwd) configure will create Makefiles from Makefile.ins Step 3: make \u0026amp; make install Finally make \u0026amp; make install - Do all things for you Generalise Idea Practically, You do not have to remember the interaction of all tools, just call autoreconf yourself and let it deal with all the lower-level tools. autoreconf is your friend. You only need a rough idea of the purpose of each tool to understand errors. GNU Autoconf autoconf Create configure from configure.ac. autoheader Create config.h.in from configure.ac. autoreconf Run all tools in the right order. autoscan Scan sources for common portability problems, and related macros missing from configure.ac. autoupdate Update obsolete macros in configure.ac. ifnames Gather identifiers from all #if/#ifdef/... directives. autom4te The heart of Autocon. It drives M4 and implements the features used by most of the above tools. Useful for creating more than just configure files. GNU Automake automake Create Makefile.in from Makefile.am and configure.ac. aclocal Scan configure.ac for uses of third-party macros, and gather definitions in aclocal.m4. GNU Libtool Libtool Helps manage the creation of static and dynamic libraries on various Unix-like operating systems Distributing Packege 1 2 3 4 5 $ make distcheck ================================================= packagename-1.0 archives ready for distribution: packagename-1.0.tar.gz ================================================= At the end of command execution you will find packagename-1.0.tar.gz in same folder. Generating Shared Library With Autotools configure.ac 1 2 3 4 5 6 7 8 9 AC_INIT([PackageName], [1.0], [bug-report@address]) AM_INIT_AUTOMAKE([foreign]) LT_INIT # Used to initialize libtool to create shared library AM_MY_MACRO=\u0026#34;-I ./\u0026#34; # Delacring Custome Macro AC_SUBST([AM_MY_MACRO]) # Passing Custome Macro to Makefile.am AC_PROG_CC AC_CONFIG_HEADERS([config.h]) AC_CONFIG_FILES([Makefile sum/Makefile src/Makefile]) AC_OUTPUT Makefile.am 1 SUBDIRS = sum src src/main.c 1 2 3 4 5 6 7 #include int main() { printf(\u0026#34;sum(0,1) = %d\\n\u0026#34;, sum(0,1)); return 0; } src/Makefile.am 1 2 3 4 bin_PROGRAMS = sum sum_SOURCES = main.c sum_LDADD = ../sum/libsum.la # add \u0026amp; link sum against libsum.so sum__LDFLAGS = $(AM_MY_MACRO) # Macro Passed By configure.ac sum/sum.c 1 2 3 4 5 6 #include\u0026lt;stdio.h\u0026gt; int sum(int a, int b) { return a + b; } sum/Makefile.am 1 2 lib_LTLIBRARIES = libsum.la libsum_la_SOURCES = sum.c Directory Structre 1 2 3 4 5 6 7 8 9 $ ls -R .: configure.ac Makefile.am src sum ./src: main.c Makefile.am ./sum: Makefile.am sum.c Build Package 1 2 3 4 5 6 7 8 9 10 11 $ autoreconf --install $ ./configure --prefix=$(pwd) $ make install $ ./bin/sum sum(0,1) = 1 $ $ ldd ./bin/sum linux-vdso.so.1 =\u0026gt; (0x00007fff606ac000) libsum.so.0 =\u0026gt; /home/vishal/asdf/lib/libsum.so.0 (0x00007fdcf43a6000) libc.so.6 =\u0026gt; /lib64/libc.so.6 (0x00007fdcf3fcd000) /lib64/ld-linux-x86-64.so.2 (0x00007fdcf45a9000) At the end of make install, there are two folders named lib \u0026amp; bin having a shared library in lib \u0026amp; executable in bin. What Next ? This is just short introduction of How Autotools help us ! There are lot to discover about its competitors like CMake, Scons, etc. Sources Autotools GNU Build System Automake ","permalink":"https://vishalchovatiya.github.io/posts/gnu-build-system-automake-autoconf-libtool/","summary":"Brief GNU Build System: Automake, Autoconf, Libtool are a suite of programming tools used to make source code packages portable to many Unix-like systems. Why We Need Autotools: Autoconf: automatically generates configure script by scans of existing tree to find its dependencies, that are supposed to work on all kinds of platforms. configure generates a config.h file (from a template) which programs can include to work around portability issues. For example, if HAVE_LIBPTHREAD is not defined, use forks instead.","title":"GNU Build System: Automake, Autoconf, Libtool"},{"content":"I know it’s long, but please bear with me \u0026amp; have patience.\nHow do we launch our programs? Do you know how programs get runs behind the screen when you double-click on it or you type ./a.out on shell As you know, the standard way to launch an application from a shell is to start terminal emulator application \u0026amp; just write the name of the program \u0026amp; pass or not arguments to our program, for example: 1 2 3 4 5 6 7 8 [vishal@machine Desktop]$ ls --version ls (GNU coreutils) 8.22 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later . This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Written by Richard M. Stallman and David MacKenzie. Get In To Bash : /dev/tty Sanity Checks So let\u0026rsquo;s start with the main function of bash shell. If you will look on the source code of the bash shell, you will find the main function in the shell.c source code file which makes many different things before the main thread loop of the bash started to work. For example this function: checks and tries to open /dev/tty check that shell running in debug mode parse command-line arguments reads shell environment loads .bashrc, .profile and other configuration files and many more. Creating Environment After all of these operations, you can see the call of the reader_loop function defined in the eval.c which reads the given program name \u0026amp; arguments, then it calls the execute_command function from the execute_cmd.c which in turn calls following function chain which makes different checks like do we need to start subshell, was it built-in bash function or not etc. 1 2 3 4 5 execute_command --\u0026gt; execute_command_internal ----\u0026gt; execute_simple_command ------\u0026gt; execute_disk_command --------\u0026gt; shell_execve In the end of this process, the shell_execve function calls the execve system call which has the following signature 1 int execve(const char *filename, char *const argv [], char *const envp[]); Executes a program by the given filename, with the given arguments and environment variables. So, a user application (bash in our case) calls the system call \u0026amp; as we already know the next step is the Linux kernel. Get Into Kernel: execve System Call execve System Call Implementation This system call defined in the fs/exec.c source code file \u0026amp; has following signature : 1 2 3 4 5 6 7 SYSCALL_DEFINE3(execve, const char __user *, filename, const char __user *const __user *, argv, const char __user *const __user *, envp) { return do_execve(getname(filename), argv, envp); } Implementation of the execve is pretty simple here, as we can see it just returns the result of the do_execve function which initialize two pointers on a userspace data with the given arguments and environment variables \u0026amp; return the result of the do_execveat_common. We can see its implementation:\n1 2 3 4 5 6 7 8 int do_execve(struct filename *filename, const char __user *const __user *__argv, const char __user *const __user *__envp) { struct user_arg_ptr argv = { .ptr.native = __argv }; struct user_arg_ptr envp = { .ptr.native = __envp }; return do_execveat_common(AT_FDCWD, filename, argv, envp, 0); } The do_execveat_common function takes a similar set of arguments, but having 2 extra arguments. Sanity Checks The first argument AT_FDCWD is the file descriptor of current directory \u0026amp; fifth argument is flags. which we will see later. do_execveat_common function checks the filename pointer \u0026amp; returns if it is NULL. After this it check flags of the current process that limit of running processes is not exceeded: 1 2 3 4 5 6 7 8 9 10 if (IS_ERR(filename)) return PTR_ERR(filename); if ((current-\u0026gt;flags \u0026amp; PF_NPROC_EXCEEDED) \u0026amp;\u0026amp; atomic_read(¤t_user()-\u0026gt;processes) \u0026gt; rlimit(RLIMIT_NPROC)) { retval = -EAGAIN; goto out_ret; } current-\u0026gt;flags \u0026amp;= ~PF_NPROC_EXCEEDED; If these two checks were successful we unset PF_NPROC_EXCEEDED flag in the flags of the current process to prevent failure of the execve. In the next step we call the unshare_files function that defined in the kernel/fork.c and unshares the files of the current task and check the result of this function: 1 2 3 retval = unshare_files(\u0026amp;displaced); if (retval) goto out_ret; We need to call this function to eliminate potential leak of the execve'd binary\u0026rsquo;s file descriptor. In the next step, we start preparation of the bprm that represented by the struct linux_binprm structure (defined in the include/linux/binfmts.h header file). Preparing Binary Parameter Struct struct linux_binprm The linux_binprm structure is used to hold the arguments that are used when loading binaries. For example it contains vm_area_struct which represents a single memory area over a contiguous interval in a given address space where our application will be loaded mm field which is memory descriptor of the binary, pointer to the top of memory and many other different fields. Allocating Memory 1 2 3 bprm = kzalloc(sizeof(*bprm), GFP_KERNEL); if (!bprm) goto out_files; Preparing Credentials 1 2 3 4 5 6 retval = prepare_bprm_creds(bprm); if (retval) goto out_free; check_unsafe_exec(bprm); current-\u0026gt;in_execve = 1; Initialization of the cred structure that stored inside of the linux_binprm structure contains the security context of a task, for example real uid of the task, real guid of the task, uid and guid for the virtual file system operations etc. In the next step, the call of the check_unsafe_exec function set the current process to the in_execve state. Set-up \u0026amp; Schedule Binary After all of these operations, we call the do_open_execat function which\n- Searches \u0026amp; opens executable file on disk \u0026amp; checks that,\n- load a binary file from noexec mount points bypassed flag 0 (we need to avoid execute a binary from filesystems that do not contain executable binaries like proc or sysfs),\n- initialize file structure \u0026amp; returns pointer on this structure. Next, we can see the call the sched_exec after this. The sched_exec function is used to determine the least loaded processor that can execute the new program \u0026amp; to migrate the current process to it. 1 2 3 4 5 6 file = do_open_execat(fd, filename, flags); retval = PTR_ERR(file); if (IS_ERR(file)) goto out_unmark; sched_exec(); After this, we need to check file descriptor of the give executable binary. We try to check does the name of the our binary file starts from the / symbol or does the path of the given executable binary is interpreted relative to the current working directory of the calling process or in other words file descriptor is AT_FDCWD. If one of these checks is successful we set the binary parameter filename: 1 2 3 4 5 bprm-\u0026gt;file = file; if (fd == AT_FDCWD || filename-\u0026gt;name[0] == \u0026#39;/\u0026#39;) { bprm-\u0026gt;filename = filename-\u0026gt;name; } Otherwise, if the filename is empty we set the binary parameter filename to the /dev/fd/%d or /dev/fd/%d/%s depends on the filename of the given executable binary which means that we will execute the file to which the file descriptor refers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 } else { if (filename-\u0026gt;name[0] == \u0026#39;\\0\u0026#39;) pathbuf = kasprintf(GFP_TEMPORARY, \u0026#34;/dev/fd/%d\u0026#34;, fd); else pathbuf = kasprintf(GFP_TEMPORARY, \u0026#34;/dev/fd/%d/%s\u0026#34;,\tfd, filename-\u0026gt;name); if (!pathbuf) { retval = -ENOMEM; goto out_unmark; } bprm-\u0026gt;filename = pathbuf; } bprm-\u0026gt;interp = bprm-\u0026gt;filename; Note that we set not only the bprm-\u0026gt;filename but also bprm-\u0026gt;interp that will contain the name of the program interpreter. For now we just write the same name there, but later it will be updated with the real name of the program interpreter depends on the binary format of a program. Preparing Memory Related Info 1 2 3 retval = bprm_mm_init(bprm); if (retval) goto out_unmark; The bprm_mm_init defined in the same source code file initializes mm_struct structure \u0026amp; populate it with a temporary stack vm_area_struct which is defined in the include/linux/mm_types.h header file \u0026amp; represents address space of a process. Counting Command Line Args \u0026amp; Environment Variables 1 2 3 4 5 6 7 bprm-\u0026gt;argc = count(argv, MAX_ARG_STRINGS); if ((retval = bprm-\u0026gt;argc) \u0026lt; 0) goto out; bprm-\u0026gt;envc = count(envp, MAX_ARG_STRINGS); if ((retval = bprm-\u0026gt;envc) \u0026lt; 0) goto out; As you can see, MAX_ARG_STRINGS is the upper limit macro defined in the header file represents maximum number of strings that were passed to the execve system call. The value of the MAX_ARG_STRINGS: 1 #define MAX_ARG_STRINGS 0x7FFFFFFF Reading Binary(ELF) File Now, the call of prepare_binprm function fills the linux_binprm structure with the uid from inode and read 128 bytes from the binary executable file. We read only first 128 from the executable file because we need to check a type of our executable. We will read the rest of the executable file in the later step. 1 2 3 retval = prepare_binprm(bprm); if (retval \u0026lt; 0) goto out; After the preparation of the linux_bprm structure we copy the filename of the executable binary file, command-line arguments and environment variables to the linux_bprm from the kernel with the call of the copy_strings_kernel function: 1 2 3 4 5 6 7 8 9 10 11 retval = copy_strings_kernel(1, \u0026amp;bprm-\u0026gt;filename, bprm); if (retval \u0026lt; 0) goto out; retval = copy_strings(bprm-\u0026gt;envc, envp, bprm); if (retval \u0026lt; 0) goto out; retval = copy_strings(bprm-\u0026gt;argc, argv, bprm); if (retval \u0026lt; 0) goto out; And set the pointer to the top of the new program\u0026rsquo;s stack that we set in the bprm_mm_init function bprm-\u0026gt;exec = bprm-\u0026gt;p; The top of the stack will contain the program filename and we store this filename to the exec field of the linux_bprm structure. Processing Binary Parameter Struct Call to exec_binprm function stores the pid from the namespace of the current task before it changes 1 2 3 retval = exec_binprm(bprm); if (retval \u0026lt; 0) goto out; and call the: search_binary_handler(bprm);\nWhich goes through the list of handlers that contains different binary formats. Currently the Linux kernel supports following binary formats:\nbinfmt_script support for interpreted scripts that start from the #! line;\nbinfmt_misc - support different binary formats, according to runtime configuration of the Linux kernel;\nbinfmt_elf - support elf format;\nbinfmt_aout - support a.out format;\nbinfmt_flat - support for flat format;\nbinfmt_elf_fdpic - Support for elf FDPIC binaries;\nbinfmt_em86 - support for Intel elf binaries running on Alpha machines.\nSo, the search_binary_handler tries to call the load_binary function and pass linux_binprm to it. If the binary handler supports the given executable file format, it starts to prepare the executable binary for execution:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int search_binary_handler(struct linux_binprm *bprm) { ... ... ... list_for_each_entry(fmt, \u0026amp;formats, lh) { retval = fmt-\u0026gt;load_binary(bprm); if (retval \u0026lt; 0 \u0026amp;\u0026amp; !bprm-\u0026gt;mm) { force_sigsegv(SIGSEGV, current); return retval; } } return retval; Where the load_binary for example checks the magic number (each elf binary file contains magic number in the header) in the linux_bprm buffer (remember that we read first 128 bytes from the executable binary file) \u0026amp; exit if it is not elf binary: Executing Binary Sanity Checks If the given executable file is in elf format, the load_elf_binary continues \u0026amp; checks the architecture and type of the executable file and exit if there is wrong architecture and executable file non-executable non shared: 1 2 3 4 if (loc-\u0026gt;elf_ex.e_type != ET_EXEC \u0026amp;\u0026amp; loc-\u0026gt;elf_ex.e_type != ET_DYN) goto out; if (!elf_check_arch(\u0026amp;loc-\u0026gt;elf_ex)) goto out; Setup Process Address Space \u0026amp; Dependencies Tries to load the program header table that describes segments. Read the program interpreter and libraries that linked with the our executable binary file from disk and load it to memory. 1 2 3 elf_phdata = load_elf_phdrs(\u0026amp;loc-\u0026gt;elf_ex, bprm-\u0026gt;file); if (!elf_phdata) goto out; The program interpreter specified in the .interp section of the executable file (in most cases, linker is - /lib64/ld-linux-x86-64.so.2 for the x86_64). It setups the stack and map elf binary into the correct location in memory. It maps the bss and the brk sections and does many other different things to prepare executable file to execute. In the end of the execution of the load_elf_binary we call the start_thread function and pass three arguments to it: 1 2 3 4 5 6 start_thread(regs, elf_entry, bprm-\u0026gt;p); retval = 0; out: kfree(loc); out_ret: return retval; These Arguments are: Set of registers for the new task Address of the entry point of the new task Address of the top of the stack for the new task As we can understand from the function\u0026rsquo;s name, it starts a new thread, but it is not so. The start_thread function just prepares new task\u0026rsquo;s registers to be ready to run. Let\u0026rsquo;s look at the implementation of this function: 1 2 3 4 5 6 void start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp) { start_thread_common(regs, new_ip, new_sp, __USER_CS, __USER_DS, 0); } As we can see the start_thread function just makes a call of the start_thread_common function that will do all for us. Put The Process On-Core 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static void start_thread_common(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp, unsigned int _cs, unsigned int _ss, unsigned int _ds) { loadsegment(fs, 0); loadsegment(es, _ds); loadsegment(ds, _ds); load_gs_index(0); regs-\u0026gt;ip = new_ip; regs-\u0026gt;sp = new_sp; regs-\u0026gt;cs = _cs; regs-\u0026gt;ss = _ss; regs-\u0026gt;flags = X86_EFLAGS_IF; force_iret(); } The start_thread_common function fills fs segment register with zero and es \u0026amp; ds with the value of the data segment register. After this we set new values to the instruction pointer, cs segments etc. At the end of the start_thread_common function we can see the force_iret macro that force a system call return via iret instruction. Ok, we prepared new thread to run in userspace and now we can return from the exec_binprm and now we are in the do_execveat_common again. After the exec_binprm will finish its execution we release memory for structures that were allocated before and return. After we returned from the execve system call handler, execution of our program will be started. We can do it, because all context-related information already configured for this purpose. As we saw the execve system call does not return control to a process, but code, data and other segments of the caller process are just overwritten of the program segments. The exit from our application will be implemented through the exit system call. And we are done with execution\n","permalink":"https://vishalchovatiya.github.io/posts/program-gets-run-linux/","summary":"I know it’s long, but please bear with me \u0026amp; have patience.\nHow do we launch our programs? Do you know how programs get runs behind the screen when you double-click on it or you type ./a.out on shell As you know, the standard way to launch an application from a shell is to start terminal emulator application \u0026amp; just write the name of the program \u0026amp; pass or not arguments to our program, for example: 1 2 3 4 5 6 7 8 [vishal@machine Desktop]$ ls --version ls (GNU coreutils) 8.","title":"How Program Gets Run: Linux"},{"content":"While I was working as a core C library developer with my previous employer. I came across this RTLD_NEXT flag in dynamic linking which has the amazing capability and can be easily exploited or used for unethical purpose(Here I intend to educate the developer to don\u0026rsquo;t be victims). In this article, I will show you a simple way to hack C/C++ application using RTLD_NEXT with an easy example.\nBrief Let say you have a C/C++ application/tool which is highly proprietary and driving most of the business to your company. You have done some licensing or encryption which prevents a hacker(or maybe rivals) from cracking your binary or to use it without your license keys or something. This binary can easily be cracked by the use of RTLD_NEXT flag if you have not taken enough precautions which we will discuss later in this article. Library linking \u0026amp; symbol resolution Library linking \u0026amp; symbol resolution i.e. extracting address(precisely offset here in dynamic linking case) of function is specified at compile time. For example, there are four shared libraries linked \u0026amp; loaded dynamically in order as A.so, B.so, C.so \u0026amp; D.so with the main application. And funcXYZ()is called from the main application which is defined in both the library C.so \u0026amp; D.so with the same prototype. Then funcXYZ()from C.so will be called first as it\u0026rsquo;s ahead of D.so in linking order. Intro to RTLD_NEXT But what if you want to call funcXYZ() from D.so? You can achieve this byRTLD_NEXTflag defined in\u0026lt;dlfcn.h\u0026gt;. What you have to do is define your funcXYZ()as below in C.so`:\n1 2 3 4 5 6 7 8 9 10 11 12 void funcXYZ() { void (*fptr)(void) = NULL; if ((fptr = (void (*)(void))dlsym(RTLD_NEXT, \u0026#34;funcXYZ\u0026#34;)) == NULL) { (void)printf(\u0026#34;dlsym: %s\\n\u0026#34;, dlerror()); exit(1); } return ((*fptr)()); } Now, whenever funcXYZ()called from main application it will come to C.so which simply search for the same symbol from next loaded libraries i.e. D.so . dlsym() search for symbol provided in argument from the memory and a returns function pointer to the same. Let\u0026rsquo;s hack C/C++ application using RTLD_NEXT malloc.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; void *malloc(size_t size) { static void *(*fptr)(size_t) = NULL; /* look up of malloc, only the first time we are here */ if (fptr == NULL) { fptr = (void *(*)(size_t))dlsym(RTLD_NEXT, \u0026#34;malloc\u0026#34;); if (fptr == NULL) { printf(\u0026#34;dlsym: %s\\n\u0026#34;, dlerror()); return NULL; } } printf(\u0026#34;Our Malloc\\n\u0026#34;); return (*fptr)(size); // Calling original malloc } main.c 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { malloc(1); return 0; } Creating a shared library 1 $ gcc -o malloc.so -shared -fPIC malloc.c -D_GNU_SOURCE Linking \u0026amp; executing the main application 1 2 3 $ gcc -o main main.c ./malloc.so -ldl $ ./main Our Malloc Note: You can also use LD_PRELOAD as below, which loads the specified library first. No need to mention ./malloc.so explicitly in the compilation.\n1 $ LD_PRELOAD=`pwd`/malloc.so ./main How it works When you compile main.c with gcc -o main main.c ./malloc.so -ldl, you specify malloc.so explicitly on first order. We can verify this by ldd command 1 2 3 4 5 6 $ ldd main linux-vdso.so.1 =\u0026gt; (0x00007fff37bf4000) malloc.so (0x00007fc5df598000) libdl.so.2 =\u0026gt; /lib64/libdl.so.2 (0x00007fc5df37d000) libc.so.6 =\u0026gt; /lib64/libc.so.6 (0x00007fc5defbb000) /lib64/ld-linux-x86-64.so.2 (0x00007fc5df79b000) So when you call malloc it will refer the first occurrence of the symbol from the loaded library sequence which is in our malloc.so library. We now extract original malloc from next loaded shared library which is /lib64/libc.so.6. What RTLD_NEXT used for? An obvious question would be \u0026ldquo;Why the hell library designer/developer keep this kind of vulnerability?\u0026rdquo;\nRTLD_NEXT allows one to provide a wrapper around a function defined in another shared library. At least that is what man page of dlsym describes. I am still confused! Is this feature or vulnerability?\nVulnerability If you not experienced enough then perhaps your question would be \u0026ldquo;What\u0026rsquo;s vulnerability in this ?\u0026quot;?‍♀️ then let me tell you, my friend, you might have stored license string, encryption key or any other proprietary data to validate against user access which usually programmer stores using struct or array kind of data structures. Now, we generally use memcmp() or strcmp()library functions to compare user access or validate key/data. You can easily generate wrapper around these functions using RTLD_NEXT` and manipulate it. Some companies use real-time authentication by an HTTP request which can also be cracked as there might be a particular function returning true or false as access check. You can simply create a wrapper of that function to manipulate it. This may take more time to find out function by hit \u0026amp; trial method. But it\u0026rsquo;s not impossible. To figure out function name you can use nm or readelf like utilities which list out symbol names \u0026amp; it\u0026rsquo;s corresponding addresses/offset as follows 1 2 3 4 5 6 7 $ nm main .... 0000000000600e00 d _DYNAMIC 00000000004005b7 T main U malloc 0000000000400540 t register_tm_clones .... If you want to learn more about binary file format ELF, then I have written a separate article for it here. Precautions you should consider Use stripped binaries for release Compiled binary usually contain symbol information as we show using nm utility above. But when you strip binary it just strip symbol table from it which is not necessary for execution as it is only being used in debugging \u0026amp; link resolution at compile time. Stripped binary can produced with the help of the compiler itself, e.g. GNU GCC compilers\u0026rsquo; -s flag, or with a dedicated tool like strip on Unix.\n1 2 3 4 $ strip --strip-all main $ nm main nm: main: no symbols $ Static linking Rather than releasing a dynamic linking binary, compile static version \u0026amp; strip it. Although it has some cons which are out of topic for this article.\nDo not use library functions for handling proprietary data While processing proprietary data in your application do not rely on library functions rather design your own with weird names. If you are storing read-only proprietary data in ASCII format within binary then encrypt it or simply add a particular number in every char so that memory dump won\u0026rsquo;t show any human-readable sentences or words.\n","permalink":"https://vishalchovatiya.github.io/posts/hack-c-cpp-application-using-rtld-next-with-an-easy-example/","summary":"While I was working as a core C library developer with my previous employer. I came across this RTLD_NEXT flag in dynamic linking which has the amazing capability and can be easily exploited or used for unethical purpose(Here I intend to educate the developer to don\u0026rsquo;t be victims). In this article, I will show you a simple way to hack C/C++ application using RTLD_NEXT with an easy example.\nBrief Let say you have a C/C++ application/tool which is highly proprietary and driving most of the business to your company.","title":"How to hack C/C++ application using RTLD_NEXT with an easy example"},{"content":"Points to Catch mmap()is system call used to maps files or devices into memory Linux provides the `mremap( ) system call for expanding or shrinking the size of a given mapping. POSIX defines the `mprotect( ) interface to allow programs to change the permissions of existing regions of memory. Synchronizing a File with a Mapping: A system call msync( ) flushes back to disk any changes made to a file mapped via mmap( ), synchronizing the mapped file with the mapping *Advantage of mmap() over open(), read()\u0026amp; write()` mmap is great if you have multiple processes accessing data in a read-only fashion from the same file which saves many system calls or context switching overheads Useful for inter-process communication. You can mmap a file as read/write in the processes that need to communicate and then use sychronization primitives in the mmapped region (this is what the MAP_HASSEMAPHORE flag is for). *Limitation of mmap() Not best fit for mapping large file as mmap has to find a contiguous block of addresses in your process\u0026rsquo;s address space that is large enough to fit the entire range of the file being mapped. In this case, you may have to map the file in smaller chunks than you would like to make it fit. Awkwardness with mmap as a replacement for read/write is that you have to start your mapping on offsets of the page size Example Following sample, program is passed a filename as an argument. It opens the file, get the file status parameters, maps it, closes it, prints the file byte-by-byte to standard out, and then unmaps the file from memory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; int main (int argc, char *argv[]) { if (argc \u0026lt; 2) return 1; int fd = open ( argv[1], O_RDONLY); struct stat sb; fstat (fd, \u0026amp;sb); // Fill File Status Structure //void * mmap (void *addr /* Address suggestion to the kernel of where best to map the file*/, // size_t len /* Length of Mapping */, // int prot /* Memory Protection Flags */, // int flags /* Type of Mapping like shared, private, etc*/, // int fd /* File descriptor */, // off_t offset /* Offset to start mapping from in file, must be multiple of page size*/); void *p = mmap (0, sb.st_size, PROT_READ, MAP_SHARED, fd, 0); // Map File in Memory close (fd); int len; for (len = 0; len \u0026lt; sb.st_size; len++) putchar ( * ((char*) p + len )); munmap (p, sb.st_size); // Un-Map Mapped File from memory return 0; } ","permalink":"https://vishalchovatiya.github.io/posts/mmap/","summary":"Points to Catch mmap()is system call used to maps files or devices into memory Linux provides the `mremap( ) system call for expanding or shrinking the size of a given mapping. POSIX defines the `mprotect( ) interface to allow programs to change the permissions of existing regions of memory. Synchronizing a File with a Mapping: A system call msync( ) flushes back to disk any changes made to a file mapped via mmap( ), synchronizing the mapped file with the mapping *Advantage of mmap() over open(), read()\u0026amp; write()` mmap is great if you have multiple processes accessing data in a read-only fashion from the same file which saves many system calls or context switching overheads Useful for inter-process communication.","title":"A Bit About mmap"},{"content":"What is vfork ? It\u0026rsquo;s a special case of a clone. It is used to create new processes without copying the page tables of the parent process. calling thread is suspended until the child call execve or _exit. Points To Remember vfork()is an obsolete optimization. Before good memory management, fork()made a full copy of the parent\u0026rsquo;s memory, so it was pretty expensive. since in many cases a fork()was followed by `exec(), which discards the current memory map and creates a new one, it was a needless expense. Nowadays, fork() doesn\u0026rsquo;t copy the memory; it\u0026rsquo;s simply set as \u0026ldquo;copy on write\u0026rdquo;, so fork()+exec()is just as efficient as vfork()+exec() Some OSs, vfork shares same address space as of parents vfork \u0026amp; fork internally calls clone Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define SIZE 5 int nums[SIZE] = {0, 1, 2, 3, 4}; int main() { int i; pid_t pid; pid = vfork(); if(pid == 0){ /* Child process */ for(i = 0; i \u0026lt; SIZE; i++){ nums[i] *= -i; printf(\u0026#34;CHILD: %d \\n\u0026#34;, nums[i]); } _exit(0); } else if (pid \u0026gt; 0){ /* Parent process */ wait(NULL); for(i = 0; i \u0026lt; SIZE; i++) printf(\u0026#34;PARENT: %d \\n\u0026#34;, nums[i]); } return 0; } Sample Output 1 2 3 4 5 6 7 8 9 10 CHILD: 0 CHILD: -1 CHILD: -4 CHILD: -9 CHILD: -16 PARENT: 0 PARENT: -1 PARENT: -4 PARENT: -9 PARENT: -16 ","permalink":"https://vishalchovatiya.github.io/posts/vfork/","summary":"What is vfork ? It\u0026rsquo;s a special case of a clone. It is used to create new processes without copying the page tables of the parent process. calling thread is suspended until the child call execve or _exit. Points To Remember vfork()is an obsolete optimization. Before good memory management, fork()made a full copy of the parent\u0026rsquo;s memory, so it was pretty expensive. since in many cases a fork()was followed by `exec(), which discards the current memory map and creates a new one, it was a needless expense.","title":"A Bit About vfork"},{"content":" Hey there\u0026hellip;! I am Vishal.\nI live in Bangalore, India.\nI write articles here about the things I\u0026rsquo;m interested in.\nI watch a lot of sci-fi movies \u0026amp; never miss the iron-man/transformer like series.\nI write code \u0026amp; preserve it if it is helpful to others \u0026amp; me in the future.\nSome of the words that describe me the best: Software Developer⌨, Tech-Lead👨‍✈️, Product Owner🥼, Fitness Freak🏋, Geek🤓, Hipster🕴, Blogger👨‍💻, Productivity Hacker⌚, Technical Writer✍️, Tech talker👨‍🎤, Leader👨‍🔬, Mentor👨🏻‍🔧, Perpetual Student👨‍🎓, Incomplete🔍 \u0026amp; Learning Fiend📚.\nThis site is host to a variety of things professional and personal; you can learn more about who I am, take a look at my professional journey, or read my articles and if you have any questions, you can contact me.\nHave a blessed day! 🙏\n","permalink":"https://vishalchovatiya.github.io/pages/vishal-chovatiya/","summary":"Hey there\u0026hellip;! I am Vishal.\nI live in Bangalore, India.\nI write articles here about the things I\u0026rsquo;m interested in.\nI watch a lot of sci-fi movies \u0026amp; never miss the iron-man/transformer like series.\nI write code \u0026amp; preserve it if it is helpful to others \u0026amp; me in the future.\nSome of the words that describe me the best: Software Developer⌨, Tech-Lead👨‍✈️, Product Owner🥼, Fitness Freak🏋, Geek🤓, Hipster🕴, Blogger👨‍💻, Productivity Hacker⌚, Technical Writer✍️, Tech talker👨‍🎤, Leader👨‍🔬, Mentor👨🏻‍🔧, Perpetual Student👨‍🎓, Incomplete🔍 \u0026amp; Learning Fiend📚.","title":"About Me"},{"content":"Semaphore is a synchronization mechanism. In more words, semaphores are a technique for coordinating or synchronizing activities in which multiple processes compete for the same resources. There are 2 types of semaphores: Binary semaphores \u0026amp; Counting semaphores. But our focus would be on binary semaphore only. That too binary semaphore example between threads in C language specifically. If you are in search of semaphore between processes then see this.\nAs its name suggest binary semaphore can have a value either 0 or 1. It means binary semaphore protect access to a SINGLE shared resource. So the internal counter of the semaphore can only take the values 1 or 0. When a resource is available, the process in charge set the semaphore to 1 else 0. Example of Binary semaphore example between threads in C using POSIX-semaphore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;semaphore.h\u0026gt; int a, b; sem_t sem; void ScanNumbers(void *ptr){ for (;;){ printf(\u0026#34;%s\u0026#34;, (char *)ptr); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); sem_post(\u0026amp;sem); usleep(100 * 1000); } } void SumAndPrint(void *ptr){ for (;;){ sem_wait(\u0026amp;sem); printf(\u0026#34;%s %d\\n\u0026#34;, (char *)ptr, a + b); } } int main() { pthread_t thread1; pthread_t thread2; char *Msg1 = \u0026#34;Enter Number Two No\\n\u0026#34;; char *Msg2 = \u0026#34;sum = \u0026#34;; /* int sem_init( sem_t *sem // pointer to semaphore variable , int pshared // If = 0: can be used in threads only, else in process, unsigned int value // initial value of the semaphore counter ); return value 0 on successful \u0026amp; -1 on failure */ sem_init(\u0026amp;sem, 0, 0); // Can also use `sem = sem_open( \u0026#34;SemaphoreName\u0026#34;, O_CREAT, 0777, 0);` pthread_create(\u0026amp;thread1, NULL, (void *)ScanNumbers, (void *)Msg1); pthread_create(\u0026amp;thread2, NULL, (void *)SumAndPrint, (void *)Msg2); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(\u0026#34;Wait For Both Thread Finished\\n\u0026#34;); sem_destroy(\u0026amp;sem); // Can also use `sem_unlink( \u0026#34;SemaphoreName\u0026#34;);` return 0; } sem_init() : Initialize semaphore sem_destroy() : releases all resources sem_wait() : Wait for the semaphore to acquire sem_post() : Release semaphore sem_trywait() : Only works when the caller does not have to wait sem_getvalue() : Reads the counter value of the semaphore sem_open() : Connects to, \u0026amp; optionally creates, a named semaphore( like sem_init() ) sem_unlink() : Ends connection to an open semaphore \u0026amp; causes the semaphore to be removed when the last process closes it( like sem_destroy()) General pointers Semaphore\u0026rsquo;s internal implementation is like memory-mapped file(mmap) Two standards of semaphore mechanism POSIX-semaphore: sem_init(), sem_destroy(), sem_wait(), sem_post(), sem_trywait(), sem_getvalue(), sem_open(),sem_unlink() System-V-semaphore: semget(), semop(), `semctl()` ","permalink":"https://vishalchovatiya.github.io/posts/binary-semaphore-example-between-threads-in-c/","summary":"Semaphore is a synchronization mechanism. In more words, semaphores are a technique for coordinating or synchronizing activities in which multiple processes compete for the same resources. There are 2 types of semaphores: Binary semaphores \u0026amp; Counting semaphores. But our focus would be on binary semaphore only. That too binary semaphore example between threads in C language specifically. If you are in search of semaphore between processes then see this.\nAs its name suggest binary semaphore can have a value either 0 or 1.","title":"Binary semaphore example between threads in C"},{"content":"This is a quick article on Clone system call example without talking shit. So let\u0026rsquo;s see some pointers for the same :\nclone() creates a new process, in a manner similar to fork. It is actually a library function layered on top of the underlying clone()system call. Unlike fork , these calls allow the child process to share parts of its execution context with the calling process, such as the memory space, the table of file descriptors, and the table of signal handlers. The main use of clone()is to implement threads: multiple threads of control in a program that run concurrently in shared memory space. When the child process is created with clone() it executes the function application fn(arg). The fn argument is a pointer to a function that is called by the child process at the beginning of its execution. The arg argument is passed to the fn function. When the fn(arg) function application returns, the child process terminates. The integer returned by fn is the exit code for the child process. The child process may also terminate explicitly by calling exit or after receiving a fatal signal. The child_stack argument specifies the location of the stack used by the child process. Since the child and calling process may share a memory. It is not possible for the child process to execute in the same stack as the calling process. The calling process must, therefore, set up memory space for the child stack and pass a pointer to this space to clone() Stacks grow downwards on all processors that run Linux (except the HP PA processors). So child_stack usually points to the topmost address of the memory space set up for the child stack. There are some flags related to child/parent control, memory, tracing signals, etc which you can find on man page. Clone system call example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sched.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #define STACK 8192 int do_something(){ printf(\u0026#34;Child pid : %d\\n\u0026#34;, getpid()); return 0; } int main() { void *stack = malloc(STACK); // Stack for new process if(!stack) { perror(\u0026#34;Malloc Failed\u0026#34;); exit(0); } if( clone( \u0026amp;do_something, (char *)stack + STACK, CLONE_VM, 0) \u0026lt; 0 ){ perror(\u0026#34;Clone Failed\u0026#34;); exit(0); } printf(\u0026#34;Parent pid : %d\\n\u0026#34;, getpid()); sleep(1); // Add sleep so we can she both processes output free(stack); return 0; } ","permalink":"https://vishalchovatiya.github.io/posts/clone-system-call-example/","summary":"This is a quick article on Clone system call example without talking shit. So let\u0026rsquo;s see some pointers for the same :\nclone() creates a new process, in a manner similar to fork. It is actually a library function layered on top of the underlying clone()system call. Unlike fork , these calls allow the child process to share parts of its execution context with the calling process, such as the memory space, the table of file descriptors, and the table of signal handlers.","title":"Clone system call example"},{"content":"Points To Catch When we fork in any process it simply creates a copy of the same process which we call child process 1 2 Parent Child return PID 0 Fork returns 0 in the child process \u0026amp; PID of the child process in the parent process, which you can see in above example. returns -1 on failer.\nCreate copy of process including memory variables \u0026amp; stored value in it with its own address space Example 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(void) { pid_t pid = fork(); if( pid \u0026gt; 0 ) printf(\u0026#34;Parent Process: ParentPID = %d, ChildPID = %d\\n\u0026#34;, getpid(), pid); else printf(\u0026#34;Child Process: ChildPID = %d, ParentPID = %d\\n\u0026#34;, getpid(), pid); sleep(2); return 0; } Output 1 2 Parent Process: ParentPID = 2640, ChildPID = 2641 Child Process: ChildPID = 2641, ParentPID = 0 Example 2 How many process this program create? 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;unistd.h\u0026gt; int main(void) { int i; for (i = 0; i \u0026lt; 3; i++) { if (fork() \u0026amp;\u0026amp; (i == 1)) { break; } } } Answer = 6\nExplanation : In Parent process(P), i = 0. we create 1 child process(C1), both entering the loop at i = 1. Total = 2 processes. In Parent(P) \u0026amp; Child(C1) process, i = 1. Both of those processes fork \u0026amp; let say create C2 \u0026amp; C3, but none of them continue to iterate because of the if (fork() \u0026amp;\u0026amp; (i == 1)) break; line. Total = 4 processes, but only two of those are continuing to loop. In Child(C2) \u0026amp; Child(C3) process, i = 2. Both fork \u0026amp; let say create C4 \u0026amp; C5, resulting in 6 processes. In Child(C4) \u0026amp; Child(C5) process, i = 3. Exit the loop (since i \u0026lt; 3 == false , there is no more looping) ","permalink":"https://vishalchovatiya.github.io/posts/create-process-using-fork/","summary":"Points To Catch When we fork in any process it simply creates a copy of the same process which we call child process 1 2 Parent Child return PID 0 Fork returns 0 in the child process \u0026amp; PID of the child process in the parent process, which you can see in above example. returns -1 on failer.\nCreate copy of process including memory variables \u0026amp; stored value in it with its own address space Example 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.","title":"Create Process Using fork()"},{"content":"There are a lot of functions called before \u0026amp; after the main execution. As an application developer you need not worry about this stuff, but yes! if you are a core developer who works in Linux kernel, Binutils, compiler or embedded system-related development, then you must know these things. Here in \u0026ldquo;CRT: C run time before starting main\u0026rdquo;, we will see some pointers related to it.\nWhat Is crt? crt stands for C runtime. crt is a set of execution startup routines compiled into a program which performs any initialization work required before calling the program\u0026rsquo;s main function. It is a basic runtime library/system. The work performed by crt depends on the ABI, machine, compiler, operating system and C standard library implementation. CRT: C Run Time Before Starting main() When an executable is loaded in the memory, the control does not immediately jump into main()here is what happen). Before going to main it goes to an intermediate start-up-routine/symbol(first symbol) called _start which does some setup/initialization work like:\nInitialize the stacks. Preparing the stdin / stdout / stderr streams; Pushing argc and argv (or whatever arguments are provided by the shell) onto the stack so that main()can find them. If required, copy the contents of the .data (initialized data) section from non-volatile memory. If required, copy the contents of the .fast section from non-volatile memory to SRAM. Initialize the .bss section to zero. Initialize the heap. Any other kind of preparation the OS or hardware might require. Call the main entry point. The shutdown/cleanup code (that makes sure that exit() is called when main()returns) is defined in a specific object file commonly called crt0.o . Other possible names are crt1.o(/usr/lib/crt1.o – used if ctors/dtors are there) or similar.\nTypical Runtime files File Detail crt0.o Will contain the _start function that initializes the process crtbegin.o GCC uses this to find the start of the constructors(init). crtend.o GCC uses this to find the start of the destructors(fini). crti.o Header of init \u0026amp; fini (for push in stack) crtn.o Footer of init \u0026amp; fini (for pop in the stack) Scrt1.o Used in place of crt1.o when generating PIE( position independent executable). There could be crt1.o, crt2.o \u0026amp; so on, depending upon implementation, crt0.c is runtime 0 \u0026amp; runs first. glibc calls this file start.S while uClibc calls this crt0.S or crt1.S General linking order is crt1.o crti.o crtbegin.o [-L paths] [user objects] [gcc libs] [C libs] [gcc libs] crtend.o crtn.o. What Is the Need for C Startup Routine? Calling main() is a C thing while calling _start()is a kernel thing, indicated by the entry point in the binary format header. (for clarity: the kernel doesn\u0026rsquo;t want or need to know that we call it _start).\nWhy Doesn’t a Compiler Give the Address of Main() as a Starting Point? That’s because typical libc implementations want to do some initializations before really starting the program.\nChanging Entry Point 1 2 3 4 5 6 $ cat centrypoint.c int disp() { printf(\u0026#34;Display !\\n\u0026#34;); exit(0); } int main() { printf(\u0026#34;not called\\n\u0026#34;); } $ gcc centrypoint.c -e disp $ ./a.out Display ! Some compiler uses --entry or -Wl,-edisp. The -Wl,... thing passes arguments to the linker, and the linker takes a -e argument to set the entry function\nFlow of x86 C Program With Runtime Routine File _init \u0026amp; _fini(push) ./crt/x86_64/crti.s _start ./arch/x86_64/crt_arch.h _start_c ./crt/crt1.c __libc_start_main ./src/env/__libc_start_main.c main Our Program exit Close process _init \u0026amp; _fini(pop) ./crt/x86_64/crtn.s ","permalink":"https://vishalchovatiya.github.io/posts/crt-run-time-before-starting-main/","summary":"There are a lot of functions called before \u0026amp; after the main execution. As an application developer you need not worry about this stuff, but yes! if you are a core developer who works in Linux kernel, Binutils, compiler or embedded system-related development, then you must know these things. Here in \u0026ldquo;CRT: C run time before starting main\u0026rdquo;, we will see some pointers related to it.\nWhat Is crt? crt stands for C runtime.","title":"CRT: C Run Time Before Starting main()"},{"content":"Why use poll()? Suppose you have to deal with multiple clients connected at the same time. A natural question, then, is: how can you read from multiple file descriptors (sockets) at once? Do you need to make some really annoyingly multi-threaded code to handle each client that\u0026rsquo;s connected? Do you have to go into some stupid loop constantly checking each socket to see if data\u0026rsquo;s available? You can resolve this issue efficiently by polling file descriptor(Sockets here). poll()system call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/poll.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main( int argc, char *argv[]) { char buf[1024]; struct pollfd pfds[1] = { STDIN, POLLIN}; // No of files discriptors to poll for int timeout = 5000; // Time Out int ret = poll(pfds, 1, timeout); // Polling for file discriptors provided with timeout if ( ret \u0026amp;\u0026amp; pfds[0].revents \u0026amp; POLLIN) { int i = read(0, buf, 1024); buf[i] = 0; printf(\u0026#34;You Typed : %s\\n\u0026#34;, buf); } else if( ret == 0 ){ printf(\u0026#34;Time Out!\\n\u0026#34;); } return 0; } Points to catch The idea behind multiplexing is that the operating system (kernel) knows when data is ready on a socket. You hand the operating system an array of file descriptors and say \u0026ldquo;tell me when something happens on one of these\u0026rdquo;. Your code blocks (stops executing) until there is data ready for you. At that point, you iterate through your array of file descriptors to determine which one has data ready. ","permalink":"https://vishalchovatiya.github.io/posts/dealing-with-multiple-file-descriptor-poll-system-call/","summary":"Why use poll()? Suppose you have to deal with multiple clients connected at the same time. A natural question, then, is: how can you read from multiple file descriptors (sockets) at once? Do you need to make some really annoyingly multi-threaded code to handle each client that\u0026rsquo;s connected? Do you have to go into some stupid loop constantly checking each socket to see if data\u0026rsquo;s available? You can resolve this issue efficiently by polling file descriptor(Sockets here).","title":"Dealing with Multiple file descriptor : poll() system call"},{"content":"Points To Catch As for the control flow: setjmp returns twice, and longjmp never returns. When you call setjmp for the first time, to store the environment, it returns zero, And then when you call longjmp, the control flow passes to return from setjmp with the value provided in the argument. Use cases are generally cited as \u0026ldquo;error handling\u0026rdquo;, and \u0026ldquo;don\u0026rsquo;t use these functions\u0026rdquo;. Note: setjmp needn\u0026rsquo;t actually be functions; it may well be a macro. longjmp is a function, though.\nHere\u0026rsquo;s a little control flow example:\nExample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; jmp_buf env; void foo() { longjmp(\u0026amp;env, 10); +----\u0026gt;----+ } | | | | int main() (entry)---+ ^ V { | | | if(setjmp(\u0026amp;env) == 0) | (= 0) | | (= 10) { | ^ | foo(); +----\u0026gt;----+ | } +----\u0026gt;----+ else | { | return 0; +--- (end) } } Important Notes: You cannot pass 0 to longjmp. If you do, 1 is returned by setjmp. You must not return from the function that called setjmp before the corresponding longjmp. In other words, longjmp must only be called above setjmp in the call stack. You cannot actually store the result of setjmp. If you want to return in several different ways, you can use a switch, though: 1 2 3 4 5 6 7 switch (setjmp(\u0026amp;env)) { case 0: // first call case 2: // returned from longjmp(\u0026amp;env, 2) case 5: // returned from longjmp(\u0026amp;env, 5) // etc. } ","permalink":"https://vishalchovatiya.github.io/posts/error-handling-setjmp-longjmp/","summary":"Points To Catch As for the control flow: setjmp returns twice, and longjmp never returns. When you call setjmp for the first time, to store the environment, it returns zero, And then when you call longjmp, the control flow passes to return from setjmp with the value provided in the argument. Use cases are generally cited as \u0026ldquo;error handling\u0026rdquo;, and \u0026ldquo;don\u0026rsquo;t use these functions\u0026rdquo;. Note: setjmp needn\u0026rsquo;t actually be functions; it may well be a macro.","title":"Error Handling : setjmp \u0026 longjmp"},{"content":"Why we need pthread_barrier_t? When multiple threads are working together, it might be required that the threads wait for each other at a certain event or point in the program before proceeding ahead. Let us say we have four threads, each of which is going to initialize a global variable. The 4 variables, in turn, might be used by all the four threads. Thus it would be feasible that all the threads wait for each other to finish the initialization of the variables before proceeding. Such operations can be implemented by adding a barrier in the thread. A barrier is a point where the thread is going to wait for other threads and will proceed further only when a predefined number of threads reach the same barrier in their respective programs. To use a barrier we need to use variables of the type pthread_barrier_t. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;pthread.h\u0026gt; #include\u0026lt;syscall.h\u0026gt; pthread_barrier_t barrier; void *func1(void *arg) { int var = 0; printf(\u0026#34;Thread1: my id is %d and my parent id is %d\\n\u0026#34;, syscall(SYS_gettid), getpid()); while(var \u0026lt; 5) { printf(\u0026#34;Thread1: var is %d\\n\u0026#34;, var); var++; sleep(1); } pthread_barrier_wait(\u0026amp;barrier); printf(\u0026#34;Thread1 exiting.....\\n\u0026#34;); pthread_exit(0); } void *func2(void *arg) { int var = 0; printf(\u0026#34;Thread2: my id is %d and my parent id is %d\\n\u0026#34;, syscall(SYS_gettid), getpid()); while(var \u0026lt; 7) { printf(\u0026#34;Thread2: var is %d\\n\u0026#34;, var); var++; sleep(1); } pthread_barrier_wait(\u0026amp;barrier); printf(\u0026#34;Thread2 exiting.....\\n\u0026#34;); pthread_exit(0); } void *func3(void *arg) { int var = 0; printf(\u0026#34;Thread3: my id is %d and my parent id is %d\\n\u0026#34;, syscall(SYS_gettid), getpid()); while(var \u0026lt; 9) { printf(\u0026#34;Thread3: var is %d\\n\u0026#34;, var); var++; sleep(1); } pthread_barrier_wait(\u0026amp;barrier); printf(\u0026#34;Thread3 exiting.....\\n\u0026#34;); pthread_exit(0); } int main() { pthread_t thread1, thread2, thread3; pthread_barrier_init(\u0026amp;barrier, NULL, 3); printf(\u0026#34;I am parent: %d\\n\u0026#34;, getpid()); if (pthread_create(\u0026amp;thread1, NULL, func1, NULL) != 0) { perror(\u0026#34;[FAIL]: pthread_create for thread1 failed\\n\u0026#34;); return -1; } if (pthread_create(\u0026amp;thread2, NULL, func2, NULL) != 0) { perror(\u0026#34;[FAIL]: pthread_create for thread2 failed\\n\u0026#34;); return -1; } if (pthread_create(\u0026amp;thread3, NULL, func3, NULL) != 0) { perror(\u0026#34;[FAIL]: pthread_create for thread3 failed\\n\u0026#34;); return -1; } if (pthread_join(thread1, NULL) != 0) { perror(\u0026#34;[FAIL]: pthread_join failed thread1\\n\u0026#34;); return -1; } else printf(\u0026#34;pthread_join success for thread1\\n\u0026#34;); if (pthread_join(thread2, NULL) != 0) { perror(\u0026#34;[FAIL]: pthread_join failed thread2\\n\u0026#34;); return -1; }else printf(\u0026#34;pthread_join success for thread2\\n\u0026#34;); if (pthread_join(thread3, NULL) != 0) { perror(\u0026#34;[FAIL]: pthread_join failed thread3\\n\u0026#34;); return -1; }else printf(\u0026#34;pthread_join success for thread3\\n\u0026#34;); printf(\u0026#34;[PASS]: barrier successful\\n\u0026#34;); } ","permalink":"https://vishalchovatiya.github.io/posts/execute-threads-parallelly-at-given-time-pthread_barrier_t/","summary":"Why we need pthread_barrier_t? When multiple threads are working together, it might be required that the threads wait for each other at a certain event or point in the program before proceeding ahead. Let us say we have four threads, each of which is going to initialize a global variable. The 4 variables, in turn, might be used by all the four threads. Thus it would be feasible that all the threads wait for each other to finish the initialization of the variables before proceeding.","title":"Execute Threads Parallelly at Given Time: pthread_barrier_t"},{"content":"Semaphore is a synchronization mechanism. In more words, semaphores are a technique for coordinating or synchronizing activities in which multiple processes compete for the same resources. There are 2 types of semaphores: Binary semaphores \u0026amp; Counting semaphores. Binary Semaphores: Only two states 0 \u0026amp; 1, i.e., locked/unlocked or available/unavailable, Mutex implementation. Counting Semaphores: Semaphores which allow arbitrary resource count called counting semaphores. Here, we will see the POSIX style semaphore. POSIX semaphore calls are much simpler than the System V semaphore calls. However, System V semaphores are more widely available, particularly on older Unix-like systems. POSIX semaphores have been available on Linux systems post version 2.6 that use Glibc.\nThere are two types of POSIX semaphores: named \u0026amp; unnamed. The named semaphore(which internally implemented using shared memory) generally used between processes. As it creates shared memory system-wide \u0026amp; can use in multiple processes. But if you have threads only then, the unnamed semaphore will be the best choice.\nSemaphore between processes example in C using POSIX-semaphore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;semaphore.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; const char *semName = \u0026#34;asdfsd\u0026#34;; void parent(void){ sem_t *sem_id = sem_open(semName, O_CREAT, 0600, 0); if (sem_id == SEM_FAILED){ perror(\u0026#34;Parent : [sem_open] Failed\\n\u0026#34;); return; } printf(\u0026#34;Parent : Wait for Child to Print\\n\u0026#34;); if (sem_wait(sem_id) \u0026lt; 0) printf(\u0026#34;Parent : [sem_wait] Failed\\n\u0026#34;); printf(\u0026#34;Parent : Child Printed! \\n\u0026#34;); if (sem_close(sem_id) != 0){ perror(\u0026#34;Parent : [sem_close] Failed\\n\u0026#34;); return; } if (sem_unlink(semName) \u0026lt; 0){ printf(\u0026#34;Parent : [sem_unlink] Failed\\n\u0026#34;); return; } } void child(void) { sem_t *sem_id = sem_open(semName, O_CREAT, 0600, 0); if (sem_id == SEM_FAILED){ perror(\u0026#34;Child : [sem_open] Failed\\n\u0026#34;); return; } printf(\u0026#34;Child : I am done! Release Semaphore\\n\u0026#34;); if (sem_post(sem_id) \u0026lt; 0) printf(\u0026#34;Child : [sem_post] Failed \\n\u0026#34;); } int main(int argc, char *argv[]) { pid_t pid; pid = fork(); if (pid \u0026lt; 0){ perror(\u0026#34;fork\u0026#34;); exit(EXIT_FAILURE); } if (!pid){ child(); printf(\u0026#34;Child : Done with sem_open \\n\u0026#34;); } else{ int status; parent(); wait(\u0026amp;status); printf(\u0026#34;Parent : Done with sem_open \\n\u0026#34;); } return 0; } sem_open() : Connects to, \u0026amp; optionally creates, a named semaphore( like sem_init()`) sem_unlink() : Ends connection to an open semaphore \u0026amp; causes the semaphore to be removed when the last process closes it( like sem_destroy()` sem_wait() Wait for the semaphore to acquire sem_post() Release semaphore General pointers Semaphore\u0026rsquo;s internal implementation is like memory-mapped file(mmap) Two standards of semaphore mechanism POSIX-semaphore: sem_init(), sem_destroy(), sem_wait(), sem_post(), sem_trywait(), sem_getvalue(), sem_open(), sem_unlink() System-V-semaphore: semget(), semop(), semctl() ","permalink":"https://vishalchovatiya.github.io/posts/semaphore-between-processes-example-in-c/","summary":"Semaphore is a synchronization mechanism. In more words, semaphores are a technique for coordinating or synchronizing activities in which multiple processes compete for the same resources. There are 2 types of semaphores: Binary semaphores \u0026amp; Counting semaphores. Binary Semaphores: Only two states 0 \u0026amp; 1, i.e., locked/unlocked or available/unavailable, Mutex implementation. Counting Semaphores: Semaphores which allow arbitrary resource count called counting semaphores. Here, we will see the POSIX style semaphore. POSIX semaphore calls are much simpler than the System V semaphore calls.","title":"Semaphore between processes example in C"},{"content":"Brief As the name suggests, shared memory is a memory that may be shared by multiple programs with an intent to provide communication among them or avoid redundant copies. Points To Catch shmget() Creates a shared memory segment, The key argument could be semaphore ID shmat(): Shared segment can be attached to a process address space using this API It can be detached using shmdt(), A shared segment can be attached multiple times by the same process The original owner of a shared memory segment can assign ownership to another user with `shmctl() List out shared memory areas by ipcs -m Get more info on the particular shared memory area ipcs -m -i [shmid] Remove shared memory ipcrm shm [shmid] Server.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #define SHMSZ 27 //Size of shared memory int main() { char c; int shmid; int shmflg = IPC_CREAT | 0666; // flags like create, access permission key_t key = 5678; // Name of Shared Memory Segment char *shm, *s; if ((shmid = shmget(key, SHMSZ, shmflg)) \u0026lt; 0) { //Create the segment perror(\u0026#34;shmget\u0026#34;); return 1; } if ((shm = shmat(shmid, NULL, 0)) == (void *) -1) { //Attach segment to data space perror(\u0026#34;shmat\u0026#34;); return 1; } s = shm; // Fill memory to read by other process for (c = \u0026#39;a\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++) *s++ = c; *s = NULL; while (*shm != \u0026#39;*\u0026#39;) // Wait for other process acknowledgement sleep(1); return 0; } Client.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #define SHMSZ 27 int main() { int shmid; int shmflg = 0666; // flags like create, access permission key_t key = 5678; char *shm, *s; if ((shmid = shmget(key, SHMSZ, shmflg)) \u0026lt; 0) { // Locate the segment perror(\u0026#34;shmget\u0026#34;); return 1; } if ((shm = shmat(shmid, NULL, 0)) == (void *) -1) { // Attach segment to data space perror(\u0026#34;shmat\u0026#34;); return 1; } for (s = shm; *s != NULL; s++) // Read what other process writes here putchar(*s); putchar(\u0026#39;\\n\u0026#39;); *shm = \u0026#39;*\u0026#39;; // Acknowledge other proces return 0; } ","permalink":"https://vishalchovatiya.github.io/posts/shared-memory-ipc/","summary":"Brief As the name suggests, shared memory is a memory that may be shared by multiple programs with an intent to provide communication among them or avoid redundant copies. Points To Catch shmget() Creates a shared memory segment, The key argument could be semaphore ID shmat(): Shared segment can be attached to a process address space using this API It can be detached using shmdt(), A shared segment can be attached multiple times by the same process The original owner of a shared memory segment can assign ownership to another user with `shmctl() List out shared memory areas by ipcs -m Get more info on the particular shared memory area ipcs -m -i [shmid] Remove shared memory ipcrm shm [shmid] Server.","title":"Shared Memory IPC"},{"content":"Points To Catch\nSignals = software interrupts. The command kill -l on the bash would give us the following. 1 2 3 4 5 6 7 8 9 10 11 12 13 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX Signals are also delivered to a process with the help of kill command. The manual page (man kill) of kill command says that the default and easier version of kill command is the kill PID. Where PID is the process ID that is found via the ps command. The default signal is SIGTERM (15). Alternatively, a signal number is specified to the kill command such as kill -2 1291 making a delivery of SIGINT(2) signal to the process ID 1291 Every thread has its own private signal mask(APIs like pthread_sigmask() etc) can be used to capture or block particular signal Some of the most important APIs to implement signal mechanisms are sigaction, signal and signalfd. signal() does not block other signals from arriving while the current signal is being executed. Thus when more than one signal occur at the same time, it becomes more problematic to understand and perform actions. If it is on the same data, this might even get more complex. The sigaction()blocks the other signals while the handler is being executed. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;signal.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; void sig_handler(int signo) { if (signo == SIGINT) printf(\u0026#34;received SIGINT\\n\u0026#34;); } int main(void) { if (signal(SIGINT, sig_handler) == SIG_ERR) printf(\u0026#34;\\ncan\u0026#39;t catch SIGINT\\n\u0026#34;); while(1) sleep(1); return 0; } ","permalink":"https://vishalchovatiya.github.io/posts/signal-handling/","summary":"Points To Catch\nSignals = software interrupts. The command kill -l on the bash would give us the following. 1 2 3 4 5 6 7 8 9 10 11 12 13 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX Signals are also delivered to a process with the help of kill command.","title":"Signal Handling"},{"content":"Points To Catch On a single system, Two processes can communicate through Pipes Message queues Shared memory To communicate between two processes over a network, you need Socket Socket = Endpoint of communication between two systems on a network OR Combination of IP \u0026amp; Port Number Server Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; void ErrorAndExit(const char *str); #define IP \u0026#34;127.0.0.1\u0026#34; /* Local Host OR Should be your local IP for test */ #define PORT 5000 int main(int argc, char *argv[]) { int listenfd = 0, connfd = 0; struct sockaddr_in serv_addr = {0}; if( (listenfd = socket(AF_INET, SOCK_STREAM, 0) ) \u0026lt; 0 ) ErrorAndExit(\u0026#34;Could not create socket\u0026#34;); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(IP); serv_addr.sin_port = htons(PORT); if( (bind(listenfd, (struct sockaddr*)\u0026amp;serv_addr, sizeof(serv_addr)) ) \u0026lt; 0 ) ErrorAndExit(\u0026#34;Could not bind on Given IP\u0026#34;); if( (listen(listenfd, 10) ) \u0026lt; 0 ) ErrorAndExit(\u0026#34;Could not listen\u0026#34;); if( ( connfd = accept(listenfd, (struct sockaddr*)NULL, NULL) ) \u0026lt; 0 ) ErrorAndExit(\u0026#34;Could not accept\u0026#34;); write(connfd, \u0026#34;Server Message\u0026#34;, strlen(\u0026#34;Server Message\u0026#34;)); close(connfd); return 0; } void ErrorAndExit(const char *str) { printf(\u0026#34;Error : %s\\n\u0026#34;, str); exit(EXIT_FAILURE); } socket() creates socket inside the kernel \u0026amp; returns socket descriptor. AF_INET represents IPv4 addresses. SOCK_STREAM specifies communication semantics means how communications would carry out. The 3rd argument is zero to let the kernel decide the default protocol to use for this connection. The default protocol used is TCP. bind(), wait for client requests on particular IP-Port specified in the structure serv_addr. listen() with the second argument as 10 specifies a maximum number of client connections that server will queue for this listening socket. accept(), but the server into sleep \u0026amp; when client requests, the three-way TCP handshake* is complete, the function wakes up \u0026amp; returns the socket descriptor representing the client socket. As soon as the server gets a request from the client, it prepares its message \u0026amp; writes on the client socket through the descriptor returned by accept(). Client Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; void ErrorAndExit(const char *str); #define IP \u0026#34;127.0.0.1\u0026#34; /* Local Host OR Should be your local IP for test */ #define PORT 5000 int main() { int sockfd = 0, n = 0; char recvBuff[1024]; struct sockaddr_in serv_addr = {0}; memset(recvBuff, `0`,sizeof(recvBuff)); if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) ErrorAndExit(\u0026#34;Could not create socket\u0026#34;); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); serv_addr.sin_addr.s_addr = inet_addr(IP); if( connect(sockfd, (struct sockaddr *)\u0026amp;serv_addr, sizeof(serv_addr)) \u0026lt; 0) ErrorAndExit(\u0026#34;Connect Failed\u0026#34;); while ( (n = read(sockfd, recvBuff, sizeof(recvBuff)-1)) \u0026gt; 0) { recvBuff[n] = 0; if(fputs(recvBuff, stdout) == EOF) ErrorAndExit(\u0026#34;fputs error\u0026#34;); } if(n \u0026lt; 0) ErrorAndExit(\u0026#34;Read error\u0026#34;); return 0; } void ErrorAndExit(const char *str) { printf(\u0026#34;Error : %s\\n\u0026#34;, str); exit(EXIT_FAILURE); } socket() does work the same as mentioned in server connect() will connect this socket with a remote host whose IP-Port \u0026amp; other info bundled up in a structure sockaddr_in. Once the sockets are connected, the server sends the data on clients socket through clients socket descriptor and a client can read it through normal read call on its socket descriptor. ","permalink":"https://vishalchovatiya.github.io/posts/socket-programming/","summary":"Points To Catch On a single system, Two processes can communicate through Pipes Message queues Shared memory To communicate between two processes over a network, you need Socket Socket = Endpoint of communication between two systems on a network OR Combination of IP \u0026amp; Port Number Server Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;sys/socket.","title":"Socket Programming"},{"content":"Brief Condition variables provide yet another way for threads to synchronize. While mutexes implement synchronization by controlling thread access to data, condition variables allow threads to synchronize based upon the actual value of data. Without condition variables, the programmer would need to have threads continually polling (possibly in a critical section), to check if the condition is met. This can be very resource consuming since the thread would be continuously busy in this activity. A condition variable is a way to achieve the same goal without polling. A condition variable is always used in conjunction with a mutex lock. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #include #include #include #include #include\u0026lt;syscall.h\u0026gt; int glovar, state = 0; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cond = PTHREAD_COND_INITIALIZER; void *thread1_func(void *arg) { printf(\u0026#34;\\n%s: my id is %d and my parent id is %d\\n\u0026#34;, arg, syscall(SYS_gettid), getpid()); if (pthread_mutex_lock(\u0026amp;mutex) != 0) { perror(\u0026#34;[FAIL]: Thread1: pthread_mutex_lock failed\\n\u0026#34;); exit(-1); } else printf(\u0026#34;Thread1: pthread_mutex_lock success.....\\n\u0026#34;); while (!state) { printf(\u0026#34;.....waiting for signal\\n\u0026#34;); pthread_cond_wait(\u0026amp;cond, \u0026amp;mutex); } if (pthread_mutex_unlock(\u0026amp;mutex) != 0) { perror(\u0026#34;[FAIL]: Thread1: pthread_mutex_unlock failed\\n\u0026#34;); exit(-1); } else printf(\u0026#34;Thread1: pthread_mutex_unlock success.....\\n\u0026#34;); printf(\u0026#34;\\nThread1: state value signaled high, thread1 starts execution\\n\u0026#34;); while (glovar \u0026lt; 5) { printf(\u0026#34;Thread1: glovar is %d\\n\u0026#34;, glovar); glovar++; sleep(1); } pthread_exit(\u0026#34;EXIT_SUCCESS\u0026#34;); } void *thread2_func(void *arg) { printf(\u0026#34;\\n%s: my id is %d and my parent id is %d\\n\u0026#34;, arg, syscall(SYS_gettid), getpid()); if (pthread_mutex_lock(\u0026amp;mutex) != 0) { perror(\u0026#34;[FAIL]: Thread2: pthread_mutex_lock failed\\n\u0026#34;); exit(-1); } else printf(\u0026#34;Thread2: pthread_mutex_lock success.....\\n\u0026#34;); printf(\u0026#34;setting state value to high\\n\u0026#34;); state = 1; if (pthread_mutex_unlock(\u0026amp;mutex) != 0) { perror(\u0026#34;[FAIL]: Thread2: pthread_mutex_unlock failed\\n\u0026#34;); exit(-1); } else printf(\u0026#34;Thread2: pthread_mutex_unlock success.....\\n\u0026#34;); if (pthread_cond_signal(\u0026amp;cond) != 0) { perror(\u0026#34;[FAIL]: pthread_cond_signal failed\\n\u0026#34;); exit(-1); } else printf(\u0026#34;pthread_cond_signal success\\n\u0026#34;); pthread_exit(\u0026#34;EXIT_SUCCESS\u0026#34;); } int main() { pthread_t thread1, thread2; char *msg1 = \u0026#34;I am thread1\u0026#34;; char *msg2 = \u0026#34;I am thread2\u0026#34;; void *recv_status; if(pthread_mutex_init(\u0026amp;mutex, NULL) != 0) { perror(\u0026#34;[PASS]: mutex init failed\\n\u0026#34;); return -1; } printf(\u0026#34;\\n.....Execution starts from here.....\\n\u0026#34;); printf(\u0026#34;Main Thread: my id is %d\\n\u0026#34;, getpid()); if (pthread_create(\u0026amp;thread1, NULL, thread1_func, msg1) != 0) { perror(\u0026#34;[FAIL]: error in creating thread1\\n\u0026#34;); return -1; } if (pthread_create(\u0026amp;thread2, NULL, thread2_func, msg2) != 0) { perror(\u0026#34;[FAIL]: error in creating thread2\\n\u0026#34;); return -1; } if (pthread_join(thread1, (void *)\u0026amp;recv_status) != 0) { perror(\u0026#34;[FAIL]: error in joining thread1\\n\u0026#34;); return -1; } printf(\u0026#34;return status of thread1 is %s\\n\u0026#34;, recv_status); if (pthread_join(thread2, (void *)\u0026amp;recv_status) != 0) { perror(\u0026#34;[FAIL]: error in joining thread2\\n\u0026#34;); return -1; } printf(\u0026#34;return status of thread2 is %s\\n\u0026#34;, recv_status); if (pthread_mutex_destroy(\u0026amp;mutex) != 0) { perror(\u0026#34;[FAIL]: error in destroy\\n\u0026#34;); return -1; } printf(\u0026#34;[PASS]: Thread created and joined successfully\\n\u0026#34;); return 0; } ","permalink":"https://vishalchovatiya.github.io/posts/thread-conditional-wait-with-mutex-pthread_cond_t/","summary":"Brief Condition variables provide yet another way for threads to synchronize. While mutexes implement synchronization by controlling thread access to data, condition variables allow threads to synchronize based upon the actual value of data. Without condition variables, the programmer would need to have threads continually polling (possibly in a critical section), to check if the condition is met. This can be very resource consuming since the thread would be continuously busy in this activity.","title":"Thread Conditional Wait with Mutex : pthread_cond_t"},{"content":" ELF is the file format used for object files (.os), binaries, shared libraries and core dumps in Linux. ELF has the same layout for all architectures, however endianness and word size can differ; relocation types, symbol types and the like may have platform-specific values, and of course, the contained code is arch-specific. An ELF file provides 2 views on the data it contains: A linking view and an execution view. Those two views can be accessed by two headers: Section header \u0026amp; Program header. Before dive in to ELF understanding, let\u0026rsquo;s clear some basic keywords as follows : Shared Library(.so) Combination of multiple objects files Single Copy loaded in memory shared by multiple processes (that\u0026rsquo;s why called shared object) Sections Sections contain information needed during the linking time Segments Segments contain information needed at run time ELF Header Neither the Section Header nor the Program Header have fixed positions, they can be located anywhere in an ELF file. To find them the ELF header is used, which is located at the very start of the file. The first bytes contain the elf magic \\x7fELF, followed by the class ID (32 or 64 bit ELF file), the data format ID (little-endian/big-endian), the machine type, etc. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 vishal@linuxmachine:~$ readelf -h /bin/bash ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2\u0026#39;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x805be30 Start of program headers: 52 (bytes into file) Start of section headers: 675344 (bytes into file) Flags: 0x0 Size of this header: 52 Size of program headers: 32 Number of program headers: 8 Size of section headers: 40 Number of section headers: 26 Section header string table index: 25 Section Headers OR Section Header Table Gives a complete overview of the sections contained in the ELF file 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 vishal@linuxmachine:~$ readelf -S /bin/bash There are 26 section headers, starting at offset 0xa4e10: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 00000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048134 00134 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048148 00148 000020 00 A 0 0 4 [ 3] .hash HASH 08048168 00168 002e48 04 A 4 0 4 [ 4] .dynsym DYNSYM 0804afb0 02fb0 007890 10 A 5 1 4 [ 5] .dynstr STRTAB 08052840 0a840 0074e2 00 A 0 0 1 [ 6] .gnu.version VERSYM 08059d22 11d22 000f12 02 A 4 0 2 [ 7] .gnu.version_r VERNEED 0805ac34 12c34 000090 00 A 5 2 4 [ 8] .rel.dyn REL 0805acc4 12cc4 000040 08 A 4 0 4 [ 9] .rel.plt REL 0805ad04 12d04 0005a8 08 A 4 11 4 [10] .init PROGBITS 0805b2ac 132ac 000017 00 AX 0 0 4 [11] .plt PROGBITS 0805b2c4 132c4 000b60 04 AX 0 0 4 [12] .text PROGBITS 0805be30 13e30 077154 00 AX 0 0 16 [13] .fini PROGBITS 080d2f84 8af84 00001a 00 AX 0 0 4 [14] .rodata PROGBITS 080d2fa0 8afa0 015198 00 A 0 0 32 [15] .eh_frame_hdr PROGBITS 080e8138 a0138 00002c 00 A 0 0 4 [16] .eh_frame PROGBITS 080e8164 a0164 00009c 00 A 0 0 4 [17] .ctors PROGBITS 080e9200 a0200 000008 00 WA 0 0 4 [18] .dtors PROGBITS 080e9208 a0208 000008 00 WA 0 0 4 [19] .jcr PROGBITS 080e9210 a0210 000004 00 WA 0 0 4 [20] .dynamic DYNAMIC 080e9214 a0214 0000d8 08 WA 5 0 4 [21] .got PROGBITS 080e92ec a02ec 000004 04 WA 0 0 4 [22] .got.plt PROGBITS 080e92f0 a02f0 0002e0 04 WA 0 0 4 [23] .data PROGBITS 080e95e0 a05e0 004764 00 WA 0 0 32 [24] .bss NOBITS 080edd60 a4d44 004bc8 00 WA 0 0 32 [25] .shstrtab STRTAB 00000000 a4d44 0000cc 00 0 0 1 Program Headers OR Program Headers Table Contains information for the kernel on how to start the program The LOAD directives determinate what parts of the ELF file get mapped into memory. The INTERP the directive specifies an ELF interpreter, which is normally /lib/ld-linux.so.2 on Linux systems. The DYNAMIC entry points to the .dynamic the section which contains information used by the ELF interpreter to set up the binary. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 vishal@linuxmachine:~$ readelf -l /bin/bash Elf file type is EXEC (Executable file) Entry point 0x805be30 There are 8 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4 INTERP 0x000134 0x08048134 0x08048134 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0xa0200 0xa0200 R E 0x1000 LOAD 0x0a0200 0x080e9200 0x080e9200 0x04b44 0x09728 RW 0x1000 DYNAMIC 0x0a0214 0x080e9214 0x080e9214 0x000d8 0x000d8 RW 0x4 NOTE 0x000148 0x08048148 0x08048148 0x00020 0x00020 R 0x4 GNU_EH_FRAME 0x0a0138 0x080e8138 0x080e8138 0x0002c 0x0002c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x4 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt ... 03 .ctors .dtors .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag 06 .eh_frame_hdr 07 Relocation Table OR Relocation Section Relocation is the process of connecting symbolic references(functions,variable,etc names) with symbolic definitions(function, variable,etc definitions). For example, when a program calls a function(at runtime), the associated call instruction must transfer control to the proper destination address at execution. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 vishal@linuxmachine:~$ readelf -r /bin/bash Relocation section \u0026#39;.rel.dyn\u0026#39; at offset 0x12cc4 contains 8 entries: Offset Info Type Sym.Value Sym. Name 080e92ec 00078006 R_386_GLOB_DAT 00000000 __gmon_start__ 080edd68 00035205 R_386_COPY 080edd68 stdout 080edd6c 00035d05 R_386_COPY 080edd6c stderr 080edd70 00046405 R_386_COPY 080edd70 PC 080edd74 00067405 R_386_COPY 080edd74 stdin 080edd78 0006e305 R_386_COPY 080edd78 UP Relocation section \u0026#39;.rel.plt\u0026#39; at offset 0x12d04 contains 181 entries: Offset Info Type Sym.Value Sym. Name 080e9368 00012c07 R_386_JUMP_SLOT 00000000 fileno 080e936c 00013807 R_386_JUMP_SLOT 00000000 strcmp 080e9370 00014107 R_386_JUMP_SLOT 0805b4a4 close 080e9374 00015307 R_386_JUMP_SLOT 00000000 dlsym 080e937c 00016a07 R_386_JUMP_SLOT 00000000 fprintf 080e9388 00018307 R_386_JUMP_SLOT 00000000 fflush 080e9390 00019c07 R_386_JUMP_SLOT 0805b524 unlink 080e930c 00003307 R_386_JUMP_SLOT 00000000 regexec 080e9328 00007a07 R_386_JUMP_SLOT 00000000 ferror 080e9330 00008307 R_386_JUMP_SLOT 00000000 readdir64 080e9334 00008f07 R_386_JUMP_SLOT 00000000 strchr 080e9338 0000a507 R_386_JUMP_SLOT 00000000 fdopen 080e9344 0000da07 R_386_JUMP_SLOT 00000000 getpid 080e9360 00012207 R_386_JUMP_SLOT 00000000 write 080e95cc 00078707 R_386_JUMP_SLOT 00000000 strcpy ... ... Symbol Table: Two Use Case Symbol table in object/executable files will contain the symbolic name of functions \u0026amp; variables with addresses which are used by Linker to resolve any unresolved references during linking. There\u0026rsquo;s also the symbol table in a shared library/DLL produced by the linker(at compile time) which is used by the dynamic linker to do run-time linking \u0026amp; resolving open references to those names to the location where the library is loaded in memory. Note: While reverse engineering an executable, many tools refer to the symbol table to check what addresses have been assigned to global variables and known functions. If the symbol table has been stripped or cleaned out before being converted into an executable, tools will find it harder to determine addresses or understand anything about the program.\nDynamic Section \u0026amp; Dynamic linking with the ELF interpreter First, the dynamic linker (contained within the interpreter) looks at the Dynamic section, whose address is stored in the Program Header. There it finds the NEEDED entries determining which libraries have to be loaded before the program can be run, the RELentries giving the address of the relocation tables, the VER entries which contain symbol versioning information, etc. So the dynamic linker loads the needed libraries and performs relocations (either directly at program startup or later(lazy resolution)). Finally, control is transferred to the address given by the symbol _start in the binary. Normally some gcc/glibc startup code lives there, which in the end calls main() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 vishal@linuxmachine:~$ readelf -d /bin/bash Dynamic section at offset 0xa0214 contains 22 entries: Tag Type Name/Value 0x00000001 (NEEDED) Shared library: [libncurses.so.5] 0x00000001 (NEEDED) Shared library: [libdl.so.2] 0x00000001 (NEEDED) Shared library: [libc.so.6] 0x0000000a (STRSZ) 29922 (bytes) 0x0000000b (SYMENT) 16 (bytes) 0x00000003 (PLTGOT) 0x80e92f0 0x00000002 (PLTRELSZ) 1448 (bytes) 0x00000014 (PLTREL) REL 0x00000017 (JMPREL) 0x805ad04 0x00000011 (REL) 0x805acc4 0x00000012 (RELSZ) 64 (bytes) 0x6ffffffe (VERNEED) 0x805ac34 0x6fffffff (VERNEEDNUM) 2 0x6ffffff0 (VERSYM) 0x8059d22 0x00000000 (NULL) 0x0 Procedure Linkage Table(.plt) is a table of addresses resides in the text segment used to store the address of all functions needed at runtime (address not known at the time of linking) The PLT uses what is called lazy resolution. Means it resolves procedure address once when it calls method How PLT works - A function func is called and the compiler translates this to a call to func@plt(you can see this in a binary dump). The program jumps to the PLT. The PLT points to the GOT. If the function has not been previously called, the GOT points back into the PLT to a resolver routine, otherwise it points to the function itself. If the function has not been previously called, PLT resolves routine \u0026amp; update the GOT entry with the actual address of the function. Global Offset Table(.got) is a table of addresses resides in the data segment used to store the relative address of variables \u0026amp; procedures which is mapped with the absolute address How GOT works - If some instruction in the text segment, wants to refer to a variable it must normally use an absolute memory address. Instead of referring to the absolute memory address, it refers to the GOT, whose location is known. NOTE: By this kind of address tables we can effectively use relocating of objects, with just updating entry each time relocation performed\nProgram loading in the kernel The execution of a program starts inside the kernel, in the exec system call. There the file type is looked up and the appropriate handler is called. The binfmt-elf the handler then loads the ELF header and the Program Header, followed by lots of sanity checks. The kernel then loads the parts specified in the LOAD directives in the Program Header into memory. If an INTERP entry is present, the interpreter is loaded too. Statically linked binaries can do without an interpreter; dynamically linked programs always need /lib/ld-linux.so as an interpreter, because it includes some startup code, loads shared libraries needed by the binary and performs relocations. Finally, control can be transferred to the program, to the interpreter, if present, otherwise to the binary itself.\n1 2 3 4 5 6 7 8 9 10 11 vishal@linuxmachine:~$ readelf -l /bin/bash Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4 INTERP 0x000134 0x08048134 0x08048134 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0xa0200 0xa0200 R E 0x1000 LOAD 0x0a0200 0x080e9200 0x080e9200 0x04b44 0x09728 RW 0x1000 DYNAMIC 0x0a0214 0x080e9214 0x080e9214 0x000d8 0x000d8 RW 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x4 ... ","permalink":"https://vishalchovatiya.github.io/posts/understand-elf-file-format/","summary":"ELF is the file format used for object files (.os), binaries, shared libraries and core dumps in Linux. ELF has the same layout for all architectures, however endianness and word size can differ; relocation types, symbol types and the like may have platform-specific values, and of course, the contained code is arch-specific. An ELF file provides 2 views on the data it contains: A linking view and an execution view.","title":"Understand ELF file format"},{"content":"Brief A Unix domain socket or IPC socket is a data communications endpoint for exchanging data between processes executing on the same host operating system. The API for Unix domain sockets is similar to that of an Internet socket, but rather than using an underlying network protocol, all communication occurs entirely within the operating system kernel. Unix domain sockets use the file system as their address namespace. Processes reference Unix domain sockets as file system inodes, so two processes can communicate by opening the same socket. Why we need Unix domain socket? In addition to sending data, processes may send file descriptors across a Unix domain socket connection using the sendmsg() and recvmsg()`system calls. This allows the sending processes to grant the receiving process access to a file descriptor for which the receiving process otherwise does not have access. This can be used to implement a limited form of capability-based security. For example, this allows the AntiVirus scanner to run as an unprivileged daemon on Linux, yet still read any file sent to the daemon\u0026rsquo;s Unix domain socket. Server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/un.h\u0026gt; static void displayError(const char *); const char socketPath[] = \u0026#34;/tmp/my_sock\u0026#34;; /* Socket With Absolute Pathname */ int main(int argc, char **argv, char **envp) { int sockfd; /* Socket File Descriptor */ int connfd; /* Connection Fide Descriptor On Whch We Communicate */ struct sockaddr_un socketAddr; /* AF_UNIX */ /* Create a AF_UNIX (aka AF_LOCAL) socket */ if ( (sockfd = socket(AF_UNIX,SOCK_STREAM,0)) \u0026lt; 0 ) displayError(\u0026#34;socket\u0026#34;); /* Here we remove name of socket from file system, in case it existed from a prior run.*/ unlink(socketPath); memset( \u0026amp;socketAddr, 0, sizeof socketAddr); socketAddr.sun_family = AF_UNIX; strncpy( socketAddr.sun_path, socketPath, sizeof socketAddr.sun_path-1); if ( bind(sockfd, (struct sockaddr *)\u0026amp;socketAddr, sizeof(struct sockaddr)) \u0026lt; 0 ) displayError(\u0026#34;Could not bind\u0026#34;); if( ( listen( sockfd, 10) ) \u0026lt; 0 ) displayError(\u0026#34;Could not listen\u0026#34;); if( ( connfd = accept( sockfd, (struct sockaddr*)NULL, NULL) ) \u0026lt; 0 ) displayError(\u0026#34;Could not accept\u0026#34;); write(connfd, \u0026#34;Server Message\\n\u0026#34;, strlen(\u0026#34;Server Message\\n\u0026#34;)); /* Close \u0026amp; unlink our socket path */ close(sockfd) ; unlink(socketPath); return 0; } /* This function reports the error and exits back to the shell: */ static void displayError(const char *on_what) { perror(on_what); exit(1); } Client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/un.h\u0026gt; static void displayError(const char *on_what); const char socketPath[] = \u0026#34;/tmp/my_sock\u0026#34;; int main(int argc, char **argv, char **envp) { int n = 0; char recvBuff[1024]; int sockfd; struct sockaddr_un socketAddr; /* Create a AF_UNIX (aka AF_LOCAL) socket: */ if ( (sockfd = socket(AF_UNIX,SOCK_STREAM,0)) \u0026lt; 0 ) displayError(\u0026#34;socket\u0026#34;); memset( \u0026amp;socketAddr, 0, sizeof socketAddr); socketAddr.sun_family = AF_UNIX; strncpy( socketAddr.sun_path, socketPath, sizeof socketAddr.sun_path-1); if( connect(sockfd, (struct sockaddr *)\u0026amp;socketAddr, sizeof(socketAddr)) \u0026lt; 0) displayError(\u0026#34;Connect Failed\u0026#34;); while ( (n = read(sockfd, recvBuff, sizeof(recvBuff)-1)) \u0026gt; 0) { recvBuff[n] = 0; if(fputs(recvBuff, stdout) == EOF) displayError(\u0026#34;fputs error\u0026#34;); } if(n \u0026lt; 0) displayError(\u0026#34;Read error\u0026#34;); /* Close and unlink our socket path: */ close(sockfd) ; unlink(socketPath); return 0; } /* This function reports the error and exits back to the shell: */ static void displayError(const char *on_what) { perror(on_what); exit(1); } ","permalink":"https://vishalchovatiya.github.io/posts/unix-domain-socket/","summary":"Brief A Unix domain socket or IPC socket is a data communications endpoint for exchanging data between processes executing on the same host operating system. The API for Unix domain sockets is similar to that of an Internet socket, but rather than using an underlying network protocol, all communication occurs entirely within the operating system kernel. Unix domain sockets use the file system as their address namespace. Processes reference Unix domain sockets as file system inodes, so two processes can communicate by opening the same socket.","title":"Unix Domain Socket"}]